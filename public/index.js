(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target2) => __defProp(target2, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target2, all) => {
    __markAsModule(target2);
    for (var name in all)
      __defProp(target2, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target2, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key2 of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target2, key2) && key2 !== "default")
          __defProp(target2, key2, { get: () => module[key2], enumerable: !(desc = __getOwnPropDesc(module, key2)) || desc.enumerable });
    }
    return target2;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // libs/pako.js
  var require_pako = __commonJS({
    "libs/pako.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.pako = {}));
      })(exports, function(exports2) {
        "use strict";
        const Z_FIXED$1 = 4;
        const Z_BINARY = 0;
        const Z_TEXT = 1;
        const Z_UNKNOWN$1 = 2;
        function zero$1(buf2) {
          let len = buf2.length;
          while (--len >= 0) {
            buf2[len] = 0;
          }
        }
        const STORED_BLOCK = 0;
        const STATIC_TREES = 1;
        const DYN_TREES = 2;
        const MIN_MATCH$1 = 3;
        const MAX_MATCH$1 = 258;
        const LENGTH_CODES$1 = 29;
        const LITERALS$1 = 256;
        const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
        const D_CODES$1 = 30;
        const BL_CODES$1 = 19;
        const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
        const MAX_BITS$1 = 15;
        const Buf_size = 16;
        const MAX_BL_BITS = 7;
        const END_BLOCK = 256;
        const REP_3_6 = 16;
        const REPZ_3_10 = 17;
        const REPZ_11_138 = 18;
        const extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
        const extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
        const extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
        const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
        const DIST_CODE_LEN = 512;
        const static_ltree = new Array((L_CODES$1 + 2) * 2);
        zero$1(static_ltree);
        const static_dtree = new Array(D_CODES$1 * 2);
        zero$1(static_dtree);
        const _dist_code = new Array(DIST_CODE_LEN);
        zero$1(_dist_code);
        const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
        zero$1(_length_code);
        const base_length = new Array(LENGTH_CODES$1);
        zero$1(base_length);
        const base_dist = new Array(D_CODES$1);
        zero$1(base_dist);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
          this.static_tree = static_tree;
          this.extra_bits = extra_bits;
          this.extra_base = extra_base;
          this.elems = elems;
          this.max_length = max_length;
          this.has_stree = static_tree && static_tree.length;
        }
        let static_l_desc;
        let static_d_desc;
        let static_bl_desc;
        function TreeDesc(dyn_tree, stat_desc) {
          this.dyn_tree = dyn_tree;
          this.max_code = 0;
          this.stat_desc = stat_desc;
        }
        const d_code = (dist) => {
          return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        };
        const put_short = (s2, w) => {
          s2.pending_buf[s2.pending++] = w & 255;
          s2.pending_buf[s2.pending++] = w >>> 8 & 255;
        };
        const send_bits = (s2, value2, length) => {
          if (s2.bi_valid > Buf_size - length) {
            s2.bi_buf |= value2 << s2.bi_valid & 65535;
            put_short(s2, s2.bi_buf);
            s2.bi_buf = value2 >> Buf_size - s2.bi_valid;
            s2.bi_valid += length - Buf_size;
          } else {
            s2.bi_buf |= value2 << s2.bi_valid & 65535;
            s2.bi_valid += length;
          }
        };
        const send_code = (s2, c, tree) => {
          send_bits(s2, tree[c * 2], tree[c * 2 + 1]);
        };
        const bi_reverse = (code, len) => {
          let res = 0;
          do {
            res |= code & 1;
            code >>>= 1;
            res <<= 1;
          } while (--len > 0);
          return res >>> 1;
        };
        const bi_flush = (s2) => {
          if (s2.bi_valid === 16) {
            put_short(s2, s2.bi_buf);
            s2.bi_buf = 0;
            s2.bi_valid = 0;
          } else if (s2.bi_valid >= 8) {
            s2.pending_buf[s2.pending++] = s2.bi_buf & 255;
            s2.bi_buf >>= 8;
            s2.bi_valid -= 8;
          }
        };
        const gen_bitlen = (s2, desc) => {
          const tree = desc.dyn_tree;
          const max_code = desc.max_code;
          const stree = desc.stat_desc.static_tree;
          const has_stree = desc.stat_desc.has_stree;
          const extra = desc.stat_desc.extra_bits;
          const base = desc.stat_desc.extra_base;
          const max_length = desc.stat_desc.max_length;
          let h3;
          let n, m;
          let bits;
          let xbits;
          let f;
          let overflow = 0;
          for (bits = 0; bits <= MAX_BITS$1; bits++) {
            s2.bl_count[bits] = 0;
          }
          tree[s2.heap[s2.heap_max] * 2 + 1] = 0;
          for (h3 = s2.heap_max + 1; h3 < HEAP_SIZE$1; h3++) {
            n = s2.heap[h3];
            bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
            if (bits > max_length) {
              bits = max_length;
              overflow++;
            }
            tree[n * 2 + 1] = bits;
            if (n > max_code) {
              continue;
            }
            s2.bl_count[bits]++;
            xbits = 0;
            if (n >= base) {
              xbits = extra[n - base];
            }
            f = tree[n * 2];
            s2.opt_len += f * (bits + xbits);
            if (has_stree) {
              s2.static_len += f * (stree[n * 2 + 1] + xbits);
            }
          }
          if (overflow === 0) {
            return;
          }
          do {
            bits = max_length - 1;
            while (s2.bl_count[bits] === 0) {
              bits--;
            }
            s2.bl_count[bits]--;
            s2.bl_count[bits + 1] += 2;
            s2.bl_count[max_length]--;
            overflow -= 2;
          } while (overflow > 0);
          for (bits = max_length; bits !== 0; bits--) {
            n = s2.bl_count[bits];
            while (n !== 0) {
              m = s2.heap[--h3];
              if (m > max_code) {
                continue;
              }
              if (tree[m * 2 + 1] !== bits) {
                s2.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                tree[m * 2 + 1] = bits;
              }
              n--;
            }
          }
        };
        const gen_codes = (tree, max_code, bl_count) => {
          const next_code = new Array(MAX_BITS$1 + 1);
          let code = 0;
          let bits;
          let n;
          for (bits = 1; bits <= MAX_BITS$1; bits++) {
            next_code[bits] = code = code + bl_count[bits - 1] << 1;
          }
          for (n = 0; n <= max_code; n++) {
            let len = tree[n * 2 + 1];
            if (len === 0) {
              continue;
            }
            tree[n * 2] = bi_reverse(next_code[len]++, len);
          }
        };
        const tr_static_init = () => {
          let n;
          let bits;
          let length;
          let code;
          let dist;
          const bl_count = new Array(MAX_BITS$1 + 1);
          length = 0;
          for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
            base_length[code] = length;
            for (n = 0; n < 1 << extra_lbits[code]; n++) {
              _length_code[length++] = code;
            }
          }
          _length_code[length - 1] = code;
          dist = 0;
          for (code = 0; code < 16; code++) {
            base_dist[code] = dist;
            for (n = 0; n < 1 << extra_dbits[code]; n++) {
              _dist_code[dist++] = code;
            }
          }
          dist >>= 7;
          for (; code < D_CODES$1; code++) {
            base_dist[code] = dist << 7;
            for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
              _dist_code[256 + dist++] = code;
            }
          }
          for (bits = 0; bits <= MAX_BITS$1; bits++) {
            bl_count[bits] = 0;
          }
          n = 0;
          while (n <= 143) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          while (n <= 255) {
            static_ltree[n * 2 + 1] = 9;
            n++;
            bl_count[9]++;
          }
          while (n <= 279) {
            static_ltree[n * 2 + 1] = 7;
            n++;
            bl_count[7]++;
          }
          while (n <= 287) {
            static_ltree[n * 2 + 1] = 8;
            n++;
            bl_count[8]++;
          }
          gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
          for (n = 0; n < D_CODES$1; n++) {
            static_dtree[n * 2 + 1] = 5;
            static_dtree[n * 2] = bi_reverse(n, 5);
          }
          static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
          static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
          static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
        };
        const init_block = (s2) => {
          let n;
          for (n = 0; n < L_CODES$1; n++) {
            s2.dyn_ltree[n * 2] = 0;
          }
          for (n = 0; n < D_CODES$1; n++) {
            s2.dyn_dtree[n * 2] = 0;
          }
          for (n = 0; n < BL_CODES$1; n++) {
            s2.bl_tree[n * 2] = 0;
          }
          s2.dyn_ltree[END_BLOCK * 2] = 1;
          s2.opt_len = s2.static_len = 0;
          s2.last_lit = s2.matches = 0;
        };
        const bi_windup = (s2) => {
          if (s2.bi_valid > 8) {
            put_short(s2, s2.bi_buf);
          } else if (s2.bi_valid > 0) {
            s2.pending_buf[s2.pending++] = s2.bi_buf;
          }
          s2.bi_buf = 0;
          s2.bi_valid = 0;
        };
        const copy_block = (s2, buf2, len, header) => {
          bi_windup(s2);
          if (header) {
            put_short(s2, len);
            put_short(s2, ~len);
          }
          s2.pending_buf.set(s2.window.subarray(buf2, buf2 + len), s2.pending);
          s2.pending += len;
        };
        const smaller = (tree, n, m, depth) => {
          const _n2 = n * 2;
          const _m2 = m * 2;
          return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        };
        const pqdownheap = (s2, tree, k2) => {
          const v = s2.heap[k2];
          let j = k2 << 1;
          while (j <= s2.heap_len) {
            if (j < s2.heap_len && smaller(tree, s2.heap[j + 1], s2.heap[j], s2.depth)) {
              j++;
            }
            if (smaller(tree, v, s2.heap[j], s2.depth)) {
              break;
            }
            s2.heap[k2] = s2.heap[j];
            k2 = j;
            j <<= 1;
          }
          s2.heap[k2] = v;
        };
        const compress_block = (s2, ltree, dtree) => {
          let dist;
          let lc;
          let lx = 0;
          let code;
          let extra;
          if (s2.last_lit !== 0) {
            do {
              dist = s2.pending_buf[s2.d_buf + lx * 2] << 8 | s2.pending_buf[s2.d_buf + lx * 2 + 1];
              lc = s2.pending_buf[s2.l_buf + lx];
              lx++;
              if (dist === 0) {
                send_code(s2, lc, ltree);
              } else {
                code = _length_code[lc];
                send_code(s2, code + LITERALS$1 + 1, ltree);
                extra = extra_lbits[code];
                if (extra !== 0) {
                  lc -= base_length[code];
                  send_bits(s2, lc, extra);
                }
                dist--;
                code = d_code(dist);
                send_code(s2, code, dtree);
                extra = extra_dbits[code];
                if (extra !== 0) {
                  dist -= base_dist[code];
                  send_bits(s2, dist, extra);
                }
              }
            } while (lx < s2.last_lit);
          }
          send_code(s2, END_BLOCK, ltree);
        };
        const build_tree = (s2, desc) => {
          const tree = desc.dyn_tree;
          const stree = desc.stat_desc.static_tree;
          const has_stree = desc.stat_desc.has_stree;
          const elems = desc.stat_desc.elems;
          let n, m;
          let max_code = -1;
          let node;
          s2.heap_len = 0;
          s2.heap_max = HEAP_SIZE$1;
          for (n = 0; n < elems; n++) {
            if (tree[n * 2] !== 0) {
              s2.heap[++s2.heap_len] = max_code = n;
              s2.depth[n] = 0;
            } else {
              tree[n * 2 + 1] = 0;
            }
          }
          while (s2.heap_len < 2) {
            node = s2.heap[++s2.heap_len] = max_code < 2 ? ++max_code : 0;
            tree[node * 2] = 1;
            s2.depth[node] = 0;
            s2.opt_len--;
            if (has_stree) {
              s2.static_len -= stree[node * 2 + 1];
            }
          }
          desc.max_code = max_code;
          for (n = s2.heap_len >> 1; n >= 1; n--) {
            pqdownheap(s2, tree, n);
          }
          node = elems;
          do {
            n = s2.heap[1];
            s2.heap[1] = s2.heap[s2.heap_len--];
            pqdownheap(s2, tree, 1);
            m = s2.heap[1];
            s2.heap[--s2.heap_max] = n;
            s2.heap[--s2.heap_max] = m;
            tree[node * 2] = tree[n * 2] + tree[m * 2];
            s2.depth[node] = (s2.depth[n] >= s2.depth[m] ? s2.depth[n] : s2.depth[m]) + 1;
            tree[n * 2 + 1] = tree[m * 2 + 1] = node;
            s2.heap[1] = node++;
            pqdownheap(s2, tree, 1);
          } while (s2.heap_len >= 2);
          s2.heap[--s2.heap_max] = s2.heap[1];
          gen_bitlen(s2, desc);
          gen_codes(tree, max_code, s2.bl_count);
        };
        const scan_tree = (s2, tree, max_code) => {
          let n;
          let prevlen = -1;
          let curlen;
          let nextlen = tree[0 * 2 + 1];
          let count = 0;
          let max_count = 7;
          let min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          tree[(max_code + 1) * 2 + 1] = 65535;
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              s2.bl_tree[curlen * 2] += count;
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                s2.bl_tree[curlen * 2]++;
              }
              s2.bl_tree[REP_3_6 * 2]++;
            } else if (count <= 10) {
              s2.bl_tree[REPZ_3_10 * 2]++;
            } else {
              s2.bl_tree[REPZ_11_138 * 2]++;
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        };
        const send_tree = (s2, tree, max_code) => {
          let n;
          let prevlen = -1;
          let curlen;
          let nextlen = tree[0 * 2 + 1];
          let count = 0;
          let max_count = 7;
          let min_count = 4;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          }
          for (n = 0; n <= max_code; n++) {
            curlen = nextlen;
            nextlen = tree[(n + 1) * 2 + 1];
            if (++count < max_count && curlen === nextlen) {
              continue;
            } else if (count < min_count) {
              do {
                send_code(s2, curlen, s2.bl_tree);
              } while (--count !== 0);
            } else if (curlen !== 0) {
              if (curlen !== prevlen) {
                send_code(s2, curlen, s2.bl_tree);
                count--;
              }
              send_code(s2, REP_3_6, s2.bl_tree);
              send_bits(s2, count - 3, 2);
            } else if (count <= 10) {
              send_code(s2, REPZ_3_10, s2.bl_tree);
              send_bits(s2, count - 3, 3);
            } else {
              send_code(s2, REPZ_11_138, s2.bl_tree);
              send_bits(s2, count - 11, 7);
            }
            count = 0;
            prevlen = curlen;
            if (nextlen === 0) {
              max_count = 138;
              min_count = 3;
            } else if (curlen === nextlen) {
              max_count = 6;
              min_count = 3;
            } else {
              max_count = 7;
              min_count = 4;
            }
          }
        };
        const build_bl_tree = (s2) => {
          let max_blindex;
          scan_tree(s2, s2.dyn_ltree, s2.l_desc.max_code);
          scan_tree(s2, s2.dyn_dtree, s2.d_desc.max_code);
          build_tree(s2, s2.bl_desc);
          for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
            if (s2.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
              break;
            }
          }
          s2.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
          return max_blindex;
        };
        const send_all_trees = (s2, lcodes, dcodes, blcodes) => {
          let rank2;
          send_bits(s2, lcodes - 257, 5);
          send_bits(s2, dcodes - 1, 5);
          send_bits(s2, blcodes - 4, 4);
          for (rank2 = 0; rank2 < blcodes; rank2++) {
            send_bits(s2, s2.bl_tree[bl_order[rank2] * 2 + 1], 3);
          }
          send_tree(s2, s2.dyn_ltree, lcodes - 1);
          send_tree(s2, s2.dyn_dtree, dcodes - 1);
        };
        const detect_data_type = (s2) => {
          let black_mask = 4093624447;
          let n;
          for (n = 0; n <= 31; n++, black_mask >>>= 1) {
            if (black_mask & 1 && s2.dyn_ltree[n * 2] !== 0) {
              return Z_BINARY;
            }
          }
          if (s2.dyn_ltree[9 * 2] !== 0 || s2.dyn_ltree[10 * 2] !== 0 || s2.dyn_ltree[13 * 2] !== 0) {
            return Z_TEXT;
          }
          for (n = 32; n < LITERALS$1; n++) {
            if (s2.dyn_ltree[n * 2] !== 0) {
              return Z_TEXT;
            }
          }
          return Z_BINARY;
        };
        let static_init_done = false;
        const _tr_init$1 = (s2) => {
          if (!static_init_done) {
            tr_static_init();
            static_init_done = true;
          }
          s2.l_desc = new TreeDesc(s2.dyn_ltree, static_l_desc);
          s2.d_desc = new TreeDesc(s2.dyn_dtree, static_d_desc);
          s2.bl_desc = new TreeDesc(s2.bl_tree, static_bl_desc);
          s2.bi_buf = 0;
          s2.bi_valid = 0;
          init_block(s2);
        };
        const _tr_stored_block$1 = (s2, buf2, stored_len, last2) => {
          send_bits(s2, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
          copy_block(s2, buf2, stored_len, true);
        };
        const _tr_align$1 = (s2) => {
          send_bits(s2, STATIC_TREES << 1, 3);
          send_code(s2, END_BLOCK, static_ltree);
          bi_flush(s2);
        };
        const _tr_flush_block$1 = (s2, buf2, stored_len, last2) => {
          let opt_lenb, static_lenb;
          let max_blindex = 0;
          if (s2.level > 0) {
            if (s2.strm.data_type === Z_UNKNOWN$1) {
              s2.strm.data_type = detect_data_type(s2);
            }
            build_tree(s2, s2.l_desc);
            build_tree(s2, s2.d_desc);
            max_blindex = build_bl_tree(s2);
            opt_lenb = s2.opt_len + 3 + 7 >>> 3;
            static_lenb = s2.static_len + 3 + 7 >>> 3;
            if (static_lenb <= opt_lenb) {
              opt_lenb = static_lenb;
            }
          } else {
            opt_lenb = static_lenb = stored_len + 5;
          }
          if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
            _tr_stored_block$1(s2, buf2, stored_len, last2);
          } else if (s2.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
            send_bits(s2, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
            compress_block(s2, static_ltree, static_dtree);
          } else {
            send_bits(s2, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
            send_all_trees(s2, s2.l_desc.max_code + 1, s2.d_desc.max_code + 1, max_blindex + 1);
            compress_block(s2, s2.dyn_ltree, s2.dyn_dtree);
          }
          init_block(s2);
          if (last2) {
            bi_windup(s2);
          }
        };
        const _tr_tally$1 = (s2, dist, lc) => {
          s2.pending_buf[s2.d_buf + s2.last_lit * 2] = dist >>> 8 & 255;
          s2.pending_buf[s2.d_buf + s2.last_lit * 2 + 1] = dist & 255;
          s2.pending_buf[s2.l_buf + s2.last_lit] = lc & 255;
          s2.last_lit++;
          if (dist === 0) {
            s2.dyn_ltree[lc * 2]++;
          } else {
            s2.matches++;
            dist--;
            s2.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
            s2.dyn_dtree[d_code(dist) * 2]++;
          }
          return s2.last_lit === s2.lit_bufsize - 1;
        };
        var _tr_init_1 = _tr_init$1;
        var _tr_stored_block_1 = _tr_stored_block$1;
        var _tr_flush_block_1 = _tr_flush_block$1;
        var _tr_tally_1 = _tr_tally$1;
        var _tr_align_1 = _tr_align$1;
        var trees = {
          _tr_init: _tr_init_1,
          _tr_stored_block: _tr_stored_block_1,
          _tr_flush_block: _tr_flush_block_1,
          _tr_tally: _tr_tally_1,
          _tr_align: _tr_align_1
        };
        const adler32 = (adler, buf2, len, pos) => {
          let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
          while (len !== 0) {
            n = len > 2e3 ? 2e3 : len;
            len -= n;
            do {
              s1 = s1 + buf2[pos++] | 0;
              s2 = s2 + s1 | 0;
            } while (--n);
            s1 %= 65521;
            s2 %= 65521;
          }
          return s1 | s2 << 16 | 0;
        };
        var adler32_1 = adler32;
        const makeTable = () => {
          let c, table = [];
          for (var n = 0; n < 256; n++) {
            c = n;
            for (var k2 = 0; k2 < 8; k2++) {
              c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
            }
            table[n] = c;
          }
          return table;
        };
        const crcTable = new Uint32Array(makeTable());
        const crc32 = (crc, buf2, len, pos) => {
          const t = crcTable;
          const end = pos + len;
          crc ^= -1;
          for (let i = pos; i < end; i++) {
            crc = crc >>> 8 ^ t[(crc ^ buf2[i]) & 255];
          }
          return crc ^ -1;
        };
        var crc32_1 = crc32;
        var messages = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        };
        var constants$2 = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_MEM_ERROR: -4,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        };
        const { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
        const {
          Z_NO_FLUSH: Z_NO_FLUSH$2,
          Z_PARTIAL_FLUSH,
          Z_FULL_FLUSH: Z_FULL_FLUSH$1,
          Z_FINISH: Z_FINISH$3,
          Z_BLOCK: Z_BLOCK$1,
          Z_OK: Z_OK$3,
          Z_STREAM_END: Z_STREAM_END$3,
          Z_STREAM_ERROR: Z_STREAM_ERROR$2,
          Z_DATA_ERROR: Z_DATA_ERROR$2,
          Z_BUF_ERROR: Z_BUF_ERROR$1,
          Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
          Z_FILTERED,
          Z_HUFFMAN_ONLY,
          Z_RLE,
          Z_FIXED,
          Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
          Z_UNKNOWN,
          Z_DEFLATED: Z_DEFLATED$2
        } = constants$2;
        const MAX_MEM_LEVEL = 9;
        const MAX_WBITS$1 = 15;
        const DEF_MEM_LEVEL = 8;
        const LENGTH_CODES = 29;
        const LITERALS = 256;
        const L_CODES = LITERALS + 1 + LENGTH_CODES;
        const D_CODES = 30;
        const BL_CODES = 19;
        const HEAP_SIZE = 2 * L_CODES + 1;
        const MAX_BITS = 15;
        const MIN_MATCH = 3;
        const MAX_MATCH = 258;
        const MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
        const PRESET_DICT = 32;
        const INIT_STATE = 42;
        const EXTRA_STATE = 69;
        const NAME_STATE = 73;
        const COMMENT_STATE = 91;
        const HCRC_STATE = 103;
        const BUSY_STATE = 113;
        const FINISH_STATE = 666;
        const BS_NEED_MORE = 1;
        const BS_BLOCK_DONE = 2;
        const BS_FINISH_STARTED = 3;
        const BS_FINISH_DONE = 4;
        const OS_CODE = 3;
        const err = (strm, errorCode) => {
          strm.msg = messages[errorCode];
          return errorCode;
        };
        const rank = (f) => {
          return (f << 1) - (f > 4 ? 9 : 0);
        };
        const zero = (buf2) => {
          let len = buf2.length;
          while (--len >= 0) {
            buf2[len] = 0;
          }
        };
        let HASH_ZLIB = (s2, prev, data) => (prev << s2.hash_shift ^ data) & s2.hash_mask;
        let HASH = HASH_ZLIB;
        const flush_pending = (strm) => {
          const s2 = strm.state;
          let len = s2.pending;
          if (len > strm.avail_out) {
            len = strm.avail_out;
          }
          if (len === 0) {
            return;
          }
          strm.output.set(s2.pending_buf.subarray(s2.pending_out, s2.pending_out + len), strm.next_out);
          strm.next_out += len;
          s2.pending_out += len;
          strm.total_out += len;
          strm.avail_out -= len;
          s2.pending -= len;
          if (s2.pending === 0) {
            s2.pending_out = 0;
          }
        };
        const flush_block_only = (s2, last2) => {
          _tr_flush_block(s2, s2.block_start >= 0 ? s2.block_start : -1, s2.strstart - s2.block_start, last2);
          s2.block_start = s2.strstart;
          flush_pending(s2.strm);
        };
        const put_byte = (s2, b) => {
          s2.pending_buf[s2.pending++] = b;
        };
        const putShortMSB = (s2, b) => {
          s2.pending_buf[s2.pending++] = b >>> 8 & 255;
          s2.pending_buf[s2.pending++] = b & 255;
        };
        const read_buf = (strm, buf2, start, size3) => {
          let len = strm.avail_in;
          if (len > size3) {
            len = size3;
          }
          if (len === 0) {
            return 0;
          }
          strm.avail_in -= len;
          buf2.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
          if (strm.state.wrap === 1) {
            strm.adler = adler32_1(strm.adler, buf2, len, start);
          } else if (strm.state.wrap === 2) {
            strm.adler = crc32_1(strm.adler, buf2, len, start);
          }
          strm.next_in += len;
          strm.total_in += len;
          return len;
        };
        const longest_match = (s2, cur_match) => {
          let chain_length = s2.max_chain_length;
          let scan = s2.strstart;
          let match;
          let len;
          let best_len = s2.prev_length;
          let nice_match = s2.nice_match;
          const limit = s2.strstart > s2.w_size - MIN_LOOKAHEAD ? s2.strstart - (s2.w_size - MIN_LOOKAHEAD) : 0;
          const _win = s2.window;
          const wmask = s2.w_mask;
          const prev = s2.prev;
          const strend = s2.strstart + MAX_MATCH;
          let scan_end1 = _win[scan + best_len - 1];
          let scan_end = _win[scan + best_len];
          if (s2.prev_length >= s2.good_match) {
            chain_length >>= 2;
          }
          if (nice_match > s2.lookahead) {
            nice_match = s2.lookahead;
          }
          do {
            match = cur_match;
            if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
              continue;
            }
            scan += 2;
            match++;
            do {
            } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
            len = MAX_MATCH - (strend - scan);
            scan = strend - MAX_MATCH;
            if (len > best_len) {
              s2.match_start = cur_match;
              best_len = len;
              if (len >= nice_match) {
                break;
              }
              scan_end1 = _win[scan + best_len - 1];
              scan_end = _win[scan + best_len];
            }
          } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
          if (best_len <= s2.lookahead) {
            return best_len;
          }
          return s2.lookahead;
        };
        const fill_window = (s2) => {
          const _w_size = s2.w_size;
          let p2, n, m, more, str;
          do {
            more = s2.window_size - s2.lookahead - s2.strstart;
            if (s2.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
              s2.window.set(s2.window.subarray(_w_size, _w_size + _w_size), 0);
              s2.match_start -= _w_size;
              s2.strstart -= _w_size;
              s2.block_start -= _w_size;
              n = s2.hash_size;
              p2 = n;
              do {
                m = s2.head[--p2];
                s2.head[p2] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              n = _w_size;
              p2 = n;
              do {
                m = s2.prev[--p2];
                s2.prev[p2] = m >= _w_size ? m - _w_size : 0;
              } while (--n);
              more += _w_size;
            }
            if (s2.strm.avail_in === 0) {
              break;
            }
            n = read_buf(s2.strm, s2.window, s2.strstart + s2.lookahead, more);
            s2.lookahead += n;
            if (s2.lookahead + s2.insert >= MIN_MATCH) {
              str = s2.strstart - s2.insert;
              s2.ins_h = s2.window[str];
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + 1]);
              while (s2.insert) {
                s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
                s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
                s2.head[s2.ins_h] = str;
                str++;
                s2.insert--;
                if (s2.lookahead + s2.insert < MIN_MATCH) {
                  break;
                }
              }
            }
          } while (s2.lookahead < MIN_LOOKAHEAD && s2.strm.avail_in !== 0);
        };
        const deflate_stored = (s2, flush) => {
          let max_block_size = 65535;
          if (max_block_size > s2.pending_buf_size - 5) {
            max_block_size = s2.pending_buf_size - 5;
          }
          for (; ; ) {
            if (s2.lookahead <= 1) {
              fill_window(s2);
              if (s2.lookahead === 0 && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            s2.strstart += s2.lookahead;
            s2.lookahead = 0;
            const max_start = s2.block_start + max_block_size;
            if (s2.strstart === 0 || s2.strstart >= max_start) {
              s2.lookahead = s2.strstart - max_start;
              s2.strstart = max_start;
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
            if (s2.strstart - s2.block_start >= s2.w_size - MIN_LOOKAHEAD) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = 0;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.strstart > s2.block_start) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_NEED_MORE;
        };
        const deflate_fast = (s2, flush) => {
          let hash_head;
          let bflush;
          for (; ; ) {
            if (s2.lookahead < MIN_LOOKAHEAD) {
              fill_window(s2);
              if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s2.lookahead >= MIN_MATCH) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
            if (hash_head !== 0 && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
              s2.match_length = longest_match(s2, hash_head);
            }
            if (s2.match_length >= MIN_MATCH) {
              bflush = _tr_tally(s2, s2.strstart - s2.match_start, s2.match_length - MIN_MATCH);
              s2.lookahead -= s2.match_length;
              if (s2.match_length <= s2.max_lazy_match && s2.lookahead >= MIN_MATCH) {
                s2.match_length--;
                do {
                  s2.strstart++;
                  s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
                  hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                  s2.head[s2.ins_h] = s2.strstart;
                } while (--s2.match_length !== 0);
                s2.strstart++;
              } else {
                s2.strstart += s2.match_length;
                s2.match_length = 0;
                s2.ins_h = s2.window[s2.strstart];
                s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + 1]);
              }
            } else {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
              s2.lookahead--;
              s2.strstart++;
            }
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.last_lit) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        const deflate_slow = (s2, flush) => {
          let hash_head;
          let bflush;
          let max_insert;
          for (; ; ) {
            if (s2.lookahead < MIN_LOOKAHEAD) {
              fill_window(s2);
              if (s2.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            hash_head = 0;
            if (s2.lookahead >= MIN_MATCH) {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
              hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = s2.strstart;
            }
            s2.prev_length = s2.match_length;
            s2.prev_match = s2.match_start;
            s2.match_length = MIN_MATCH - 1;
            if (hash_head !== 0 && s2.prev_length < s2.max_lazy_match && s2.strstart - hash_head <= s2.w_size - MIN_LOOKAHEAD) {
              s2.match_length = longest_match(s2, hash_head);
              if (s2.match_length <= 5 && (s2.strategy === Z_FILTERED || s2.match_length === MIN_MATCH && s2.strstart - s2.match_start > 4096)) {
                s2.match_length = MIN_MATCH - 1;
              }
            }
            if (s2.prev_length >= MIN_MATCH && s2.match_length <= s2.prev_length) {
              max_insert = s2.strstart + s2.lookahead - MIN_MATCH;
              bflush = _tr_tally(s2, s2.strstart - 1 - s2.prev_match, s2.prev_length - MIN_MATCH);
              s2.lookahead -= s2.prev_length - 1;
              s2.prev_length -= 2;
              do {
                if (++s2.strstart <= max_insert) {
                  s2.ins_h = HASH(s2, s2.ins_h, s2.window[s2.strstart + MIN_MATCH - 1]);
                  hash_head = s2.prev[s2.strstart & s2.w_mask] = s2.head[s2.ins_h];
                  s2.head[s2.ins_h] = s2.strstart;
                }
              } while (--s2.prev_length !== 0);
              s2.match_available = 0;
              s2.match_length = MIN_MATCH - 1;
              s2.strstart++;
              if (bflush) {
                flush_block_only(s2, false);
                if (s2.strm.avail_out === 0) {
                  return BS_NEED_MORE;
                }
              }
            } else if (s2.match_available) {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
              if (bflush) {
                flush_block_only(s2, false);
              }
              s2.strstart++;
              s2.lookahead--;
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            } else {
              s2.match_available = 1;
              s2.strstart++;
              s2.lookahead--;
            }
          }
          if (s2.match_available) {
            bflush = _tr_tally(s2, 0, s2.window[s2.strstart - 1]);
            s2.match_available = 0;
          }
          s2.insert = s2.strstart < MIN_MATCH - 1 ? s2.strstart : MIN_MATCH - 1;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.last_lit) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        const deflate_rle = (s2, flush) => {
          let bflush;
          let prev;
          let scan, strend;
          const _win = s2.window;
          for (; ; ) {
            if (s2.lookahead <= MAX_MATCH) {
              fill_window(s2);
              if (s2.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
                return BS_NEED_MORE;
              }
              if (s2.lookahead === 0) {
                break;
              }
            }
            s2.match_length = 0;
            if (s2.lookahead >= MIN_MATCH && s2.strstart > 0) {
              scan = s2.strstart - 1;
              prev = _win[scan];
              if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                strend = s2.strstart + MAX_MATCH;
                do {
                } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                s2.match_length = MAX_MATCH - (strend - scan);
                if (s2.match_length > s2.lookahead) {
                  s2.match_length = s2.lookahead;
                }
              }
            }
            if (s2.match_length >= MIN_MATCH) {
              bflush = _tr_tally(s2, 1, s2.match_length - MIN_MATCH);
              s2.lookahead -= s2.match_length;
              s2.strstart += s2.match_length;
              s2.match_length = 0;
            } else {
              bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
              s2.lookahead--;
              s2.strstart++;
            }
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = 0;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.last_lit) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        const deflate_huff = (s2, flush) => {
          let bflush;
          for (; ; ) {
            if (s2.lookahead === 0) {
              fill_window(s2);
              if (s2.lookahead === 0) {
                if (flush === Z_NO_FLUSH$2) {
                  return BS_NEED_MORE;
                }
                break;
              }
            }
            s2.match_length = 0;
            bflush = _tr_tally(s2, 0, s2.window[s2.strstart]);
            s2.lookahead--;
            s2.strstart++;
            if (bflush) {
              flush_block_only(s2, false);
              if (s2.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          }
          s2.insert = 0;
          if (flush === Z_FINISH$3) {
            flush_block_only(s2, true);
            if (s2.strm.avail_out === 0) {
              return BS_FINISH_STARTED;
            }
            return BS_FINISH_DONE;
          }
          if (s2.last_lit) {
            flush_block_only(s2, false);
            if (s2.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          return BS_BLOCK_DONE;
        };
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
          this.good_length = good_length;
          this.max_lazy = max_lazy;
          this.nice_length = nice_length;
          this.max_chain = max_chain;
          this.func = func;
        }
        const configuration_table = [
          new Config(0, 0, 0, 0, deflate_stored),
          new Config(4, 4, 8, 4, deflate_fast),
          new Config(4, 5, 16, 8, deflate_fast),
          new Config(4, 6, 32, 32, deflate_fast),
          new Config(4, 4, 16, 16, deflate_slow),
          new Config(8, 16, 32, 32, deflate_slow),
          new Config(8, 16, 128, 128, deflate_slow),
          new Config(8, 32, 128, 256, deflate_slow),
          new Config(32, 128, 258, 1024, deflate_slow),
          new Config(32, 258, 258, 4096, deflate_slow)
        ];
        const lm_init = (s2) => {
          s2.window_size = 2 * s2.w_size;
          zero(s2.head);
          s2.max_lazy_match = configuration_table[s2.level].max_lazy;
          s2.good_match = configuration_table[s2.level].good_length;
          s2.nice_match = configuration_table[s2.level].nice_length;
          s2.max_chain_length = configuration_table[s2.level].max_chain;
          s2.strstart = 0;
          s2.block_start = 0;
          s2.lookahead = 0;
          s2.insert = 0;
          s2.match_length = s2.prev_length = MIN_MATCH - 1;
          s2.match_available = 0;
          s2.ins_h = 0;
        };
        function DeflateState() {
          this.strm = null;
          this.status = 0;
          this.pending_buf = null;
          this.pending_buf_size = 0;
          this.pending_out = 0;
          this.pending = 0;
          this.wrap = 0;
          this.gzhead = null;
          this.gzindex = 0;
          this.method = Z_DEFLATED$2;
          this.last_flush = -1;
          this.w_size = 0;
          this.w_bits = 0;
          this.w_mask = 0;
          this.window = null;
          this.window_size = 0;
          this.prev = null;
          this.head = null;
          this.ins_h = 0;
          this.hash_size = 0;
          this.hash_bits = 0;
          this.hash_mask = 0;
          this.hash_shift = 0;
          this.block_start = 0;
          this.match_length = 0;
          this.prev_match = 0;
          this.match_available = 0;
          this.strstart = 0;
          this.match_start = 0;
          this.lookahead = 0;
          this.prev_length = 0;
          this.max_chain_length = 0;
          this.max_lazy_match = 0;
          this.level = 0;
          this.strategy = 0;
          this.good_match = 0;
          this.nice_match = 0;
          this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
          this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
          this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
          zero(this.dyn_ltree);
          zero(this.dyn_dtree);
          zero(this.bl_tree);
          this.l_desc = null;
          this.d_desc = null;
          this.bl_desc = null;
          this.bl_count = new Uint16Array(MAX_BITS + 1);
          this.heap = new Uint16Array(2 * L_CODES + 1);
          zero(this.heap);
          this.heap_len = 0;
          this.heap_max = 0;
          this.depth = new Uint16Array(2 * L_CODES + 1);
          zero(this.depth);
          this.l_buf = 0;
          this.lit_bufsize = 0;
          this.last_lit = 0;
          this.d_buf = 0;
          this.opt_len = 0;
          this.static_len = 0;
          this.matches = 0;
          this.insert = 0;
          this.bi_buf = 0;
          this.bi_valid = 0;
        }
        const deflateResetKeep = (strm) => {
          if (!strm || !strm.state) {
            return err(strm, Z_STREAM_ERROR$2);
          }
          strm.total_in = strm.total_out = 0;
          strm.data_type = Z_UNKNOWN;
          const s2 = strm.state;
          s2.pending = 0;
          s2.pending_out = 0;
          if (s2.wrap < 0) {
            s2.wrap = -s2.wrap;
          }
          s2.status = s2.wrap ? INIT_STATE : BUSY_STATE;
          strm.adler = s2.wrap === 2 ? 0 : 1;
          s2.last_flush = Z_NO_FLUSH$2;
          _tr_init(s2);
          return Z_OK$3;
        };
        const deflateReset = (strm) => {
          const ret = deflateResetKeep(strm);
          if (ret === Z_OK$3) {
            lm_init(strm.state);
          }
          return ret;
        };
        const deflateSetHeader = (strm, head) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$2;
          }
          if (strm.state.wrap !== 2) {
            return Z_STREAM_ERROR$2;
          }
          strm.state.gzhead = head;
          return Z_OK$3;
        };
        const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
          if (!strm) {
            return Z_STREAM_ERROR$2;
          }
          let wrap = 1;
          if (level === Z_DEFAULT_COMPRESSION$1) {
            level = 6;
          }
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else if (windowBits > 15) {
            wrap = 2;
            windowBits -= 16;
          }
          if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
            return err(strm, Z_STREAM_ERROR$2);
          }
          if (windowBits === 8) {
            windowBits = 9;
          }
          const s2 = new DeflateState();
          strm.state = s2;
          s2.strm = strm;
          s2.wrap = wrap;
          s2.gzhead = null;
          s2.w_bits = windowBits;
          s2.w_size = 1 << s2.w_bits;
          s2.w_mask = s2.w_size - 1;
          s2.hash_bits = memLevel + 7;
          s2.hash_size = 1 << s2.hash_bits;
          s2.hash_mask = s2.hash_size - 1;
          s2.hash_shift = ~~((s2.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
          s2.window = new Uint8Array(s2.w_size * 2);
          s2.head = new Uint16Array(s2.hash_size);
          s2.prev = new Uint16Array(s2.w_size);
          s2.lit_bufsize = 1 << memLevel + 6;
          s2.pending_buf_size = s2.lit_bufsize * 4;
          s2.pending_buf = new Uint8Array(s2.pending_buf_size);
          s2.d_buf = 1 * s2.lit_bufsize;
          s2.l_buf = (1 + 2) * s2.lit_bufsize;
          s2.level = level;
          s2.strategy = strategy;
          s2.method = method;
          return deflateReset(strm);
        };
        const deflateInit = (strm, level) => {
          return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
        };
        const deflate$2 = (strm, flush) => {
          let beg, val;
          if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {
            return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
          }
          const s2 = strm.state;
          if (!strm.output || !strm.input && strm.avail_in !== 0 || s2.status === FINISH_STATE && flush !== Z_FINISH$3) {
            return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
          }
          s2.strm = strm;
          const old_flush = s2.last_flush;
          s2.last_flush = flush;
          if (s2.status === INIT_STATE) {
            if (s2.wrap === 2) {
              strm.adler = 0;
              put_byte(s2, 31);
              put_byte(s2, 139);
              put_byte(s2, 8);
              if (!s2.gzhead) {
                put_byte(s2, 0);
                put_byte(s2, 0);
                put_byte(s2, 0);
                put_byte(s2, 0);
                put_byte(s2, 0);
                put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
                put_byte(s2, OS_CODE);
                s2.status = BUSY_STATE;
              } else {
                put_byte(s2, (s2.gzhead.text ? 1 : 0) + (s2.gzhead.hcrc ? 2 : 0) + (!s2.gzhead.extra ? 0 : 4) + (!s2.gzhead.name ? 0 : 8) + (!s2.gzhead.comment ? 0 : 16));
                put_byte(s2, s2.gzhead.time & 255);
                put_byte(s2, s2.gzhead.time >> 8 & 255);
                put_byte(s2, s2.gzhead.time >> 16 & 255);
                put_byte(s2, s2.gzhead.time >> 24 & 255);
                put_byte(s2, s2.level === 9 ? 2 : s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2 ? 4 : 0);
                put_byte(s2, s2.gzhead.os & 255);
                if (s2.gzhead.extra && s2.gzhead.extra.length) {
                  put_byte(s2, s2.gzhead.extra.length & 255);
                  put_byte(s2, s2.gzhead.extra.length >> 8 & 255);
                }
                if (s2.gzhead.hcrc) {
                  strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending, 0);
                }
                s2.gzindex = 0;
                s2.status = EXTRA_STATE;
              }
            } else {
              let header = Z_DEFLATED$2 + (s2.w_bits - 8 << 4) << 8;
              let level_flags = -1;
              if (s2.strategy >= Z_HUFFMAN_ONLY || s2.level < 2) {
                level_flags = 0;
              } else if (s2.level < 6) {
                level_flags = 1;
              } else if (s2.level === 6) {
                level_flags = 2;
              } else {
                level_flags = 3;
              }
              header |= level_flags << 6;
              if (s2.strstart !== 0) {
                header |= PRESET_DICT;
              }
              header += 31 - header % 31;
              s2.status = BUSY_STATE;
              putShortMSB(s2, header);
              if (s2.strstart !== 0) {
                putShortMSB(s2, strm.adler >>> 16);
                putShortMSB(s2, strm.adler & 65535);
              }
              strm.adler = 1;
            }
          }
          if (s2.status === EXTRA_STATE) {
            if (s2.gzhead.extra) {
              beg = s2.pending;
              while (s2.gzindex < (s2.gzhead.extra.length & 65535)) {
                if (s2.pending === s2.pending_buf_size) {
                  if (s2.gzhead.hcrc && s2.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s2.pending;
                  if (s2.pending === s2.pending_buf_size) {
                    break;
                  }
                }
                put_byte(s2, s2.gzhead.extra[s2.gzindex] & 255);
                s2.gzindex++;
              }
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              if (s2.gzindex === s2.gzhead.extra.length) {
                s2.gzindex = 0;
                s2.status = NAME_STATE;
              }
            } else {
              s2.status = NAME_STATE;
            }
          }
          if (s2.status === NAME_STATE) {
            if (s2.gzhead.name) {
              beg = s2.pending;
              do {
                if (s2.pending === s2.pending_buf_size) {
                  if (s2.gzhead.hcrc && s2.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s2.pending;
                  if (s2.pending === s2.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s2.gzindex < s2.gzhead.name.length) {
                  val = s2.gzhead.name.charCodeAt(s2.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s2, val);
              } while (val !== 0);
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              if (val === 0) {
                s2.gzindex = 0;
                s2.status = COMMENT_STATE;
              }
            } else {
              s2.status = COMMENT_STATE;
            }
          }
          if (s2.status === COMMENT_STATE) {
            if (s2.gzhead.comment) {
              beg = s2.pending;
              do {
                if (s2.pending === s2.pending_buf_size) {
                  if (s2.gzhead.hcrc && s2.pending > beg) {
                    strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
                  }
                  flush_pending(strm);
                  beg = s2.pending;
                  if (s2.pending === s2.pending_buf_size) {
                    val = 1;
                    break;
                  }
                }
                if (s2.gzindex < s2.gzhead.comment.length) {
                  val = s2.gzhead.comment.charCodeAt(s2.gzindex++) & 255;
                } else {
                  val = 0;
                }
                put_byte(s2, val);
              } while (val !== 0);
              if (s2.gzhead.hcrc && s2.pending > beg) {
                strm.adler = crc32_1(strm.adler, s2.pending_buf, s2.pending - beg, beg);
              }
              if (val === 0) {
                s2.status = HCRC_STATE;
              }
            } else {
              s2.status = HCRC_STATE;
            }
          }
          if (s2.status === HCRC_STATE) {
            if (s2.gzhead.hcrc) {
              if (s2.pending + 2 > s2.pending_buf_size) {
                flush_pending(strm);
              }
              if (s2.pending + 2 <= s2.pending_buf_size) {
                put_byte(s2, strm.adler & 255);
                put_byte(s2, strm.adler >> 8 & 255);
                strm.adler = 0;
                s2.status = BUSY_STATE;
              }
            } else {
              s2.status = BUSY_STATE;
            }
          }
          if (s2.pending !== 0) {
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s2.last_flush = -1;
              return Z_OK$3;
            }
          } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
            return err(strm, Z_BUF_ERROR$1);
          }
          if (s2.status === FINISH_STATE && strm.avail_in !== 0) {
            return err(strm, Z_BUF_ERROR$1);
          }
          if (strm.avail_in !== 0 || s2.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s2.status !== FINISH_STATE) {
            let bstate = s2.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s2, flush) : s2.strategy === Z_RLE ? deflate_rle(s2, flush) : configuration_table[s2.level].func(s2, flush);
            if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
              s2.status = FINISH_STATE;
            }
            if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
              if (strm.avail_out === 0) {
                s2.last_flush = -1;
              }
              return Z_OK$3;
            }
            if (bstate === BS_BLOCK_DONE) {
              if (flush === Z_PARTIAL_FLUSH) {
                _tr_align(s2);
              } else if (flush !== Z_BLOCK$1) {
                _tr_stored_block(s2, 0, 0, false);
                if (flush === Z_FULL_FLUSH$1) {
                  zero(s2.head);
                  if (s2.lookahead === 0) {
                    s2.strstart = 0;
                    s2.block_start = 0;
                    s2.insert = 0;
                  }
                }
              }
              flush_pending(strm);
              if (strm.avail_out === 0) {
                s2.last_flush = -1;
                return Z_OK$3;
              }
            }
          }
          if (flush !== Z_FINISH$3) {
            return Z_OK$3;
          }
          if (s2.wrap <= 0) {
            return Z_STREAM_END$3;
          }
          if (s2.wrap === 2) {
            put_byte(s2, strm.adler & 255);
            put_byte(s2, strm.adler >> 8 & 255);
            put_byte(s2, strm.adler >> 16 & 255);
            put_byte(s2, strm.adler >> 24 & 255);
            put_byte(s2, strm.total_in & 255);
            put_byte(s2, strm.total_in >> 8 & 255);
            put_byte(s2, strm.total_in >> 16 & 255);
            put_byte(s2, strm.total_in >> 24 & 255);
          } else {
            putShortMSB(s2, strm.adler >>> 16);
            putShortMSB(s2, strm.adler & 65535);
          }
          flush_pending(strm);
          if (s2.wrap > 0) {
            s2.wrap = -s2.wrap;
          }
          return s2.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
        };
        const deflateEnd = (strm) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$2;
          }
          const status = strm.state.status;
          if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
            return err(strm, Z_STREAM_ERROR$2);
          }
          strm.state = null;
          return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
        };
        const deflateSetDictionary = (strm, dictionary) => {
          let dictLength = dictionary.length;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$2;
          }
          const s2 = strm.state;
          const wrap = s2.wrap;
          if (wrap === 2 || wrap === 1 && s2.status !== INIT_STATE || s2.lookahead) {
            return Z_STREAM_ERROR$2;
          }
          if (wrap === 1) {
            strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
          }
          s2.wrap = 0;
          if (dictLength >= s2.w_size) {
            if (wrap === 0) {
              zero(s2.head);
              s2.strstart = 0;
              s2.block_start = 0;
              s2.insert = 0;
            }
            let tmpDict = new Uint8Array(s2.w_size);
            tmpDict.set(dictionary.subarray(dictLength - s2.w_size, dictLength), 0);
            dictionary = tmpDict;
            dictLength = s2.w_size;
          }
          const avail = strm.avail_in;
          const next = strm.next_in;
          const input = strm.input;
          strm.avail_in = dictLength;
          strm.next_in = 0;
          strm.input = dictionary;
          fill_window(s2);
          while (s2.lookahead >= MIN_MATCH) {
            let str = s2.strstart;
            let n = s2.lookahead - (MIN_MATCH - 1);
            do {
              s2.ins_h = HASH(s2, s2.ins_h, s2.window[str + MIN_MATCH - 1]);
              s2.prev[str & s2.w_mask] = s2.head[s2.ins_h];
              s2.head[s2.ins_h] = str;
              str++;
            } while (--n);
            s2.strstart = str;
            s2.lookahead = MIN_MATCH - 1;
            fill_window(s2);
          }
          s2.strstart += s2.lookahead;
          s2.block_start = s2.strstart;
          s2.insert = s2.lookahead;
          s2.lookahead = 0;
          s2.match_length = s2.prev_length = MIN_MATCH - 1;
          s2.match_available = 0;
          strm.next_in = next;
          strm.input = input;
          strm.avail_in = avail;
          s2.wrap = wrap;
          return Z_OK$3;
        };
        var deflateInit_1 = deflateInit;
        var deflateInit2_1 = deflateInit2;
        var deflateReset_1 = deflateReset;
        var deflateResetKeep_1 = deflateResetKeep;
        var deflateSetHeader_1 = deflateSetHeader;
        var deflate_2$1 = deflate$2;
        var deflateEnd_1 = deflateEnd;
        var deflateSetDictionary_1 = deflateSetDictionary;
        var deflateInfo = "pako deflate (from Nodeca project)";
        var deflate_1$2 = {
          deflateInit: deflateInit_1,
          deflateInit2: deflateInit2_1,
          deflateReset: deflateReset_1,
          deflateResetKeep: deflateResetKeep_1,
          deflateSetHeader: deflateSetHeader_1,
          deflate: deflate_2$1,
          deflateEnd: deflateEnd_1,
          deflateSetDictionary: deflateSetDictionary_1,
          deflateInfo
        };
        const _has = (obj, key2) => {
          return Object.prototype.hasOwnProperty.call(obj, key2);
        };
        var assign = function(obj) {
          const sources = Array.prototype.slice.call(arguments, 1);
          while (sources.length) {
            const source = sources.shift();
            if (!source) {
              continue;
            }
            if (typeof source !== "object") {
              throw new TypeError(source + "must be non-object");
            }
            for (const p2 in source) {
              if (_has(source, p2)) {
                obj[p2] = source[p2];
              }
            }
          }
          return obj;
        };
        var flattenChunks = (chunks) => {
          let len = 0;
          for (let i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          const result = new Uint8Array(len);
          for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
            let chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        };
        var common = {
          assign,
          flattenChunks
        };
        let STR_APPLY_UIA_OK = true;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (__) {
          STR_APPLY_UIA_OK = false;
        }
        const _utf8len = new Uint8Array(256);
        for (let q = 0; q < 256; q++) {
          _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
        }
        _utf8len[254] = _utf8len[254] = 1;
        var string2buf = (str) => {
          if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
            return new TextEncoder().encode(str);
          }
          let buf2, c, c22, m_pos, i, str_len = str.length, buf_len = 0;
          for (m_pos = 0; m_pos < str_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
          }
          buf2 = new Uint8Array(buf_len);
          for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
            c = str.charCodeAt(m_pos);
            if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
              c22 = str.charCodeAt(m_pos + 1);
              if ((c22 & 64512) === 56320) {
                c = 65536 + (c - 55296 << 10) + (c22 - 56320);
                m_pos++;
              }
            }
            if (c < 128) {
              buf2[i++] = c;
            } else if (c < 2048) {
              buf2[i++] = 192 | c >>> 6;
              buf2[i++] = 128 | c & 63;
            } else if (c < 65536) {
              buf2[i++] = 224 | c >>> 12;
              buf2[i++] = 128 | c >>> 6 & 63;
              buf2[i++] = 128 | c & 63;
            } else {
              buf2[i++] = 240 | c >>> 18;
              buf2[i++] = 128 | c >>> 12 & 63;
              buf2[i++] = 128 | c >>> 6 & 63;
              buf2[i++] = 128 | c & 63;
            }
          }
          return buf2;
        };
        const buf2binstring = (buf2, len) => {
          if (len < 65534) {
            if (buf2.subarray && STR_APPLY_UIA_OK) {
              return String.fromCharCode.apply(null, buf2.length === len ? buf2 : buf2.subarray(0, len));
            }
          }
          let result = "";
          for (let i = 0; i < len; i++) {
            result += String.fromCharCode(buf2[i]);
          }
          return result;
        };
        var buf2string = (buf2, max) => {
          const len = max || buf2.length;
          if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
            return new TextDecoder().decode(buf2.subarray(0, max));
          }
          let i, out;
          const utf16buf = new Array(len * 2);
          for (out = 0, i = 0; i < len; ) {
            let c = buf2[i++];
            if (c < 128) {
              utf16buf[out++] = c;
              continue;
            }
            let c_len = _utf8len[c];
            if (c_len > 4) {
              utf16buf[out++] = 65533;
              i += c_len - 1;
              continue;
            }
            c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
            while (c_len > 1 && i < len) {
              c = c << 6 | buf2[i++] & 63;
              c_len--;
            }
            if (c_len > 1) {
              utf16buf[out++] = 65533;
              continue;
            }
            if (c < 65536) {
              utf16buf[out++] = c;
            } else {
              c -= 65536;
              utf16buf[out++] = 55296 | c >> 10 & 1023;
              utf16buf[out++] = 56320 | c & 1023;
            }
          }
          return buf2binstring(utf16buf, out);
        };
        var utf8border = (buf2, max) => {
          max = max || buf2.length;
          if (max > buf2.length) {
            max = buf2.length;
          }
          let pos = max - 1;
          while (pos >= 0 && (buf2[pos] & 192) === 128) {
            pos--;
          }
          if (pos < 0) {
            return max;
          }
          if (pos === 0) {
            return max;
          }
          return pos + _utf8len[buf2[pos]] > max ? pos : max;
        };
        var strings = {
          string2buf,
          buf2string,
          utf8border
        };
        function ZStream() {
          this.input = null;
          this.next_in = 0;
          this.avail_in = 0;
          this.total_in = 0;
          this.output = null;
          this.next_out = 0;
          this.avail_out = 0;
          this.total_out = 0;
          this.msg = "";
          this.state = null;
          this.data_type = 2;
          this.adler = 0;
        }
        var zstream = ZStream;
        const toString$1 = Object.prototype.toString;
        const {
          Z_NO_FLUSH: Z_NO_FLUSH$1,
          Z_SYNC_FLUSH,
          Z_FULL_FLUSH,
          Z_FINISH: Z_FINISH$2,
          Z_OK: Z_OK$2,
          Z_STREAM_END: Z_STREAM_END$2,
          Z_DEFAULT_COMPRESSION,
          Z_DEFAULT_STRATEGY,
          Z_DEFLATED: Z_DEFLATED$1
        } = constants$2;
        function Deflate$1(options) {
          this.options = common.assign({
            level: Z_DEFAULT_COMPRESSION,
            method: Z_DEFLATED$1,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: Z_DEFAULT_STRATEGY
          }, options || {});
          let opt = this.options;
          if (opt.raw && opt.windowBits > 0) {
            opt.windowBits = -opt.windowBits;
          } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
            opt.windowBits += 16;
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
          if (status !== Z_OK$2) {
            throw new Error(messages[status]);
          }
          if (opt.header) {
            deflate_1$2.deflateSetHeader(this.strm, opt.header);
          }
          if (opt.dictionary) {
            let dict;
            if (typeof opt.dictionary === "string") {
              dict = strings.string2buf(opt.dictionary);
            } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
              dict = new Uint8Array(opt.dictionary);
            } else {
              dict = opt.dictionary;
            }
            status = deflate_1$2.deflateSetDictionary(this.strm, dict);
            if (status !== Z_OK$2) {
              throw new Error(messages[status]);
            }
            this._dict_set = true;
          }
        }
        Deflate$1.prototype.push = function(data, flush_mode) {
          const strm = this.strm;
          const chunkSize = this.options.chunkSize;
          let status, _flush_mode;
          if (this.ended) {
            return false;
          }
          if (flush_mode === ~~flush_mode)
            _flush_mode = flush_mode;
          else
            _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
          if (typeof data === "string") {
            strm.input = strings.string2buf(data);
          } else if (toString$1.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          for (; ; ) {
            if (strm.avail_out === 0) {
              strm.output = new Uint8Array(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
              this.onData(strm.output.subarray(0, strm.next_out));
              strm.avail_out = 0;
              continue;
            }
            status = deflate_1$2.deflate(strm, _flush_mode);
            if (status === Z_STREAM_END$2) {
              if (strm.next_out > 0) {
                this.onData(strm.output.subarray(0, strm.next_out));
              }
              status = deflate_1$2.deflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return status === Z_OK$2;
            }
            if (strm.avail_out === 0) {
              this.onData(strm.output);
              continue;
            }
            if (_flush_mode > 0 && strm.next_out > 0) {
              this.onData(strm.output.subarray(0, strm.next_out));
              strm.avail_out = 0;
              continue;
            }
            if (strm.avail_in === 0)
              break;
          }
          return true;
        };
        Deflate$1.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Deflate$1.prototype.onEnd = function(status) {
          if (status === Z_OK$2) {
            this.result = common.flattenChunks(this.chunks);
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function deflate$1(input, options) {
          const deflator = new Deflate$1(options);
          deflator.push(input, true);
          if (deflator.err) {
            throw deflator.msg || messages[deflator.err];
          }
          return deflator.result;
        }
        function deflateRaw$1(input, options) {
          options = options || {};
          options.raw = true;
          return deflate$1(input, options);
        }
        function gzip$1(input, options) {
          options = options || {};
          options.gzip = true;
          return deflate$1(input, options);
        }
        var Deflate_1$1 = Deflate$1;
        var deflate_2 = deflate$1;
        var deflateRaw_1$1 = deflateRaw$1;
        var gzip_1$1 = gzip$1;
        var constants$1 = constants$2;
        var deflate_1$1 = {
          Deflate: Deflate_1$1,
          deflate: deflate_2,
          deflateRaw: deflateRaw_1$1,
          gzip: gzip_1$1,
          constants: constants$1
        };
        const BAD$1 = 30;
        const TYPE$1 = 12;
        var inffast = function inflate_fast(strm, start) {
          let _in;
          let last2;
          let _out;
          let beg;
          let end;
          let dmax;
          let wsize;
          let whave;
          let wnext;
          let s_window;
          let hold;
          let bits;
          let lcode;
          let dcode;
          let lmask;
          let dmask;
          let here;
          let op;
          let len;
          let dist;
          let from;
          let from_source;
          let input, output2;
          const state = strm.state;
          _in = strm.next_in;
          input = strm.input;
          last2 = _in + (strm.avail_in - 5);
          _out = strm.next_out;
          output2 = strm.output;
          beg = _out - (start - strm.avail_out);
          end = _out + (strm.avail_out - 257);
          dmax = state.dmax;
          wsize = state.wsize;
          whave = state.whave;
          wnext = state.wnext;
          s_window = state.window;
          hold = state.hold;
          bits = state.bits;
          lcode = state.lencode;
          dcode = state.distcode;
          lmask = (1 << state.lenbits) - 1;
          dmask = (1 << state.distbits) - 1;
          top:
            do {
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = lcode[hold & lmask];
              dolen:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op === 0) {
                    output2[_out++] = here & 65535;
                  } else if (op & 16) {
                    len = here & 65535;
                    op &= 15;
                    if (op) {
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                      len += hold & (1 << op) - 1;
                      hold >>>= op;
                      bits -= op;
                    }
                    if (bits < 15) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    here = dcode[hold & dmask];
                    dodist:
                      for (; ; ) {
                        op = here >>> 24;
                        hold >>>= op;
                        bits -= op;
                        op = here >>> 16 & 255;
                        if (op & 16) {
                          dist = here & 65535;
                          op &= 15;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            if (bits < op) {
                              hold += input[_in++] << bits;
                              bits += 8;
                            }
                          }
                          dist += hold & (1 << op) - 1;
                          if (dist > dmax) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD$1;
                            break top;
                          }
                          hold >>>= op;
                          bits -= op;
                          op = _out - beg;
                          if (dist > op) {
                            op = dist - op;
                            if (op > whave) {
                              if (state.sane) {
                                strm.msg = "invalid distance too far back";
                                state.mode = BAD$1;
                                break top;
                              }
                            }
                            from = 0;
                            from_source = s_window;
                            if (wnext === 0) {
                              from += wsize - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output2[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output2;
                              }
                            } else if (wnext < op) {
                              from += wsize + wnext - op;
                              op -= wnext;
                              if (op < len) {
                                len -= op;
                                do {
                                  output2[_out++] = s_window[from++];
                                } while (--op);
                                from = 0;
                                if (wnext < len) {
                                  op = wnext;
                                  len -= op;
                                  do {
                                    output2[_out++] = s_window[from++];
                                  } while (--op);
                                  from = _out - dist;
                                  from_source = output2;
                                }
                              }
                            } else {
                              from += wnext - op;
                              if (op < len) {
                                len -= op;
                                do {
                                  output2[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output2;
                              }
                            }
                            while (len > 2) {
                              output2[_out++] = from_source[from++];
                              output2[_out++] = from_source[from++];
                              output2[_out++] = from_source[from++];
                              len -= 3;
                            }
                            if (len) {
                              output2[_out++] = from_source[from++];
                              if (len > 1) {
                                output2[_out++] = from_source[from++];
                              }
                            }
                          } else {
                            from = _out - dist;
                            do {
                              output2[_out++] = output2[from++];
                              output2[_out++] = output2[from++];
                              output2[_out++] = output2[from++];
                              len -= 3;
                            } while (len > 2);
                            if (len) {
                              output2[_out++] = output2[from++];
                              if (len > 1) {
                                output2[_out++] = output2[from++];
                              }
                            }
                          }
                        } else if ((op & 64) === 0) {
                          here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                          continue dodist;
                        } else {
                          strm.msg = "invalid distance code";
                          state.mode = BAD$1;
                          break top;
                        }
                        break;
                      }
                  } else if ((op & 64) === 0) {
                    here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dolen;
                  } else if (op & 32) {
                    state.mode = TYPE$1;
                    break top;
                  } else {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } while (_in < last2 && _out < end);
          len = bits >> 3;
          _in -= len;
          bits -= len << 3;
          hold &= (1 << bits) - 1;
          strm.next_in = _in;
          strm.next_out = _out;
          strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
          strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
          state.hold = hold;
          state.bits = bits;
          return;
        };
        const MAXBITS = 15;
        const ENOUGH_LENS$1 = 852;
        const ENOUGH_DISTS$1 = 592;
        const CODES$1 = 0;
        const LENS$1 = 1;
        const DISTS$1 = 2;
        const lbase = new Uint16Array([
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ]);
        const lext = new Uint8Array([
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ]);
        const dbase = new Uint16Array([
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ]);
        const dext = new Uint8Array([
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ]);
        const inflate_table = (type2, lens, lens_index, codes, table, table_index, work, opts) => {
          const bits = opts.bits;
          let len = 0;
          let sym = 0;
          let min = 0, max = 0;
          let root = 0;
          let curr = 0;
          let drop = 0;
          let left = 0;
          let used = 0;
          let huff = 0;
          let incr;
          let fill;
          let low;
          let mask;
          let next;
          let base = null;
          let base_index = 0;
          let end;
          const count = new Uint16Array(MAXBITS + 1);
          const offs = new Uint16Array(MAXBITS + 1);
          let extra = null;
          let extra_index = 0;
          let here_bits, here_op, here_val;
          for (len = 0; len <= MAXBITS; len++) {
            count[len] = 0;
          }
          for (sym = 0; sym < codes; sym++) {
            count[lens[lens_index + sym]]++;
          }
          root = bits;
          for (max = MAXBITS; max >= 1; max--) {
            if (count[max] !== 0) {
              break;
            }
          }
          if (root > max) {
            root = max;
          }
          if (max === 0) {
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            table[table_index++] = 1 << 24 | 64 << 16 | 0;
            opts.bits = 1;
            return 0;
          }
          for (min = 1; min < max; min++) {
            if (count[min] !== 0) {
              break;
            }
          }
          if (root < min) {
            root = min;
          }
          left = 1;
          for (len = 1; len <= MAXBITS; len++) {
            left <<= 1;
            left -= count[len];
            if (left < 0) {
              return -1;
            }
          }
          if (left > 0 && (type2 === CODES$1 || max !== 1)) {
            return -1;
          }
          offs[1] = 0;
          for (len = 1; len < MAXBITS; len++) {
            offs[len + 1] = offs[len] + count[len];
          }
          for (sym = 0; sym < codes; sym++) {
            if (lens[lens_index + sym] !== 0) {
              work[offs[lens[lens_index + sym]]++] = sym;
            }
          }
          if (type2 === CODES$1) {
            base = extra = work;
            end = 19;
          } else if (type2 === LENS$1) {
            base = lbase;
            base_index -= 257;
            extra = lext;
            extra_index -= 257;
            end = 256;
          } else {
            base = dbase;
            extra = dext;
            end = -1;
          }
          huff = 0;
          sym = 0;
          len = min;
          next = table_index;
          curr = root;
          drop = 0;
          low = -1;
          used = 1 << root;
          mask = used - 1;
          if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
            return 1;
          }
          for (; ; ) {
            here_bits = len - drop;
            if (work[sym] < end) {
              here_op = 0;
              here_val = work[sym];
            } else if (work[sym] > end) {
              here_op = extra[extra_index + work[sym]];
              here_val = base[base_index + work[sym]];
            } else {
              here_op = 32 + 64;
              here_val = 0;
            }
            incr = 1 << len - drop;
            fill = 1 << curr;
            min = fill;
            do {
              fill -= incr;
              table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
            } while (fill !== 0);
            incr = 1 << len - 1;
            while (huff & incr) {
              incr >>= 1;
            }
            if (incr !== 0) {
              huff &= incr - 1;
              huff += incr;
            } else {
              huff = 0;
            }
            sym++;
            if (--count[len] === 0) {
              if (len === max) {
                break;
              }
              len = lens[lens_index + work[sym]];
            }
            if (len > root && (huff & mask) !== low) {
              if (drop === 0) {
                drop = root;
              }
              next += min;
              curr = len - drop;
              left = 1 << curr;
              while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) {
                  break;
                }
                curr++;
                left <<= 1;
              }
              used += 1 << curr;
              if (type2 === LENS$1 && used > ENOUGH_LENS$1 || type2 === DISTS$1 && used > ENOUGH_DISTS$1) {
                return 1;
              }
              low = huff & mask;
              table[low] = root << 24 | curr << 16 | next - table_index | 0;
            }
          }
          if (huff !== 0) {
            table[next + huff] = len - drop << 24 | 64 << 16 | 0;
          }
          opts.bits = root;
          return 0;
        };
        var inftrees = inflate_table;
        const CODES = 0;
        const LENS = 1;
        const DISTS = 2;
        const {
          Z_FINISH: Z_FINISH$1,
          Z_BLOCK,
          Z_TREES,
          Z_OK: Z_OK$1,
          Z_STREAM_END: Z_STREAM_END$1,
          Z_NEED_DICT: Z_NEED_DICT$1,
          Z_STREAM_ERROR: Z_STREAM_ERROR$1,
          Z_DATA_ERROR: Z_DATA_ERROR$1,
          Z_MEM_ERROR: Z_MEM_ERROR$1,
          Z_BUF_ERROR,
          Z_DEFLATED
        } = constants$2;
        const HEAD = 1;
        const FLAGS = 2;
        const TIME = 3;
        const OS = 4;
        const EXLEN = 5;
        const EXTRA = 6;
        const NAME = 7;
        const COMMENT = 8;
        const HCRC = 9;
        const DICTID = 10;
        const DICT = 11;
        const TYPE = 12;
        const TYPEDO = 13;
        const STORED = 14;
        const COPY_ = 15;
        const COPY = 16;
        const TABLE = 17;
        const LENLENS = 18;
        const CODELENS = 19;
        const LEN_ = 20;
        const LEN = 21;
        const LENEXT = 22;
        const DIST = 23;
        const DISTEXT = 24;
        const MATCH = 25;
        const LIT = 26;
        const CHECK = 27;
        const LENGTH = 28;
        const DONE = 29;
        const BAD = 30;
        const MEM = 31;
        const SYNC = 32;
        const ENOUGH_LENS = 852;
        const ENOUGH_DISTS = 592;
        const MAX_WBITS = 15;
        const DEF_WBITS = MAX_WBITS;
        const zswap32 = (q) => {
          return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
        };
        function InflateState() {
          this.mode = 0;
          this.last = false;
          this.wrap = 0;
          this.havedict = false;
          this.flags = 0;
          this.dmax = 0;
          this.check = 0;
          this.total = 0;
          this.head = null;
          this.wbits = 0;
          this.wsize = 0;
          this.whave = 0;
          this.wnext = 0;
          this.window = null;
          this.hold = 0;
          this.bits = 0;
          this.length = 0;
          this.offset = 0;
          this.extra = 0;
          this.lencode = null;
          this.distcode = null;
          this.lenbits = 0;
          this.distbits = 0;
          this.ncode = 0;
          this.nlen = 0;
          this.ndist = 0;
          this.have = 0;
          this.next = null;
          this.lens = new Uint16Array(320);
          this.work = new Uint16Array(288);
          this.lendyn = null;
          this.distdyn = null;
          this.sane = 0;
          this.back = 0;
          this.was = 0;
        }
        const inflateResetKeep = (strm) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          const state = strm.state;
          strm.total_in = strm.total_out = state.total = 0;
          strm.msg = "";
          if (state.wrap) {
            strm.adler = state.wrap & 1;
          }
          state.mode = HEAD;
          state.last = 0;
          state.havedict = 0;
          state.dmax = 32768;
          state.head = null;
          state.hold = 0;
          state.bits = 0;
          state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
          state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
          state.sane = 1;
          state.back = -1;
          return Z_OK$1;
        };
        const inflateReset = (strm) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          const state = strm.state;
          state.wsize = 0;
          state.whave = 0;
          state.wnext = 0;
          return inflateResetKeep(strm);
        };
        const inflateReset2 = (strm, windowBits) => {
          let wrap;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          const state = strm.state;
          if (windowBits < 0) {
            wrap = 0;
            windowBits = -windowBits;
          } else {
            wrap = (windowBits >> 4) + 1;
            if (windowBits < 48) {
              windowBits &= 15;
            }
          }
          if (windowBits && (windowBits < 8 || windowBits > 15)) {
            return Z_STREAM_ERROR$1;
          }
          if (state.window !== null && state.wbits !== windowBits) {
            state.window = null;
          }
          state.wrap = wrap;
          state.wbits = windowBits;
          return inflateReset(strm);
        };
        const inflateInit2 = (strm, windowBits) => {
          if (!strm) {
            return Z_STREAM_ERROR$1;
          }
          const state = new InflateState();
          strm.state = state;
          state.window = null;
          const ret = inflateReset2(strm, windowBits);
          if (ret !== Z_OK$1) {
            strm.state = null;
          }
          return ret;
        };
        const inflateInit = (strm) => {
          return inflateInit2(strm, DEF_WBITS);
        };
        let virgin = true;
        let lenfix, distfix;
        const fixedtables = (state) => {
          if (virgin) {
            lenfix = new Int32Array(512);
            distfix = new Int32Array(32);
            let sym = 0;
            while (sym < 144) {
              state.lens[sym++] = 8;
            }
            while (sym < 256) {
              state.lens[sym++] = 9;
            }
            while (sym < 280) {
              state.lens[sym++] = 7;
            }
            while (sym < 288) {
              state.lens[sym++] = 8;
            }
            inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
            sym = 0;
            while (sym < 32) {
              state.lens[sym++] = 5;
            }
            inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
            virgin = false;
          }
          state.lencode = lenfix;
          state.lenbits = 9;
          state.distcode = distfix;
          state.distbits = 5;
        };
        const updatewindow = (strm, src, end, copy) => {
          let dist;
          const state = strm.state;
          if (state.window === null) {
            state.wsize = 1 << state.wbits;
            state.wnext = 0;
            state.whave = 0;
            state.window = new Uint8Array(state.wsize);
          }
          if (copy >= state.wsize) {
            state.window.set(src.subarray(end - state.wsize, end), 0);
            state.wnext = 0;
            state.whave = state.wsize;
          } else {
            dist = state.wsize - state.wnext;
            if (dist > copy) {
              dist = copy;
            }
            state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
            copy -= dist;
            if (copy) {
              state.window.set(src.subarray(end - copy, end), 0);
              state.wnext = copy;
              state.whave = state.wsize;
            } else {
              state.wnext += dist;
              if (state.wnext === state.wsize) {
                state.wnext = 0;
              }
              if (state.whave < state.wsize) {
                state.whave += dist;
              }
            }
          }
          return 0;
        };
        const inflate$2 = (strm, flush) => {
          let state;
          let input, output2;
          let next;
          let put;
          let have, left;
          let hold;
          let bits;
          let _in, _out;
          let copy;
          let from;
          let from_source;
          let here = 0;
          let here_bits, here_op, here_val;
          let last_bits, last_op, last_val;
          let len;
          let ret;
          const hbuf = new Uint8Array(4);
          let opts;
          let n;
          const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
          if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
            return Z_STREAM_ERROR$1;
          }
          state = strm.state;
          if (state.mode === TYPE) {
            state.mode = TYPEDO;
          }
          put = strm.next_out;
          output2 = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          _in = have;
          _out = left;
          ret = Z_OK$1;
          inf_leave:
            for (; ; ) {
              switch (state.mode) {
                case HEAD:
                  if (state.wrap === 0) {
                    state.mode = TYPEDO;
                    break;
                  }
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.wrap & 2 && hold === 35615) {
                    state.check = 0;
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                    hold = 0;
                    bits = 0;
                    state.mode = FLAGS;
                    break;
                  }
                  state.flags = 0;
                  if (state.head) {
                    state.head.done = false;
                  }
                  if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check";
                    state.mode = BAD;
                    break;
                  }
                  if ((hold & 15) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  hold >>>= 4;
                  bits -= 4;
                  len = (hold & 15) + 8;
                  if (state.wbits === 0) {
                    state.wbits = len;
                  } else if (len > state.wbits) {
                    strm.msg = "invalid window size";
                    state.mode = BAD;
                    break;
                  }
                  state.dmax = 1 << state.wbits;
                  strm.adler = state.check = 1;
                  state.mode = hold & 512 ? DICTID : TYPE;
                  hold = 0;
                  bits = 0;
                  break;
                case FLAGS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.flags = hold;
                  if ((state.flags & 255) !== Z_DEFLATED) {
                    strm.msg = "unknown compression method";
                    state.mode = BAD;
                    break;
                  }
                  if (state.flags & 57344) {
                    strm.msg = "unknown header flags set";
                    state.mode = BAD;
                    break;
                  }
                  if (state.head) {
                    state.head.text = hold >> 8 & 1;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = TIME;
                case TIME:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.time = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    hbuf[2] = hold >>> 16 & 255;
                    hbuf[3] = hold >>> 24 & 255;
                    state.check = crc32_1(state.check, hbuf, 4, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = OS;
                case OS:
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (state.head) {
                    state.head.xflags = hold & 255;
                    state.head.os = hold >> 8;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32_1(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                  state.mode = EXLEN;
                case EXLEN:
                  if (state.flags & 1024) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length = hold;
                    if (state.head) {
                      state.head.extra_len = hold;
                    }
                    if (state.flags & 512) {
                      hbuf[0] = hold & 255;
                      hbuf[1] = hold >>> 8 & 255;
                      state.check = crc32_1(state.check, hbuf, 2, 0);
                    }
                    hold = 0;
                    bits = 0;
                  } else if (state.head) {
                    state.head.extra = null;
                  }
                  state.mode = EXTRA;
                case EXTRA:
                  if (state.flags & 1024) {
                    copy = state.length;
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy) {
                      if (state.head) {
                        len = state.head.extra_len - state.length;
                        if (!state.head.extra) {
                          state.head.extra = new Uint8Array(state.head.extra_len);
                        }
                        state.head.extra.set(input.subarray(next, next + copy), len);
                      }
                      if (state.flags & 512) {
                        state.check = crc32_1(state.check, input, copy, next);
                      }
                      have -= copy;
                      next += copy;
                      state.length -= copy;
                    }
                    if (state.length) {
                      break inf_leave;
                    }
                  }
                  state.length = 0;
                  state.mode = NAME;
                case NAME:
                  if (state.flags & 2048) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.name += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.name = null;
                  }
                  state.length = 0;
                  state.mode = COMMENT;
                case COMMENT:
                  if (state.flags & 4096) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    copy = 0;
                    do {
                      len = input[next + copy++];
                      if (state.head && len && state.length < 65536) {
                        state.head.comment += String.fromCharCode(len);
                      }
                    } while (len && copy < have);
                    if (state.flags & 512) {
                      state.check = crc32_1(state.check, input, copy, next);
                    }
                    have -= copy;
                    next += copy;
                    if (len) {
                      break inf_leave;
                    }
                  } else if (state.head) {
                    state.head.comment = null;
                  }
                  state.mode = HCRC;
                case HCRC:
                  if (state.flags & 512) {
                    while (bits < 16) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.check & 65535)) {
                      strm.msg = "header crc mismatch";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  if (state.head) {
                    state.head.hcrc = state.flags >> 9 & 1;
                    state.head.done = true;
                  }
                  strm.adler = state.check = 0;
                  state.mode = TYPE;
                  break;
                case DICTID:
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  strm.adler = state.check = zswap32(hold);
                  hold = 0;
                  bits = 0;
                  state.mode = DICT;
                case DICT:
                  if (state.havedict === 0) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    return Z_NEED_DICT$1;
                  }
                  strm.adler = state.check = 1;
                  state.mode = TYPE;
                case TYPE:
                  if (flush === Z_BLOCK || flush === Z_TREES) {
                    break inf_leave;
                  }
                case TYPEDO:
                  if (state.last) {
                    hold >>>= bits & 7;
                    bits -= bits & 7;
                    state.mode = CHECK;
                    break;
                  }
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.last = hold & 1;
                  hold >>>= 1;
                  bits -= 1;
                  switch (hold & 3) {
                    case 0:
                      state.mode = STORED;
                      break;
                    case 1:
                      fixedtables(state);
                      state.mode = LEN_;
                      if (flush === Z_TREES) {
                        hold >>>= 2;
                        bits -= 2;
                        break inf_leave;
                      }
                      break;
                    case 2:
                      state.mode = TABLE;
                      break;
                    case 3:
                      strm.msg = "invalid block type";
                      state.mode = BAD;
                  }
                  hold >>>= 2;
                  bits -= 2;
                  break;
                case STORED:
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths";
                    state.mode = BAD;
                    break;
                  }
                  state.length = hold & 65535;
                  hold = 0;
                  bits = 0;
                  state.mode = COPY_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case COPY_:
                  state.mode = COPY;
                case COPY:
                  copy = state.length;
                  if (copy) {
                    if (copy > have) {
                      copy = have;
                    }
                    if (copy > left) {
                      copy = left;
                    }
                    if (copy === 0) {
                      break inf_leave;
                    }
                    output2.set(input.subarray(next, next + copy), put);
                    have -= copy;
                    next += copy;
                    left -= copy;
                    put += copy;
                    state.length -= copy;
                    break;
                  }
                  state.mode = TYPE;
                  break;
                case TABLE:
                  while (bits < 14) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.nlen = (hold & 31) + 257;
                  hold >>>= 5;
                  bits -= 5;
                  state.ndist = (hold & 31) + 1;
                  hold >>>= 5;
                  bits -= 5;
                  state.ncode = (hold & 15) + 4;
                  hold >>>= 4;
                  bits -= 4;
                  if (state.nlen > 286 || state.ndist > 30) {
                    strm.msg = "too many length or distance symbols";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = LENLENS;
                case LENLENS:
                  while (state.have < state.ncode) {
                    while (bits < 3) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.lens[order[state.have++]] = hold & 7;
                    hold >>>= 3;
                    bits -= 3;
                  }
                  while (state.have < 19) {
                    state.lens[order[state.have++]] = 0;
                  }
                  state.lencode = state.lendyn;
                  state.lenbits = 7;
                  opts = { bits: state.lenbits };
                  ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid code lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.have = 0;
                  state.mode = CODELENS;
                case CODELENS:
                  while (state.have < state.nlen + state.ndist) {
                    for (; ; ) {
                      here = state.lencode[hold & (1 << state.lenbits) - 1];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (here_val < 16) {
                      hold >>>= here_bits;
                      bits -= here_bits;
                      state.lens[state.have++] = here_val;
                    } else {
                      if (here_val === 16) {
                        n = here_bits + 2;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        if (state.have === 0) {
                          strm.msg = "invalid bit length repeat";
                          state.mode = BAD;
                          break;
                        }
                        len = state.lens[state.have - 1];
                        copy = 3 + (hold & 3);
                        hold >>>= 2;
                        bits -= 2;
                      } else if (here_val === 17) {
                        n = here_bits + 3;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 3 + (hold & 7);
                        hold >>>= 3;
                        bits -= 3;
                      } else {
                        n = here_bits + 7;
                        while (bits < n) {
                          if (have === 0) {
                            break inf_leave;
                          }
                          have--;
                          hold += input[next++] << bits;
                          bits += 8;
                        }
                        hold >>>= here_bits;
                        bits -= here_bits;
                        len = 0;
                        copy = 11 + (hold & 127);
                        hold >>>= 7;
                        bits -= 7;
                      }
                      if (state.have + copy > state.nlen + state.ndist) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      while (copy--) {
                        state.lens[state.have++] = len;
                      }
                    }
                  }
                  if (state.mode === BAD) {
                    break;
                  }
                  if (state.lens[256] === 0) {
                    strm.msg = "invalid code -- missing end-of-block";
                    state.mode = BAD;
                    break;
                  }
                  state.lenbits = 9;
                  opts = { bits: state.lenbits };
                  ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                  state.lenbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid literal/lengths set";
                    state.mode = BAD;
                    break;
                  }
                  state.distbits = 6;
                  state.distcode = state.distdyn;
                  opts = { bits: state.distbits };
                  ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                  state.distbits = opts.bits;
                  if (ret) {
                    strm.msg = "invalid distances set";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    break inf_leave;
                  }
                case LEN_:
                  state.mode = LEN;
                case LEN:
                  if (have >= 6 && left >= 258) {
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    inffast(strm, _out);
                    put = strm.next_out;
                    output2 = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    if (state.mode === TYPE) {
                      state.back = -1;
                    }
                    break;
                  }
                  state.back = 0;
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_op && (here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  state.length = here_val;
                  if (here_op === 0) {
                    state.mode = LIT;
                    break;
                  }
                  if (here_op & 32) {
                    state.back = -1;
                    state.mode = TYPE;
                    break;
                  }
                  if (here_op & 64) {
                    strm.msg = "invalid literal/length code";
                    state.mode = BAD;
                    break;
                  }
                  state.extra = here_op & 15;
                  state.mode = LENEXT;
                case LENEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  state.was = state.length;
                  state.mode = DIST;
                case DIST:
                  for (; ; ) {
                    here = state.distcode[hold & (1 << state.distbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if ((here_op & 240) === 0) {
                    last_bits = here_bits;
                    last_op = here_op;
                    last_val = here_val;
                    for (; ; ) {
                      here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                      here_bits = here >>> 24;
                      here_op = here >>> 16 & 255;
                      here_val = here & 65535;
                      if (last_bits + here_bits <= bits) {
                        break;
                      }
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= last_bits;
                    bits -= last_bits;
                    state.back += last_bits;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.back += here_bits;
                  if (here_op & 64) {
                    strm.msg = "invalid distance code";
                    state.mode = BAD;
                    break;
                  }
                  state.offset = here_val;
                  state.extra = here_op & 15;
                  state.mode = DISTEXT;
                case DISTEXT:
                  if (state.extra) {
                    n = state.extra;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1;
                    hold >>>= state.extra;
                    bits -= state.extra;
                    state.back += state.extra;
                  }
                  if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                  state.mode = MATCH;
                case MATCH:
                  if (left === 0) {
                    break inf_leave;
                  }
                  copy = _out - left;
                  if (state.offset > copy) {
                    copy = state.offset - copy;
                    if (copy > state.whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break;
                      }
                    }
                    if (copy > state.wnext) {
                      copy -= state.wnext;
                      from = state.wsize - copy;
                    } else {
                      from = state.wnext - copy;
                    }
                    if (copy > state.length) {
                      copy = state.length;
                    }
                    from_source = state.window;
                  } else {
                    from_source = output2;
                    from = put - state.offset;
                    copy = state.length;
                  }
                  if (copy > left) {
                    copy = left;
                  }
                  left -= copy;
                  state.length -= copy;
                  do {
                    output2[put++] = from_source[from++];
                  } while (--copy);
                  if (state.length === 0) {
                    state.mode = LEN;
                  }
                  break;
                case LIT:
                  if (left === 0) {
                    break inf_leave;
                  }
                  output2[put++] = state.length;
                  left--;
                  state.mode = LEN;
                  break;
                case CHECK:
                  if (state.wrap) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold |= input[next++] << bits;
                      bits += 8;
                    }
                    _out -= left;
                    strm.total_out += _out;
                    state.total += _out;
                    if (_out) {
                      strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
                    }
                    _out = left;
                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                      strm.msg = "incorrect data check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = LENGTH;
                case LENGTH:
                  if (state.wrap && state.flags) {
                    while (bits < 32) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    if (hold !== (state.total & 4294967295)) {
                      strm.msg = "incorrect length check";
                      state.mode = BAD;
                      break;
                    }
                    hold = 0;
                    bits = 0;
                  }
                  state.mode = DONE;
                case DONE:
                  ret = Z_STREAM_END$1;
                  break inf_leave;
                case BAD:
                  ret = Z_DATA_ERROR$1;
                  break inf_leave;
                case MEM:
                  return Z_MEM_ERROR$1;
                case SYNC:
                default:
                  return Z_STREAM_ERROR$1;
              }
            }
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
            if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
              ;
          }
          _in -= strm.avail_in;
          _out -= strm.avail_out;
          strm.total_in += _in;
          strm.total_out += _out;
          state.total += _out;
          if (state.wrap && _out) {
            strm.adler = state.check = state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
          }
          strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
          if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
            ret = Z_BUF_ERROR;
          }
          return ret;
        };
        const inflateEnd = (strm) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          let state = strm.state;
          if (state.window) {
            state.window = null;
          }
          strm.state = null;
          return Z_OK$1;
        };
        const inflateGetHeader = (strm, head) => {
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          const state = strm.state;
          if ((state.wrap & 2) === 0) {
            return Z_STREAM_ERROR$1;
          }
          state.head = head;
          head.done = false;
          return Z_OK$1;
        };
        const inflateSetDictionary = (strm, dictionary) => {
          const dictLength = dictionary.length;
          let state;
          let dictid;
          let ret;
          if (!strm || !strm.state) {
            return Z_STREAM_ERROR$1;
          }
          state = strm.state;
          if (state.wrap !== 0 && state.mode !== DICT) {
            return Z_STREAM_ERROR$1;
          }
          if (state.mode === DICT) {
            dictid = 1;
            dictid = adler32_1(dictid, dictionary, dictLength, 0);
            if (dictid !== state.check) {
              return Z_DATA_ERROR$1;
            }
          }
          ret = updatewindow(strm, dictionary, dictLength, dictLength);
          if (ret) {
            state.mode = MEM;
            return Z_MEM_ERROR$1;
          }
          state.havedict = 1;
          return Z_OK$1;
        };
        var inflateReset_1 = inflateReset;
        var inflateReset2_1 = inflateReset2;
        var inflateResetKeep_1 = inflateResetKeep;
        var inflateInit_1 = inflateInit;
        var inflateInit2_1 = inflateInit2;
        var inflate_2$1 = inflate$2;
        var inflateEnd_1 = inflateEnd;
        var inflateGetHeader_1 = inflateGetHeader;
        var inflateSetDictionary_1 = inflateSetDictionary;
        var inflateInfo = "pako inflate (from Nodeca project)";
        var inflate_1$2 = {
          inflateReset: inflateReset_1,
          inflateReset2: inflateReset2_1,
          inflateResetKeep: inflateResetKeep_1,
          inflateInit: inflateInit_1,
          inflateInit2: inflateInit2_1,
          inflate: inflate_2$1,
          inflateEnd: inflateEnd_1,
          inflateGetHeader: inflateGetHeader_1,
          inflateSetDictionary: inflateSetDictionary_1,
          inflateInfo
        };
        function GZheader() {
          this.text = 0;
          this.time = 0;
          this.xflags = 0;
          this.os = 0;
          this.extra = null;
          this.extra_len = 0;
          this.name = "";
          this.comment = "";
          this.hcrc = 0;
          this.done = false;
        }
        var gzheader = GZheader;
        const toString2 = Object.prototype.toString;
        const {
          Z_NO_FLUSH,
          Z_FINISH,
          Z_OK,
          Z_STREAM_END,
          Z_NEED_DICT,
          Z_STREAM_ERROR,
          Z_DATA_ERROR,
          Z_MEM_ERROR
        } = constants$2;
        function Inflate$1(options) {
          this.options = common.assign({
            chunkSize: 1024 * 64,
            windowBits: 15,
            to: ""
          }, options || {});
          const opt = this.options;
          if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
            opt.windowBits = -opt.windowBits;
            if (opt.windowBits === 0) {
              opt.windowBits = -15;
            }
          }
          if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
            opt.windowBits += 32;
          }
          if (opt.windowBits > 15 && opt.windowBits < 48) {
            if ((opt.windowBits & 15) === 0) {
              opt.windowBits |= 15;
            }
          }
          this.err = 0;
          this.msg = "";
          this.ended = false;
          this.chunks = [];
          this.strm = new zstream();
          this.strm.avail_out = 0;
          let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);
          if (status !== Z_OK) {
            throw new Error(messages[status]);
          }
          this.header = new gzheader();
          inflate_1$2.inflateGetHeader(this.strm, this.header);
          if (opt.dictionary) {
            if (typeof opt.dictionary === "string") {
              opt.dictionary = strings.string2buf(opt.dictionary);
            } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
              opt.dictionary = new Uint8Array(opt.dictionary);
            }
            if (opt.raw) {
              status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
              if (status !== Z_OK) {
                throw new Error(messages[status]);
              }
            }
          }
        }
        Inflate$1.prototype.push = function(data, flush_mode) {
          const strm = this.strm;
          const chunkSize = this.options.chunkSize;
          const dictionary = this.options.dictionary;
          let status, _flush_mode, last_avail_out;
          if (this.ended)
            return false;
          if (flush_mode === ~~flush_mode)
            _flush_mode = flush_mode;
          else
            _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
          if (toString2.call(data) === "[object ArrayBuffer]") {
            strm.input = new Uint8Array(data);
          } else {
            strm.input = data;
          }
          strm.next_in = 0;
          strm.avail_in = strm.input.length;
          for (; ; ) {
            if (strm.avail_out === 0) {
              strm.output = new Uint8Array(chunkSize);
              strm.next_out = 0;
              strm.avail_out = chunkSize;
            }
            status = inflate_1$2.inflate(strm, _flush_mode);
            if (status === Z_NEED_DICT && dictionary) {
              status = inflate_1$2.inflateSetDictionary(strm, dictionary);
              if (status === Z_OK) {
                status = inflate_1$2.inflate(strm, _flush_mode);
              } else if (status === Z_DATA_ERROR) {
                status = Z_NEED_DICT;
              }
            }
            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
              inflate_1$2.inflateReset(strm);
              status = inflate_1$2.inflate(strm, _flush_mode);
            }
            switch (status) {
              case Z_STREAM_ERROR:
              case Z_DATA_ERROR:
              case Z_NEED_DICT:
              case Z_MEM_ERROR:
                this.onEnd(status);
                this.ended = true;
                return false;
            }
            last_avail_out = strm.avail_out;
            if (strm.next_out) {
              if (strm.avail_out === 0 || status === Z_STREAM_END) {
                if (this.options.to === "string") {
                  let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                  let tail = strm.next_out - next_out_utf8;
                  let utf8str = strings.buf2string(strm.output, next_out_utf8);
                  strm.next_out = tail;
                  strm.avail_out = chunkSize - tail;
                  if (tail)
                    strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
                  this.onData(utf8str);
                } else {
                  this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
                }
              }
            }
            if (status === Z_OK && last_avail_out === 0)
              continue;
            if (status === Z_STREAM_END) {
              status = inflate_1$2.inflateEnd(this.strm);
              this.onEnd(status);
              this.ended = true;
              return true;
            }
            if (strm.avail_in === 0)
              break;
          }
          return true;
        };
        Inflate$1.prototype.onData = function(chunk) {
          this.chunks.push(chunk);
        };
        Inflate$1.prototype.onEnd = function(status) {
          if (status === Z_OK) {
            if (this.options.to === "string") {
              this.result = this.chunks.join("");
            } else {
              this.result = common.flattenChunks(this.chunks);
            }
          }
          this.chunks = [];
          this.err = status;
          this.msg = this.strm.msg;
        };
        function inflate$1(input, options) {
          const inflator = new Inflate$1(options);
          inflator.push(input);
          if (inflator.err)
            throw inflator.msg || messages[inflator.err];
          return inflator.result;
        }
        function inflateRaw$1(input, options) {
          options = options || {};
          options.raw = true;
          return inflate$1(input, options);
        }
        var Inflate_1$1 = Inflate$1;
        var inflate_2 = inflate$1;
        var inflateRaw_1$1 = inflateRaw$1;
        var ungzip$1 = inflate$1;
        var constants = constants$2;
        var inflate_1$1 = {
          Inflate: Inflate_1$1,
          inflate: inflate_2,
          inflateRaw: inflateRaw_1$1,
          ungzip: ungzip$1,
          constants
        };
        const { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
        const { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
        var Deflate_1 = Deflate;
        var deflate_1 = deflate;
        var deflateRaw_1 = deflateRaw;
        var gzip_1 = gzip;
        var Inflate_1 = Inflate;
        var inflate_1 = inflate;
        var inflateRaw_1 = inflateRaw;
        var ungzip_1 = ungzip;
        var constants_1 = constants$2;
        var pako2 = {
          Deflate: Deflate_1,
          deflate: deflate_1,
          deflateRaw: deflateRaw_1,
          gzip: gzip_1,
          Inflate: Inflate_1,
          inflate: inflate_1,
          inflateRaw: inflateRaw_1,
          ungzip: ungzip_1,
          constants: constants_1
        };
        exports2.Deflate = Deflate_1;
        exports2.Inflate = Inflate_1;
        exports2.constants = constants_1;
        exports2["default"] = pako2;
        exports2.deflate = deflate_1;
        exports2.deflateRaw = deflateRaw_1;
        exports2.gzip = gzip_1;
        exports2.inflate = inflate_1;
        exports2.inflateRaw = inflateRaw_1;
        exports2.ungzip = ungzip_1;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str, expectsLowerCase) {
    const map2 = Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map2[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
  }
  function generateCodeFrame(source, start = 0, end = source.length) {
    let lines = source.split(/(\r?\n)/);
    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);
    lines = lines.filter((_, idx) => idx % 2 === 0);
    let count = 0;
    const res = [];
    for (let i = 0; i < lines.length; i++) {
      count += lines[i].length + (newlineSequences[i] && newlineSequences[i].length || 0);
      if (count >= start) {
        for (let j = i - range; j <= i + range || end > count; j++) {
          if (j < 0 || j >= lines.length)
            continue;
          const line = j + 1;
          res.push(`${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);
          const lineLength = lines[j].length;
          const newLineSeqLength = newlineSequences[j] && newlineSequences[j].length || 0;
          if (j === i) {
            const pad2 = start - (count - (lineLength + newLineSeqLength));
            const length = Math.max(1, end > count ? lineLength - pad2 : end - start);
            res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
          } else if (j > i) {
            if (end > count) {
              const length = Math.max(Math.min(end - count, lineLength), 1);
              res.push(`   |  ` + "^".repeat(length));
            }
            count += lineLength + newLineSeqLength;
          }
        }
        break;
      }
    }
    return res.join("\n");
  }
  function includeBooleanAttr(value2) {
    return !!value2 || value2 === "";
  }
  function normalizeStyle(value2) {
    if (isArray(value2)) {
      const res = {};
      for (let i = 0; i < value2.length; i++) {
        const item2 = value2[i];
        const normalized = isString(item2) ? parseStringStyle(item2) : normalizeStyle(item2);
        if (normalized) {
          for (const key2 in normalized) {
            res[key2] = normalized[key2];
          }
        }
      }
      return res;
    } else if (isString(value2)) {
      return value2;
    } else if (isObject(value2)) {
      return value2;
    }
  }
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.split(listDelimiterRE).forEach((item2) => {
      if (item2) {
        const tmp = item2.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value2) {
    let res = "";
    if (isString(value2)) {
      res = value2;
    } else if (isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        const normalized = normalizeClass(value2[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject(value2)) {
      for (const name in value2) {
        if (value2[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }
  function normalizeProps(props2) {
    if (!props2)
      return null;
    let { class: klass, style: style2 } = props2;
    if (klass && !isString(klass)) {
      props2.class = normalizeClass(klass);
    }
    if (style2) {
      props2.style = normalizeStyle(style2);
    }
    return props2;
  }
  function looseCompareArrays(a, b) {
    if (a.length !== b.length)
      return false;
    let equal = true;
    for (let i = 0; equal && i < a.length; i++) {
      equal = looseEqual(a[i], b[i]);
    }
    return equal;
  }
  function looseEqual(a, b) {
    if (a === b)
      return true;
    let aValidType = isDate(a);
    let bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? looseCompareArrays(a, b) : false;
    }
    aValidType = isObject(a);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      const aKeysCount = Object.keys(a).length;
      const bKeysCount = Object.keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (const key2 in a) {
        const aHasKey = a.hasOwnProperty(key2);
        const bHasKey = b.hasOwnProperty(key2);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key2], b[key2])) {
          return false;
        }
      }
    }
    return String(a) === String(b);
  }
  function looseIndexOf(arr, val) {
    return arr.findIndex((item2) => looseEqual(item2, val));
  }
  var import_pako, PatchFlagNames, slotFlagsText, GLOBALS_WHITE_LISTED, isGloballyWhitelisted, range, specialBooleanAttrs, isSpecialBooleanAttr, isBooleanAttr, listDelimiterRE, propertyDelimiterRE, HTML_TAGS, SVG_TAGS, VOID_TAGS, isHTMLTag, isSVGTag, isVoidTag, toDisplayString, replacer, EMPTY_OBJ, EMPTY_ARR, NOOP, NO, onRE, isOn, isModelListener, extend, remove, hasOwnProperty, hasOwn, isArray, isMap, isSet, isDate, isFunction, isString, isSymbol, isObject, isPromise, objectToString, toTypeString, toRawType, isPlainObject, isIntegerKey, isReservedProp, cacheStringFunction, camelizeRE, camelize, hyphenateRE, hyphenate, capitalize, toHandlerKey, hasChanged, invokeArrayFns, def, toNumber, _globalThis, getGlobalThis;
  var init_shared_esm_bundler = __esm({
    "node_modules/@vue/shared/dist/shared.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      PatchFlagNames = {
        [1]: `TEXT`,
        [2]: `CLASS`,
        [4]: `STYLE`,
        [8]: `PROPS`,
        [16]: `FULL_PROPS`,
        [32]: `HYDRATE_EVENTS`,
        [64]: `STABLE_FRAGMENT`,
        [128]: `KEYED_FRAGMENT`,
        [256]: `UNKEYED_FRAGMENT`,
        [512]: `NEED_PATCH`,
        [1024]: `DYNAMIC_SLOTS`,
        [2048]: `DEV_ROOT_FRAGMENT`,
        [-1]: `HOISTED`,
        [-2]: `BAIL`
      };
      slotFlagsText = {
        [1]: "STABLE",
        [2]: "DYNAMIC",
        [3]: "FORWARDED"
      };
      GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
      isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
      range = 2;
      specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
      isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
      isBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs + `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected`);
      listDelimiterRE = /;(?![^(]*\))/g;
      propertyDelimiterRE = /:(.+)/;
      HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
      SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
      VOID_TAGS = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr";
      isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
      isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
      isVoidTag = /* @__PURE__ */ makeMap(VOID_TAGS);
      toDisplayString = (val) => {
        return val == null ? "" : isArray(val) || isObject(val) && (val.toString === objectToString || !isFunction(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
      };
      replacer = (_key, val) => {
        if (val && val.__v_isRef) {
          return replacer(_key, val.value);
        } else if (isMap(val)) {
          return {
            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key2, val2]) => {
              entries[`${key2} =>`] = val2;
              return entries;
            }, {})
          };
        } else if (isSet(val)) {
          return {
            [`Set(${val.size})`]: [...val.values()]
          };
        } else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {
          return String(val);
        }
        return val;
      };
      EMPTY_OBJ = true ? Object.freeze({}) : {};
      EMPTY_ARR = true ? Object.freeze([]) : [];
      NOOP = () => {
      };
      NO = () => false;
      onRE = /^on[^a-z]/;
      isOn = (key2) => onRE.test(key2);
      isModelListener = (key2) => key2.startsWith("onUpdate:");
      extend = Object.assign;
      remove = (arr, el) => {
        const i = arr.indexOf(el);
        if (i > -1) {
          arr.splice(i, 1);
        }
      };
      hasOwnProperty = Object.prototype.hasOwnProperty;
      hasOwn = (val, key2) => hasOwnProperty.call(val, key2);
      isArray = Array.isArray;
      isMap = (val) => toTypeString(val) === "[object Map]";
      isSet = (val) => toTypeString(val) === "[object Set]";
      isDate = (val) => val instanceof Date;
      isFunction = (val) => typeof val === "function";
      isString = (val) => typeof val === "string";
      isSymbol = (val) => typeof val === "symbol";
      isObject = (val) => val !== null && typeof val === "object";
      isPromise = (val) => {
        return isObject(val) && isFunction(val.then) && isFunction(val.catch);
      };
      objectToString = Object.prototype.toString;
      toTypeString = (value2) => objectToString.call(value2);
      toRawType = (value2) => {
        return toTypeString(value2).slice(8, -1);
      };
      isPlainObject = (val) => toTypeString(val) === "[object Object]";
      isIntegerKey = (key2) => isString(key2) && key2 !== "NaN" && key2[0] !== "-" && "" + parseInt(key2, 10) === key2;
      isReservedProp = /* @__PURE__ */ makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
      cacheStringFunction = (fn) => {
        const cache = Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      camelizeRE = /-(\w)/g;
      camelize = cacheStringFunction((str) => {
        return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
      });
      hyphenateRE = /\B([A-Z])/g;
      hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
      capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
      toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
      hasChanged = (value2, oldValue) => !Object.is(value2, oldValue);
      invokeArrayFns = (fns, arg) => {
        for (let i = 0; i < fns.length; i++) {
          fns[i](arg);
        }
      };
      def = (obj, key2, value2) => {
        Object.defineProperty(obj, key2, {
          configurable: true,
          enumerable: false,
          value: value2
        });
      };
      toNumber = (val) => {
        const n = parseFloat(val);
        return isNaN(n) ? val : n;
      };
      getGlobalThis = () => {
        return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
      };
    }
  });

  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  function warn(msg, ...args) {
    console.warn(`[Vue warn] ${msg}`, ...args);
  }
  function effectScope(detached) {
    return new EffectScope(detached);
  }
  function recordEffectScope(effect2, scope) {
    scope = scope || activeEffectScope;
    if (scope && scope.active) {
      scope.effects.push(effect2);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }
  function onScopeDispose(fn) {
    if (activeEffectScope) {
      activeEffectScope.cleanups.push(fn);
    } else if (true) {
      warn(`onScopeDispose() is called when there is no active effect scope to be associated with.`);
    }
  }
  function cleanupEffect(effect2) {
    const { deps } = effect2;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect2);
      }
      deps.length = 0;
    }
  }
  function effect(fn, options) {
    if (fn.effect) {
      fn = fn.effect.fn;
    }
    const _effect = new ReactiveEffect(fn);
    if (options) {
      extend(_effect, options);
      if (options.scope)
        recordEffectScope(_effect, options.scope);
    }
    if (!options || !options.lazy) {
      _effect.run();
    }
    const runner = _effect.run.bind(_effect);
    runner.effect = _effect;
    return runner;
  }
  function stop(runner) {
    runner.effect.stop();
  }
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last2 = trackStack.pop();
    shouldTrack = last2 === void 0 ? true : last2;
  }
  function track(target2, type2, key2) {
    if (!isTracking()) {
      return;
    }
    let depsMap = targetMap.get(target2);
    if (!depsMap) {
      targetMap.set(target2, depsMap = new Map());
    }
    let dep = depsMap.get(key2);
    if (!dep) {
      depsMap.set(key2, dep = createDep());
    }
    const eventInfo = true ? { effect: activeEffect, target: target2, type: type2, key: key2 } : void 0;
    trackEffects(dep, eventInfo);
  }
  function isTracking() {
    return shouldTrack && activeEffect !== void 0;
  }
  function trackEffects(dep, debuggerEventExtraInfo) {
    let shouldTrack2 = false;
    if (effectTrackDepth <= maxMarkerBits) {
      if (!newTracked(dep)) {
        dep.n |= trackOpBit;
        shouldTrack2 = !wasTracked(dep);
      }
    } else {
      shouldTrack2 = !dep.has(activeEffect);
    }
    if (shouldTrack2) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.onTrack) {
        activeEffect.onTrack(Object.assign({
          effect: activeEffect
        }, debuggerEventExtraInfo));
      }
    }
  }
  function trigger(target2, type2, key2, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target2);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type2 === "clear") {
      deps = [...depsMap.values()];
    } else if (key2 === "length" && isArray(target2)) {
      depsMap.forEach((dep, key3) => {
        if (key3 === "length" || key3 >= newValue) {
          deps.push(dep);
        }
      });
    } else {
      if (key2 !== void 0) {
        deps.push(depsMap.get(key2));
      }
      switch (type2) {
        case "add":
          if (!isArray(target2)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target2)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key2)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target2)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target2)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target2)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const eventInfo = true ? { target: target2, type: type2, key: key2, newValue, oldValue, oldTarget } : void 0;
    if (deps.length === 1) {
      if (deps[0]) {
        if (true) {
          triggerEffects(deps[0], eventInfo);
        } else {
          triggerEffects(deps[0]);
        }
      }
    } else {
      const effects = [];
      for (const dep of deps) {
        if (dep) {
          effects.push(...dep);
        }
      }
      if (true) {
        triggerEffects(createDep(effects), eventInfo);
      } else {
        triggerEffects(createDep(effects));
      }
    }
  }
  function triggerEffects(dep, debuggerEventExtraInfo) {
    for (const effect2 of isArray(dep) ? dep : [...dep]) {
      if (effect2 !== activeEffect || effect2.allowRecurse) {
        if (effect2.onTrigger) {
          effect2.onTrigger(extend({ effect: effect2 }, debuggerEventExtraInfo));
        }
        if (effect2.scheduler) {
          effect2.scheduler();
        } else {
          effect2.run();
        }
      }
    }
  }
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key2) => {
      instrumentations[key2] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key2](...args);
        if (res === -1 || res === false) {
          return arr[key2](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key2) => {
      instrumentations[key2] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key2].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly2 = false, shallow = false) {
    return function get3(target2, key2, receiver) {
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target2)) {
        return target2;
      }
      const targetIsArray = isArray(target2);
      if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key2)) {
        return Reflect.get(arrayInstrumentations, key2, receiver);
      }
      const res = Reflect.get(target2, key2, receiver);
      if (isSymbol(key2) ? builtInSymbols.has(key2) : isNonTrackableKeys(key2)) {
        return res;
      }
      if (!isReadonly2) {
        track(target2, "get", key2);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key2);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly2 ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  function createSetter(shallow = false) {
    return function set3(target2, key2, value2, receiver) {
      let oldValue = target2[key2];
      if (!shallow) {
        value2 = toRaw(value2);
        oldValue = toRaw(oldValue);
        if (!isArray(target2) && isRef(oldValue) && !isRef(value2)) {
          oldValue.value = value2;
          return true;
        }
      }
      const hadKey = isArray(target2) && isIntegerKey(key2) ? Number(key2) < target2.length : hasOwn(target2, key2);
      const result = Reflect.set(target2, key2, value2, receiver);
      if (target2 === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target2, "add", key2, value2);
        } else if (hasChanged(value2, oldValue)) {
          trigger(target2, "set", key2, value2, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target2, key2) {
    const hadKey = hasOwn(target2, key2);
    const oldValue = target2[key2];
    const result = Reflect.deleteProperty(target2, key2);
    if (result && hadKey) {
      trigger(target2, "delete", key2, void 0, oldValue);
    }
    return result;
  }
  function has(target2, key2) {
    const result = Reflect.has(target2, key2);
    if (!isSymbol(key2) || !builtInSymbols.has(key2)) {
      track(target2, "has", key2);
    }
    return result;
  }
  function ownKeys(target2) {
    track(target2, "iterate", isArray(target2) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target2);
  }
  function get$1(target2, key2, isReadonly2 = false, isShallow = false) {
    target2 = target2["__v_raw"];
    const rawTarget = toRaw(target2);
    const rawKey = toRaw(key2);
    if (key2 !== rawKey) {
      !isReadonly2 && track(rawTarget, "get", key2);
    }
    !isReadonly2 && track(rawTarget, "get", rawKey);
    const { has: has3 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
    if (has3.call(rawTarget, key2)) {
      return wrap(target2.get(key2));
    } else if (has3.call(rawTarget, rawKey)) {
      return wrap(target2.get(rawKey));
    } else if (target2 !== rawTarget) {
      target2.get(key2);
    }
  }
  function has$1(key2, isReadonly2 = false) {
    const target2 = this["__v_raw"];
    const rawTarget = toRaw(target2);
    const rawKey = toRaw(key2);
    if (key2 !== rawKey) {
      !isReadonly2 && track(rawTarget, "has", key2);
    }
    !isReadonly2 && track(rawTarget, "has", rawKey);
    return key2 === rawKey ? target2.has(key2) : target2.has(key2) || target2.has(rawKey);
  }
  function size(target2, isReadonly2 = false) {
    target2 = target2["__v_raw"];
    !isReadonly2 && track(toRaw(target2), "iterate", ITERATE_KEY);
    return Reflect.get(target2, "size", target2);
  }
  function add(value2) {
    value2 = toRaw(value2);
    const target2 = toRaw(this);
    const proto = getProto(target2);
    const hadKey = proto.has.call(target2, value2);
    if (!hadKey) {
      target2.add(value2);
      trigger(target2, "add", value2, value2);
    }
    return this;
  }
  function set$1(key2, value2) {
    value2 = toRaw(value2);
    const target2 = toRaw(this);
    const { has: has3, get: get3 } = getProto(target2);
    let hadKey = has3.call(target2, key2);
    if (!hadKey) {
      key2 = toRaw(key2);
      hadKey = has3.call(target2, key2);
    } else if (true) {
      checkIdentityKeys(target2, has3, key2);
    }
    const oldValue = get3.call(target2, key2);
    target2.set(key2, value2);
    if (!hadKey) {
      trigger(target2, "add", key2, value2);
    } else if (hasChanged(value2, oldValue)) {
      trigger(target2, "set", key2, value2, oldValue);
    }
    return this;
  }
  function deleteEntry(key2) {
    const target2 = toRaw(this);
    const { has: has3, get: get3 } = getProto(target2);
    let hadKey = has3.call(target2, key2);
    if (!hadKey) {
      key2 = toRaw(key2);
      hadKey = has3.call(target2, key2);
    } else if (true) {
      checkIdentityKeys(target2, has3, key2);
    }
    const oldValue = get3 ? get3.call(target2, key2) : void 0;
    const result = target2.delete(key2);
    if (hadKey) {
      trigger(target2, "delete", key2, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target2 = toRaw(this);
    const hadItems = target2.size !== 0;
    const oldTarget = true ? isMap(target2) ? new Map(target2) : new Set(target2) : void 0;
    const result = target2.clear();
    if (hadItems) {
      trigger(target2, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly2, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target2 = observed["__v_raw"];
      const rawTarget = toRaw(target2);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target2.forEach((value2, key2) => {
        return callback.call(thisArg, wrap(value2), wrap(key2), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly2, isShallow) {
    return function(...args) {
      const target2 = this["__v_raw"];
      const rawTarget = toRaw(target2);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target2[method](...args);
      const wrap = isShallow ? toShallow : isReadonly2 ? toReadonly : toReactive;
      !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        next() {
          const { value: value2, done } = innerIterator.next();
          return done ? { value: value2, done } : {
            value: isPair ? [wrap(value2[0]), wrap(value2[1])] : wrap(value2),
            done
          };
        },
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type2) {
    return function(...args) {
      if (true) {
        const key2 = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type2)} operation ${key2}failed: target is readonly.`, toRaw(this));
      }
      return type2 === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key2) {
        return get$1(this, key2);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key2) {
        return get$1(this, key2, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key2) {
        return get$1(this, key2, true);
      },
      get size() {
        return size(this, true);
      },
      has(key2) {
        return has$1.call(this, key2, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key2) {
        return get$1(this, key2, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key2) {
        return has$1.call(this, key2, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  function createInstrumentationGetter(isReadonly2, shallow) {
    const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
    return (target2, key2, receiver) => {
      if (key2 === "__v_isReactive") {
        return !isReadonly2;
      } else if (key2 === "__v_isReadonly") {
        return isReadonly2;
      } else if (key2 === "__v_raw") {
        return target2;
      }
      return Reflect.get(hasOwn(instrumentations, key2) && key2 in target2 ? instrumentations : target2, key2, receiver);
    };
  }
  function checkIdentityKeys(target2, has3, key2) {
    const rawKey = toRaw(key2);
    if (rawKey !== key2 && has3.call(target2, rawKey)) {
      const type2 = toRawType(target2);
      console.warn(`Reactive ${type2} contains both the raw and reactive versions of the same object${type2 === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value2) {
    return value2["__v_skip"] || !Object.isExtensible(value2) ? 0 : targetTypeMap(toRawType(value2));
  }
  function reactive2(target2) {
    if (target2 && target2["__v_isReadonly"]) {
      return target2;
    }
    return createReactiveObject(target2, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function shallowReactive(target2) {
    return createReactiveObject(target2, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
  }
  function readonly(target2) {
    return createReactiveObject(target2, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function shallowReadonly(target2) {
    return createReactiveObject(target2, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
  }
  function createReactiveObject(target2, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target2)) {
      if (true) {
        console.warn(`value cannot be made reactive: ${String(target2)}`);
      }
      return target2;
    }
    if (target2["__v_raw"] && !(isReadonly2 && target2["__v_isReactive"])) {
      return target2;
    }
    const existingProxy = proxyMap.get(target2);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target2);
    if (targetType === 0) {
      return target2;
    }
    const proxy = new Proxy(target2, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target2, proxy);
    return proxy;
  }
  function isReactive(value2) {
    if (isReadonly(value2)) {
      return isReactive(value2["__v_raw"]);
    }
    return !!(value2 && value2["__v_isReactive"]);
  }
  function isReadonly(value2) {
    return !!(value2 && value2["__v_isReadonly"]);
  }
  function isProxy(value2) {
    return isReactive(value2) || isReadonly(value2);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value2) {
    def(value2, "__v_skip", true);
    return value2;
  }
  function trackRefValue(ref3) {
    if (isTracking()) {
      ref3 = toRaw(ref3);
      if (!ref3.dep) {
        ref3.dep = createDep();
      }
      if (true) {
        trackEffects(ref3.dep, {
          target: ref3,
          type: "get",
          key: "value"
        });
      } else {
        trackEffects(ref3.dep);
      }
    }
  }
  function triggerRefValue(ref3, newVal) {
    ref3 = toRaw(ref3);
    if (ref3.dep) {
      if (true) {
        triggerEffects(ref3.dep, {
          target: ref3,
          type: "set",
          key: "value",
          newValue: newVal
        });
      } else {
        triggerEffects(ref3.dep);
      }
    }
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }
  function ref(value2) {
    return createRef(value2, false);
  }
  function shallowRef(value2) {
    return createRef(value2, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  function triggerRef(ref3) {
    triggerRefValue(ref3, true ? ref3.value : void 0);
  }
  function unref(ref3) {
    return isRef(ref3) ? ref3.value : ref3;
  }
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  function customRef(factory) {
    return new CustomRefImpl(factory);
  }
  function toRefs(object) {
    if (!isProxy(object)) {
      console.warn(`toRefs() expects a reactive object but received a plain one.`);
    }
    const ret = isArray(object) ? new Array(object.length) : {};
    for (const key2 in object) {
      ret[key2] = toRef(object, key2);
    }
    return ret;
  }
  function toRef(object, key2) {
    const val = object[key2];
    return isRef(val) ? val : new ObjectRefImpl(object, key2);
  }
  function computed2(getterOrOptions, debugOptions) {
    let getter;
    let setter;
    if (isFunction(getterOrOptions)) {
      getter = getterOrOptions;
      setter = true ? () => {
        console.warn("Write operation failed: computed value is readonly");
      } : NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);
    if (debugOptions) {
      cRef.effect.onTrack = debugOptions.onTrack;
      cRef.effect.onTrigger = debugOptions.onTrigger;
    }
    return cRef;
  }
  var import_pako, activeEffectScope, effectScopeStack, EffectScope, createDep, wasTracked, newTracked, initDepMarkers, finalizeDepMarkers, targetMap, effectTrackDepth, trackOpBit, maxMarkerBits, effectStack, activeEffect, ITERATE_KEY, MAP_KEY_ITERATE_KEY, ReactiveEffect, shouldTrack, trackStack, isNonTrackableKeys, builtInSymbols, get, shallowGet, readonlyGet, shallowReadonlyGet, arrayInstrumentations, set, shallowSet, mutableHandlers, readonlyHandlers, shallowReactiveHandlers, shallowReadonlyHandlers, toReactive, toReadonly, toShallow, getProto, mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations, mutableCollectionHandlers, shallowCollectionHandlers, readonlyCollectionHandlers, shallowReadonlyCollectionHandlers, reactiveMap, shallowReactiveMap, readonlyMap, shallowReadonlyMap, convert, RefImpl, shallowUnwrapHandlers, CustomRefImpl, ObjectRefImpl, ComputedRefImpl, _a, tick;
  var init_reactivity_esm_bundler = __esm({
    "node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_shared_esm_bundler();
      effectScopeStack = [];
      EffectScope = class {
        constructor(detached = false) {
          this.active = true;
          this.effects = [];
          this.cleanups = [];
          if (!detached && activeEffectScope) {
            this.parent = activeEffectScope;
            this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
          }
        }
        run(fn) {
          if (this.active) {
            try {
              this.on();
              return fn();
            } finally {
              this.off();
            }
          } else if (true) {
            warn(`cannot run an inactive effect scope.`);
          }
        }
        on() {
          if (this.active) {
            effectScopeStack.push(this);
            activeEffectScope = this;
          }
        }
        off() {
          if (this.active) {
            effectScopeStack.pop();
            activeEffectScope = effectScopeStack[effectScopeStack.length - 1];
          }
        }
        stop(fromParent) {
          if (this.active) {
            this.effects.forEach((e) => e.stop());
            this.cleanups.forEach((cleanup) => cleanup());
            if (this.scopes) {
              this.scopes.forEach((e) => e.stop(true));
            }
            if (this.parent && !fromParent) {
              const last2 = this.parent.scopes.pop();
              if (last2 && last2 !== this) {
                this.parent.scopes[this.index] = last2;
                last2.index = this.index;
              }
            }
            this.active = false;
          }
        }
      };
      createDep = (effects) => {
        const dep = new Set(effects);
        dep.w = 0;
        dep.n = 0;
        return dep;
      };
      wasTracked = (dep) => (dep.w & trackOpBit) > 0;
      newTracked = (dep) => (dep.n & trackOpBit) > 0;
      initDepMarkers = ({ deps }) => {
        if (deps.length) {
          for (let i = 0; i < deps.length; i++) {
            deps[i].w |= trackOpBit;
          }
        }
      };
      finalizeDepMarkers = (effect2) => {
        const { deps } = effect2;
        if (deps.length) {
          let ptr = 0;
          for (let i = 0; i < deps.length; i++) {
            const dep = deps[i];
            if (wasTracked(dep) && !newTracked(dep)) {
              dep.delete(effect2);
            } else {
              deps[ptr++] = dep;
            }
            dep.w &= ~trackOpBit;
            dep.n &= ~trackOpBit;
          }
          deps.length = ptr;
        }
      };
      targetMap = new WeakMap();
      effectTrackDepth = 0;
      trackOpBit = 1;
      maxMarkerBits = 30;
      effectStack = [];
      ITERATE_KEY = Symbol(true ? "iterate" : "");
      MAP_KEY_ITERATE_KEY = Symbol(true ? "Map key iterate" : "");
      ReactiveEffect = class {
        constructor(fn, scheduler = null, scope) {
          this.fn = fn;
          this.scheduler = scheduler;
          this.active = true;
          this.deps = [];
          recordEffectScope(this, scope);
        }
        run() {
          if (!this.active) {
            return this.fn();
          }
          if (!effectStack.includes(this)) {
            try {
              effectStack.push(activeEffect = this);
              enableTracking();
              trackOpBit = 1 << ++effectTrackDepth;
              if (effectTrackDepth <= maxMarkerBits) {
                initDepMarkers(this);
              } else {
                cleanupEffect(this);
              }
              return this.fn();
            } finally {
              if (effectTrackDepth <= maxMarkerBits) {
                finalizeDepMarkers(this);
              }
              trackOpBit = 1 << --effectTrackDepth;
              resetTracking();
              effectStack.pop();
              const n = effectStack.length;
              activeEffect = n > 0 ? effectStack[n - 1] : void 0;
            }
          }
        }
        stop() {
          if (this.active) {
            cleanupEffect(this);
            if (this.onStop) {
              this.onStop();
            }
            this.active = false;
          }
        }
      };
      shouldTrack = true;
      trackStack = [];
      isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
      builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key2) => Symbol[key2]).filter(isSymbol));
      get = /* @__PURE__ */ createGetter();
      shallowGet = /* @__PURE__ */ createGetter(false, true);
      readonlyGet = /* @__PURE__ */ createGetter(true);
      shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
      arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
      set = /* @__PURE__ */ createSetter();
      shallowSet = /* @__PURE__ */ createSetter(true);
      mutableHandlers = {
        get,
        set,
        deleteProperty,
        has,
        ownKeys
      };
      readonlyHandlers = {
        get: readonlyGet,
        set(target2, key2) {
          if (true) {
            console.warn(`Set operation on key "${String(key2)}" failed: target is readonly.`, target2);
          }
          return true;
        },
        deleteProperty(target2, key2) {
          if (true) {
            console.warn(`Delete operation on key "${String(key2)}" failed: target is readonly.`, target2);
          }
          return true;
        }
      };
      shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
        get: shallowGet,
        set: shallowSet
      });
      shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
        get: shallowReadonlyGet
      });
      toReactive = (value2) => isObject(value2) ? reactive2(value2) : value2;
      toReadonly = (value2) => isObject(value2) ? readonly(value2) : value2;
      toShallow = (value2) => value2;
      getProto = (v) => Reflect.getPrototypeOf(v);
      [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
      mutableCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, false)
      };
      shallowCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(false, true)
      };
      readonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, false)
      };
      shallowReadonlyCollectionHandlers = {
        get: /* @__PURE__ */ createInstrumentationGetter(true, true)
      };
      reactiveMap = new WeakMap();
      shallowReactiveMap = new WeakMap();
      readonlyMap = new WeakMap();
      shallowReadonlyMap = new WeakMap();
      convert = (val) => isObject(val) ? reactive2(val) : val;
      RefImpl = class {
        constructor(value2, _shallow) {
          this._shallow = _shallow;
          this.dep = void 0;
          this.__v_isRef = true;
          this._rawValue = _shallow ? value2 : toRaw(value2);
          this._value = _shallow ? value2 : convert(value2);
        }
        get value() {
          trackRefValue(this);
          return this._value;
        }
        set value(newVal) {
          newVal = this._shallow ? newVal : toRaw(newVal);
          if (hasChanged(newVal, this._rawValue)) {
            this._rawValue = newVal;
            this._value = this._shallow ? newVal : convert(newVal);
            triggerRefValue(this, newVal);
          }
        }
      };
      shallowUnwrapHandlers = {
        get: (target2, key2, receiver) => unref(Reflect.get(target2, key2, receiver)),
        set: (target2, key2, value2, receiver) => {
          const oldValue = target2[key2];
          if (isRef(oldValue) && !isRef(value2)) {
            oldValue.value = value2;
            return true;
          } else {
            return Reflect.set(target2, key2, value2, receiver);
          }
        }
      };
      CustomRefImpl = class {
        constructor(factory) {
          this.dep = void 0;
          this.__v_isRef = true;
          const { get: get3, set: set3 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
          this._get = get3;
          this._set = set3;
        }
        get value() {
          return this._get();
        }
        set value(newVal) {
          this._set(newVal);
        }
      };
      ObjectRefImpl = class {
        constructor(_object, _key) {
          this._object = _object;
          this._key = _key;
          this.__v_isRef = true;
        }
        get value() {
          return this._object[this._key];
        }
        set value(newVal) {
          this._object[this._key] = newVal;
        }
      };
      ComputedRefImpl = class {
        constructor(getter, _setter, isReadonly2) {
          this._setter = _setter;
          this.dep = void 0;
          this._dirty = true;
          this.__v_isRef = true;
          this.effect = new ReactiveEffect(getter, () => {
            if (!this._dirty) {
              this._dirty = true;
              triggerRefValue(this);
            }
          });
          this["__v_isReadonly"] = isReadonly2;
        }
        get value() {
          const self2 = toRaw(this);
          trackRefValue(self2);
          if (self2._dirty) {
            self2._dirty = false;
            self2._value = self2.effect.run();
          }
          return self2._value;
        }
        set value(newValue) {
          this._setter(newValue);
        }
      };
      tick = Promise.resolve();
      _a = "__v_isReadonly";
    }
  });

  // node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js
  function registerHMR(instance) {
    const id2 = instance.type.__hmrId;
    let record = map.get(id2);
    if (!record) {
      createRecord(id2);
      record = map.get(id2);
    }
    record.add(instance);
  }
  function unregisterHMR(instance) {
    map.get(instance.type.__hmrId).delete(instance);
  }
  function createRecord(id2) {
    if (map.has(id2)) {
      return false;
    }
    map.set(id2, new Set());
    return true;
  }
  function normalizeClassComponent(component) {
    return isClassComponent(component) ? component.__vccOpts : component;
  }
  function rerender(id2, newRender) {
    const record = map.get(id2);
    if (!record) {
      return;
    }
    [...record].forEach((instance) => {
      if (newRender) {
        instance.render = newRender;
        normalizeClassComponent(instance.type).render = newRender;
      }
      instance.renderCache = [];
      isHmrUpdating = true;
      instance.update();
      isHmrUpdating = false;
    });
  }
  function reload(id2, newComp) {
    const record = map.get(id2);
    if (!record)
      return;
    newComp = normalizeClassComponent(newComp);
    const instances = [...record];
    for (const instance of instances) {
      const oldComp = normalizeClassComponent(instance.type);
      if (!hmrDirtyComponents.has(oldComp)) {
        extend(oldComp, newComp);
        for (const key2 in oldComp) {
          if (key2 !== "__file" && !(key2 in newComp)) {
            delete oldComp[key2];
          }
        }
        hmrDirtyComponents.add(oldComp);
      }
      instance.appContext.optionsCache.delete(instance.type);
      if (instance.ceReload) {
        hmrDirtyComponents.add(oldComp);
        instance.ceReload(newComp.styles);
        hmrDirtyComponents.delete(oldComp);
      } else if (instance.parent) {
        queueJob(instance.parent.update);
        if (instance.parent.type.__asyncLoader && instance.parent.ceReload) {
          instance.parent.ceReload(newComp.styles);
        }
      } else if (instance.appContext.reload) {
        instance.appContext.reload();
      } else if (typeof window !== "undefined") {
        window.location.reload();
      } else {
        console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
      }
    }
    queuePostFlushCb(() => {
      for (const instance of instances) {
        hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
      }
    });
  }
  function tryWrap(fn) {
    return (id2, arg) => {
      try {
        return fn(id2, arg);
      } catch (e) {
        console.error(e);
        console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
      }
    };
  }
  function setDevtoolsHook(hook) {
    devtools = hook;
  }
  function devtoolsInitApp(app2, version2) {
    if (!devtools)
      return;
    devtools.emit("app:init", app2, version2, {
      Fragment,
      Text,
      Comment,
      Static
    });
  }
  function devtoolsUnmountApp(app2) {
    if (!devtools)
      return;
    devtools.emit("app:unmount", app2);
  }
  function createDevtoolsComponentHook(hook) {
    return (component) => {
      if (!devtools)
        return;
      devtools.emit(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
    };
  }
  function createDevtoolsPerformanceHook(hook) {
    return (component, type2, time) => {
      if (!devtools)
        return;
      devtools.emit(hook, component.appContext.app, component.uid, component, type2, time);
    };
  }
  function devtoolsComponentEmit(component, event3, params) {
    if (!devtools)
      return;
    devtools.emit("component:emit", component.appContext.app, component, event3, params);
  }
  function emit(instance, event3, ...rawArgs) {
    const props2 = instance.vnode.props || EMPTY_OBJ;
    if (true) {
      const { emitsOptions, propsOptions: [propsOptions] } = instance;
      if (emitsOptions) {
        if (!(event3 in emitsOptions) && true) {
          if (!propsOptions || !(toHandlerKey(event3) in propsOptions)) {
            warn2(`Component emitted event "${event3}" but it is neither declared in the emits option nor as an "${toHandlerKey(event3)}" prop.`);
          }
        } else {
          const validator = emitsOptions[event3];
          if (isFunction(validator)) {
            const isValid2 = validator(...rawArgs);
            if (!isValid2) {
              warn2(`Invalid event arguments: event validation failed for event "${event3}".`);
            }
          }
        }
      }
    }
    let args = rawArgs;
    const isModelListener2 = event3.startsWith("update:");
    const modelArg = isModelListener2 && event3.slice(7);
    if (modelArg && modelArg in props2) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props2[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => a.trim());
      } else if (number) {
        args = rawArgs.map(toNumber);
      }
    }
    if (true) {
      devtoolsComponentEmit(instance, event3, args);
    }
    if (true) {
      const lowerCaseEvent = event3.toLowerCase();
      if (lowerCaseEvent !== event3 && props2[toHandlerKey(lowerCaseEvent)]) {
        warn2(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event3}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event3)}" instead of "${event3}".`);
      }
    }
    let handlerName;
    let handler = props2[handlerName = toHandlerKey(event3)] || props2[handlerName = toHandlerKey(camelize(event3))];
    if (!handler && isModelListener2) {
      handler = props2[handlerName = toHandlerKey(hyphenate(event3))];
    }
    if (handler) {
      callWithAsyncErrorHandling(handler, instance, 6, args);
    }
    const onceHandler = props2[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(onceHandler, instance, 6, args);
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      cache.set(comp, null);
      return null;
    }
    if (isArray(raw)) {
      raw.forEach((key2) => normalized[key2] = null);
    } else {
      extend(normalized, raw);
    }
    cache.set(comp, normalized);
    return normalized;
  }
  function isEmitListener(options, key2) {
    if (!options || !isOn(key2)) {
      return false;
    }
    key2 = key2.slice(2).replace(/Once$/, "");
    return hasOwn(options, key2[0].toLowerCase() + key2.slice(1)) || hasOwn(options, hyphenate(key2)) || hasOwn(options, key2);
  }
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function pushScopeId(id2) {
    currentScopeId = id2;
  }
  function popScopeId() {
    currentScopeId = null;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      const res = fn(...args);
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
      if (true) {
        devtoolsComponentUpdated(ctx);
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function markAttrsAccessed() {
    accessedAttrs = true;
  }
  function renderComponentRoot(instance) {
    const { type: Component2, vnode, proxy, withProxy, props: props2, propsOptions: [propsOptions], slots, attrs, emit: emit2, render: render3, renderCache, data, setupState, ctx, inheritAttrs } = instance;
    let result;
    const prev = setCurrentRenderingInstance(instance);
    if (true) {
      accessedAttrs = false;
    }
    try {
      let fallthroughAttrs;
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        result = normalizeVNode(render3.call(proxyToUse, proxyToUse, renderCache, props2, setupState, data, ctx));
        fallthroughAttrs = attrs;
      } else {
        const render4 = Component2;
        if (attrs === props2) {
          markAttrsAccessed();
        }
        result = normalizeVNode(render4.length > 1 ? render4(props2, true ? {
          get attrs() {
            markAttrsAccessed();
            return attrs;
          },
          slots,
          emit: emit2
        } : { attrs, slots, emit: emit2 }) : render4(props2, null));
        fallthroughAttrs = Component2.props ? attrs : getFunctionalFallthrough(attrs);
      }
      let root = result;
      let setRoot = void 0;
      if (result.patchFlag > 0 && result.patchFlag & 2048) {
        ;
        [root, setRoot] = getChildRoot(result);
      }
      if (fallthroughAttrs && inheritAttrs !== false) {
        const keys = Object.keys(fallthroughAttrs);
        const { shapeFlag } = root;
        if (keys.length) {
          if (shapeFlag & (1 | 6)) {
            if (propsOptions && keys.some(isModelListener)) {
              fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
            }
            root = cloneVNode(root, fallthroughAttrs);
          } else if (!accessedAttrs && root.type !== Comment) {
            const allAttrs = Object.keys(attrs);
            const eventAttrs = [];
            const extraAttrs = [];
            for (let i = 0, l = allAttrs.length; i < l; i++) {
              const key2 = allAttrs[i];
              if (isOn(key2)) {
                if (!isModelListener(key2)) {
                  eventAttrs.push(key2[2].toLowerCase() + key2.slice(3));
                }
              } else {
                extraAttrs.push(key2);
              }
            }
            if (extraAttrs.length) {
              warn2(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
            }
            if (eventAttrs.length) {
              warn2(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
            }
          }
        }
      }
      if (false)
        ;
      if (vnode.dirs) {
        if (!isElementRoot(root)) {
          warn2(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
        }
        root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
      }
      if (vnode.transition) {
        if (!isElementRoot(root)) {
          warn2(`Component inside <Transition> renders non-element root node that cannot be animated.`);
        }
        root.transition = vnode.transition;
      }
      if (setRoot) {
        setRoot(root);
      } else {
        result = root;
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  function filterSingleRoot(children) {
    let singleRoot;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (isVNode(child)) {
        if (child.type !== Comment || child.children === "v-if") {
          if (singleRoot) {
            return;
          } else {
            singleRoot = child;
          }
        }
      } else {
        return;
      }
    }
    return singleRoot;
  }
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits2 = component.emitsOptions;
    if ((prevChildren || nextChildren) && isHmrUpdating) {
      return true;
    }
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits2);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key2 = dynamicProps[i];
          if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emits2, key2)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits2);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key2 = nextKeys[i];
      if (nextProps[key2] !== prevProps[key2] && !isEmitListener(emitsOptions, key2)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    while (parent && parent.subTree === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    }
  }
  function triggerEvent(vnode, name) {
    const eventListener = vnode.props && vnode.props[name];
    if (isFunction(eventListener)) {
      eventListener();
    }
  }
  function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    const { p: patch, o: { createElement } } = rendererInternals;
    const hiddenContainer = createElement("div");
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
    patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
    if (suspense.deps > 0) {
      triggerEvent(vnode, "onPending");
      triggerEvent(vnode, "onFallback");
      patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
      setActiveBranch(suspense, vnode.ssFallback);
    } else {
      suspense.resolve();
    }
  }
  function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
    const suspense = n2.suspense = n1.suspense;
    suspense.vnode = n2;
    n2.el = n1.el;
    const newBranch = n2.ssContent;
    const newFallback = n2.ssFallback;
    const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
    if (pendingBranch) {
      suspense.pendingBranch = newBranch;
      if (isSameVNodeType(newBranch, pendingBranch)) {
        patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else if (isInFallback) {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else {
        suspense.pendingId++;
        if (isHydrating) {
          suspense.isHydrating = false;
          suspense.activeBranch = pendingBranch;
        } else {
          unmount(pendingBranch, parentComponent, suspense);
        }
        suspense.deps = 0;
        suspense.effects.length = 0;
        suspense.hiddenContainer = createElement("div");
        if (isInFallback) {
          patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          } else {
            patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
            setActiveBranch(suspense, newFallback);
          }
        } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
          patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          suspense.resolve(true);
        } else {
          patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
          if (suspense.deps <= 0) {
            suspense.resolve();
          }
        }
      }
    } else {
      if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newBranch);
      } else {
        triggerEvent(n2, "onPending");
        suspense.pendingBranch = newBranch;
        suspense.pendingId++;
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          const { timeout: timeout2, pendingId } = suspense;
          if (timeout2 > 0) {
            setTimeout(() => {
              if (suspense.pendingId === pendingId) {
                suspense.fallback(newFallback);
              }
            }, timeout2);
          } else if (timeout2 === 0) {
            suspense.fallback(newFallback);
          }
        }
      }
    }
  }
  function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
    if (!hasWarned) {
      hasWarned = true;
      console[console.info ? "info" : "log"](`<Suspense> is an experimental feature and its API will likely change.`);
    }
    const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove3 } } = rendererInternals;
    const timeout2 = toNumber(vnode.props && vnode.props.timeout);
    const suspense = {
      vnode,
      parent,
      parentComponent,
      isSVG,
      container,
      hiddenContainer,
      anchor,
      deps: 0,
      pendingId: 0,
      timeout: typeof timeout2 === "number" ? timeout2 : -1,
      activeBranch: null,
      pendingBranch: null,
      isInFallback: true,
      isHydrating,
      isUnmounted: false,
      effects: [],
      resolve(resume = false) {
        if (true) {
          if (!resume && !suspense.pendingBranch) {
            throw new Error(`suspense.resolve() is called without a pending branch.`);
          }
          if (suspense.isUnmounted) {
            throw new Error(`suspense.resolve() is called on an already unmounted suspense boundary.`);
          }
        }
        const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
        if (suspense.isHydrating) {
          suspense.isHydrating = false;
        } else if (!resume) {
          const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
          if (delayEnter) {
            activeBranch.transition.afterLeave = () => {
              if (pendingId === suspense.pendingId) {
                move(pendingBranch, container2, anchor2, 0);
              }
            };
          }
          let { anchor: anchor2 } = suspense;
          if (activeBranch) {
            anchor2 = next(activeBranch);
            unmount(activeBranch, parentComponent2, suspense, true);
          }
          if (!delayEnter) {
            move(pendingBranch, container2, anchor2, 0);
          }
        }
        setActiveBranch(suspense, pendingBranch);
        suspense.pendingBranch = null;
        suspense.isInFallback = false;
        let parent2 = suspense.parent;
        let hasUnresolvedAncestor = false;
        while (parent2) {
          if (parent2.pendingBranch) {
            parent2.effects.push(...effects);
            hasUnresolvedAncestor = true;
            break;
          }
          parent2 = parent2.parent;
        }
        if (!hasUnresolvedAncestor) {
          queuePostFlushCb(effects);
        }
        suspense.effects = [];
        triggerEvent(vnode2, "onResolve");
      },
      fallback(fallbackVNode) {
        if (!suspense.pendingBranch) {
          return;
        }
        const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
        triggerEvent(vnode2, "onFallback");
        const anchor2 = next(activeBranch);
        const mountFallback = () => {
          if (!suspense.isInFallback) {
            return;
          }
          patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
          setActiveBranch(suspense, fallbackVNode);
        };
        const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = mountFallback;
        }
        suspense.isInFallback = true;
        unmount(activeBranch, parentComponent2, null, true);
        if (!delayEnter) {
          mountFallback();
        }
      },
      move(container2, anchor2, type2) {
        suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type2);
        suspense.container = container2;
      },
      next() {
        return suspense.activeBranch && next(suspense.activeBranch);
      },
      registerDep(instance, setupRenderEffect) {
        const isInPendingSuspense = !!suspense.pendingBranch;
        if (isInPendingSuspense) {
          suspense.deps++;
        }
        const hydratedEl = instance.vnode.el;
        instance.asyncDep.catch((err) => {
          handleError(err, instance, 0);
        }).then((asyncSetupResult) => {
          if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
            return;
          }
          instance.asyncResolved = true;
          const { vnode: vnode2 } = instance;
          if (true) {
            pushWarningContext(vnode2);
          }
          handleSetupResult(instance, asyncSetupResult, false);
          if (hydratedEl) {
            vnode2.el = hydratedEl;
          }
          const placeholder = !hydratedEl && instance.subTree.el;
          setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
          if (placeholder) {
            remove3(placeholder);
          }
          updateHOCHostEl(instance, vnode2.el);
          if (true) {
            popWarningContext();
          }
          if (isInPendingSuspense && --suspense.deps === 0) {
            suspense.resolve();
          }
        });
      },
      unmount(parentSuspense, doRemove) {
        suspense.isUnmounted = true;
        if (suspense.activeBranch) {
          unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
        }
        if (suspense.pendingBranch) {
          unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
        }
      }
    };
    return suspense;
  }
  function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
    const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
    const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
    if (suspense.deps === 0) {
      suspense.resolve();
    }
    return result;
  }
  function normalizeSuspenseChildren(vnode) {
    const { shapeFlag, children } = vnode;
    const isSlotChildren = shapeFlag & 32;
    vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
    vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
  }
  function normalizeSuspenseSlot(s2) {
    let block;
    if (isFunction(s2)) {
      const isCompiledSlot = s2._c;
      if (isCompiledSlot) {
        s2._d = false;
        openBlock();
      }
      s2 = s2();
      if (isCompiledSlot) {
        s2._d = true;
        block = currentBlock;
        closeBlock();
      }
    }
    if (isArray(s2)) {
      const singleChild = filterSingleRoot(s2);
      if (!singleChild) {
        warn2(`<Suspense> slots expect a single root node.`);
      }
      s2 = singleChild;
    }
    s2 = normalizeVNode(s2);
    if (block && !s2.dynamicChildren) {
      s2.dynamicChildren = block.filter((c) => c !== s2);
    }
    return s2;
  }
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }
  function setActiveBranch(suspense, branch) {
    suspense.activeBranch = branch;
    const { vnode, parentComponent } = suspense;
    const el = vnode.el = branch.el;
    if (parentComponent && parentComponent.subTree === vnode) {
      parentComponent.vnode.el = el;
      updateHOCHostEl(parentComponent, el);
    }
  }
  function provide2(key2, value2) {
    if (!currentInstance) {
      if (true) {
        warn2(`provide() can only be used inside setup().`);
      }
    } else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key2] = value2;
    }
  }
  function inject2(key2, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance) {
      const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
      if (provides && key2 in provides) {
        return provides[key2];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
      } else if (true) {
        warn2(`injection "${String(key2)}" not found.`);
      }
    } else if (true) {
      warn2(`inject() can only be used inside setup() or functional components.`);
    }
  }
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: new Map()
    };
    onMounted2(() => {
      state.isMounted = true;
    });
    onBeforeUnmount2(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props2, state, instance) {
    const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props2;
    const key2 = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook3 = (hook, args) => {
      hook && callWithAsyncErrorHandling(hook, instance, 9, args);
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el._leaveCb) {
          el._leaveCb(true);
        }
        const leavingVNode = leavingVNodesCache[key2];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
          leavingVNode.el._leaveCb();
        }
        callHook3(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el._enterCb = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook3(cancelHook, [el]);
          } else {
            callHook3(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el._enterCb = void 0;
        };
        if (hook) {
          hook(el, done);
          if (hook.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      leave(el, remove3) {
        const key3 = String(vnode.key);
        if (el._enterCb) {
          el._enterCb(true);
        }
        if (state.isUnmounting) {
          return remove3();
        }
        callHook3(onBeforeLeave, [el]);
        let called = false;
        const done = el._leaveCb = (cancelled) => {
          if (called)
            return;
          called = true;
          remove3();
          if (cancelled) {
            callHook3(onLeaveCancelled, [el]);
          } else {
            callHook3(onAfterLeave, [el]);
          }
          el._leaveCb = void 0;
          if (leavingVNodesCache[key3] === vnode) {
            delete leavingVNodesCache[key3];
          }
        };
        leavingVNodesCache[key3] = vnode;
        if (onLeave) {
          onLeave(el, done);
          if (onLeave.length <= 1) {
            done();
          }
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props2, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(getTransitionRawChildren(child.children, keepComment));
      } else if (keepComment || child.type !== Comment) {
        ret.push(child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }
  function defineComponent2(options) {
    return isFunction(options) ? { setup: options, name: options.name } : options;
  }
  function defineAsyncComponent(source) {
    if (isFunction(source)) {
      source = { loader: source };
    }
    const {
      loader,
      loadingComponent,
      errorComponent,
      delay = 200,
      timeout: timeout2,
      suspensible = true,
      onError: userOnError
    } = source;
    let pendingRequest = null;
    let resolvedComp;
    let retries = 0;
    const retry = () => {
      retries++;
      pendingRequest = null;
      return load();
    };
    const load = () => {
      let thisRequest;
      return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
        err = err instanceof Error ? err : new Error(String(err));
        if (userOnError) {
          return new Promise((resolve2, reject) => {
            const userRetry = () => resolve2(retry());
            const userFail = () => reject(err);
            userOnError(err, userRetry, userFail, retries + 1);
          });
        } else {
          throw err;
        }
      }).then((comp) => {
        if (thisRequest !== pendingRequest && pendingRequest) {
          return pendingRequest;
        }
        if (!comp) {
          warn2(`Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.`);
        }
        if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
          comp = comp.default;
        }
        if (comp && !isObject(comp) && !isFunction(comp)) {
          throw new Error(`Invalid async component load result: ${comp}`);
        }
        resolvedComp = comp;
        return comp;
      }));
    };
    return defineComponent2({
      name: "AsyncComponentWrapper",
      __asyncLoader: load,
      get __asyncResolved() {
        return resolvedComp;
      },
      setup() {
        const instance = currentInstance;
        if (resolvedComp) {
          return () => createInnerComp(resolvedComp, instance);
        }
        const onError = (err) => {
          pendingRequest = null;
          handleError(err, instance, 13, !errorComponent);
        };
        if (suspensible && instance.suspense || false) {
          return load().then((comp) => {
            return () => createInnerComp(comp, instance);
          }).catch((err) => {
            onError(err);
            return () => errorComponent ? createVNode(errorComponent, {
              error: err
            }) : null;
          });
        }
        const loaded = ref(false);
        const error = ref();
        const delayed = ref(!!delay);
        if (delay) {
          setTimeout(() => {
            delayed.value = false;
          }, delay);
        }
        if (timeout2 != null) {
          setTimeout(() => {
            if (!loaded.value && !error.value) {
              const err = new Error(`Async component timed out after ${timeout2}ms.`);
              onError(err);
              error.value = err;
            }
          }, timeout2);
        }
        load().then(() => {
          loaded.value = true;
          if (instance.parent && isKeepAlive(instance.parent.vnode)) {
            queueJob(instance.parent.update);
          }
        }).catch((err) => {
          onError(err);
          error.value = err;
        });
        return () => {
          if (loaded.value && resolvedComp) {
            return createInnerComp(resolvedComp, instance);
          } else if (error.value && errorComponent) {
            return createVNode(errorComponent, {
              error: error.value
            });
          } else if (loadingComponent && !delayed.value) {
            return createVNode(loadingComponent);
          }
        };
      }
    });
  }
  function createInnerComp(comp, { vnode: { ref: ref3, props: props2, children } }) {
    const vnode = createVNode(comp, props2, children);
    vnode.ref = ref3;
    return vnode;
  }
  function matches(pattern, name) {
    if (isArray(pattern)) {
      return pattern.some((p2) => matches(p2, name));
    } else if (isString(pattern)) {
      return pattern.split(",").indexOf(name) > -1;
    } else if (pattern.test) {
      return pattern.test(name);
    }
    return false;
  }
  function onActivated(hook, target2) {
    registerKeepAliveHook(hook, "a", target2);
  }
  function onDeactivated(hook, target2) {
    registerKeepAliveHook(hook, "da", target2);
  }
  function registerKeepAliveHook(hook, type2, target2 = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target2;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      hook();
    });
    injectHook(type2, wrappedHook, target2);
    if (target2) {
      let current = target2.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type2, target2, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type2, target2, keepAliveRoot) {
    const injected = injectHook(type2, hook, keepAliveRoot, true);
    onUnmounted(() => {
      remove(keepAliveRoot[type2], injected);
    }, target2);
  }
  function resetShapeFlag(vnode) {
    let shapeFlag = vnode.shapeFlag;
    if (shapeFlag & 256) {
      shapeFlag -= 256;
    }
    if (shapeFlag & 512) {
      shapeFlag -= 512;
    }
    vnode.shapeFlag = shapeFlag;
  }
  function getInnerChild(vnode) {
    return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
  }
  function injectHook(type2, hook, target2 = currentInstance, prepend = false) {
    if (target2) {
      const hooks = target2[type2] || (target2[type2] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target2.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target2);
        const res = callWithAsyncErrorHandling(hook, target2, type2, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    } else if (true) {
      const apiName = toHandlerKey(ErrorTypeStrings[type2].replace(/ hook$/, ""));
      warn2(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
    }
  }
  function onErrorCaptured(hook, target2 = currentInstance) {
    injectHook("ec", hook, target2);
  }
  function createDuplicateChecker() {
    const cache = Object.create(null);
    return (type2, key2) => {
      if (cache[key2]) {
        warn2(`${type2} property "${key2}" is already defined in ${cache[key2]}.`);
      } else {
        cache[key2] = type2;
      }
    };
  }
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook(options.beforeCreate, instance, "bc");
    }
    const {
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render: render3,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      expose,
      inheritAttrs,
      components: components2,
      directives: directives2,
      filters
    } = options;
    const checkDuplicateProperties = true ? createDuplicateChecker() : null;
    if (true) {
      const [propsOptions] = instance.propsOptions;
      if (propsOptions) {
        for (const key2 in propsOptions) {
          checkDuplicateProperties("Props", key2);
        }
      }
    }
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
    }
    if (methods) {
      for (const key2 in methods) {
        const methodHandler = methods[key2];
        if (isFunction(methodHandler)) {
          if (true) {
            Object.defineProperty(ctx, key2, {
              value: methodHandler.bind(publicThis),
              configurable: true,
              enumerable: true,
              writable: true
            });
          } else {
            ctx[key2] = methodHandler.bind(publicThis);
          }
          if (true) {
            checkDuplicateProperties("Methods", key2);
          }
        } else if (true) {
          warn2(`Method "${key2}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
        }
      }
    }
    if (dataOptions) {
      if (!isFunction(dataOptions)) {
        warn2(`The data option must be a function. Plain object usage is no longer supported.`);
      }
      const data = dataOptions.call(publicThis, publicThis);
      if (isPromise(data)) {
        warn2(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
      }
      if (!isObject(data)) {
        warn2(`data() should return an object.`);
      } else {
        instance.data = reactive2(data);
        if (true) {
          for (const key2 in data) {
            checkDuplicateProperties("Data", key2);
            if (key2[0] !== "$" && key2[0] !== "_") {
              Object.defineProperty(ctx, key2, {
                configurable: true,
                enumerable: true,
                get: () => data[key2],
                set: NOOP
              });
            }
          }
        }
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key2 in computedOptions) {
        const opt = computedOptions[key2];
        const get3 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        if (get3 === NOOP) {
          warn2(`Computed property "${key2}" has no getter.`);
        }
        const set3 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : true ? () => {
          warn2(`Write operation failed: computed property "${key2}" is readonly.`);
        } : NOOP;
        const c = computed2({
          get: get3,
          set: set3
        });
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
        if (true) {
          checkDuplicateProperties("Computed", key2);
        }
      }
    }
    if (watchOptions) {
      for (const key2 in watchOptions) {
        createWatcher(watchOptions[key2], ctx, publicThis, key2);
      }
    }
    if (provideOptions) {
      const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key2) => {
        provide2(key2, provides[key2]);
      });
    }
    if (created) {
      callHook(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted2, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount2, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key2) => {
          Object.defineProperty(exposed, key2, {
            get: () => publicThis[key2],
            set: (val) => publicThis[key2] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render3 && instance.render === NOOP) {
      instance.render = render3;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components2)
      instance.components = components2;
    if (directives2)
      instance.directives = directives2;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
    if (isArray(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key2 in injectOptions) {
      const opt = injectOptions[key2];
      let injected;
      if (isObject(opt)) {
        if ("default" in opt) {
          injected = inject2(opt.from || key2, opt.default, true);
        } else {
          injected = inject2(opt.from || key2);
        }
      } else {
        injected = inject2(opt);
      }
      if (isRef(injected)) {
        if (unwrapRef) {
          Object.defineProperty(ctx, key2, {
            enumerable: true,
            configurable: true,
            get: () => injected.value,
            set: (v) => injected.value = v
          });
        } else {
          if (true) {
            warn2(`injected property "${key2}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
          }
          ctx[key2] = injected;
        }
      } else {
        ctx[key2] = injected;
      }
      if (true) {
        checkDuplicateProperties("Inject", key2);
      }
    }
  }
  function callHook(hook, instance, type2) {
    callWithAsyncErrorHandling(isArray(hook) ? hook.map((h3) => h3.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type2);
  }
  function createWatcher(raw, ctx, publicThis, key2) {
    const getter = key2.includes(".") ? createPathGetter(publicThis, key2) : () => publicThis[key2];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction(handler)) {
        watch(getter, handler);
      } else if (true) {
        warn2(`Invalid watch handler specified by key "${raw}"`, handler);
      }
    } else if (isFunction(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject(raw)) {
      if (isArray(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key2));
      } else {
        const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction(handler)) {
          watch(getter, handler, raw);
        } else if (true) {
          warn2(`Invalid watch handler specified by key "${raw.handler}"`, handler);
        }
      }
    } else if (true) {
      warn2(`Invalid watch option: "${key2}"`, raw);
    }
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    cache.set(base, resolved);
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach((m) => mergeOptions(to, m, strats, true));
    }
    for (const key2 in from) {
      if (asMixin && key2 === "expose") {
        warn2(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
      } else {
        const strat = internalOptionMergeStrats[key2] || strats && strats[key2];
        to[key2] = strat ? strat(to[key2], from[key2]) : from[key2];
      }
    }
    return to;
  }
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(extend(Object.create(null), to), from) : from;
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(Object.create(null), to);
    for (const key2 in from) {
      merged[key2] = mergeAsArray(to[key2], from[key2]);
    }
    return merged;
  }
  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props2 = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = Object.create(null);
    setFullProps(instance, rawProps, props2, attrs);
    for (const key2 in instance.propsOptions[0]) {
      if (!(key2 in props2)) {
        props2[key2] = void 0;
      }
    }
    if (true) {
      validateProps(rawProps || {}, props2, instance);
    }
    if (isStateful) {
      instance.props = isSSR ? props2 : shallowReactive(props2);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props2;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const { props: props2, attrs, vnode: { patchFlag } } = instance;
    const rawCurrentProps = toRaw(props2);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (!(instance.type.__hmrId || instance.parent && instance.parent.type.__hmrId) && (optimized || patchFlag > 0) && !(patchFlag & 16)) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key2 = propsToUpdate[i];
          const value2 = rawProps[key2];
          if (options) {
            if (hasOwn(attrs, key2)) {
              if (value2 !== attrs[key2]) {
                attrs[key2] = value2;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key2);
              props2[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value2, instance, false);
            }
          } else {
            if (value2 !== attrs[key2]) {
              attrs[key2] = value2;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props2, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key2 in rawCurrentProps) {
        if (!rawProps || !hasOwn(rawProps, key2) && ((kebabKey = hyphenate(key2)) === key2 || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && (rawPrevProps[key2] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
              props2[key2] = resolvePropValue(options, rawCurrentProps, key2, void 0, instance, true);
            }
          } else {
            delete props2[key2];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key2 in attrs) {
          if (!rawProps || !hasOwn(rawProps, key2)) {
            delete attrs[key2];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger(instance, "set", "$attrs");
    }
    if (true) {
      validateProps(rawProps || {}, props2, instance);
    }
  }
  function setFullProps(instance, rawProps, props2, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key2 in rawProps) {
        if (isReservedProp(key2)) {
          continue;
        }
        const value2 = rawProps[key2];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key2))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props2[camelKey] = value2;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value2;
          }
        } else if (!isEmitListener(instance.emitsOptions, key2)) {
          if (value2 !== attrs[key2]) {
            attrs[key2] = value2;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props2);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key2 = needCastKeys[i];
        props2[key2] = resolvePropValue(options, rawCurrentProps, key2, castValues[key2], instance, !hasOwn(castValues, key2));
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props2, key2, value2, instance, isAbsent) {
    const opt = options[key2];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value2 === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && isFunction(defaultValue)) {
          const { propsDefaults } = instance;
          if (key2 in propsDefaults) {
            value2 = propsDefaults[key2];
          } else {
            setCurrentInstance(instance);
            value2 = propsDefaults[key2] = defaultValue.call(null, props2);
            unsetCurrentInstance();
          }
        } else {
          value2 = defaultValue;
        }
      }
      if (opt[0]) {
        if (isAbsent && !hasDefault) {
          value2 = false;
        } else if (opt[1] && (value2 === "" || value2 === hyphenate(key2))) {
          value2 = true;
        }
      }
    }
    return value2;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (!isFunction(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props2, keys] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props2);
        if (keys)
          needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      cache.set(comp, EMPTY_ARR);
      return EMPTY_ARR;
    }
    if (isArray(raw)) {
      for (let i = 0; i < raw.length; i++) {
        if (!isString(raw[i])) {
          warn2(`props must be strings when using array syntax.`, raw[i]);
        }
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      if (!isObject(raw)) {
        warn2(`invalid props options`, raw);
      }
      for (const key2 in raw) {
        const normalizedKey = camelize(key2);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key2];
          const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : opt;
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0] = booleanIndex > -1;
            prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    cache.set(comp, res);
    return res;
  }
  function validatePropName(key2) {
    if (key2[0] !== "$") {
      return true;
    } else if (true) {
      warn2(`Invalid prop name: "${key2}" is a reserved property.`);
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
    return match ? match[1] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type2, expectedTypes) {
    if (isArray(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type2));
    } else if (isFunction(expectedTypes)) {
      return isSameType(expectedTypes, type2) ? 0 : -1;
    }
    return -1;
  }
  function validateProps(rawProps, props2, instance) {
    const resolvedValues = toRaw(props2);
    const options = instance.propsOptions[0];
    for (const key2 in options) {
      let opt = options[key2];
      if (opt == null)
        continue;
      validateProp(key2, resolvedValues[key2], opt, !hasOwn(rawProps, key2) && !hasOwn(rawProps, hyphenate(key2)));
    }
  }
  function validateProp(name, value2, prop, isAbsent) {
    const { type: type2, required, validator } = prop;
    if (required && isAbsent) {
      warn2('Missing required prop: "' + name + '"');
      return;
    }
    if (value2 == null && !prop.required) {
      return;
    }
    if (type2 != null && type2 !== true) {
      let isValid2 = false;
      const types = isArray(type2) ? type2 : [type2];
      const expectedTypes = [];
      for (let i = 0; i < types.length && !isValid2; i++) {
        const { valid, expectedType } = assertType(value2, types[i]);
        expectedTypes.push(expectedType || "");
        isValid2 = valid;
      }
      if (!isValid2) {
        warn2(getInvalidTypeMessage(name, value2, expectedTypes));
        return;
      }
    }
    if (validator && !validator(value2)) {
      warn2('Invalid prop: custom validator check failed for prop "' + name + '".');
    }
  }
  function assertType(value2, type2) {
    let valid;
    const expectedType = getType(type2);
    if (isSimpleType(expectedType)) {
      const t = typeof value2;
      valid = t === expectedType.toLowerCase();
      if (!valid && t === "object") {
        valid = value2 instanceof type2;
      }
    } else if (expectedType === "Object") {
      valid = isObject(value2);
    } else if (expectedType === "Array") {
      valid = isArray(value2);
    } else if (expectedType === "null") {
      valid = value2 === null;
    } else {
      valid = value2 instanceof type2;
    }
    return {
      valid,
      expectedType
    };
  }
  function getInvalidTypeMessage(name, value2, expectedTypes) {
    let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
    const expectedType = expectedTypes[0];
    const receivedType = toRawType(value2);
    const expectedValue = styleValue(value2, expectedType);
    const receivedValue = styleValue(value2, receivedType);
    if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
      message += ` with value ${expectedValue}`;
    }
    message += `, got ${receivedType} `;
    if (isExplicable(receivedType)) {
      message += `with value ${receivedValue}.`;
    }
    return message;
  }
  function styleValue(value2, type2) {
    if (type2 === "String") {
      return `"${value2}"`;
    } else if (type2 === "Number") {
      return `${Number(value2)}`;
    } else {
      return `${value2}`;
    }
  }
  function isExplicable(type2) {
    const explicitTypes = ["string", "number", "boolean"];
    return explicitTypes.some((elem) => type2.toLowerCase() === elem);
  }
  function isBoolean(...args) {
    return args.some((elem) => elem.toLowerCase() === "boolean");
  }
  function validateDirectiveName(name) {
    if (isBuiltInDirective(name)) {
      warn2("Do not use built-in directive ids as custom directive id: " + name);
    }
  }
  function withDirectives(vnode, directives2) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
      warn2(`withDirectives can only be used inside render functions.`);
      return vnode;
    }
    const instance = internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives2.length; i++) {
      let [dir, value2, arg, modifiers = EMPTY_OBJ] = directives2[i];
      if (isFunction(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value2);
      }
      bindings.push({
        dir,
        instance,
        value: value2,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }
  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap(),
      propsCache: new WeakMap(),
      emitsCache: new WeakMap()
    };
  }
  function createAppAPI(render3, hydrate2) {
    return function createApp4(rootComponent, rootProps = null) {
      if (rootProps != null && !isObject(rootProps)) {
        warn2(`root props passed to app.mount() must be an object.`);
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = new Set();
      let isMounted = false;
      const app2 = context.app = {
        _uid: uid++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version,
        get config() {
          return context.config;
        },
        set config(v) {
          if (true) {
            warn2(`app.config cannot be replaced. Modify individual options instead.`);
          }
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) {
            warn2(`Plugin has already been applied to target app.`);
          } else if (plugin && isFunction(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app2, ...options);
          } else if (isFunction(plugin)) {
            installedPlugins.add(plugin);
            plugin(app2, ...options);
          } else if (true) {
            warn2(`A plugin must either be a function or an object with an "install" function.`);
          }
          return app2;
        },
        mixin(mixin) {
          if (true) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            } else if (true) {
              warn2("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
            }
          } else if (true) {
            warn2("Mixins are only available in builds supporting Options API");
          }
          return app2;
        },
        component(name, component) {
          if (true) {
            validateComponentName(name, context.config);
          }
          if (!component) {
            return context.components[name];
          }
          if (context.components[name]) {
            warn2(`Component "${name}" has already been registered in target app.`);
          }
          context.components[name] = component;
          return app2;
        },
        directive(name, directive) {
          if (true) {
            validateDirectiveName(name);
          }
          if (!directive) {
            return context.directives[name];
          }
          if (context.directives[name]) {
            warn2(`Directive "${name}" has already been registered in target app.`);
          }
          context.directives[name] = directive;
          return app2;
        },
        mount(rootContainer, isHydrate, isSVG) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (true) {
              context.reload = () => {
                render3(cloneVNode(vnode), rootContainer, isSVG);
              };
            }
            if (isHydrate && hydrate2) {
              hydrate2(vnode, rootContainer);
            } else {
              render3(vnode, rootContainer, isSVG);
            }
            isMounted = true;
            app2._container = rootContainer;
            rootContainer.__vue_app__ = app2;
            if (true) {
              app2._instance = vnode.component;
              devtoolsInitApp(app2, version);
            }
            return vnode.component.proxy;
          } else if (true) {
            warn2(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
          }
        },
        unmount() {
          if (isMounted) {
            render3(null, app2._container);
            if (true) {
              app2._instance = null;
              devtoolsUnmountApp(app2);
            }
            delete app2._container.__vue_app__;
          } else if (true) {
            warn2(`Cannot unmount an app that is not mounted.`);
          }
        },
        provide(key2, value2) {
          if (key2 in context.provides) {
            warn2(`App already provides property with key "${String(key2)}". It will be overwritten with the new value.`);
          }
          context.provides[key2] = value2;
          return app2;
        }
      };
      return app2;
    };
  }
  function createHydrationFunctions(rendererInternals) {
    const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, nextSibling, parentNode, remove: remove3, insert, createComment } } = rendererInternals;
    const hydrate2 = (vnode, container) => {
      if (!container.hasChildNodes()) {
        warn2(`Attempting to hydrate existing markup but container is empty. Performing full mount instead.`);
        patch(null, vnode, container);
        flushPostFlushCbs();
        return;
      }
      hasMismatch = false;
      hydrateNode(container.firstChild, vnode, null, null, null);
      flushPostFlushCbs();
      if (hasMismatch && true) {
        console.error(`Hydration completed but contains mismatches.`);
      }
    };
    const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
      const isFragmentStart = isComment(node) && node.data === "[";
      const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
      const { type: type2, ref: ref3, shapeFlag } = vnode;
      const domType = node.nodeType;
      vnode.el = node;
      let nextNode = null;
      switch (type2) {
        case Text:
          if (domType !== 3) {
            nextNode = onMismatch();
          } else {
            if (node.data !== vnode.children) {
              hasMismatch = true;
              warn2(`Hydration text mismatch:
- Client: ${JSON.stringify(node.data)}
- Server: ${JSON.stringify(vnode.children)}`);
              node.data = vnode.children;
            }
            nextNode = nextSibling(node);
          }
          break;
        case Comment:
          if (domType !== 8 || isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = nextSibling(node);
          }
          break;
        case Static:
          if (domType !== 1) {
            nextNode = onMismatch();
          } else {
            nextNode = node;
            const needToAdoptContent = !vnode.children.length;
            for (let i = 0; i < vnode.staticCount; i++) {
              if (needToAdoptContent)
                vnode.children += nextNode.outerHTML;
              if (i === vnode.staticCount - 1) {
                vnode.anchor = nextNode;
              }
              nextNode = nextSibling(nextNode);
            }
            return nextNode;
          }
          break;
        case Fragment:
          if (!isFragmentStart) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
          break;
        default:
          if (shapeFlag & 1) {
            if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
              nextNode = onMismatch();
            } else {
              nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
            }
          } else if (shapeFlag & 6) {
            vnode.slotScopeIds = slotScopeIds;
            const container = parentNode(node);
            mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
            nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
            if (isAsyncWrapper(vnode)) {
              let subTree;
              if (isFragmentStart) {
                subTree = createVNode(Fragment);
                subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
              } else {
                subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
              }
              subTree.el = node;
              vnode.component.subTree = subTree;
            }
          } else if (shapeFlag & 64) {
            if (domType !== 8) {
              nextNode = onMismatch();
            } else {
              nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
            }
          } else if (shapeFlag & 128) {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
          } else if (true) {
            warn2("Invalid HostVNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode);
      }
      return nextNode;
    };
    const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!vnode.dynamicChildren;
      const { type: type2, props: props2, patchFlag, shapeFlag, dirs } = vnode;
      const forcePatchValue = type2 === "input" && dirs || type2 === "option";
      if (forcePatchValue || patchFlag !== -1) {
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props2) {
          if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
            for (const key2 in props2) {
              if (forcePatchValue && key2.endsWith("value") || isOn(key2) && !isReservedProp(key2)) {
                patchProp2(el, key2, null, props2[key2]);
              }
            }
          } else if (props2.onClick) {
            patchProp2(el, "onClick", null, props2.onClick);
          }
        }
        let vnodeHooks;
        if (vnodeHooks = props2 && props2.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHooks, parentComponent, vnode);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
        }
        if ((vnodeHooks = props2 && props2.onVnodeMounted) || dirs) {
          queueEffectWithSuspense(() => {
            vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
            dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
          }, parentSuspense);
        }
        if (shapeFlag & 16 && !(props2 && (props2.innerHTML || props2.textContent))) {
          let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
          let hasWarned2 = false;
          while (next) {
            hasMismatch = true;
            if (!hasWarned2) {
              warn2(`Hydration children mismatch in <${vnode.type}>: server rendered element contains more child nodes than client vdom.`);
              hasWarned2 = true;
            }
            const cur = next;
            next = next.nextSibling;
            remove3(cur);
          }
        } else if (shapeFlag & 8) {
          if (el.textContent !== vnode.children) {
            hasMismatch = true;
            warn2(`Hydration text content mismatch in <${vnode.type}>:
- Client: ${el.textContent}
- Server: ${vnode.children}`);
            el.textContent = vnode.children;
          }
        }
      }
      return el.nextSibling;
    };
    const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      optimized = optimized || !!parentVNode.dynamicChildren;
      const children = parentVNode.children;
      const l = children.length;
      let hasWarned2 = false;
      for (let i = 0; i < l; i++) {
        const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
        if (node) {
          node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        } else if (vnode.type === Text && !vnode.children) {
          continue;
        } else {
          hasMismatch = true;
          if (!hasWarned2) {
            warn2(`Hydration children mismatch in <${container.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`);
            hasWarned2 = true;
          }
          patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
        }
      }
      return node;
    };
    const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
      const { slotScopeIds: fragmentSlotScopeIds } = vnode;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      const container = parentNode(node);
      const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
      if (next && isComment(next) && next.data === "]") {
        return nextSibling(vnode.anchor = next);
      } else {
        hasMismatch = true;
        insert(vnode.anchor = createComment(`]`), container, next);
        return next;
      }
    };
    const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
      hasMismatch = true;
      warn2(`Hydration node mismatch:
- Client vnode:`, vnode.type, `
- Server rendered DOM:`, node, node.nodeType === 3 ? `(text)` : isComment(node) && node.data === "[" ? `(start of fragment)` : ``);
      vnode.el = null;
      if (isFragment) {
        const end = locateClosingAsyncAnchor(node);
        while (true) {
          const next2 = nextSibling(node);
          if (next2 && next2 !== end) {
            remove3(next2);
          } else {
            break;
          }
        }
      }
      const next = nextSibling(node);
      const container = parentNode(node);
      remove3(node);
      patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      return next;
    };
    const locateClosingAsyncAnchor = (node) => {
      let match = 0;
      while (node) {
        node = nextSibling(node);
        if (node && isComment(node)) {
          if (node.data === "[")
            match++;
          if (node.data === "]") {
            if (match === 0) {
              return nextSibling(node);
            } else {
              match--;
            }
          }
        }
      }
      return node;
    };
    return [hydrate2, hydrateNode];
  }
  function startMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      perf.mark(`vue-${type2}-${instance.uid}`);
    }
    if (true) {
      devtoolsPerfStart(instance, type2, supported ? perf.now() : Date.now());
    }
  }
  function endMeasure(instance, type2) {
    if (instance.appContext.config.performance && isSupported()) {
      const startTag = `vue-${type2}-${instance.uid}`;
      const endTag = startTag + `:end`;
      perf.mark(endTag);
      perf.measure(`<${formatComponentName(instance, instance.type)}> ${type2}`, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
    }
    if (true) {
      devtoolsPerfEnd(instance, type2, supported ? perf.now() : Date.now());
    }
  }
  function isSupported() {
    if (supported !== void 0) {
      return supported;
    }
    if (typeof window !== "undefined" && window.performance) {
      supported = true;
      perf = window.performance;
    } else {
      supported = false;
    }
    return supported;
  }
  function initFeatureFlags() {
    let needWarn = false;
    if (false) {
      needWarn = true;
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (false) {
      needWarn = true;
      getGlobalThis().__VUE_PROD_DEVTOOLS__ = false;
    }
    if (needWarn) {
      console.warn(`You are running the esm-bundler build of Vue. It is recommended to configure your bundler to explicitly replace feature flag globals with boolean literals to get proper tree-shaking in the final bundle. See http://link.vuejs.org/feature-flags for more details.`);
    }
  }
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function createHydrationRenderer(options) {
    return baseCreateRenderer(options, createHydrationFunctions);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    if (true) {
      const target2 = getGlobalThis();
      target2.__VUE__ = true;
      setDevtoolsHook(target2.__VUE_DEVTOOLS_GLOBAL_HOOK__);
    }
    const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = isHmrUpdating ? false : !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type: type2, ref: ref3, shapeFlag } = n2;
      switch (type2) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, isSVG);
          } else if (true) {
            patchStaticNode(n1, n2, container, isSVG);
          }
          break;
        case Fragment:
          processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          break;
        default:
          if (shapeFlag & 1) {
            processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 6) {
            processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (shapeFlag & 64) {
            type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (shapeFlag & 128) {
            type2.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
          } else if (true) {
            warn2("Invalid VNode type:", type2, `(${typeof type2})`);
          }
      }
      if (ref3 != null && parentComponent) {
        setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, isSVG) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    };
    const patchStaticNode = (n1, n2, container, isSVG) => {
      if (n2.children !== n1.children) {
        const anchor = hostNextSibling(n1.anchor);
        removeStaticNode(n1);
        [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
      } else {
        n2.el = n1.el;
        n2.anchor = n1.anchor;
      }
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      isSVG = isSVG || n2.type === "svg";
      if (n1 == null) {
        mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { type: type2, props: props2, shapeFlag, transition, patchFlag, dirs } = vnode;
      if (false) {
        el = vnode.el = hostCloneNode(vnode.el);
      } else {
        el = vnode.el = hostCreateElement(vnode.type, isSVG, props2 && props2.is, props2);
        if (shapeFlag & 8) {
          hostSetElementText(el, vnode.children);
        } else if (shapeFlag & 16) {
          mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type2 !== "foreignObject", slotScopeIds, optimized);
        }
        if (dirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "created");
        }
        if (props2) {
          for (const key2 in props2) {
            if (key2 !== "value" && !isReservedProp(key2)) {
              hostPatchProp(el, key2, null, props2[key2], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
          if ("value" in props2) {
            hostPatchProp(el, "value", null, props2.value);
          }
          if (vnodeHook = props2.onVnodeBeforeMount) {
            invokeVNodeHook(vnodeHook, parentComponent, vnode);
          }
        }
        setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      }
      if (true) {
        Object.defineProperty(el, "__vnode", {
          value: vnode,
          enumerable: false
        });
        Object.defineProperty(el, "__vueParentComponent", {
          value: parentComponent,
          enumerable: false
        });
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props2 && props2.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
          subTree = filterSingleRoot(subTree.children) || subTree;
        }
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      const areChildrenSVG = isSVG && n2.type !== "foreignObject";
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
        if (parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        }
      } else if (!optimized) {
        patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, isSVG);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key2 = propsToUpdate[i];
              const prev = oldProps[key2];
              const next = newProps[key2];
              if (next !== prev || key2 === "value") {
                hostPatchProp(el, key2, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
        patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
      if (oldProps !== newProps) {
        for (const key2 in newProps) {
          if (isReservedProp(key2))
            continue;
          const next = newProps[key2];
          const prev = oldProps[key2];
          if (next !== prev && key2 !== "value") {
            hostPatchProp(el, key2, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if (oldProps !== EMPTY_OBJ) {
          for (const key2 in oldProps) {
            if (!isReservedProp(key2) && !(key2 in newProps)) {
              hostPatchProp(el, key2, oldProps[key2], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (isHmrUpdating) {
        patchFlag = 0;
        optimized = false;
        dynamicChildren = null;
      }
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
          patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
          if (parentComponent && parentComponent.type.__hmrId) {
            traverseStaticChildren(n1, n2);
          } else if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
            traverseStaticChildren(n1, n2, true);
          }
        } else {
          patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
        } else {
          mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
      const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
      if (instance.type.__hmrId) {
        registerHMR(instance);
      }
      if (true) {
        pushWarningContext(initialVNode);
        startMeasure(instance, `mount`);
      }
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        if (true) {
          startMeasure(instance, `init`);
        }
        setupComponent(instance);
        if (true) {
          endMeasure(instance, `init`);
        }
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
        return;
      }
      setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
      if (true) {
        popWarningContext();
        endMeasure(instance, `mount`);
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          if (true) {
            pushWarningContext(n2);
          }
          updateComponentPreRender(instance, n2, optimized);
          if (true) {
            popWarningContext();
          }
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.update();
        }
      } else {
        n2.component = n1.component;
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props: props2 } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          effect2.allowRecurse = false;
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          effect2.allowRecurse = true;
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              if (true) {
                startMeasure(instance, `render`);
              }
              instance.subTree = renderComponentRoot(instance);
              if (true) {
                endMeasure(instance, `render`);
              }
              if (true) {
                startMeasure(instance, `hydrate`);
              }
              hydrateNode(el, instance.subTree, instance, parentSuspense, null);
              if (true) {
                endMeasure(instance, `hydrate`);
              }
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
            } else {
              hydrateSubTree();
            }
          } else {
            if (true) {
              startMeasure(instance, `render`);
            }
            const subTree = instance.subTree = renderComponentRoot(instance);
            if (true) {
              endMeasure(instance, `render`);
            }
            if (true) {
              startMeasure(instance, `patch`);
            }
            patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
            if (true) {
              endMeasure(instance, `patch`);
            }
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props2 && props2.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
          }
          if (initialVNode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          if (true) {
            devtoolsComponentAdded(instance);
          }
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          let originNext = next;
          let vnodeHook;
          if (true) {
            pushWarningContext(next || instance.vnode);
          }
          effect2.allowRecurse = false;
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          effect2.allowRecurse = true;
          if (true) {
            startMeasure(instance, `render`);
          }
          const nextTree = renderComponentRoot(instance);
          if (true) {
            endMeasure(instance, `render`);
          }
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          if (true) {
            startMeasure(instance, `patch`);
          }
          patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
          if (true) {
            endMeasure(instance, `patch`);
          }
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
          }
          if (true) {
            devtoolsComponentUpdated(instance);
          }
          if (true) {
            popWarningContext();
          }
        }
      };
      const effect2 = new ReactiveEffect(componentUpdateFn, () => queueJob(instance.update), instance.scope);
      const update2 = instance.update = effect2.run.bind(effect2);
      update2.id = instance.uid;
      effect2.allowRecurse = update2.allowRecurse = true;
      if (true) {
        effect2.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
        effect2.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
        update2.ownerInstance = instance;
      }
      update2();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(void 0, instance.update);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
      const c12 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c22 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c12, parentComponent, parentSuspense);
        }
        if (c22 !== c12) {
          hostSetElementText(container, c22);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else {
            unmountChildren(c12, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          }
        }
      }
    };
    const patchUnkeyedChildren = (c12, c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      c12 = c12 || EMPTY_ARR;
      c22 = c22 || EMPTY_ARR;
      const oldLength = c12.length;
      const newLength = c22.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
        patch(c12[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
      if (oldLength > newLength) {
        unmountChildren(c12, parentComponent, parentSuspense, true, false, commonLength);
      } else {
        mountChildren(c22, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
      }
    };
    const patchKeyedChildren = (c12, c22, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c22.length;
      let e1 = c12.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c12[i];
        const n2 = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c12[e1];
        const n2 = c22[e2] = optimized ? cloneIfMounted(c22[e2]) : normalizeVNode(c22[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c22[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(null, c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c12[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c22[i] = optimized ? cloneIfMounted(c22[i]) : normalizeVNode(c22[i]);
          if (nextChild.key != null) {
            if (keyToNewIndexMap.has(nextChild.key)) {
              warn2(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
            }
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c12[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c22[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(prevChild, c22[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c22[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c22[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type: type2, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type2.move(vnode, container, anchor, internals);
        return;
      }
      if (type2 === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type2 === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove4 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove4();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove4, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const { type: type2, props: props2, ref: ref3, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
      if (ref3 != null) {
        setRef(ref3, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
        } else if (dynamicChildren && (type2 !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
        } else if (type2 === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove3(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props2 && props2.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove3 = (vnode) => {
      const { type: type2, el, anchor, transition } = vnode;
      if (type2 === Fragment) {
        removeFragment(el, anchor);
        return;
      }
      if (type2 === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      if (instance.type.__hmrId) {
        unregisterHMR(instance);
      }
      const { bum, scope, update: update2, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update2) {
        update2.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
      if (true) {
        devtoolsComponentRemoved(instance);
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render3 = (vnode, container, isSVG) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(container._vnode || null, vnode, container, null, null, null, isSVG);
      }
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove3,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate2;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate2, hydrateNode] = createHydrationFns(internals);
    }
    return {
      render: render3,
      hydrate: hydrate2,
      createApp: createAppAPI(render3, hydrate2)
    };
  }
  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray(rawRef)) {
      rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value2 = isUnmount ? null : refValue;
    const { i: owner, r: ref3 } = rawRef;
    if (!owner) {
      warn2(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
      return;
    }
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref3) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isString(ref3)) {
      const doSet = () => {
        {
          refs[ref3] = value2;
        }
        if (hasOwn(setupState, ref3)) {
          setupState[ref3] = value2;
        }
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isRef(ref3)) {
      const doSet = () => {
        ref3.value = value2;
      };
      if (value2) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (isFunction(ref3)) {
      callWithErrorHandling(ref3, owner, 12, [value2, refs]);
    } else if (true) {
      warn2("Invalid template ref type:", value2, `(${typeof value2})`);
    }
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray(ch1) && isArray(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c12 = ch1[i];
        let c22 = ch2[i];
        if (c22.shapeFlag & 1 && !c22.dynamicChildren) {
          if (c22.patchFlag <= 0 || c22.patchFlag === 32) {
            c22 = ch2[i] = cloneIfMounted(ch2[i]);
            c22.el = c12.el;
          }
          if (!shallow)
            traverseStaticChildren(c12, c22);
        }
        if (c22.type === Comment && !c22.el) {
          c22.el = c12.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p2 = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p2[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p2[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p2[v];
    }
    return result;
  }
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props: props2 } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props2)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, parentAnchor, 2);
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
    const target2 = vnode.target = resolveTarget(vnode.props, querySelector);
    if (target2) {
      const targetNode = target2._lpa || target2.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          vnode.targetAnchor = hydrateChildren(targetNode, vnode, target2, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        target2._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
      }
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  function resolveDynamicComponent(component) {
    if (isString(component)) {
      return resolveAsset(COMPONENTS, component, false) || component;
    } else {
      return component || NULL_DYNAMIC_COMPONENT;
    }
  }
  function resolveDirective(name) {
    return resolveAsset(DIRECTIVES, name);
  }
  function resolveAsset(type2, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component2 = instance.type;
      if (type2 === COMPONENTS) {
        const selfName = getComponentName(Component2);
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
          return Component2;
        }
      }
      const res = resolve(instance[type2] || Component2[type2], name) || resolve(instance.appContext[type2], name);
      if (!res && maybeSelfReference) {
        return Component2;
      }
      if (warnMissing && !res) {
        warn2(`Failed to resolve ${type2.slice(0, -1)}: ${name}`);
      }
      return res;
    } else if (true) {
      warn2(`resolve${capitalize(type2.slice(0, -1))} can only be used in render() or setup().`);
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
  }
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  function setBlockTracking(value2) {
    isBlockTreeEnabled += value2;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createElementBlock(type2, props2, children, patchFlag, dynamicProps, shapeFlag) {
    return setupBlock(createBaseVNode(type2, props2, children, patchFlag, dynamicProps, shapeFlag, true));
  }
  function createBlock(type2, props2, children, patchFlag, dynamicProps) {
    return setupBlock(createVNode(type2, props2, children, patchFlag, dynamicProps, true));
  }
  function isVNode(value2) {
    return value2 ? value2.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    if (n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
      return false;
    }
    return n1.type === n2.type && n1.key === n2.key;
  }
  function transformVNodeArgs(transformer) {
    vnodeArgsTransformer = transformer;
  }
  function createBaseVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type2 === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type: type2,
      props: props2,
      key: props2 && normalizeKey(props2),
      ref: props2 && normalizeRef(props2),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type2.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (vnode.key !== vnode.key) {
      warn2(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function _createVNode(type2, props2 = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type2 || type2 === NULL_DYNAMIC_COMPONENT) {
      if (!type2) {
        warn2(`Invalid vnode type when creating vnode: ${type2}.`);
      }
      type2 = Comment;
    }
    if (isVNode(type2)) {
      const cloned = cloneVNode(type2, props2, true);
      if (children) {
        normalizeChildren(cloned, children);
      }
      return cloned;
    }
    if (isClassComponent(type2)) {
      type2 = type2.__vccOpts;
    }
    if (props2) {
      props2 = guardReactiveProps(props2);
      let { class: klass, style: style2 } = props2;
      if (klass && !isString(klass)) {
        props2.class = normalizeClass(klass);
      }
      if (isObject(style2)) {
        if (isProxy(style2) && !isArray(style2)) {
          style2 = extend({}, style2);
        }
        props2.style = normalizeStyle(style2);
      }
    }
    const shapeFlag = isString(type2) ? 1 : isSuspense(type2) ? 128 : isTeleport(type2) ? 64 : isObject(type2) ? 4 : isFunction(type2) ? 2 : 0;
    if (shapeFlag & 4 && isProxy(type2)) {
      type2 = toRaw(type2);
      warn2(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type2);
    }
    return createBaseVNode(type2, props2, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
  }
  function guardReactiveProps(props2) {
    if (!props2)
      return null;
    return isProxy(props2) || InternalObjectKey in props2 ? extend({}, props2) : props2;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props: props2, ref: ref3, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props2 || {}, extraProps) : props2;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? mergeRef && ref3 ? isArray(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref3,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor
    };
    return cloned;
  }
  function deepCloneVNode(vnode) {
    const cloned = cloneVNode(vnode);
    if (isArray(vnode.children)) {
      cloned.children = vnode.children.map(deepCloneVNode);
    }
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createStaticVNode(content, numberOfNodes) {
    const vnode = createVNode(Static, null, content);
    vnode.staticCount = numberOfNodes;
    return vnode;
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray(child)) {
      return createVNode(Fragment, null, child.slice());
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type2 = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray(children)) {
      type2 = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type2 = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type2 = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type2 = 16;
        children = [createTextVNode(children)];
      } else {
        type2 = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type2;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key2 in toMerge) {
        if (key2 === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key2 === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key2)) {
          const existing = ret[key2];
          const incoming = toMerge[key2];
          if (existing !== incoming) {
            ret[key2] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key2 !== "") {
          ret[key2] = toMerge[key2];
        }
      }
    }
    return ret;
  }
  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if (isArray(source) || isString(source)) {
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source === "number") {
      if (!Number.isInteger(source)) {
        warn2(`The v-for range expect an integer value but got ${source}.`);
        return [];
      }
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(source, (item2, i) => renderItem(item2, i, void 0, cached && cached[i]));
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key2 = keys[i];
          ret[i] = renderItem(source[key2], key2, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }
  function createSlots(slots, dynamicSlots) {
    for (let i = 0; i < dynamicSlots.length; i++) {
      const slot = dynamicSlots[i];
      if (isArray(slot)) {
        for (let j = 0; j < slot.length; j++) {
          slots[slot[j].name] = slot[j].fn;
        }
      } else if (slot) {
        slots[slot.name] = slot.fn;
      }
    }
    return slots;
  }
  function renderSlot(slots, name, props2 = {}, fallback2, noSlotted) {
    if (currentRenderingInstance.isCE) {
      return createVNode("slot", name === "default" ? null : { name }, fallback2 && fallback2());
    }
    let slot = slots[name];
    if (slot && slot.length > 1) {
      warn2(`SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.`);
      slot = () => [];
    }
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode(slot(props2));
    const rendered = createBlock(Fragment, { key: props2.key || `_${name}` }, validSlotContent || (fallback2 ? fallback2() : []), validSlotContent && slots._ === 1 ? 64 : -2);
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }
  function toHandlers(obj) {
    const ret = {};
    if (!isObject(obj)) {
      warn2(`v-on with no argument expects an object value.`);
      return ret;
    }
    for (const key2 in obj) {
      ret[toHandlerKey(key2)] = obj[key2];
    }
    return ret;
  }
  function createDevRenderContext(instance) {
    const target2 = {};
    Object.defineProperty(target2, `_`, {
      configurable: true,
      enumerable: false,
      get: () => instance
    });
    Object.keys(publicPropertiesMap).forEach((key2) => {
      Object.defineProperty(target2, key2, {
        configurable: true,
        enumerable: false,
        get: () => publicPropertiesMap[key2](instance),
        set: NOOP
      });
    });
    return target2;
  }
  function exposePropsOnRenderContext(instance) {
    const { ctx, propsOptions: [propsOptions] } = instance;
    if (propsOptions) {
      Object.keys(propsOptions).forEach((key2) => {
        Object.defineProperty(ctx, key2, {
          enumerable: true,
          configurable: true,
          get: () => instance.props[key2],
          set: NOOP
        });
      });
    }
  }
  function exposeSetupStateOnRenderContext(instance) {
    const { ctx, setupState } = instance;
    Object.keys(toRaw(setupState)).forEach((key2) => {
      if (!setupState.__isScriptSetup && (key2[0] === "$" || key2[0] === "_")) {
        warn2(`setup() return property ${JSON.stringify(key2)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key2, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key2],
        set: NOOP
      });
    });
  }
  function createComponentInstance(vnode, parent, suspense) {
    const type2 = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid$1++,
      vnode,
      type: type2,
      parent,
      appContext,
      root: null,
      next: null,
      subTree: null,
      update: null,
      scope: new EffectScope(true),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      components: null,
      directives: null,
      propsOptions: normalizePropsOptions(type2, appContext),
      emitsOptions: normalizeEmitsOptions(type2, appContext),
      emit: null,
      emitted: null,
      propsDefaults: EMPTY_OBJ,
      inheritAttrs: type2.inheritAttrs,
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    if (true) {
      instance.ctx = createDevRenderContext(instance);
    } else {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  function validateComponentName(name, config) {
    const appIsNativeTag = config.isNativeTag || NO;
    if (isBuiltInTag(name) || appIsNativeTag(name)) {
      warn2("Do not use built-in or reserved HTML elements as component id: " + name);
    }
  }
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  function setupComponent(instance, isSSR = false) {
    isInSSRComponentSetup = isSSR;
    const { props: props2, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props2, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isInSSRComponentSetup = false;
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component2 = instance.type;
    if (true) {
      if (Component2.name) {
        validateComponentName(Component2.name, instance.appContext.config);
      }
      if (Component2.components) {
        const names = Object.keys(Component2.components);
        for (let i = 0; i < names.length; i++) {
          validateComponentName(names[i], instance.appContext.config);
        }
      }
      if (Component2.directives) {
        const names = Object.keys(Component2.directives);
        for (let i = 0; i < names.length; i++) {
          validateDirectiveName(names[i]);
        }
      }
      if (Component2.compilerOptions && isRuntimeOnly()) {
        warn2(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
      }
    }
    instance.accessCache = Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    if (true) {
      exposePropsOnRenderContext(instance);
    }
    const { setup } = Component2;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(setup, instance, 0, [true ? shallowReadonly(instance.props) : instance.props, setupContext]);
      resetTracking();
      unsetCurrentInstance();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction(setupResult)) {
      {
        instance.render = setupResult;
      }
    } else if (isObject(setupResult)) {
      if (isVNode(setupResult)) {
        warn2(`setup() should not return VNodes directly - return a render function instead.`);
      }
      if (true) {
        instance.devtoolsRawSetupState = setupResult;
      }
      instance.setupState = proxyRefs(setupResult);
      if (true) {
        exposeSetupStateOnRenderContext(instance);
      }
    } else if (setupResult !== void 0) {
      warn2(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
    }
    finishComponentSetup(instance, isSSR);
  }
  function registerRuntimeCompiler(_compile) {
    compile = _compile;
    installWithProxy = (i) => {
      if (i.render._rc) {
        i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
      }
    };
  }
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component2 = instance.type;
    if (!instance.render) {
      if (compile && !Component2.render) {
        const template = Component2.template;
        if (template) {
          if (true) {
            startMeasure(instance, `compile`);
          }
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component2;
          const finalCompilerOptions = extend(extend({
            isCustomElement,
            delimiters
          }, compilerOptions), componentCompilerOptions);
          Component2.render = compile(template, finalCompilerOptions);
          if (true) {
            endMeasure(instance, `compile`);
          }
        }
      }
      instance.render = Component2.render || NOOP;
      if (installWithProxy) {
        installWithProxy(instance);
      }
    }
    if (true) {
      setCurrentInstance(instance);
      pauseTracking();
      applyOptions(instance);
      resetTracking();
      unsetCurrentInstance();
    }
    if (!Component2.render && instance.render === NOOP && !isSSR) {
      if (!compile && Component2.template) {
        warn2(`Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`);
      } else {
        warn2(`Component is missing template or render function.`);
      }
    }
  }
  function createAttrsProxy(instance) {
    return new Proxy(instance.attrs, true ? {
      get(target2, key2) {
        markAttrsAccessed();
        track(instance, "get", "$attrs");
        return target2[key2];
      },
      set() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      },
      deleteProperty() {
        warn2(`setupContext.attrs is readonly.`);
        return false;
      }
    } : {
      get(target2, key2) {
        track(instance, "get", "$attrs");
        return target2[key2];
      }
    });
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      if (instance.exposed) {
        warn2(`expose() should be called only once per setup().`);
      }
      instance.exposed = exposed || {};
    };
    let attrs;
    if (true) {
      return Object.freeze({
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        get slots() {
          return shallowReadonly(instance.slots);
        },
        get emit() {
          return (event3, ...args) => instance.emit(event3, ...args);
        },
        expose
      });
    } else {
      return {
        get attrs() {
          return attrs || (attrs = createAttrsProxy(instance));
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target2, key2) {
          if (key2 in target2) {
            return target2[key2];
          } else if (key2 in publicPropertiesMap) {
            return publicPropertiesMap[key2](instance);
          }
        }
      }));
    }
  }
  function getComponentName(Component2) {
    return isFunction(Component2) ? Component2.displayName || Component2.name : Component2.name;
  }
  function formatComponentName(instance, Component2, isRoot = false) {
    let name = getComponentName(Component2);
    if (!name && Component2.__file) {
      const match = Component2.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key2 in registry) {
          if (registry[key2] === Component2) {
            return key2;
          }
        }
      };
      name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value2) {
    return isFunction(value2) && "__vccOpts" in value2;
  }
  function pushWarningContext(vnode) {
    stack.push(vnode);
  }
  function popWarningContext() {
    stack.pop();
  }
  function warn2(msg, ...args) {
    pauseTracking();
    const instance = stack.length ? stack[stack.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(appWarnHandler, instance, 11, [
        msg + args.join(""),
        instance && instance.proxy,
        trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
        trace
      ]);
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack[stack.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last2 = normalizedStack[0];
      if (last2 && last2.vnode === currentVNode) {
        last2.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props2) {
    const res = [];
    const keys = Object.keys(props2);
    keys.slice(0, 3).forEach((key2) => {
      res.push(...formatProp(key2, props2[key2]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key2, value2, raw) {
    if (isString(value2)) {
      value2 = JSON.stringify(value2);
      return raw ? value2 : [`${key2}=${value2}`];
    } else if (typeof value2 === "number" || typeof value2 === "boolean" || value2 == null) {
      return raw ? value2 : [`${key2}=${value2}`];
    } else if (isRef(value2)) {
      value2 = formatProp(key2, toRaw(value2.value), true);
      return raw ? value2 : [`${key2}=Ref<`, value2, `>`];
    } else if (isFunction(value2)) {
      return [`${key2}=fn${value2.name ? `<${value2.name}>` : ``}`];
    } else {
      value2 = toRaw(value2);
      return raw ? value2 : [`${key2}=`, value2];
    }
  }
  function callWithErrorHandling(fn, instance, type2, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type2);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type2, args) {
    if (isFunction(fn)) {
      const res = callWithErrorHandling(fn, instance, type2, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type2);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type2, args));
    }
    return values;
  }
  function handleError(err, instance, type2, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = true ? ErrorTypeStrings[type2] : type2;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
        return;
      }
    }
    logError(err, type2, contextVNode, throwInDev);
  }
  function logError(err, type2, contextVNode, throwInDev = true) {
    if (true) {
      const info = ErrorTypeStrings[type2];
      if (contextVNode) {
        pushWarningContext(contextVNode);
      }
      warn2(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
      if (contextVNode) {
        popWarningContext();
      }
      if (throwInDev) {
        throw err;
      } else {
        console.error(err);
      }
    } else {
      console.error(err);
    }
  }
  function nextTick2(fn) {
    const p2 = currentFlushPromise || resolvedPromise;
    return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
  }
  function findInsertionIndex(id2) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJobId = getId(queue[middle]);
      middleJobId < id2 ? start = middle + 1 : end = middle;
    }
    return start;
  }
  function queueJob(job) {
    if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queueCb(cb, activeQueue, pendingQueue, index) {
    if (!isArray(cb)) {
      if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index + 1 : index)) {
        pendingQueue.push(cb);
      }
    } else {
      pendingQueue.push(...cb);
    }
    queueFlush();
  }
  function queuePreFlushCb(cb) {
    queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
  }
  function queuePostFlushCb(cb) {
    queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
  }
  function flushPreFlushCbs(seen2, parentJob = null) {
    if (pendingPreFlushCbs.length) {
      currentPreFlushParentJob = parentJob;
      activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
      pendingPreFlushCbs.length = 0;
      if (true) {
        seen2 = seen2 || new Map();
      }
      for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
        if (checkRecursiveUpdates(seen2, activePreFlushCbs[preFlushIndex])) {
          continue;
        }
        activePreFlushCbs[preFlushIndex]();
      }
      activePreFlushCbs = null;
      preFlushIndex = 0;
      currentPreFlushParentJob = null;
      flushPreFlushCbs(seen2, parentJob);
    }
  }
  function flushPostFlushCbs(seen2) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      if (true) {
        seen2 = seen2 || new Map();
      }
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        if (checkRecursiveUpdates(seen2, activePostFlushCbs[postFlushIndex])) {
          continue;
        }
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  function flushJobs(seen2) {
    isFlushPending = false;
    isFlushing = true;
    if (true) {
      seen2 = seen2 || new Map();
    }
    flushPreFlushCbs(seen2);
    queue.sort((a, b) => getId(a) - getId(b));
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (checkRecursiveUpdates(seen2, job)) {
            continue;
          }
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs(seen2);
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
        flushJobs(seen2);
      }
    }
  }
  function checkRecursiveUpdates(seen2, fn) {
    if (!seen2.has(fn)) {
      seen2.set(fn, 1);
    } else {
      const count = seen2.get(fn);
      if (count > RECURSION_LIMIT) {
        const instance = fn.ownerInstance;
        const componentName = instance && getComponentName(instance.type);
        warn2(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
        return true;
      } else {
        seen2.set(fn, count + 1);
      }
    }
  }
  function watchEffect(effect2, options) {
    return doWatch(effect2, null, options);
  }
  function watchPostEffect(effect2, options) {
    return doWatch(effect2, null, true ? Object.assign(options || {}, { flush: "post" }) : { flush: "post" });
  }
  function watchSyncEffect(effect2, options) {
    return doWatch(effect2, null, true ? Object.assign(options || {}, { flush: "sync" }) : { flush: "sync" });
  }
  function watch(source, cb, options) {
    if (!isFunction(cb)) {
      warn2(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
    }
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
    if (!cb) {
      if (immediate !== void 0) {
        warn2(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
      }
      if (deep !== void 0) {
        warn2(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
      }
    }
    const warnInvalidSource = (s2) => {
      warn2(`Invalid watch source: `, s2, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
    };
    const instance = currentInstance;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = !!source._shallow;
    } else if (isReactive(source)) {
      getter = () => source;
      deep = true;
    } else if (isArray(source)) {
      isMultiSource = true;
      forceTrigger = source.some(isReactive);
      getter = () => source.map((s2) => {
        if (isRef(s2)) {
          return s2.value;
        } else if (isReactive(s2)) {
          return traverse(s2);
        } else if (isFunction(s2)) {
          return callWithErrorHandling(s2, instance, 2);
        } else {
          warnInvalidSource(s2);
        }
      });
    } else if (isFunction(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(source, instance, 3, [onInvalidate]);
        };
      }
    } else {
      getter = NOOP;
      warnInvalidSource(source);
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse(baseGetter());
    }
    let cleanup;
    let onInvalidate = (fn) => {
      cleanup = effect2.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
      };
    };
    let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect2.active) {
        return;
      }
      if (cb) {
        const newValue = effect2.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
            onInvalidate
          ]);
          oldValue = newValue;
        }
      } else {
        effect2.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      scheduler = () => {
        if (!instance || instance.isMounted) {
          queuePreFlushCb(job);
        } else {
          job();
        }
      };
    }
    const effect2 = new ReactiveEffect(getter, scheduler);
    if (true) {
      effect2.onTrack = onTrack;
      effect2.onTrigger = onTrigger;
    }
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect2.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
    } else {
      effect2.run();
    }
    return () => {
      effect2.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect2);
      }
    };
  }
  function instanceWatch(source, value2, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction(value2)) {
      cb = value2;
    } else {
      cb = value2.handler;
      options = value2;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse(value2, seen2 = new Set()) {
    if (!isObject(value2) || value2["__v_skip"]) {
      return value2;
    }
    seen2 = seen2 || new Set();
    if (seen2.has(value2)) {
      return value2;
    }
    seen2.add(value2);
    if (isRef(value2)) {
      traverse(value2.value, seen2);
    } else if (isArray(value2)) {
      for (let i = 0; i < value2.length; i++) {
        traverse(value2[i], seen2);
      }
    } else if (isSet(value2) || isMap(value2)) {
      value2.forEach((v) => {
        traverse(v, seen2);
      });
    } else if (isPlainObject(value2)) {
      for (const key2 in value2) {
        traverse(value2[key2], seen2);
      }
    }
    return value2;
  }
  function defineProps() {
    if (true) {
      warnRuntimeUsage(`defineProps`);
    }
    return null;
  }
  function defineEmits() {
    if (true) {
      warnRuntimeUsage(`defineEmits`);
    }
    return null;
  }
  function defineExpose(exposed) {
    if (true) {
      warnRuntimeUsage(`defineExpose`);
    }
  }
  function withDefaults(props2, defaults2) {
    if (true) {
      warnRuntimeUsage(`withDefaults`);
    }
    return null;
  }
  function useSlots() {
    return getContext().slots;
  }
  function useAttrs() {
    return getContext().attrs;
  }
  function getContext() {
    const i = getCurrentInstance();
    if (!i) {
      warn2(`useContext() called without active instance.`);
    }
    return i.setupContext || (i.setupContext = createSetupContext(i));
  }
  function mergeDefaults(props2, defaults2) {
    for (const key2 in defaults2) {
      const val = props2[key2];
      if (val) {
        val.default = defaults2[key2];
      } else if (val === null) {
        props2[key2] = { default: defaults2[key2] };
      } else if (true) {
        warn2(`props default key "${key2}" has no corresponding declaration.`);
      }
    }
    return props2;
  }
  function withAsyncContext(getAwaitable) {
    const ctx = getCurrentInstance();
    if (!ctx) {
      warn2(`withAsyncContext called without active current instance. This is likely a bug.`);
    }
    let awaitable = getAwaitable();
    unsetCurrentInstance();
    if (isPromise2(awaitable)) {
      awaitable = awaitable.catch((e) => {
        setCurrentInstance(ctx);
        throw e;
      });
    }
    return [awaitable, () => setCurrentInstance(ctx)];
  }
  function h(type2, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject(propsOrChildren) && !isArray(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type2, null, [propsOrChildren]);
        }
        return createVNode(type2, propsOrChildren);
      } else {
        return createVNode(type2, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type2, propsOrChildren, children);
    }
  }
  function initCustomFormatter() {
    if (typeof window === "undefined") {
      return;
    }
    const vueStyle = { style: "color:#3ba776" };
    const numberStyle = { style: "color:#0b1bc9" };
    const stringStyle = { style: "color:#b62e24" };
    const keywordStyle = { style: "color:#9d288c" };
    const formatter2 = {
      header(obj) {
        if (!isObject(obj)) {
          return null;
        }
        if (obj.__isVue) {
          return ["div", vueStyle, `VueInstance`];
        } else if (isRef(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, genRefFlag(obj)],
            "<",
            formatValue(obj.value),
            `>`
          ];
        } else if (isReactive(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Reactive"],
            "<",
            formatValue(obj),
            `>${isReadonly(obj) ? ` (readonly)` : ``}`
          ];
        } else if (isReadonly(obj)) {
          return [
            "div",
            {},
            ["span", vueStyle, "Readonly"],
            "<",
            formatValue(obj),
            ">"
          ];
        }
        return null;
      },
      hasBody(obj) {
        return obj && obj.__isVue;
      },
      body(obj) {
        if (obj && obj.__isVue) {
          return [
            "div",
            {},
            ...formatInstance(obj.$)
          ];
        }
      }
    };
    function formatInstance(instance) {
      const blocks = [];
      if (instance.type.props && instance.props) {
        blocks.push(createInstanceBlock("props", toRaw(instance.props)));
      }
      if (instance.setupState !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("setup", instance.setupState));
      }
      if (instance.data !== EMPTY_OBJ) {
        blocks.push(createInstanceBlock("data", toRaw(instance.data)));
      }
      const computed4 = extractKeys(instance, "computed");
      if (computed4) {
        blocks.push(createInstanceBlock("computed", computed4));
      }
      const injected = extractKeys(instance, "inject");
      if (injected) {
        blocks.push(createInstanceBlock("injected", injected));
      }
      blocks.push([
        "div",
        {},
        [
          "span",
          {
            style: keywordStyle.style + ";opacity:0.66"
          },
          "$ (internal): "
        ],
        ["object", { object: instance }]
      ]);
      return blocks;
    }
    function createInstanceBlock(type2, target2) {
      target2 = extend({}, target2);
      if (!Object.keys(target2).length) {
        return ["span", {}];
      }
      return [
        "div",
        { style: "line-height:1.25em;margin-bottom:0.6em" },
        [
          "div",
          {
            style: "color:#476582"
          },
          type2
        ],
        [
          "div",
          {
            style: "padding-left:1.25em"
          },
          ...Object.keys(target2).map((key2) => {
            return [
              "div",
              {},
              ["span", keywordStyle, key2 + ": "],
              formatValue(target2[key2], false)
            ];
          })
        ]
      ];
    }
    function formatValue(v, asRaw = true) {
      if (typeof v === "number") {
        return ["span", numberStyle, v];
      } else if (typeof v === "string") {
        return ["span", stringStyle, JSON.stringify(v)];
      } else if (typeof v === "boolean") {
        return ["span", keywordStyle, v];
      } else if (isObject(v)) {
        return ["object", { object: asRaw ? toRaw(v) : v }];
      } else {
        return ["span", stringStyle, String(v)];
      }
    }
    function extractKeys(instance, type2) {
      const Comp = instance.type;
      if (isFunction(Comp)) {
        return;
      }
      const extracted = {};
      for (const key2 in instance.ctx) {
        if (isKeyOfType(Comp, key2, type2)) {
          extracted[key2] = instance.ctx[key2];
        }
      }
      return extracted;
    }
    function isKeyOfType(Comp, key2, type2) {
      const opts = Comp[type2];
      if (isArray(opts) && opts.includes(key2) || isObject(opts) && key2 in opts) {
        return true;
      }
      if (Comp.extends && isKeyOfType(Comp.extends, key2, type2)) {
        return true;
      }
      if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key2, type2))) {
        return true;
      }
    }
    function genRefFlag(v) {
      if (v._shallow) {
        return `ShallowRef`;
      }
      if (v.effect) {
        return `ComputedRef`;
      }
      return `Ref`;
    }
    if (window.devtoolsFormatters) {
      window.devtoolsFormatters.push(formatter2);
    } else {
      window.devtoolsFormatters = [formatter2];
    }
  }
  function withMemo(memo, render3, cache, index) {
    const cached = cache[index];
    if (cached && isMemoSame(cached, memo)) {
      return cached;
    }
    const ret = render3();
    ret.memo = memo.slice();
    return cache[index] = ret;
  }
  function isMemoSame(cached, memo) {
    const prev = cached.memo;
    if (prev.length != memo.length) {
      return false;
    }
    for (let i = 0; i < prev.length; i++) {
      if (prev[i] !== memo[i]) {
        return false;
      }
    }
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(cached);
    }
    return true;
  }
  var import_pako, isHmrUpdating, hmrDirtyComponents, map, devtools, devtoolsComponentAdded, devtoolsComponentUpdated, devtoolsComponentRemoved, devtoolsPerfStart, devtoolsPerfEnd, deprecationData, instanceWarned, warnCount, currentRenderingInstance, currentScopeId, withScopeId, accessedAttrs, getChildRoot, getFunctionalFallthrough, filterModelListeners, isElementRoot, isSuspense, SuspenseImpl, Suspense, hasWarned, TransitionHookValidator, BaseTransitionImpl, BaseTransition, isAsyncWrapper, isKeepAlive, KeepAliveImpl, KeepAlive, createHook, onBeforeMount, onMounted2, onBeforeUpdate, onUpdated, onBeforeUnmount2, onUnmounted, onServerPrefetch, onRenderTriggered, onRenderTracked, shouldCacheAccess, internalOptionMergeStrats, isSimpleType, isInternalKey, normalizeSlotValue, normalizeSlot, normalizeObjectSlots, normalizeVNodeSlots, initSlots, updateSlots, isBuiltInDirective, uid, hasMismatch, isSVGContainer, isComment, supported, perf, queuePostRenderEffect, isTeleport, isTeleportDisabled, isTargetSVG, resolveTarget, TeleportImpl, Teleport, COMPONENTS, DIRECTIVES, NULL_DYNAMIC_COMPONENT, Fragment, Text, Comment, Static, blockStack, currentBlock, isBlockTreeEnabled, vnodeArgsTransformer, createVNodeWithArgsTransform, InternalObjectKey, normalizeKey, normalizeRef, createVNode, getPublicInstance, publicPropertiesMap, PublicInstanceProxyHandlers, RuntimeCompiledPublicInstanceProxyHandlers, emptyAppContext, uid$1, currentInstance, getCurrentInstance, setCurrentInstance, unsetCurrentInstance, isBuiltInTag, isInSSRComponentSetup, compile, installWithProxy, isRuntimeOnly, classifyRE, classify, stack, ErrorTypeStrings, isFlushing, isFlushPending, queue, flushIndex, pendingPreFlushCbs, activePreFlushCbs, preFlushIndex, pendingPostFlushCbs, activePostFlushCbs, postFlushIndex, resolvedPromise, currentFlushPromise, currentPreFlushParentJob, RECURSION_LIMIT, getId, INITIAL_WATCHER_VALUE, isFunction2, isObject2, isPromise2, warnRuntimeUsage, ssrContextKey, useSSRContext, version, _ssrUtils, ssrUtils, resolveFilter, compatUtils;
  var init_runtime_core_esm_bundler = __esm({
    "node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_reactivity_esm_bundler();
      init_reactivity_esm_bundler();
      init_shared_esm_bundler();
      init_shared_esm_bundler();
      isHmrUpdating = false;
      hmrDirtyComponents = new Set();
      if (true) {
        const globalObject = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
        globalObject.__VUE_HMR_RUNTIME__ = {
          createRecord: tryWrap(createRecord),
          rerender: tryWrap(rerender),
          reload: tryWrap(reload)
        };
      }
      map = new Map();
      devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook("component:added");
      devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook("component:updated");
      devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook("component:removed");
      devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:start");
      devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook("perf:end");
      deprecationData = {
        ["GLOBAL_MOUNT"]: {
          message: `The global app bootstrapping API has changed: vm.$mount() and the "el" option have been removed. Use createApp(RootComponent).mount() instead.`,
          link: `https://v3.vuejs.org/guide/migration/global-api.html#mounting-app-instance`
        },
        ["GLOBAL_MOUNT_CONTAINER"]: {
          message: `Vue detected directives on the mount container. In Vue 3, the container is no longer considered part of the template and will not be processed/replaced.`,
          link: `https://v3.vuejs.org/guide/migration/mount-changes.html`
        },
        ["GLOBAL_EXTEND"]: {
          message: `Vue.extend() has been removed in Vue 3. Use defineComponent() instead.`,
          link: `https://v3.vuejs.org/api/global-api.html#definecomponent`
        },
        ["GLOBAL_PROTOTYPE"]: {
          message: `Vue.prototype is no longer available in Vue 3. Use app.config.globalProperties instead.`,
          link: `https://v3.vuejs.org/guide/migration/global-api.html#vue-prototype-replaced-by-config-globalproperties`
        },
        ["GLOBAL_SET"]: {
          message: `Vue.set() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
        },
        ["GLOBAL_DELETE"]: {
          message: `Vue.delete() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
        },
        ["GLOBAL_OBSERVABLE"]: {
          message: `Vue.observable() has been removed. Use \`import { reactive } from "vue"\` from Composition API instead.`,
          link: `https://v3.vuejs.org/api/basic-reactivity.html`
        },
        ["GLOBAL_PRIVATE_UTIL"]: {
          message: `Vue.util has been removed. Please refactor to avoid its usage since it was an internal API even in Vue 2.`
        },
        ["CONFIG_SILENT"]: {
          message: `config.silent has been removed because it is not good practice to intentionally suppress warnings. You can use your browser console's filter features to focus on relevant messages.`
        },
        ["CONFIG_DEVTOOLS"]: {
          message: `config.devtools has been removed. To enable devtools for production, configure the __VUE_PROD_DEVTOOLS__ compile-time flag.`,
          link: `https://github.com/vuejs/vue-next/tree/master/packages/vue#bundler-build-feature-flags`
        },
        ["CONFIG_KEY_CODES"]: {
          message: `config.keyCodes has been removed. In Vue 3, you can directly use the kebab-case key names as v-on modifiers.`,
          link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
        },
        ["CONFIG_PRODUCTION_TIP"]: {
          message: `config.productionTip has been removed.`,
          link: `https://v3.vuejs.org/guide/migration/global-api.html#config-productiontip-removed`
        },
        ["CONFIG_IGNORED_ELEMENTS"]: {
          message: () => {
            let msg = `config.ignoredElements has been removed.`;
            if (isRuntimeOnly()) {
              msg += ` Pass the "isCustomElement" option to @vue/compiler-dom instead.`;
            } else {
              msg += ` Use config.isCustomElement instead.`;
            }
            return msg;
          },
          link: `https://v3.vuejs.org/guide/migration/global-api.html#config-ignoredelements-is-now-config-iscustomelement`
        },
        ["CONFIG_WHITESPACE"]: {
          message: `Vue 3 compiler's whitespace option will default to "condense" instead of "preserve". To suppress this warning, provide an explicit value for \`config.compilerOptions.whitespace\`.`
        },
        ["CONFIG_OPTION_MERGE_STRATS"]: {
          message: `config.optionMergeStrategies no longer exposes internal strategies. Use custom merge functions instead.`
        },
        ["INSTANCE_SET"]: {
          message: `vm.$set() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
        },
        ["INSTANCE_DELETE"]: {
          message: `vm.$delete() has been removed as it is no longer needed in Vue 3. Simply use native JavaScript mutations.`
        },
        ["INSTANCE_DESTROY"]: {
          message: `vm.$destroy() has been removed. Use app.unmount() instead.`,
          link: `https://v3.vuejs.org/api/application-api.html#unmount`
        },
        ["INSTANCE_EVENT_EMITTER"]: {
          message: `vm.$on/$once/$off() have been removed. Use an external event emitter library instead.`,
          link: `https://v3.vuejs.org/guide/migration/events-api.html`
        },
        ["INSTANCE_EVENT_HOOKS"]: {
          message: (event3) => `"${event3}" lifecycle events are no longer supported. From templates, use the "vnode" prefix instead of "hook:". For example, @${event3} should be changed to @vnode-${event3.slice(5)}. From JavaScript, use Composition API to dynamically register lifecycle hooks.`,
          link: `https://v3.vuejs.org/guide/migration/vnode-lifecycle-events.html`
        },
        ["INSTANCE_CHILDREN"]: {
          message: `vm.$children has been removed. Consider refactoring your logic to avoid relying on direct access to child components.`,
          link: `https://v3.vuejs.org/guide/migration/children.html`
        },
        ["INSTANCE_LISTENERS"]: {
          message: `vm.$listeners has been removed. In Vue 3, parent v-on listeners are included in vm.$attrs and it is no longer necessary to separately use v-on="$listeners" if you are already using v-bind="$attrs". (Note: the Vue 3 behavior only applies if this compat config is disabled)`,
          link: `https://v3.vuejs.org/guide/migration/listeners-removed.html`
        },
        ["INSTANCE_SCOPED_SLOTS"]: {
          message: `vm.$scopedSlots has been removed. Use vm.$slots instead.`,
          link: `https://v3.vuejs.org/guide/migration/slots-unification.html`
        },
        ["INSTANCE_ATTRS_CLASS_STYLE"]: {
          message: (componentName) => `Component <${componentName || "Anonymous"}> has \`inheritAttrs: false\` but is relying on class/style fallthrough from parent. In Vue 3, class/style are now included in $attrs and will no longer fallthrough when inheritAttrs is false. If you are already using v-bind="$attrs" on component root it should render the same end result. If you are binding $attrs to a non-root element and expecting class/style to fallthrough on root, you will need to now manually bind them on root via :class="$attrs.class".`,
          link: `https://v3.vuejs.org/guide/migration/attrs-includes-class-style.html`
        },
        ["OPTIONS_DATA_FN"]: {
          message: `The "data" option can no longer be a plain object. Always use a function.`,
          link: `https://v3.vuejs.org/guide/migration/data-option.html`
        },
        ["OPTIONS_DATA_MERGE"]: {
          message: (key2) => `Detected conflicting key "${key2}" when merging data option values. In Vue 3, data keys are merged shallowly and will override one another.`,
          link: `https://v3.vuejs.org/guide/migration/data-option.html#mixin-merge-behavior-change`
        },
        ["OPTIONS_BEFORE_DESTROY"]: {
          message: `\`beforeDestroy\` has been renamed to \`beforeUnmount\`.`
        },
        ["OPTIONS_DESTROYED"]: {
          message: `\`destroyed\` has been renamed to \`unmounted\`.`
        },
        ["WATCH_ARRAY"]: {
          message: `"watch" option or vm.$watch on an array value will no longer trigger on array mutation unless the "deep" option is specified. If current usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"WATCH_ARRAY"}: false })
`,
          link: `https://v3.vuejs.org/guide/migration/watch.html`
        },
        ["PROPS_DEFAULT_THIS"]: {
          message: (key2) => `props default value function no longer has access to "this". The compat build only offers access to this.$options.(found in prop "${key2}")`,
          link: `https://v3.vuejs.org/guide/migration/props-default-this.html`
        },
        ["CUSTOM_DIR"]: {
          message: (legacyHook, newHook) => `Custom directive hook "${legacyHook}" has been removed. Use "${newHook}" instead.`,
          link: `https://v3.vuejs.org/guide/migration/custom-directives.html`
        },
        ["V_FOR_REF"]: {
          message: `Ref usage on v-for no longer creates array ref values in Vue 3. Consider using function refs or refactor to avoid ref usage altogether.`,
          link: `https://v3.vuejs.org/guide/migration/array-refs.html`
        },
        ["V_ON_KEYCODE_MODIFIER"]: {
          message: `Using keyCode as v-on modifier is no longer supported. Use kebab-case key name modifiers instead.`,
          link: `https://v3.vuejs.org/guide/migration/keycode-modifiers.html`
        },
        ["ATTR_FALSE_VALUE"]: {
          message: (name) => `Attribute "${name}" with v-bind value \`false\` will render ${name}="false" instead of removing it in Vue 3. To remove the attribute, use \`null\` or \`undefined\` instead. If the usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"ATTR_FALSE_VALUE"}: false })
`,
          link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
        },
        ["ATTR_ENUMERATED_COERCION"]: {
          message: (name, value2, coerced) => `Enumerated attribute "${name}" with v-bind value \`${value2}\` will ${value2 === null ? `be removed` : `render the value as-is`} instead of coercing the value to "${coerced}" in Vue 3. Always use explicit "true" or "false" values for enumerated attributes. If the usage is intended, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"ATTR_ENUMERATED_COERCION"}: false })
`,
          link: `https://v3.vuejs.org/guide/migration/attribute-coercion.html`
        },
        ["TRANSITION_CLASSES"]: {
          message: ``
        },
        ["TRANSITION_GROUP_ROOT"]: {
          message: `<TransitionGroup> no longer renders a root <span> element by default if no "tag" prop is specified. If you do not rely on the span for styling, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"TRANSITION_GROUP_ROOT"}: false })
`,
          link: `https://v3.vuejs.org/guide/migration/transition-group.html`
        },
        ["COMPONENT_ASYNC"]: {
          message: (comp) => {
            const name = getComponentName(comp);
            return `Async component${name ? ` <${name}>` : `s`} should be explicitly created via \`defineAsyncComponent()\` in Vue 3. Plain functions will be treated as functional components in non-compat build. If you have already migrated all async component usage and intend to use plain functions for functional components, you can disable the compat behavior and suppress this warning with:

  configureCompat({ ${"COMPONENT_ASYNC"}: false })
`;
          },
          link: `https://v3.vuejs.org/guide/migration/async-components.html`
        },
        ["COMPONENT_FUNCTIONAL"]: {
          message: (comp) => {
            const name = getComponentName(comp);
            return `Functional component${name ? ` <${name}>` : `s`} should be defined as a plain function in Vue 3. The "functional" option has been removed. NOTE: Before migrating to use plain functions for functional components, first make sure that all async components usage have been migrated and its compat behavior has been disabled.`;
          },
          link: `https://v3.vuejs.org/guide/migration/functional-components.html`
        },
        ["COMPONENT_V_MODEL"]: {
          message: (comp) => {
            const configMsg = `opt-in to Vue 3 behavior on a per-component basis with \`compatConfig: { ${"COMPONENT_V_MODEL"}: false }\`.`;
            if (comp.props && (isArray(comp.props) ? comp.props.includes("modelValue") : hasOwn(comp.props, "modelValue"))) {
              return `Component delcares "modelValue" prop, which is Vue 3 usage, but is running under Vue 2 compat v-model behavior. You can ${configMsg}`;
            }
            return `v-model usage on component has changed in Vue 3. Component that expects to work with v-model should now use the "modelValue" prop and emit the "update:modelValue" event. You can update the usage and then ${configMsg}`;
          },
          link: `https://v3.vuejs.org/guide/migration/v-model.html`
        },
        ["RENDER_FUNCTION"]: {
          message: `Vue 3's render function API has changed. You can opt-in to the new API with:

  configureCompat({ ${"RENDER_FUNCTION"}: false })

  (This can also be done per-component via the "compatConfig" option.)`,
          link: `https://v3.vuejs.org/guide/migration/render-function-api.html`
        },
        ["FILTERS"]: {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3.vuejs.org/guide/migration/filters.html`
        },
        ["PRIVATE_APIS"]: {
          message: (name) => `"${name}" is a Vue 2 private API that no longer exists in Vue 3. If you are seeing this warning only due to a dependency, you can suppress this warning via { PRIVATE_APIS: 'supress-warning' }.`
        }
      };
      instanceWarned = Object.create(null);
      warnCount = Object.create(null);
      currentRenderingInstance = null;
      currentScopeId = null;
      withScopeId = (_id) => withCtx;
      accessedAttrs = false;
      getChildRoot = (vnode) => {
        const rawChildren = vnode.children;
        const dynamicChildren = vnode.dynamicChildren;
        const childRoot = filterSingleRoot(rawChildren);
        if (!childRoot) {
          return [vnode, void 0];
        }
        const index = rawChildren.indexOf(childRoot);
        const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
        const setRoot = (updatedRoot) => {
          rawChildren[index] = updatedRoot;
          if (dynamicChildren) {
            if (dynamicIndex > -1) {
              dynamicChildren[dynamicIndex] = updatedRoot;
            } else if (updatedRoot.patchFlag > 0) {
              vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
            }
          }
        };
        return [normalizeVNode(childRoot), setRoot];
      };
      getFunctionalFallthrough = (attrs) => {
        let res;
        for (const key2 in attrs) {
          if (key2 === "class" || key2 === "style" || isOn(key2)) {
            (res || (res = {}))[key2] = attrs[key2];
          }
        }
        return res;
      };
      filterModelListeners = (attrs, props2) => {
        const res = {};
        for (const key2 in attrs) {
          if (!isModelListener(key2) || !(key2.slice(9) in props2)) {
            res[key2] = attrs[key2];
          }
        }
        return res;
      };
      isElementRoot = (vnode) => {
        return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
      };
      isSuspense = (type2) => type2.__isSuspense;
      SuspenseImpl = {
        name: "Suspense",
        __isSuspense: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
          if (n1 == null) {
            mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
          } else {
            patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
          }
        },
        hydrate: hydrateSuspense,
        create: createSuspenseBoundary,
        normalize: normalizeSuspenseChildren
      };
      Suspense = SuspenseImpl;
      hasWarned = false;
      TransitionHookValidator = [Function, Array];
      BaseTransitionImpl = {
        name: `BaseTransition`,
        props: {
          mode: String,
          appear: Boolean,
          persisted: Boolean,
          onBeforeEnter: TransitionHookValidator,
          onEnter: TransitionHookValidator,
          onAfterEnter: TransitionHookValidator,
          onEnterCancelled: TransitionHookValidator,
          onBeforeLeave: TransitionHookValidator,
          onLeave: TransitionHookValidator,
          onAfterLeave: TransitionHookValidator,
          onLeaveCancelled: TransitionHookValidator,
          onBeforeAppear: TransitionHookValidator,
          onAppear: TransitionHookValidator,
          onAfterAppear: TransitionHookValidator,
          onAppearCancelled: TransitionHookValidator
        },
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevTransitionKey;
          return () => {
            const children = slots.default && getTransitionRawChildren(slots.default(), true);
            if (!children || !children.length) {
              return;
            }
            if (children.length > 1) {
              warn2("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
            }
            const rawProps = toRaw(props2);
            const { mode } = rawProps;
            if (mode && !["in-out", "out-in", "default"].includes(mode)) {
              warn2(`invalid <transition> mode: ${mode}`);
            }
            const child = children[0];
            if (state.isLeaving) {
              return emptyPlaceholder(child);
            }
            const innerChild = getKeepAliveChild(child);
            if (!innerChild) {
              return emptyPlaceholder(child);
            }
            const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
            setTransitionHooks(innerChild, enterHooks);
            const oldChild = instance.subTree;
            const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
            let transitionKeyChanged = false;
            const { getTransitionKey } = innerChild.type;
            if (getTransitionKey) {
              const key2 = getTransitionKey();
              if (prevTransitionKey === void 0) {
                prevTransitionKey = key2;
              } else if (key2 !== prevTransitionKey) {
                prevTransitionKey = key2;
                transitionKeyChanged = true;
              }
            }
            if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
              const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
              setTransitionHooks(oldInnerChild, leavingHooks);
              if (mode === "out-in") {
                state.isLeaving = true;
                leavingHooks.afterLeave = () => {
                  state.isLeaving = false;
                  instance.update();
                };
                return emptyPlaceholder(child);
              } else if (mode === "in-out" && innerChild.type !== Comment) {
                leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
                  const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
                  leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
                  el._leaveCb = () => {
                    earlyRemove();
                    el._leaveCb = void 0;
                    delete enterHooks.delayedLeave;
                  };
                  enterHooks.delayedLeave = delayedLeave;
                };
              }
            }
            return child;
          };
        }
      };
      BaseTransition = BaseTransitionImpl;
      isAsyncWrapper = (i) => !!i.type.__asyncLoader;
      isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
      KeepAliveImpl = {
        name: `KeepAlive`,
        __isKeepAlive: true,
        props: {
          include: [String, RegExp, Array],
          exclude: [String, RegExp, Array],
          max: [String, Number]
        },
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const sharedContext = instance.ctx;
          if (!sharedContext.renderer) {
            return slots.default;
          }
          const cache = new Map();
          const keys = new Set();
          let current = null;
          if (true) {
            instance.__v_cache = cache;
          }
          const parentSuspense = instance.suspense;
          const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
          const storageContainer = createElement("div");
          sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
            const instance2 = vnode.component;
            move(vnode, container, anchor, 0, parentSuspense);
            patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
            queuePostRenderEffect(() => {
              instance2.isDeactivated = false;
              if (instance2.a) {
                invokeArrayFns(instance2.a);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
            }, parentSuspense);
            if (true) {
              devtoolsComponentAdded(instance2);
            }
          };
          sharedContext.deactivate = (vnode) => {
            const instance2 = vnode.component;
            move(vnode, storageContainer, null, 1, parentSuspense);
            queuePostRenderEffect(() => {
              if (instance2.da) {
                invokeArrayFns(instance2.da);
              }
              const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
              if (vnodeHook) {
                invokeVNodeHook(vnodeHook, instance2.parent, vnode);
              }
              instance2.isDeactivated = true;
            }, parentSuspense);
            if (true) {
              devtoolsComponentAdded(instance2);
            }
          };
          function unmount(vnode) {
            resetShapeFlag(vnode);
            _unmount(vnode, instance, parentSuspense);
          }
          function pruneCache(filter) {
            cache.forEach((vnode, key2) => {
              const name = getComponentName(vnode.type);
              if (name && (!filter || !filter(name))) {
                pruneCacheEntry(key2);
              }
            });
          }
          function pruneCacheEntry(key2) {
            const cached = cache.get(key2);
            if (!current || cached.type !== current.type) {
              unmount(cached);
            } else if (current) {
              resetShapeFlag(current);
            }
            cache.delete(key2);
            keys.delete(key2);
          }
          watch(() => [props2.include, props2.exclude], ([include, exclude]) => {
            include && pruneCache((name) => matches(include, name));
            exclude && pruneCache((name) => !matches(exclude, name));
          }, { flush: "post", deep: true });
          let pendingCacheKey = null;
          const cacheSubtree = () => {
            if (pendingCacheKey != null) {
              cache.set(pendingCacheKey, getInnerChild(instance.subTree));
            }
          };
          onMounted2(cacheSubtree);
          onUpdated(cacheSubtree);
          onBeforeUnmount2(() => {
            cache.forEach((cached) => {
              const { subTree, suspense } = instance;
              const vnode = getInnerChild(subTree);
              if (cached.type === vnode.type) {
                resetShapeFlag(vnode);
                const da = vnode.component.da;
                da && queuePostRenderEffect(da, suspense);
                return;
              }
              unmount(cached);
            });
          });
          return () => {
            pendingCacheKey = null;
            if (!slots.default) {
              return null;
            }
            const children = slots.default();
            const rawVNode = children[0];
            if (children.length > 1) {
              if (true) {
                warn2(`KeepAlive should contain exactly one component child.`);
              }
              current = null;
              return children;
            } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
              current = null;
              return rawVNode;
            }
            let vnode = getInnerChild(rawVNode);
            const comp = vnode.type;
            const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
            const { include, exclude, max } = props2;
            if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
              current = vnode;
              return rawVNode;
            }
            const key2 = vnode.key == null ? comp : vnode.key;
            const cachedVNode = cache.get(key2);
            if (vnode.el) {
              vnode = cloneVNode(vnode);
              if (rawVNode.shapeFlag & 128) {
                rawVNode.ssContent = vnode;
              }
            }
            pendingCacheKey = key2;
            if (cachedVNode) {
              vnode.el = cachedVNode.el;
              vnode.component = cachedVNode.component;
              if (vnode.transition) {
                setTransitionHooks(vnode, vnode.transition);
              }
              vnode.shapeFlag |= 512;
              keys.delete(key2);
              keys.add(key2);
            } else {
              keys.add(key2);
              if (max && keys.size > parseInt(max, 10)) {
                pruneCacheEntry(keys.values().next().value);
              }
            }
            vnode.shapeFlag |= 256;
            current = vnode;
            return rawVNode;
          };
        }
      };
      KeepAlive = KeepAliveImpl;
      createHook = (lifecycle) => (hook, target2 = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target2);
      onBeforeMount = createHook("bm");
      onMounted2 = createHook("m");
      onBeforeUpdate = createHook("bu");
      onUpdated = createHook("u");
      onBeforeUnmount2 = createHook("bum");
      onUnmounted = createHook("um");
      onServerPrefetch = createHook("sp");
      onRenderTriggered = createHook("rtg");
      onRenderTracked = createHook("rtc");
      shouldCacheAccess = true;
      internalOptionMergeStrats = {
        data: mergeDataFn,
        props: mergeObjectOptions,
        emits: mergeObjectOptions,
        methods: mergeObjectOptions,
        computed: mergeObjectOptions,
        beforeCreate: mergeAsArray,
        created: mergeAsArray,
        beforeMount: mergeAsArray,
        mounted: mergeAsArray,
        beforeUpdate: mergeAsArray,
        updated: mergeAsArray,
        beforeDestroy: mergeAsArray,
        beforeUnmount: mergeAsArray,
        destroyed: mergeAsArray,
        unmounted: mergeAsArray,
        activated: mergeAsArray,
        deactivated: mergeAsArray,
        errorCaptured: mergeAsArray,
        serverPrefetch: mergeAsArray,
        components: mergeObjectOptions,
        directives: mergeObjectOptions,
        watch: mergeWatchOptions,
        provide: mergeDataFn,
        inject: mergeInject
      };
      isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
      isInternalKey = (key2) => key2[0] === "_" || key2 === "$stable";
      normalizeSlotValue = (value2) => isArray(value2) ? value2.map(normalizeVNode) : [normalizeVNode(value2)];
      normalizeSlot = (key2, rawSlot, ctx) => {
        const normalized = withCtx((...args) => {
          if (currentInstance) {
            warn2(`Slot "${key2}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
          }
          return normalizeSlotValue(rawSlot(...args));
        }, ctx);
        normalized._c = false;
        return normalized;
      };
      normalizeObjectSlots = (rawSlots, slots, instance) => {
        const ctx = rawSlots._ctx;
        for (const key2 in rawSlots) {
          if (isInternalKey(key2))
            continue;
          const value2 = rawSlots[key2];
          if (isFunction(value2)) {
            slots[key2] = normalizeSlot(key2, value2, ctx);
          } else if (value2 != null) {
            if (true) {
              warn2(`Non-function value encountered for slot "${key2}". Prefer function slots for better performance.`);
            }
            const normalized = normalizeSlotValue(value2);
            slots[key2] = () => normalized;
          }
        }
      };
      normalizeVNodeSlots = (instance, children) => {
        if (!isKeepAlive(instance.vnode) && true) {
          warn2(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
        }
        const normalized = normalizeSlotValue(children);
        instance.slots.default = () => normalized;
      };
      initSlots = (instance, children) => {
        if (instance.vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            instance.slots = toRaw(children);
            def(children, "_", type2);
          } else {
            normalizeObjectSlots(children, instance.slots = {});
          }
        } else {
          instance.slots = {};
          if (children) {
            normalizeVNodeSlots(instance, children);
          }
        }
        def(instance.slots, InternalObjectKey, 1);
      };
      updateSlots = (instance, children, optimized) => {
        const { vnode, slots } = instance;
        let needDeletionCheck = true;
        let deletionComparisonTarget = EMPTY_OBJ;
        if (vnode.shapeFlag & 32) {
          const type2 = children._;
          if (type2) {
            if (isHmrUpdating) {
              extend(slots, children);
            } else if (optimized && type2 === 1) {
              needDeletionCheck = false;
            } else {
              extend(slots, children);
              if (!optimized && type2 === 1) {
                delete slots._;
              }
            }
          } else {
            needDeletionCheck = !children.$stable;
            normalizeObjectSlots(children, slots);
          }
          deletionComparisonTarget = children;
        } else if (children) {
          normalizeVNodeSlots(instance, children);
          deletionComparisonTarget = { default: 1 };
        }
        if (needDeletionCheck) {
          for (const key2 in slots) {
            if (!isInternalKey(key2) && !(key2 in deletionComparisonTarget)) {
              delete slots[key2];
            }
          }
        }
      };
      isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text");
      uid = 0;
      hasMismatch = false;
      isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
      isComment = (node) => node.nodeType === 8;
      queuePostRenderEffect = queueEffectWithSuspense;
      isTeleport = (type2) => type2.__isTeleport;
      isTeleportDisabled = (props2) => props2 && (props2.disabled || props2.disabled === "");
      isTargetSVG = (target2) => typeof SVGElement !== "undefined" && target2 instanceof SVGElement;
      resolveTarget = (props2, select) => {
        const targetSelector = props2 && props2.to;
        if (isString(targetSelector)) {
          if (!select) {
            warn2(`Current renderer does not support string target for Teleports. (missing querySelector renderer option)`);
            return null;
          } else {
            const target2 = select(targetSelector);
            if (!target2) {
              warn2(`Failed to locate Teleport target with selector "${targetSelector}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`);
            }
            return target2;
          }
        } else {
          if (!targetSelector && !isTeleportDisabled(props2)) {
            warn2(`Invalid Teleport target: ${targetSelector}`);
          }
          return targetSelector;
        }
      };
      TeleportImpl = {
        __isTeleport: true,
        process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
          const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
          const disabled = isTeleportDisabled(n2.props);
          let { shapeFlag, children, dynamicChildren } = n2;
          if (isHmrUpdating) {
            optimized = false;
            dynamicChildren = null;
          }
          if (n1 == null) {
            const placeholder = n2.el = true ? createComment("teleport start") : createText("");
            const mainAnchor = n2.anchor = true ? createComment("teleport end") : createText("");
            insert(placeholder, container, anchor);
            insert(mainAnchor, container, anchor);
            const target2 = n2.target = resolveTarget(n2.props, querySelector);
            const targetAnchor = n2.targetAnchor = createText("");
            if (target2) {
              insert(targetAnchor, target2);
              isSVG = isSVG || isTargetSVG(target2);
            } else if (!disabled) {
              warn2("Invalid Teleport target on mount:", target2, `(${typeof target2})`);
            }
            const mount = (container2, anchor2) => {
              if (shapeFlag & 16) {
                mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
              }
            };
            if (disabled) {
              mount(container, mainAnchor);
            } else if (target2) {
              mount(target2, targetAnchor);
            }
          } else {
            n2.el = n1.el;
            const mainAnchor = n2.anchor = n1.anchor;
            const target2 = n2.target = n1.target;
            const targetAnchor = n2.targetAnchor = n1.targetAnchor;
            const wasDisabled = isTeleportDisabled(n1.props);
            const currentContainer = wasDisabled ? container : target2;
            const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
            isSVG = isSVG || isTargetSVG(target2);
            if (dynamicChildren) {
              patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
              traverseStaticChildren(n1, n2, true);
            } else if (!optimized) {
              patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
            }
            if (disabled) {
              if (!wasDisabled) {
                moveTeleport(n2, container, mainAnchor, internals, 1);
              }
            } else {
              if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
                const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
                if (nextTarget) {
                  moveTeleport(n2, nextTarget, null, internals, 0);
                } else if (true) {
                  warn2("Invalid Teleport target on update:", target2, `(${typeof target2})`);
                }
              } else if (wasDisabled) {
                moveTeleport(n2, target2, targetAnchor, internals, 1);
              }
            }
          }
        },
        remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
          const { shapeFlag, children, anchor, targetAnchor, target: target2, props: props2 } = vnode;
          if (target2) {
            hostRemove(targetAnchor);
          }
          if (doRemove || !isTeleportDisabled(props2)) {
            hostRemove(anchor);
            if (shapeFlag & 16) {
              for (let i = 0; i < children.length; i++) {
                const child = children[i];
                unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
              }
            }
          }
        },
        move: moveTeleport,
        hydrate: hydrateTeleport
      };
      Teleport = TeleportImpl;
      COMPONENTS = "components";
      DIRECTIVES = "directives";
      NULL_DYNAMIC_COMPONENT = Symbol();
      Fragment = Symbol(true ? "Fragment" : void 0);
      Text = Symbol(true ? "Text" : void 0);
      Comment = Symbol(true ? "Comment" : void 0);
      Static = Symbol(true ? "Static" : void 0);
      blockStack = [];
      currentBlock = null;
      isBlockTreeEnabled = 1;
      createVNodeWithArgsTransform = (...args) => {
        return _createVNode(...vnodeArgsTransformer ? vnodeArgsTransformer(args, currentRenderingInstance) : args);
      };
      InternalObjectKey = `__vInternal`;
      normalizeKey = ({ key: key2 }) => key2 != null ? key2 : null;
      normalizeRef = ({ ref: ref3 }) => {
        return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction(ref3) ? { i: currentRenderingInstance, r: ref3 } : ref3 : null;
      };
      createVNode = true ? createVNodeWithArgsTransform : _createVNode;
      getPublicInstance = (i) => {
        if (!i)
          return null;
        if (isStatefulComponent(i))
          return getExposeProxy(i) || i.proxy;
        return getPublicInstance(i.parent);
      };
      publicPropertiesMap = extend(Object.create(null), {
        $: (i) => i,
        $el: (i) => i.vnode.el,
        $data: (i) => i.data,
        $props: (i) => true ? shallowReadonly(i.props) : i.props,
        $attrs: (i) => true ? shallowReadonly(i.attrs) : i.attrs,
        $slots: (i) => true ? shallowReadonly(i.slots) : i.slots,
        $refs: (i) => true ? shallowReadonly(i.refs) : i.refs,
        $parent: (i) => getPublicInstance(i.parent),
        $root: (i) => getPublicInstance(i.root),
        $emit: (i) => i.emit,
        $options: (i) => true ? resolveMergedOptions(i) : i.type,
        $forceUpdate: (i) => () => queueJob(i.update),
        $nextTick: (i) => nextTick2.bind(i.proxy),
        $watch: (i) => true ? instanceWatch.bind(i) : NOOP
      });
      PublicInstanceProxyHandlers = {
        get({ _: instance }, key2) {
          const { ctx, setupState, data, props: props2, accessCache, type: type2, appContext } = instance;
          if (key2 === "__isVue") {
            return true;
          }
          if (setupState !== EMPTY_OBJ && setupState.__isScriptSetup && hasOwn(setupState, key2)) {
            return setupState[key2];
          }
          let normalizedProps;
          if (key2[0] !== "$") {
            const n = accessCache[key2];
            if (n !== void 0) {
              switch (n) {
                case 0:
                  return setupState[key2];
                case 1:
                  return data[key2];
                case 3:
                  return ctx[key2];
                case 2:
                  return props2[key2];
              }
            } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key2)) {
              accessCache[key2] = 0;
              return setupState[key2];
            } else if (data !== EMPTY_OBJ && hasOwn(data, key2)) {
              accessCache[key2] = 1;
              return data[key2];
            } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key2)) {
              accessCache[key2] = 2;
              return props2[key2];
            } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key2)) {
              accessCache[key2] = 3;
              return ctx[key2];
            } else if (shouldCacheAccess) {
              accessCache[key2] = 4;
            }
          }
          const publicGetter = publicPropertiesMap[key2];
          let cssModule, globalProperties;
          if (publicGetter) {
            if (key2 === "$attrs") {
              track(instance, "get", key2);
              markAttrsAccessed();
            }
            return publicGetter(instance);
          } else if ((cssModule = type2.__cssModules) && (cssModule = cssModule[key2])) {
            return cssModule;
          } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key2)) {
            accessCache[key2] = 3;
            return ctx[key2];
          } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key2)) {
            {
              return globalProperties[key2];
            }
          } else if (currentRenderingInstance && (!isString(key2) || key2.indexOf("__v") !== 0)) {
            if (data !== EMPTY_OBJ && (key2[0] === "$" || key2[0] === "_") && hasOwn(data, key2)) {
              warn2(`Property ${JSON.stringify(key2)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
            } else if (instance === currentRenderingInstance) {
              warn2(`Property ${JSON.stringify(key2)} was accessed during render but is not defined on instance.`);
            }
          }
        },
        set({ _: instance }, key2, value2) {
          const { data, setupState, ctx } = instance;
          if (setupState !== EMPTY_OBJ && hasOwn(setupState, key2)) {
            setupState[key2] = value2;
          } else if (data !== EMPTY_OBJ && hasOwn(data, key2)) {
            data[key2] = value2;
          } else if (hasOwn(instance.props, key2)) {
            warn2(`Attempting to mutate prop "${key2}". Props are readonly.`, instance);
            return false;
          }
          if (key2[0] === "$" && key2.slice(1) in instance) {
            warn2(`Attempting to mutate public property "${key2}". Properties starting with $ are reserved and readonly.`, instance);
            return false;
          } else {
            if (key2 in instance.appContext.config.globalProperties) {
              Object.defineProperty(ctx, key2, {
                enumerable: true,
                configurable: true,
                value: value2
              });
            } else {
              ctx[key2] = value2;
            }
          }
          return true;
        },
        has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key2) {
          let normalizedProps;
          return accessCache[key2] !== void 0 || data !== EMPTY_OBJ && hasOwn(data, key2) || setupState !== EMPTY_OBJ && hasOwn(setupState, key2) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key2) || hasOwn(ctx, key2) || hasOwn(publicPropertiesMap, key2) || hasOwn(appContext.config.globalProperties, key2);
        }
      };
      if (true) {
        PublicInstanceProxyHandlers.ownKeys = (target2) => {
          warn2(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
          return Reflect.ownKeys(target2);
        };
      }
      RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
        get(target2, key2) {
          if (key2 === Symbol.unscopables) {
            return;
          }
          return PublicInstanceProxyHandlers.get(target2, key2, target2);
        },
        has(_, key2) {
          const has3 = key2[0] !== "_" && !isGloballyWhitelisted(key2);
          if (!has3 && PublicInstanceProxyHandlers.has(_, key2)) {
            warn2(`Property ${JSON.stringify(key2)} should not start with _ which is a reserved prefix for Vue internals.`);
          }
          return has3;
        }
      });
      emptyAppContext = createAppContext();
      uid$1 = 0;
      currentInstance = null;
      getCurrentInstance = () => currentInstance || currentRenderingInstance;
      setCurrentInstance = (instance) => {
        currentInstance = instance;
        instance.scope.on();
      };
      unsetCurrentInstance = () => {
        currentInstance && currentInstance.scope.off();
        currentInstance = null;
      };
      isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
      isInSSRComponentSetup = false;
      isRuntimeOnly = () => !compile;
      classifyRE = /(?:^|[-_])(\w)/g;
      classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
      stack = [];
      ErrorTypeStrings = {
        ["sp"]: "serverPrefetch hook",
        ["bc"]: "beforeCreate hook",
        ["c"]: "created hook",
        ["bm"]: "beforeMount hook",
        ["m"]: "mounted hook",
        ["bu"]: "beforeUpdate hook",
        ["u"]: "updated",
        ["bum"]: "beforeUnmount hook",
        ["um"]: "unmounted hook",
        ["a"]: "activated hook",
        ["da"]: "deactivated hook",
        ["ec"]: "errorCaptured hook",
        ["rtc"]: "renderTracked hook",
        ["rtg"]: "renderTriggered hook",
        [0]: "setup function",
        [1]: "render function",
        [2]: "watcher getter",
        [3]: "watcher callback",
        [4]: "watcher cleanup function",
        [5]: "native event handler",
        [6]: "component event handler",
        [7]: "vnode hook",
        [8]: "directive hook",
        [9]: "transition hook",
        [10]: "app errorHandler",
        [11]: "app warnHandler",
        [12]: "ref function",
        [13]: "async component loader",
        [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-next"
      };
      isFlushing = false;
      isFlushPending = false;
      queue = [];
      flushIndex = 0;
      pendingPreFlushCbs = [];
      activePreFlushCbs = null;
      preFlushIndex = 0;
      pendingPostFlushCbs = [];
      activePostFlushCbs = null;
      postFlushIndex = 0;
      resolvedPromise = Promise.resolve();
      currentFlushPromise = null;
      currentPreFlushParentJob = null;
      RECURSION_LIMIT = 100;
      getId = (job) => job.id == null ? Infinity : job.id;
      INITIAL_WATCHER_VALUE = {};
      true ? Object.freeze({}) : {};
      true ? Object.freeze([]) : [];
      isFunction2 = (val) => typeof val === "function";
      isObject2 = (val) => val !== null && typeof val === "object";
      isPromise2 = (val) => {
        return isObject2(val) && isFunction2(val.then) && isFunction2(val.catch);
      };
      warnRuntimeUsage = (method) => warn2(`${method}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);
      ssrContextKey = Symbol(true ? `ssrContext` : ``);
      useSSRContext = () => {
        {
          const ctx = inject2(ssrContextKey);
          if (!ctx) {
            warn2(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
          }
          return ctx;
        }
      };
      version = "3.2.11";
      _ssrUtils = {
        createComponentInstance,
        setupComponent,
        renderComponentRoot,
        setCurrentRenderingInstance,
        isVNode,
        normalizeVNode
      };
      ssrUtils = _ssrUtils;
      resolveFilter = null;
      compatUtils = null;
    }
  });

  // node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js
  var runtime_dom_esm_bundler_exports = {};
  __export(runtime_dom_esm_bundler_exports, {
    BaseTransition: () => BaseTransition,
    Comment: () => Comment,
    EffectScope: () => EffectScope,
    Fragment: () => Fragment,
    KeepAlive: () => KeepAlive,
    ReactiveEffect: () => ReactiveEffect,
    Static: () => Static,
    Suspense: () => Suspense,
    Teleport: () => Teleport,
    Text: () => Text,
    Transition: () => Transition,
    TransitionGroup: () => TransitionGroup,
    VueElement: () => VueElement,
    callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
    callWithErrorHandling: () => callWithErrorHandling,
    camelize: () => camelize,
    capitalize: () => capitalize,
    cloneVNode: () => cloneVNode,
    compatUtils: () => compatUtils,
    computed: () => computed2,
    createApp: () => createApp2,
    createBlock: () => createBlock,
    createCommentVNode: () => createCommentVNode,
    createElementBlock: () => createElementBlock,
    createElementVNode: () => createBaseVNode,
    createHydrationRenderer: () => createHydrationRenderer,
    createRenderer: () => createRenderer,
    createSSRApp: () => createSSRApp,
    createSlots: () => createSlots,
    createStaticVNode: () => createStaticVNode,
    createTextVNode: () => createTextVNode,
    createVNode: () => createVNode,
    customRef: () => customRef,
    defineAsyncComponent: () => defineAsyncComponent,
    defineComponent: () => defineComponent2,
    defineCustomElement: () => defineCustomElement,
    defineEmits: () => defineEmits,
    defineExpose: () => defineExpose,
    defineProps: () => defineProps,
    defineSSRCustomElement: () => defineSSRCustomElement,
    devtools: () => devtools,
    effect: () => effect,
    effectScope: () => effectScope,
    getCurrentInstance: () => getCurrentInstance,
    getCurrentScope: () => getCurrentScope,
    getTransitionRawChildren: () => getTransitionRawChildren,
    guardReactiveProps: () => guardReactiveProps,
    h: () => h,
    handleError: () => handleError,
    hydrate: () => hydrate,
    initCustomFormatter: () => initCustomFormatter,
    inject: () => inject2,
    isMemoSame: () => isMemoSame,
    isProxy: () => isProxy,
    isReactive: () => isReactive,
    isReadonly: () => isReadonly,
    isRef: () => isRef,
    isRuntimeOnly: () => isRuntimeOnly,
    isVNode: () => isVNode,
    markRaw: () => markRaw,
    mergeDefaults: () => mergeDefaults,
    mergeProps: () => mergeProps,
    nextTick: () => nextTick2,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    onActivated: () => onActivated,
    onBeforeMount: () => onBeforeMount,
    onBeforeUnmount: () => onBeforeUnmount2,
    onBeforeUpdate: () => onBeforeUpdate,
    onDeactivated: () => onDeactivated,
    onErrorCaptured: () => onErrorCaptured,
    onMounted: () => onMounted2,
    onRenderTracked: () => onRenderTracked,
    onRenderTriggered: () => onRenderTriggered,
    onScopeDispose: () => onScopeDispose,
    onServerPrefetch: () => onServerPrefetch,
    onUnmounted: () => onUnmounted,
    onUpdated: () => onUpdated,
    openBlock: () => openBlock,
    popScopeId: () => popScopeId,
    provide: () => provide2,
    proxyRefs: () => proxyRefs,
    pushScopeId: () => pushScopeId,
    queuePostFlushCb: () => queuePostFlushCb,
    reactive: () => reactive2,
    readonly: () => readonly,
    ref: () => ref,
    registerRuntimeCompiler: () => registerRuntimeCompiler,
    render: () => render,
    renderList: () => renderList,
    renderSlot: () => renderSlot,
    resolveComponent: () => resolveComponent,
    resolveDirective: () => resolveDirective,
    resolveDynamicComponent: () => resolveDynamicComponent,
    resolveFilter: () => resolveFilter,
    resolveTransitionHooks: () => resolveTransitionHooks,
    setBlockTracking: () => setBlockTracking,
    setDevtoolsHook: () => setDevtoolsHook,
    setTransitionHooks: () => setTransitionHooks,
    shallowReactive: () => shallowReactive,
    shallowReadonly: () => shallowReadonly,
    shallowRef: () => shallowRef,
    ssrContextKey: () => ssrContextKey,
    ssrUtils: () => ssrUtils,
    stop: () => stop,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toHandlers: () => toHandlers,
    toRaw: () => toRaw,
    toRef: () => toRef,
    toRefs: () => toRefs,
    transformVNodeArgs: () => transformVNodeArgs,
    triggerRef: () => triggerRef,
    unref: () => unref,
    useAttrs: () => useAttrs,
    useCssModule: () => useCssModule,
    useCssVars: () => useCssVars,
    useSSRContext: () => useSSRContext,
    useSlots: () => useSlots,
    useTransitionState: () => useTransitionState,
    vModelCheckbox: () => vModelCheckbox,
    vModelDynamic: () => vModelDynamic,
    vModelRadio: () => vModelRadio,
    vModelSelect: () => vModelSelect,
    vModelText: () => vModelText,
    vShow: () => vShow,
    version: () => version,
    warn: () => warn2,
    watch: () => watch,
    watchEffect: () => watchEffect,
    watchPostEffect: () => watchPostEffect,
    watchSyncEffect: () => watchSyncEffect,
    withAsyncContext: () => withAsyncContext,
    withCtx: () => withCtx,
    withDefaults: () => withDefaults,
    withDirectives: () => withDirectives,
    withKeys: () => withKeys,
    withMemo: () => withMemo,
    withModifiers: () => withModifiers,
    withScopeId: () => withScopeId
  });
  function patchClass(el, value2, isSVG) {
    const transitionClasses = el._vtc;
    if (transitionClasses) {
      value2 = (value2 ? [value2, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value2 == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value2);
    } else {
      el.className = value2;
    }
  }
  function patchStyle(el, prev, next) {
    const style2 = el.style;
    const currentDisplay = style2.display;
    if (!next) {
      el.removeAttribute("style");
    } else if (isString(next)) {
      if (prev !== next) {
        style2.cssText = next;
      }
    } else {
      for (const key2 in next) {
        setStyle(style2, key2, next[key2]);
      }
      if (prev && !isString(prev)) {
        for (const key2 in prev) {
          if (next[key2] == null) {
            setStyle(style2, key2, "");
          }
        }
      }
    }
    if ("_vod" in el) {
      style2.display = currentDisplay;
    }
  }
  function setStyle(style2, name, val) {
    if (isArray(val)) {
      val.forEach((v) => setStyle(style2, name, v));
    } else {
      if (name.startsWith("--")) {
        style2.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style2, name);
        if (importantRE.test(val)) {
          style2.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
        } else {
          style2[prefixed] = val;
        }
      }
    }
  }
  function autoPrefix(style2, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style2) {
      return prefixCache[rawName] = name;
    }
    name = capitalize(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style2) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }
  function patchAttr(el, key2, value2, isSVG, instance) {
    if (isSVG && key2.startsWith("xlink:")) {
      if (value2 == null) {
        el.removeAttributeNS(xlinkNS, key2.slice(6, key2.length));
      } else {
        el.setAttributeNS(xlinkNS, key2, value2);
      }
    } else {
      const isBoolean2 = isSpecialBooleanAttr(key2);
      if (value2 == null || isBoolean2 && !includeBooleanAttr(value2)) {
        el.removeAttribute(key2);
      } else {
        el.setAttribute(key2, isBoolean2 ? "" : value2);
      }
    }
  }
  function patchDOMProp(el, key2, value2, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key2 === "innerHTML" || key2 === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key2] = value2 == null ? "" : value2;
      return;
    }
    if (key2 === "value" && el.tagName !== "PROGRESS") {
      el._value = value2;
      const newValue = value2 == null ? "" : value2;
      if (el.value !== newValue) {
        el.value = newValue;
      }
      if (value2 == null) {
        el.removeAttribute(key2);
      }
      return;
    }
    if (value2 === "" || value2 == null) {
      const type2 = typeof el[key2];
      if (type2 === "boolean") {
        el[key2] = includeBooleanAttr(value2);
        return;
      } else if (value2 == null && type2 === "string") {
        el[key2] = "";
        el.removeAttribute(key2);
        return;
      } else if (type2 === "number") {
        try {
          el[key2] = 0;
        } catch (_a2) {
        }
        el.removeAttribute(key2);
        return;
      }
    }
    try {
      el[key2] = value2;
    } catch (e) {
      if (true) {
        warn2(`Failed setting prop "${key2}" on <${el.tagName.toLowerCase()}>: value ${value2} is invalid.`, e);
      }
    }
  }
  function addEventListener2(el, event3, handler, options) {
    el.addEventListener(event3, handler, options);
  }
  function removeEventListener2(el, event3, handler, options) {
    el.removeEventListener(event3, handler, options);
  }
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el._vei || (el._vei = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener2(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener2(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    return [hyphenate(name.slice(2)), options];
  }
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      const timeStamp = e.timeStamp || _getNow();
      if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
      }
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value2) {
    if (isArray(value2)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value2.map((fn) => (e2) => !e2._stopped && fn(e2));
    } else {
      return value2;
    }
  }
  function shouldSetAsProp(el, key2, value2, isSVG) {
    if (isSVG) {
      if (key2 === "innerHTML" || key2 === "textContent") {
        return true;
      }
      if (key2 in el && nativeOnRE.test(key2) && isFunction(value2)) {
        return true;
      }
      return false;
    }
    if (key2 === "spellcheck" || key2 === "draggable") {
      return false;
    }
    if (key2 === "form") {
      return false;
    }
    if (key2 === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key2 === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (nativeOnRE.test(key2) && isString(value2)) {
      return false;
    }
    return key2 in el;
  }
  function defineCustomElement(options, hydate) {
    const Comp = defineComponent2(options);
    class VueCustomElement extends VueElement {
      constructor(initialProps) {
        super(Comp, initialProps, hydate);
      }
    }
    VueCustomElement.def = Comp;
    return VueCustomElement;
  }
  function useCssModule(name = "$style") {
    {
      const instance = getCurrentInstance();
      if (!instance) {
        warn2(`useCssModule must be called inside setup()`);
        return EMPTY_OBJ;
      }
      const modules2 = instance.type.__cssModules;
      if (!modules2) {
        warn2(`Current instance does not have CSS modules injected.`);
        return EMPTY_OBJ;
      }
      const mod2 = modules2[name];
      if (!mod2) {
        warn2(`Current instance does not have CSS module named "${name}".`);
        return EMPTY_OBJ;
      }
      return mod2;
    }
  }
  function useCssVars(getter) {
    const instance = getCurrentInstance();
    if (!instance) {
      warn2(`useCssVars is called without current active component instance.`);
      return;
    }
    const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
    watchPostEffect(setVars);
    onMounted2(() => {
      const ob = new MutationObserver(setVars);
      ob.observe(instance.subTree.el.parentNode, { childList: true });
      onUnmounted(() => ob.disconnect());
    });
  }
  function setVarsOnVNode(vnode, vars) {
    if (vnode.shapeFlag & 128) {
      const suspense = vnode.suspense;
      vnode = suspense.activeBranch;
      if (suspense.pendingBranch && !suspense.isHydrating) {
        suspense.effects.push(() => {
          setVarsOnVNode(suspense.activeBranch, vars);
        });
      }
    }
    while (vnode.component) {
      vnode = vnode.component.subTree;
    }
    if (vnode.shapeFlag & 1 && vnode.el) {
      setVarsOnNode(vnode.el, vars);
    } else if (vnode.type === Fragment) {
      vnode.children.forEach((c) => setVarsOnVNode(c, vars));
    } else if (vnode.type === Static) {
      let { el, anchor } = vnode;
      while (el) {
        setVarsOnNode(el, vars);
        if (el === anchor)
          break;
        el = el.nextSibling;
      }
    }
  }
  function setVarsOnNode(el, vars) {
    if (el.nodeType === 1) {
      const style2 = el.style;
      for (const key2 in vars) {
        style2.setProperty(`--${key2}`, vars[key2]);
      }
    }
  }
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key2 in rawProps) {
      if (!(key2 in DOMTransitionPropsValidators)) {
        baseProps[key2] = rawProps[key2];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const { name = "v", type: type2, duration: duration2, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
    const durations = normalizeDuration(duration2);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve2 = () => finishEnter(el, isAppear, done);
        callHook2(hook, [el, resolve2]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type2, enterDuration, resolve2);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook2(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook2(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        const resolve2 = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type2, leaveDuration, resolve2);
          }
        });
        callHook2(onLeave, [el, resolve2]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook2(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook2(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook2(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration2) {
    if (duration2 == null) {
      return null;
    } else if (isObject(duration2)) {
      return [NumberOf(duration2.enter), NumberOf(duration2.leave)];
    } else {
      const n = NumberOf(duration2);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber(val);
    if (true)
      validateDuration(res);
    return res;
  }
  function validateDuration(val) {
    if (typeof val !== "number") {
      warn2(`<transition> explicit duration is not a valid number - got ${JSON.stringify(val)}.`);
    } else if (isNaN(val)) {
      warn2(`<transition> explicit duration is NaN - the duration expression might be incorrect.`);
    }
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el._vtc || (el._vtc = new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const { _vtc } = el;
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el._vtc = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
    const id2 = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id2 === el._endId) {
        resolve2();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type: type2, timeout: timeout2, propCount } = getTransitionInfo(el, expectedType);
    if (!type2) {
      return resolve2();
    }
    const endEvent = type2 + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout2 + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key2) => (styles[key2] || "").split(", ");
    const transitionDelays = getStyleProperties(TRANSITION + "Delay");
    const transitionDurations = getStyleProperties(TRANSITION + "Duration");
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(ANIMATION + "Delay");
    const animationDurations = getStyleProperties(ANIMATION + "Duration");
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type2 = null;
    let timeout2 = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type2 = TRANSITION;
        timeout2 = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type2 = ANIMATION;
        timeout2 = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout2 = Math.max(transitionTimeout, animationTimeout);
      type2 = timeout2 > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type2 ? type2 === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type2 === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
    return {
      type: type2,
      timeout: timeout2,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s2) {
    return Number(s2.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }
  function callPendingCbs(c) {
    const el = c.el;
    if (el._moveCb) {
      el._moveCb();
    }
    if (el._enterCb) {
      el._enterCb();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s2 = c.el.style;
      s2.transform = s2.webkitTransform = `translate(${dx}px,${dy}px)`;
      s2.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone2 = el.cloneNode();
    if (el._vtc) {
      el._vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c) => c && clone2.classList.remove(c));
      });
    }
    moveClass.split(/\s+/).forEach((c) => c && clone2.classList.add(c));
    clone2.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone2);
    const { hasTransform } = getTransitionInfo(clone2);
    container.removeChild(clone2);
    return hasTransform;
  }
  function onCompositionStart(e) {
    e.target.composing = true;
  }
  function onCompositionEnd(e) {
    const target2 = e.target;
    if (target2.composing) {
      target2.composing = false;
      trigger2(target2, "input");
    }
  }
  function trigger2(el, type2) {
    const e = document.createEvent("HTMLEvents");
    e.initEvent(type2, true, true);
    el.dispatchEvent(e);
  }
  function setChecked(el, { value: value2, oldValue }, vnode) {
    el._modelValue = value2;
    if (isArray(value2)) {
      el.checked = looseIndexOf(value2, vnode.props.value) > -1;
    } else if (isSet(value2)) {
      el.checked = value2.has(vnode.props.value);
    } else if (value2 !== oldValue) {
      el.checked = looseEqual(value2, getCheckboxValue(el, true));
    }
  }
  function setSelected(el, value2) {
    const isMultiple = el.multiple;
    if (isMultiple && !isArray(value2) && !isSet(value2)) {
      warn2(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(value2).slice(8, -1)}.`);
      return;
    }
    for (let i = 0, l = el.options.length; i < l; i++) {
      const option = el.options[i];
      const optionValue = getValue(option);
      if (isMultiple) {
        if (isArray(value2)) {
          option.selected = looseIndexOf(value2, optionValue) > -1;
        } else {
          option.selected = value2.has(optionValue);
        }
      } else {
        if (looseEqual(getValue(option), value2)) {
          if (el.selectedIndex !== i)
            el.selectedIndex = i;
          return;
        }
      }
    }
    if (!isMultiple && el.selectedIndex !== -1) {
      el.selectedIndex = -1;
    }
  }
  function getValue(el) {
    return "_value" in el ? el._value : el.value;
  }
  function getCheckboxValue(el, checked2) {
    const key2 = checked2 ? "_trueValue" : "_falseValue";
    return key2 in el ? el[key2] : checked2;
  }
  function callModelHook(el, binding, vnode, prevVNode, hook) {
    let modelToUse;
    switch (el.tagName) {
      case "SELECT":
        modelToUse = vModelSelect;
        break;
      case "TEXTAREA":
        modelToUse = vModelText;
        break;
      default:
        switch (vnode.props && vnode.props.type) {
          case "checkbox":
            modelToUse = vModelCheckbox;
            break;
          case "radio":
            modelToUse = vModelRadio;
            break;
          default:
            modelToUse = vModelText;
        }
    }
    const fn = modelToUse[hook];
    fn && fn(el, binding, vnode, prevVNode);
  }
  function setDisplay(el, value2) {
    el.style.display = value2 ? el._vod : "none";
  }
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  function ensureHydrationRenderer() {
    renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
    enabledHydration = true;
    return renderer;
  }
  function injectNativeTagCheck(app2) {
    Object.defineProperty(app2.config, "isNativeTag", {
      value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
      writable: false
    });
  }
  function injectCompilerOptionsCheck(app2) {
    if (isRuntimeOnly()) {
      const isCustomElement = app2.config.isCustomElement;
      Object.defineProperty(app2.config, "isCustomElement", {
        get() {
          return isCustomElement;
        },
        set() {
          warn2(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
        }
      });
      const compilerOptions = app2.config.compilerOptions;
      const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
      Object.defineProperty(app2.config, "compilerOptions", {
        get() {
          warn2(msg);
          return compilerOptions;
        },
        set() {
          warn2(msg);
        }
      });
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      if (!res) {
        warn2(`Failed to mount app: mount target selector "${container}" returned null.`);
      }
      return res;
    }
    if (window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
      warn2(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
    }
    return container;
  }
  var import_pako, svgNS, doc, staticTemplateCache, nodeOps, importantRE, prefixes, prefixCache, xlinkNS, _getNow, skipTimestampCheck, cachedNow, p, reset, getNow, optionsModifierRE, nativeOnRE, patchProp, defineSSRCustomElement, BaseClass, VueElement, TRANSITION, ANIMATION, Transition, DOMTransitionPropsValidators, TransitionPropsValidators, callHook2, hasExplicitCallback, endId, positionMap, newPositionMap, TransitionGroupImpl, TransitionGroup, getModelAssigner, vModelText, vModelCheckbox, vModelRadio, vModelSelect, vModelDynamic, systemModifiers, modifierGuards, withModifiers, keyNames, withKeys, vShow, rendererOptions, renderer, enabledHydration, render, hydrate, createApp2, createSSRApp;
  var init_runtime_dom_esm_bundler = __esm({
    "node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_runtime_core_esm_bundler();
      init_runtime_core_esm_bundler();
      init_shared_esm_bundler();
      svgNS = "http://www.w3.org/2000/svg";
      doc = typeof document !== "undefined" ? document : null;
      staticTemplateCache = new Map();
      nodeOps = {
        insert: (child, parent, anchor) => {
          parent.insertBefore(child, anchor || null);
        },
        remove: (child) => {
          const parent = child.parentNode;
          if (parent) {
            parent.removeChild(child);
          }
        },
        createElement: (tag, isSVG, is, props2) => {
          const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
          if (tag === "select" && props2 && props2.multiple != null) {
            el.setAttribute("multiple", props2.multiple);
          }
          return el;
        },
        createText: (text) => doc.createTextNode(text),
        createComment: (text) => doc.createComment(text),
        setText: (node, text) => {
          node.nodeValue = text;
        },
        setElementText: (el, text) => {
          el.textContent = text;
        },
        parentNode: (node) => node.parentNode,
        nextSibling: (node) => node.nextSibling,
        querySelector: (selector) => doc.querySelector(selector),
        setScopeId(el, id2) {
          el.setAttribute(id2, "");
        },
        cloneNode(el) {
          const cloned = el.cloneNode(true);
          if (`_value` in el) {
            cloned._value = el._value;
          }
          return cloned;
        },
        insertStaticContent(content, parent, anchor, isSVG) {
          const before = anchor ? anchor.previousSibling : parent.lastChild;
          let template = staticTemplateCache.get(content);
          if (!template) {
            const t = doc.createElement("template");
            t.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
            template = t.content;
            if (isSVG) {
              const wrapper = template.firstChild;
              while (wrapper.firstChild) {
                template.appendChild(wrapper.firstChild);
              }
              template.removeChild(wrapper);
            }
            staticTemplateCache.set(content, template);
          }
          parent.insertBefore(template.cloneNode(true), anchor);
          return [
            before ? before.nextSibling : parent.firstChild,
            anchor ? anchor.previousSibling : parent.lastChild
          ];
        }
      };
      importantRE = /\s*!important$/;
      prefixes = ["Webkit", "Moz", "ms"];
      prefixCache = {};
      xlinkNS = "http://www.w3.org/1999/xlink";
      _getNow = Date.now;
      skipTimestampCheck = false;
      if (typeof window !== "undefined") {
        if (_getNow() > document.createEvent("Event").timeStamp) {
          _getNow = () => performance.now();
        }
        const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
        skipTimestampCheck = !!(ffMatch && Number(ffMatch[1]) <= 53);
      }
      cachedNow = 0;
      p = Promise.resolve();
      reset = () => {
        cachedNow = 0;
      };
      getNow = () => cachedNow || (p.then(reset), cachedNow = _getNow());
      optionsModifierRE = /(?:Once|Passive|Capture)$/;
      nativeOnRE = /^on[a-z]/;
      patchProp = (el, key2, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
        if (key2 === "class") {
          patchClass(el, nextValue, isSVG);
        } else if (key2 === "style") {
          patchStyle(el, prevValue, nextValue);
        } else if (isOn(key2)) {
          if (!isModelListener(key2)) {
            patchEvent(el, key2, prevValue, nextValue, parentComponent);
          }
        } else if (key2[0] === "." ? (key2 = key2.slice(1), true) : key2[0] === "^" ? (key2 = key2.slice(1), false) : shouldSetAsProp(el, key2, nextValue, isSVG)) {
          patchDOMProp(el, key2, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
        } else {
          if (key2 === "true-value") {
            el._trueValue = nextValue;
          } else if (key2 === "false-value") {
            el._falseValue = nextValue;
          }
          patchAttr(el, key2, nextValue, isSVG);
        }
      };
      defineSSRCustomElement = (options) => {
        return defineCustomElement(options, hydrate);
      };
      BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
      };
      VueElement = class extends BaseClass {
        constructor(_def, _props = {}, hydrate2) {
          super();
          this._def = _def;
          this._props = _props;
          this._instance = null;
          this._connected = false;
          this._resolved = false;
          if (this.shadowRoot && hydrate2) {
            hydrate2(this._createVNode(), this.shadowRoot);
          } else {
            if (this.shadowRoot) {
              warn2(`Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use \`defineSSRCustomElement\`.`);
            }
            this.attachShadow({ mode: "open" });
          }
          for (let i = 0; i < this.attributes.length; i++) {
            this._setAttr(this.attributes[i].name);
          }
          const observer = new MutationObserver((mutations) => {
            for (const m of mutations) {
              this._setAttr(m.attributeName);
            }
          });
          observer.observe(this, { attributes: true });
        }
        connectedCallback() {
          this._connected = true;
          if (!this._instance) {
            this._resolveDef();
            render(this._createVNode(), this.shadowRoot);
          }
        }
        disconnectedCallback() {
          this._connected = false;
          nextTick2(() => {
            if (!this._connected) {
              render(null, this.shadowRoot);
              this._instance = null;
            }
          });
        }
        _resolveDef() {
          if (this._resolved) {
            return;
          }
          const resolve2 = (def2) => {
            this._resolved = true;
            for (const key2 of Object.keys(this)) {
              if (key2[0] !== "_") {
                this._setProp(key2, this[key2]);
              }
            }
            const { props: props2, styles } = def2;
            const rawKeys = props2 ? isArray(props2) ? props2 : Object.keys(props2) : [];
            for (const key2 of rawKeys.map(camelize)) {
              Object.defineProperty(this, key2, {
                get() {
                  return this._getProp(key2);
                },
                set(val) {
                  this._setProp(key2, val);
                }
              });
            }
            this._applyStyles(styles);
          };
          const asyncDef = this._def.__asyncLoader;
          if (asyncDef) {
            asyncDef().then(resolve2);
          } else {
            resolve2(this._def);
          }
        }
        _setAttr(key2) {
          this._setProp(camelize(key2), toNumber(this.getAttribute(key2)), false);
        }
        _getProp(key2) {
          return this._props[key2];
        }
        _setProp(key2, val, shouldReflect = true) {
          if (val !== this._props[key2]) {
            this._props[key2] = val;
            if (this._instance) {
              render(this._createVNode(), this.shadowRoot);
            }
            if (shouldReflect) {
              if (val === true) {
                this.setAttribute(hyphenate(key2), "");
              } else if (typeof val === "string" || typeof val === "number") {
                this.setAttribute(hyphenate(key2), val + "");
              } else if (!val) {
                this.removeAttribute(hyphenate(key2));
              }
            }
          }
        }
        _createVNode() {
          const vnode = createVNode(this._def, extend({}, this._props));
          if (!this._instance) {
            vnode.ce = (instance) => {
              this._instance = instance;
              instance.isCE = true;
              if (true) {
                instance.ceReload = (newStyles) => {
                  if (this._styles) {
                    this._styles.forEach((s2) => this.shadowRoot.removeChild(s2));
                    this._styles.length = 0;
                  }
                  this._applyStyles(newStyles);
                  if (!this._def.__asyncLoader) {
                    this._instance = null;
                    render(this._createVNode(), this.shadowRoot);
                  }
                };
              }
              instance.emit = (event3, ...args) => {
                this.dispatchEvent(new CustomEvent(event3, {
                  detail: args
                }));
              };
              let parent = this;
              while (parent = parent && (parent.parentNode || parent.host)) {
                if (parent instanceof VueElement) {
                  instance.parent = parent._instance;
                  break;
                }
              }
            };
          }
          return vnode;
        }
        _applyStyles(styles) {
          if (styles) {
            styles.forEach((css2) => {
              const s2 = document.createElement("style");
              s2.textContent = css2;
              this.shadowRoot.appendChild(s2);
              if (true) {
                (this._styles || (this._styles = [])).push(s2);
              }
            });
          }
        }
      };
      TRANSITION = "transition";
      ANIMATION = "animation";
      Transition = (props2, { slots }) => h(BaseTransition, resolveTransitionProps(props2), slots);
      Transition.displayName = "Transition";
      DOMTransitionPropsValidators = {
        name: String,
        type: String,
        css: {
          type: Boolean,
          default: true
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
      };
      TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
      callHook2 = (hook, args = []) => {
        if (isArray(hook)) {
          hook.forEach((h3) => h3(...args));
        } else if (hook) {
          hook(...args);
        }
      };
      hasExplicitCallback = (hook) => {
        return hook ? isArray(hook) ? hook.some((h3) => h3.length > 1) : hook.length > 1 : false;
      };
      endId = 0;
      positionMap = new WeakMap();
      newPositionMap = new WeakMap();
      TransitionGroupImpl = {
        name: "TransitionGroup",
        props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
          tag: String,
          moveClass: String
        }),
        setup(props2, { slots }) {
          const instance = getCurrentInstance();
          const state = useTransitionState();
          let prevChildren;
          let children;
          onUpdated(() => {
            if (!prevChildren.length) {
              return;
            }
            const moveClass = props2.moveClass || `${props2.name || "v"}-move`;
            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
              return;
            }
            prevChildren.forEach(callPendingCbs);
            prevChildren.forEach(recordPosition);
            const movedChildren = prevChildren.filter(applyTranslation);
            forceReflow();
            movedChildren.forEach((c) => {
              const el = c.el;
              const style2 = el.style;
              addTransitionClass(el, moveClass);
              style2.transform = style2.webkitTransform = style2.transitionDuration = "";
              const cb = el._moveCb = (e) => {
                if (e && e.target !== el) {
                  return;
                }
                if (!e || /transform$/.test(e.propertyName)) {
                  el.removeEventListener("transitionend", cb);
                  el._moveCb = null;
                  removeTransitionClass(el, moveClass);
                }
              };
              el.addEventListener("transitionend", cb);
            });
          });
          return () => {
            const rawProps = toRaw(props2);
            const cssTransitionProps = resolveTransitionProps(rawProps);
            let tag = rawProps.tag || Fragment;
            prevChildren = children;
            children = slots.default ? getTransitionRawChildren(slots.default()) : [];
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (child.key != null) {
                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
              } else if (true) {
                warn2(`<TransitionGroup> children must be keyed.`);
              }
            }
            if (prevChildren) {
              for (let i = 0; i < prevChildren.length; i++) {
                const child = prevChildren[i];
                setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
                positionMap.set(child, child.el.getBoundingClientRect());
              }
            }
            return createVNode(tag, null, children);
          };
        }
      };
      TransitionGroup = TransitionGroupImpl;
      getModelAssigner = (vnode) => {
        const fn = vnode.props["onUpdate:modelValue"];
        return isArray(fn) ? (value2) => invokeArrayFns(fn, value2) : fn;
      };
      vModelText = {
        created(el, { modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          const castToNumber = number || vnode.props && vnode.props.type === "number";
          addEventListener2(el, lazy ? "change" : "input", (e) => {
            if (e.target.composing)
              return;
            let domValue = el.value;
            if (trim) {
              domValue = domValue.trim();
            } else if (castToNumber) {
              domValue = toNumber(domValue);
            }
            el._assign(domValue);
          });
          if (trim) {
            addEventListener2(el, "change", () => {
              el.value = el.value.trim();
            });
          }
          if (!lazy) {
            addEventListener2(el, "compositionstart", onCompositionStart);
            addEventListener2(el, "compositionend", onCompositionEnd);
            addEventListener2(el, "change", onCompositionEnd);
          }
        },
        mounted(el, { value: value2 }) {
          el.value = value2 == null ? "" : value2;
        },
        beforeUpdate(el, { value: value2, modifiers: { lazy, trim, number } }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (el.composing)
            return;
          if (document.activeElement === el) {
            if (lazy) {
              return;
            }
            if (trim && el.value.trim() === value2) {
              return;
            }
            if ((number || el.type === "number") && toNumber(el.value) === value2) {
              return;
            }
          }
          const newValue = value2 == null ? "" : value2;
          if (el.value !== newValue) {
            el.value = newValue;
          }
        }
      };
      vModelCheckbox = {
        deep: true,
        created(el, _, vnode) {
          el._assign = getModelAssigner(vnode);
          addEventListener2(el, "change", () => {
            const modelValue = el._modelValue;
            const elementValue = getValue(el);
            const checked2 = el.checked;
            const assign = el._assign;
            if (isArray(modelValue)) {
              const index = looseIndexOf(modelValue, elementValue);
              const found = index !== -1;
              if (checked2 && !found) {
                assign(modelValue.concat(elementValue));
              } else if (!checked2 && found) {
                const filtered = [...modelValue];
                filtered.splice(index, 1);
                assign(filtered);
              }
            } else if (isSet(modelValue)) {
              const cloned = new Set(modelValue);
              if (checked2) {
                cloned.add(elementValue);
              } else {
                cloned.delete(elementValue);
              }
              assign(cloned);
            } else {
              assign(getCheckboxValue(el, checked2));
            }
          });
        },
        mounted: setChecked,
        beforeUpdate(el, binding, vnode) {
          el._assign = getModelAssigner(vnode);
          setChecked(el, binding, vnode);
        }
      };
      vModelRadio = {
        created(el, { value: value2 }, vnode) {
          el.checked = looseEqual(value2, vnode.props.value);
          el._assign = getModelAssigner(vnode);
          addEventListener2(el, "change", () => {
            el._assign(getValue(el));
          });
        },
        beforeUpdate(el, { value: value2, oldValue }, vnode) {
          el._assign = getModelAssigner(vnode);
          if (value2 !== oldValue) {
            el.checked = looseEqual(value2, vnode.props.value);
          }
        }
      };
      vModelSelect = {
        deep: true,
        created(el, { value: value2, modifiers: { number } }, vnode) {
          const isSetModel = isSet(value2);
          addEventListener2(el, "change", () => {
            const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number ? toNumber(getValue(o)) : getValue(o));
            el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
          });
          el._assign = getModelAssigner(vnode);
        },
        mounted(el, { value: value2 }) {
          setSelected(el, value2);
        },
        beforeUpdate(el, _binding, vnode) {
          el._assign = getModelAssigner(vnode);
        },
        updated(el, { value: value2 }) {
          setSelected(el, value2);
        }
      };
      vModelDynamic = {
        created(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "created");
        },
        mounted(el, binding, vnode) {
          callModelHook(el, binding, vnode, null, "mounted");
        },
        beforeUpdate(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
        },
        updated(el, binding, vnode, prevVNode) {
          callModelHook(el, binding, vnode, prevVNode, "updated");
        }
      };
      systemModifiers = ["ctrl", "shift", "alt", "meta"];
      modifierGuards = {
        stop: (e) => e.stopPropagation(),
        prevent: (e) => e.preventDefault(),
        self: (e) => e.target !== e.currentTarget,
        ctrl: (e) => !e.ctrlKey,
        shift: (e) => !e.shiftKey,
        alt: (e) => !e.altKey,
        meta: (e) => !e.metaKey,
        left: (e) => "button" in e && e.button !== 0,
        middle: (e) => "button" in e && e.button !== 1,
        right: (e) => "button" in e && e.button !== 2,
        exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
      };
      withModifiers = (fn, modifiers) => {
        return (event3, ...args) => {
          for (let i = 0; i < modifiers.length; i++) {
            const guard = modifierGuards[modifiers[i]];
            if (guard && guard(event3, modifiers))
              return;
          }
          return fn(event3, ...args);
        };
      };
      keyNames = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
      };
      withKeys = (fn, modifiers) => {
        return (event3) => {
          if (!("key" in event3)) {
            return;
          }
          const eventKey = hyphenate(event3.key);
          if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
            return fn(event3);
          }
        };
      };
      vShow = {
        beforeMount(el, { value: value2 }, { transition }) {
          el._vod = el.style.display === "none" ? "" : el.style.display;
          if (transition && value2) {
            transition.beforeEnter(el);
          } else {
            setDisplay(el, value2);
          }
        },
        mounted(el, { value: value2 }, { transition }) {
          if (transition && value2) {
            transition.enter(el);
          }
        },
        updated(el, { value: value2, oldValue }, { transition }) {
          if (!value2 === !oldValue)
            return;
          if (transition) {
            if (value2) {
              transition.beforeEnter(el);
              setDisplay(el, true);
              transition.enter(el);
            } else {
              transition.leave(el, () => {
                setDisplay(el, false);
              });
            }
          } else {
            setDisplay(el, value2);
          }
        },
        beforeUnmount(el, { value: value2 }) {
          setDisplay(el, value2);
        }
      };
      rendererOptions = extend({ patchProp }, nodeOps);
      enabledHydration = false;
      render = (...args) => {
        ensureRenderer().render(...args);
      };
      hydrate = (...args) => {
        ensureHydrationRenderer().hydrate(...args);
      };
      createApp2 = (...args) => {
        const app2 = ensureRenderer().createApp(...args);
        if (true) {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (!container)
            return;
          const component = app2._component;
          if (!isFunction(component) && !component.render && !component.template) {
            component.template = container.innerHTML;
          }
          container.innerHTML = "";
          const proxy = mount(container, false, container instanceof SVGElement);
          if (container instanceof Element) {
            container.removeAttribute("v-cloak");
            container.setAttribute("data-v-app", "");
          }
          return proxy;
        };
        return app2;
      };
      createSSRApp = (...args) => {
        const app2 = ensureHydrationRenderer().createApp(...args);
        if (true) {
          injectNativeTagCheck(app2);
          injectCompilerOptionsCheck(app2);
        }
        const { mount } = app2;
        app2.mount = (containerOrSelector) => {
          const container = normalizeContainer(containerOrSelector);
          if (container) {
            return mount(container, true, container instanceof SVGElement);
          }
        };
        return app2;
      };
    }
  });

  // node_modules/@vue/compiler-dom/node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js
  function defaultOnError(error) {
    throw error;
  }
  function defaultOnWarn(msg) {
    console.warn(`[Vue warn] ${msg.message}`);
  }
  function createCompilerError(code, loc, messages, additionalMessage) {
    const msg = true ? (messages || errorMessages)[code] + (additionalMessage || ``) : code;
    const error = new SyntaxError(String(msg));
    error.code = code;
    error.loc = loc;
    return error;
  }
  function registerRuntimeHelpers(helpers) {
    Object.getOwnPropertySymbols(helpers).forEach((s2) => {
      helperNameMap[s2] = helpers[s2];
    });
  }
  function createRoot(children, loc = locStub) {
    return {
      type: 0,
      children,
      helpers: [],
      components: [],
      directives: [],
      hoists: [],
      imports: [],
      cached: 0,
      temps: 0,
      codegenNode: void 0,
      loc
    };
  }
  function createVNodeCall(context, tag, props2, children, patchFlag, dynamicProps, directives2, isBlock = false, disableTracking = false, isComponent2 = false, loc = locStub) {
    if (context) {
      if (isBlock) {
        context.helper(OPEN_BLOCK);
        context.helper(getVNodeBlockHelper(context.inSSR, isComponent2));
      } else {
        context.helper(getVNodeHelper(context.inSSR, isComponent2));
      }
      if (directives2) {
        context.helper(WITH_DIRECTIVES);
      }
    }
    return {
      type: 13,
      tag,
      props: props2,
      children,
      patchFlag,
      dynamicProps,
      directives: directives2,
      isBlock,
      disableTracking,
      isComponent: isComponent2,
      loc
    };
  }
  function createArrayExpression(elements, loc = locStub) {
    return {
      type: 17,
      loc,
      elements
    };
  }
  function createObjectExpression(properties, loc = locStub) {
    return {
      type: 15,
      loc,
      properties
    };
  }
  function createObjectProperty(key2, value2) {
    return {
      type: 16,
      loc: locStub,
      key: isString(key2) ? createSimpleExpression(key2, true) : key2,
      value: value2
    };
  }
  function createSimpleExpression(content, isStatic = false, loc = locStub, constType = 0) {
    return {
      type: 4,
      loc,
      content,
      isStatic,
      constType: isStatic ? 3 : constType
    };
  }
  function createCompoundExpression(children, loc = locStub) {
    return {
      type: 8,
      loc,
      children
    };
  }
  function createCallExpression(callee, args = [], loc = locStub) {
    return {
      type: 14,
      loc,
      callee,
      arguments: args
    };
  }
  function createFunctionExpression(params, returns = void 0, newline = false, isSlot = false, loc = locStub) {
    return {
      type: 18,
      params,
      returns,
      newline,
      isSlot,
      loc
    };
  }
  function createConditionalExpression(test, consequent, alternate, newline = true) {
    return {
      type: 19,
      test,
      consequent,
      alternate,
      newline,
      loc: locStub
    };
  }
  function createCacheExpression(index, value2, isVNode2 = false) {
    return {
      type: 20,
      index,
      value: value2,
      isVNode: isVNode2,
      loc: locStub
    };
  }
  function createBlockStatement(body) {
    return {
      type: 21,
      body,
      loc: locStub
    };
  }
  function isCoreComponent(tag) {
    if (isBuiltInType(tag, "Teleport")) {
      return TELEPORT;
    } else if (isBuiltInType(tag, "Suspense")) {
      return SUSPENSE;
    } else if (isBuiltInType(tag, "KeepAlive")) {
      return KEEP_ALIVE;
    } else if (isBuiltInType(tag, "BaseTransition")) {
      return BASE_TRANSITION;
    }
  }
  function getInnerRange(loc, offset2, length) {
    const source = loc.source.substr(offset2, length);
    const newLoc = {
      source,
      start: advancePositionWithClone(loc.start, loc.source, offset2),
      end: loc.end
    };
    if (length != null) {
      newLoc.end = advancePositionWithClone(loc.start, loc.source, offset2 + length);
    }
    return newLoc;
  }
  function advancePositionWithClone(pos, source, numberOfCharacters = source.length) {
    return advancePositionWithMutation(extend({}, pos), source, numberOfCharacters);
  }
  function advancePositionWithMutation(pos, source, numberOfCharacters = source.length) {
    let linesCount = 0;
    let lastNewLinePos = -1;
    for (let i = 0; i < numberOfCharacters; i++) {
      if (source.charCodeAt(i) === 10) {
        linesCount++;
        lastNewLinePos = i;
      }
    }
    pos.offset += numberOfCharacters;
    pos.line += linesCount;
    pos.column = lastNewLinePos === -1 ? pos.column + numberOfCharacters : numberOfCharacters - lastNewLinePos;
    return pos;
  }
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg || `unexpected compiler condition`);
    }
  }
  function findDir(node, name, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 7 && (allowEmpty || p2.exp) && (isString(name) ? p2.name === name : name.test(p2.name))) {
        return p2;
      }
    }
  }
  function findProp(node, name, dynamicOnly = false, allowEmpty = false) {
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 6) {
        if (dynamicOnly)
          continue;
        if (p2.name === name && (p2.value || allowEmpty)) {
          return p2;
        }
      } else if (p2.name === "bind" && (p2.exp || allowEmpty) && isBindKey(p2.arg, name)) {
        return p2;
      }
    }
  }
  function isBindKey(arg, name) {
    return !!(arg && isStaticExp(arg) && arg.content === name);
  }
  function hasDynamicKeyVBind(node) {
    return node.props.some((p2) => p2.type === 7 && p2.name === "bind" && (!p2.arg || p2.arg.type !== 4 || !p2.arg.isStatic));
  }
  function isText(node) {
    return node.type === 5 || node.type === 2;
  }
  function isVSlot(p2) {
    return p2.type === 7 && p2.name === "slot";
  }
  function isTemplateNode(node) {
    return node.type === 1 && node.tagType === 3;
  }
  function isSlotOutlet(node) {
    return node.type === 1 && node.tagType === 2;
  }
  function getVNodeHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_VNODE : CREATE_ELEMENT_VNODE;
  }
  function getVNodeBlockHelper(ssr, isComponent2) {
    return ssr || isComponent2 ? CREATE_BLOCK : CREATE_ELEMENT_BLOCK;
  }
  function getUnnormalizedProps(props2, callPath = []) {
    if (props2 && !isString(props2) && props2.type === 14) {
      const callee = props2.callee;
      if (!isString(callee) && propsHelperSet.has(callee)) {
        return getUnnormalizedProps(props2.arguments[0], callPath.concat(props2));
      }
    }
    return [props2, callPath];
  }
  function injectProp(node, prop, context) {
    let propsWithInjection;
    const originalProps = node.type === 13 ? node.props : node.arguments[2];
    let props2 = originalProps;
    let callPath = [];
    let parentCall;
    if (props2 && !isString(props2) && props2.type === 14) {
      const ret = getUnnormalizedProps(props2);
      props2 = ret[0];
      callPath = ret[1];
      parentCall = callPath[callPath.length - 1];
    }
    if (props2 == null || isString(props2)) {
      propsWithInjection = createObjectExpression([prop]);
    } else if (props2.type === 14) {
      const first = props2.arguments[0];
      if (!isString(first) && first.type === 15) {
        first.properties.unshift(prop);
      } else {
        if (props2.callee === TO_HANDLERS) {
          propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
            createObjectExpression([prop]),
            props2
          ]);
        } else {
          props2.arguments.unshift(createObjectExpression([prop]));
        }
      }
      !propsWithInjection && (propsWithInjection = props2);
    } else if (props2.type === 15) {
      let alreadyExists = false;
      if (prop.key.type === 4) {
        const propKeyName = prop.key.content;
        alreadyExists = props2.properties.some((p2) => p2.key.type === 4 && p2.key.content === propKeyName);
      }
      if (!alreadyExists) {
        props2.properties.unshift(prop);
      }
      propsWithInjection = props2;
    } else {
      propsWithInjection = createCallExpression(context.helper(MERGE_PROPS), [
        createObjectExpression([prop]),
        props2
      ]);
      if (parentCall && parentCall.callee === GUARD_REACTIVE_PROPS) {
        parentCall = callPath[callPath.length - 2];
      }
    }
    if (node.type === 13) {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.props = propsWithInjection;
      }
    } else {
      if (parentCall) {
        parentCall.arguments[0] = propsWithInjection;
      } else {
        node.arguments[2] = propsWithInjection;
      }
    }
  }
  function toValidAssetId(name, type2) {
    return `_${type2}_${name.replace(/[^\w]/g, (searchValue, replaceValue) => {
      return searchValue === "-" ? "_" : name.charCodeAt(replaceValue).toString();
    })}`;
  }
  function getMemoedVNodeCall(node) {
    if (node.type === 14 && node.callee === WITH_MEMO) {
      return node.arguments[1].returns;
    } else {
      return node;
    }
  }
  function makeBlock(node, { helper, removeHelper, inSSR }) {
    if (!node.isBlock) {
      node.isBlock = true;
      removeHelper(getVNodeHelper(inSSR, node.isComponent));
      helper(OPEN_BLOCK);
      helper(getVNodeBlockHelper(inSSR, node.isComponent));
    }
  }
  function getCompatValue(key2, context) {
    const config = context.options ? context.options.compatConfig : context.compatConfig;
    const value2 = config && config[key2];
    if (key2 === "MODE") {
      return value2 || 3;
    } else {
      return value2;
    }
  }
  function isCompatEnabled(key2, context) {
    const mode = getCompatValue("MODE", context);
    const value2 = getCompatValue(key2, context);
    return mode === 3 ? value2 === true : value2 !== false;
  }
  function checkCompatEnabled(key2, context, loc, ...args) {
    const enabled = isCompatEnabled(key2, context);
    if (enabled) {
      warnDeprecation(key2, context, loc, ...args);
    }
    return enabled;
  }
  function warnDeprecation(key2, context, loc, ...args) {
    const val = getCompatValue(key2, context);
    if (val === "suppress-warning") {
      return;
    }
    const { message, link } = deprecationData2[key2];
    const msg = `(deprecation ${key2}) ${typeof message === "function" ? message(...args) : message}${link ? `
  Details: ${link}` : ``}`;
    const err = new SyntaxError(msg);
    err.code = key2;
    if (loc)
      err.loc = loc;
    context.onWarn(err);
  }
  function baseParse(content, options = {}) {
    const context = createParserContext(content, options);
    const start = getCursor(context);
    return createRoot(parseChildren(context, 0, []), getSelection(context, start));
  }
  function createParserContext(content, rawOptions) {
    const options = extend({}, defaultParserOptions);
    let key2;
    for (key2 in rawOptions) {
      options[key2] = rawOptions[key2] === void 0 ? defaultParserOptions[key2] : rawOptions[key2];
    }
    return {
      options,
      column: 1,
      line: 1,
      offset: 0,
      originalSource: content,
      source: content,
      inPre: false,
      inVPre: false,
      onWarn: options.onWarn
    };
  }
  function parseChildren(context, mode, ancestors) {
    const parent = last(ancestors);
    const ns = parent ? parent.ns : 0;
    const nodes = [];
    while (!isEnd(context, mode, ancestors)) {
      const s2 = context.source;
      let node = void 0;
      if (mode === 0 || mode === 1) {
        if (!context.inVPre && startsWith(s2, context.options.delimiters[0])) {
          node = parseInterpolation(context, mode);
        } else if (mode === 0 && s2[0] === "<") {
          if (s2.length === 1) {
            emitError(context, 5, 1);
          } else if (s2[1] === "!") {
            if (startsWith(s2, "<!--")) {
              node = parseComment(context);
            } else if (startsWith(s2, "<!DOCTYPE")) {
              node = parseBogusComment(context);
            } else if (startsWith(s2, "<![CDATA[")) {
              if (ns !== 0) {
                node = parseCDATA(context, ancestors);
              } else {
                emitError(context, 1);
                node = parseBogusComment(context);
              }
            } else {
              emitError(context, 11);
              node = parseBogusComment(context);
            }
          } else if (s2[1] === "/") {
            if (s2.length === 2) {
              emitError(context, 5, 2);
            } else if (s2[2] === ">") {
              emitError(context, 14, 2);
              advanceBy(context, 3);
              continue;
            } else if (/[a-z]/i.test(s2[2])) {
              emitError(context, 23);
              parseTag(context, 1, parent);
              continue;
            } else {
              emitError(context, 12, 2);
              node = parseBogusComment(context);
            }
          } else if (/[a-z]/i.test(s2[1])) {
            node = parseElement(context, ancestors);
            if (isCompatEnabled("COMPILER_NATIVE_TEMPLATE", context) && node && node.tag === "template" && !node.props.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
              warnDeprecation("COMPILER_NATIVE_TEMPLATE", context, node.loc);
              node = node.children;
            }
          } else if (s2[1] === "?") {
            emitError(context, 21, 1);
            node = parseBogusComment(context);
          } else {
            emitError(context, 12, 1);
          }
        }
      }
      if (!node) {
        node = parseText(context, mode);
      }
      if (isArray(node)) {
        for (let i = 0; i < node.length; i++) {
          pushNode(nodes, node[i]);
        }
      } else {
        pushNode(nodes, node);
      }
    }
    let removedWhitespace = false;
    if (mode !== 2 && mode !== 1) {
      const shouldCondense = context.options.whitespace !== "preserve";
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!context.inPre && node.type === 2) {
          if (!/[^\t\r\n\f ]/.test(node.content)) {
            const prev = nodes[i - 1];
            const next = nodes[i + 1];
            if (!prev || !next || shouldCondense && (prev.type === 3 || next.type === 3 || prev.type === 1 && next.type === 1 && /[\r\n]/.test(node.content))) {
              removedWhitespace = true;
              nodes[i] = null;
            } else {
              node.content = " ";
            }
          } else if (shouldCondense) {
            node.content = node.content.replace(/[\t\r\n\f ]+/g, " ");
          }
        } else if (node.type === 3 && !context.options.comments) {
          removedWhitespace = true;
          nodes[i] = null;
        }
      }
      if (context.inPre && parent && context.options.isPreTag(parent.tag)) {
        const first = nodes[0];
        if (first && first.type === 2) {
          first.content = first.content.replace(/^\r?\n/, "");
        }
      }
    }
    return removedWhitespace ? nodes.filter(Boolean) : nodes;
  }
  function pushNode(nodes, node) {
    if (node.type === 2) {
      const prev = last(nodes);
      if (prev && prev.type === 2 && prev.loc.end.offset === node.loc.start.offset) {
        prev.content += node.content;
        prev.loc.end = node.loc.end;
        prev.loc.source += node.loc.source;
        return;
      }
    }
    nodes.push(node);
  }
  function parseCDATA(context, ancestors) {
    advanceBy(context, 9);
    const nodes = parseChildren(context, 3, ancestors);
    if (context.source.length === 0) {
      emitError(context, 6);
    } else {
      advanceBy(context, 3);
    }
    return nodes;
  }
  function parseComment(context) {
    const start = getCursor(context);
    let content;
    const match = /--(\!)?>/.exec(context.source);
    if (!match) {
      content = context.source.slice(4);
      advanceBy(context, context.source.length);
      emitError(context, 7);
    } else {
      if (match.index <= 3) {
        emitError(context, 0);
      }
      if (match[1]) {
        emitError(context, 10);
      }
      content = context.source.slice(4, match.index);
      const s2 = context.source.slice(0, match.index);
      let prevIndex = 1, nestedIndex = 0;
      while ((nestedIndex = s2.indexOf("<!--", prevIndex)) !== -1) {
        advanceBy(context, nestedIndex - prevIndex + 1);
        if (nestedIndex + 4 < s2.length) {
          emitError(context, 16);
        }
        prevIndex = nestedIndex + 1;
      }
      advanceBy(context, match.index + match[0].length - prevIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseBogusComment(context) {
    const start = getCursor(context);
    const contentStart = context.source[1] === "?" ? 1 : 2;
    let content;
    const closeIndex = context.source.indexOf(">");
    if (closeIndex === -1) {
      content = context.source.slice(contentStart);
      advanceBy(context, context.source.length);
    } else {
      content = context.source.slice(contentStart, closeIndex);
      advanceBy(context, closeIndex + 1);
    }
    return {
      type: 3,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseElement(context, ancestors) {
    const wasInPre = context.inPre;
    const wasInVPre = context.inVPre;
    const parent = last(ancestors);
    const element = parseTag(context, 0, parent);
    const isPreBoundary = context.inPre && !wasInPre;
    const isVPreBoundary = context.inVPre && !wasInVPre;
    if (element.isSelfClosing || context.options.isVoidTag(element.tag)) {
      if (isPreBoundary) {
        context.inPre = false;
      }
      if (isVPreBoundary) {
        context.inVPre = false;
      }
      return element;
    }
    ancestors.push(element);
    const mode = context.options.getTextMode(element, parent);
    const children = parseChildren(context, mode, ancestors);
    ancestors.pop();
    {
      const inlineTemplateProp = element.props.find((p2) => p2.type === 6 && p2.name === "inline-template");
      if (inlineTemplateProp && checkCompatEnabled("COMPILER_INLINE_TEMPLATE", context, inlineTemplateProp.loc)) {
        const loc = getSelection(context, element.loc.end);
        inlineTemplateProp.value = {
          type: 2,
          content: loc.source,
          loc
        };
      }
    }
    element.children = children;
    if (startsWithEndTagOpen(context.source, element.tag)) {
      parseTag(context, 1, parent);
    } else {
      emitError(context, 24, 0, element.loc.start);
      if (context.source.length === 0 && element.tag.toLowerCase() === "script") {
        const first = children[0];
        if (first && startsWith(first.loc.source, "<!--")) {
          emitError(context, 8);
        }
      }
    }
    element.loc = getSelection(context, element.loc.start);
    if (isPreBoundary) {
      context.inPre = false;
    }
    if (isVPreBoundary) {
      context.inVPre = false;
    }
    return element;
  }
  function parseTag(context, type2, parent) {
    const start = getCursor(context);
    const match = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);
    const tag = match[1];
    const ns = context.options.getNamespace(tag, parent);
    advanceBy(context, match[0].length);
    advanceSpaces(context);
    const cursor = getCursor(context);
    const currentSource = context.source;
    if (context.options.isPreTag(tag)) {
      context.inPre = true;
    }
    let props2 = parseAttributes(context, type2);
    if (type2 === 0 && !context.inVPre && props2.some((p2) => p2.type === 7 && p2.name === "pre")) {
      context.inVPre = true;
      extend(context, cursor);
      context.source = currentSource;
      props2 = parseAttributes(context, type2).filter((p2) => p2.name !== "v-pre");
    }
    let isSelfClosing = false;
    if (context.source.length === 0) {
      emitError(context, 9);
    } else {
      isSelfClosing = startsWith(context.source, "/>");
      if (type2 === 1 && isSelfClosing) {
        emitError(context, 4);
      }
      advanceBy(context, isSelfClosing ? 2 : 1);
    }
    if (type2 === 1) {
      return;
    }
    if (isCompatEnabled("COMPILER_V_IF_V_FOR_PRECEDENCE", context)) {
      let hasIf = false;
      let hasFor = false;
      for (let i = 0; i < props2.length; i++) {
        const p2 = props2[i];
        if (p2.type === 7) {
          if (p2.name === "if") {
            hasIf = true;
          } else if (p2.name === "for") {
            hasFor = true;
          }
        }
        if (hasIf && hasFor) {
          warnDeprecation("COMPILER_V_IF_V_FOR_PRECEDENCE", context, getSelection(context, start));
        }
      }
    }
    let tagType = 0;
    if (!context.inVPre) {
      if (tag === "slot") {
        tagType = 2;
      } else if (tag === "template") {
        if (props2.some((p2) => p2.type === 7 && isSpecialTemplateDirective(p2.name))) {
          tagType = 3;
        }
      } else if (isComponent(tag, props2, context)) {
        tagType = 1;
      }
    }
    return {
      type: 1,
      ns,
      tag,
      tagType,
      props: props2,
      isSelfClosing,
      children: [],
      loc: getSelection(context, start),
      codegenNode: void 0
    };
  }
  function isComponent(tag, props2, context) {
    const options = context.options;
    if (options.isCustomElement(tag)) {
      return false;
    }
    if (tag === "component" || /^[A-Z]/.test(tag) || isCoreComponent(tag) || options.isBuiltInComponent && options.isBuiltInComponent(tag) || options.isNativeTag && !options.isNativeTag(tag)) {
      return true;
    }
    for (let i = 0; i < props2.length; i++) {
      const p2 = props2[i];
      if (p2.type === 6) {
        if (p2.name === "is" && p2.value) {
          if (p2.value.content.startsWith("vue:")) {
            return true;
          } else if (checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p2.loc)) {
            return true;
          }
        }
      } else {
        if (p2.name === "is") {
          return true;
        } else if (p2.name === "bind" && isBindKey(p2.arg, "is") && true && checkCompatEnabled("COMPILER_IS_ON_ELEMENT", context, p2.loc)) {
          return true;
        }
      }
    }
  }
  function parseAttributes(context, type2) {
    const props2 = [];
    const attributeNames = new Set();
    while (context.source.length > 0 && !startsWith(context.source, ">") && !startsWith(context.source, "/>")) {
      if (startsWith(context.source, "/")) {
        emitError(context, 22);
        advanceBy(context, 1);
        advanceSpaces(context);
        continue;
      }
      if (type2 === 1) {
        emitError(context, 3);
      }
      const attr = parseAttribute(context, attributeNames);
      if (attr.type === 6 && attr.value && attr.name === "class") {
        attr.value.content = attr.value.content.replace(/\s+/g, " ").trim();
      }
      if (type2 === 0) {
        props2.push(attr);
      }
      if (/^[^\t\r\n\f />]/.test(context.source)) {
        emitError(context, 15);
      }
      advanceSpaces(context);
    }
    return props2;
  }
  function parseAttribute(context, nameSet) {
    const start = getCursor(context);
    const match = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);
    const name = match[0];
    if (nameSet.has(name)) {
      emitError(context, 2);
    }
    nameSet.add(name);
    if (name[0] === "=") {
      emitError(context, 19);
    }
    {
      const pattern = /["'<]/g;
      let m;
      while (m = pattern.exec(name)) {
        emitError(context, 17, m.index);
      }
    }
    advanceBy(context, name.length);
    let value2 = void 0;
    if (/^[\t\r\n\f ]*=/.test(context.source)) {
      advanceSpaces(context);
      advanceBy(context, 1);
      advanceSpaces(context);
      value2 = parseAttributeValue(context);
      if (!value2) {
        emitError(context, 13);
      }
    }
    const loc = getSelection(context, start);
    if (!context.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)) {
      const match2 = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);
      let isPropShorthand = startsWith(name, ".");
      let dirName = match2[1] || (isPropShorthand || startsWith(name, ":") ? "bind" : startsWith(name, "@") ? "on" : "slot");
      let arg;
      if (match2[2]) {
        const isSlot = dirName === "slot";
        const startOffset = name.lastIndexOf(match2[2]);
        const loc2 = getSelection(context, getNewPosition(context, start, startOffset), getNewPosition(context, start, startOffset + match2[2].length + (isSlot && match2[3] || "").length));
        let content = match2[2];
        let isStatic = true;
        if (content.startsWith("[")) {
          isStatic = false;
          if (!content.endsWith("]")) {
            emitError(context, 27);
            content = content.substr(1);
          } else {
            content = content.substr(1, content.length - 2);
          }
        } else if (isSlot) {
          content += match2[3] || "";
        }
        arg = {
          type: 4,
          content,
          isStatic,
          constType: isStatic ? 3 : 0,
          loc: loc2
        };
      }
      if (value2 && value2.isQuoted) {
        const valueLoc = value2.loc;
        valueLoc.start.offset++;
        valueLoc.start.column++;
        valueLoc.end = advancePositionWithClone(valueLoc.start, value2.content);
        valueLoc.source = valueLoc.source.slice(1, -1);
      }
      const modifiers = match2[3] ? match2[3].substr(1).split(".") : [];
      if (isPropShorthand)
        modifiers.push("prop");
      if (dirName === "bind" && arg) {
        if (modifiers.includes("sync") && checkCompatEnabled("COMPILER_V_BIND_SYNC", context, loc, arg.loc.source)) {
          dirName = "model";
          modifiers.splice(modifiers.indexOf("sync"), 1);
        }
        if (modifiers.includes("prop")) {
          checkCompatEnabled("COMPILER_V_BIND_PROP", context, loc);
        }
      }
      return {
        type: 7,
        name: dirName,
        exp: value2 && {
          type: 4,
          content: value2.content,
          isStatic: false,
          constType: 0,
          loc: value2.loc
        },
        arg,
        modifiers,
        loc
      };
    }
    if (!context.inVPre && startsWith(name, "v-")) {
      emitError(context, 26);
    }
    return {
      type: 6,
      name,
      value: value2 && {
        type: 2,
        content: value2.content,
        loc: value2.loc
      },
      loc
    };
  }
  function parseAttributeValue(context) {
    const start = getCursor(context);
    let content;
    const quote = context.source[0];
    const isQuoted = quote === `"` || quote === `'`;
    if (isQuoted) {
      advanceBy(context, 1);
      const endIndex = context.source.indexOf(quote);
      if (endIndex === -1) {
        content = parseTextData(context, context.source.length, 4);
      } else {
        content = parseTextData(context, endIndex, 4);
        advanceBy(context, 1);
      }
    } else {
      const match = /^[^\t\r\n\f >]+/.exec(context.source);
      if (!match) {
        return void 0;
      }
      const unexpectedChars = /["'<=`]/g;
      let m;
      while (m = unexpectedChars.exec(match[0])) {
        emitError(context, 18, m.index);
      }
      content = parseTextData(context, match[0].length, 4);
    }
    return { content, isQuoted, loc: getSelection(context, start) };
  }
  function parseInterpolation(context, mode) {
    const [open, close] = context.options.delimiters;
    const closeIndex = context.source.indexOf(close, open.length);
    if (closeIndex === -1) {
      emitError(context, 25);
      return void 0;
    }
    const start = getCursor(context);
    advanceBy(context, open.length);
    const innerStart = getCursor(context);
    const innerEnd = getCursor(context);
    const rawContentLength = closeIndex - open.length;
    const rawContent = context.source.slice(0, rawContentLength);
    const preTrimContent = parseTextData(context, rawContentLength, mode);
    const content = preTrimContent.trim();
    const startOffset = preTrimContent.indexOf(content);
    if (startOffset > 0) {
      advancePositionWithMutation(innerStart, rawContent, startOffset);
    }
    const endOffset = rawContentLength - (preTrimContent.length - content.length - startOffset);
    advancePositionWithMutation(innerEnd, rawContent, endOffset);
    advanceBy(context, close.length);
    return {
      type: 5,
      content: {
        type: 4,
        isStatic: false,
        constType: 0,
        content,
        loc: getSelection(context, innerStart, innerEnd)
      },
      loc: getSelection(context, start)
    };
  }
  function parseText(context, mode) {
    const endTokens = mode === 3 ? ["]]>"] : ["<", context.options.delimiters[0]];
    let endIndex = context.source.length;
    for (let i = 0; i < endTokens.length; i++) {
      const index = context.source.indexOf(endTokens[i], 1);
      if (index !== -1 && endIndex > index) {
        endIndex = index;
      }
    }
    const start = getCursor(context);
    const content = parseTextData(context, endIndex, mode);
    return {
      type: 2,
      content,
      loc: getSelection(context, start)
    };
  }
  function parseTextData(context, length, mode) {
    const rawText = context.source.slice(0, length);
    advanceBy(context, length);
    if (mode === 2 || mode === 3 || rawText.indexOf("&") === -1) {
      return rawText;
    } else {
      return context.options.decodeEntities(rawText, mode === 4);
    }
  }
  function getCursor(context) {
    const { column, line, offset: offset2 } = context;
    return { column, line, offset: offset2 };
  }
  function getSelection(context, start, end) {
    end = end || getCursor(context);
    return {
      start,
      end,
      source: context.originalSource.slice(start.offset, end.offset)
    };
  }
  function last(xs) {
    return xs[xs.length - 1];
  }
  function startsWith(source, searchString) {
    return source.startsWith(searchString);
  }
  function advanceBy(context, numberOfCharacters) {
    const { source } = context;
    advancePositionWithMutation(context, source, numberOfCharacters);
    context.source = source.slice(numberOfCharacters);
  }
  function advanceSpaces(context) {
    const match = /^[\t\r\n\f ]+/.exec(context.source);
    if (match) {
      advanceBy(context, match[0].length);
    }
  }
  function getNewPosition(context, start, numberOfCharacters) {
    return advancePositionWithClone(start, context.originalSource.slice(start.offset, numberOfCharacters), numberOfCharacters);
  }
  function emitError(context, code, offset2, loc = getCursor(context)) {
    if (offset2) {
      loc.offset += offset2;
      loc.column += offset2;
    }
    context.options.onError(createCompilerError(code, {
      start: loc,
      end: loc,
      source: ""
    }));
  }
  function isEnd(context, mode, ancestors) {
    const s2 = context.source;
    switch (mode) {
      case 0:
        if (startsWith(s2, "</")) {
          for (let i = ancestors.length - 1; i >= 0; --i) {
            if (startsWithEndTagOpen(s2, ancestors[i].tag)) {
              return true;
            }
          }
        }
        break;
      case 1:
      case 2: {
        const parent = last(ancestors);
        if (parent && startsWithEndTagOpen(s2, parent.tag)) {
          return true;
        }
        break;
      }
      case 3:
        if (startsWith(s2, "]]>")) {
          return true;
        }
        break;
    }
    return !s2;
  }
  function startsWithEndTagOpen(source, tag) {
    return startsWith(source, "</") && source.substr(2, tag.length).toLowerCase() === tag.toLowerCase() && /[\t\r\n\f />]/.test(source[2 + tag.length] || ">");
  }
  function hoistStatic(root, context) {
    walk(root, context, isSingleElementRoot(root, root.children[0]));
  }
  function isSingleElementRoot(root, child) {
    const { children } = root;
    return children.length === 1 && child.type === 1 && !isSlotOutlet(child);
  }
  function walk(node, context, doNotHoistNode = false) {
    let canStringify = true;
    const { children } = node;
    const originalCount = children.length;
    let hoistedCount = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.type === 1 && child.tagType === 0) {
        const constantType = doNotHoistNode ? 0 : getConstantType(child, context);
        if (constantType > 0) {
          if (constantType < 3) {
            canStringify = false;
          }
          if (constantType >= 2) {
            child.codegenNode.patchFlag = -1 + (true ? ` /* HOISTED */` : ``);
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
            continue;
          }
        } else {
          const codegenNode = child.codegenNode;
          if (codegenNode.type === 13) {
            const flag = getPatchFlag(codegenNode);
            if ((!flag || flag === 512 || flag === 1) && getGeneratedPropsConstantType(child, context) >= 2) {
              const props2 = getNodeProps(child);
              if (props2) {
                codegenNode.props = context.hoist(props2);
              }
            }
            if (codegenNode.dynamicProps) {
              codegenNode.dynamicProps = context.hoist(codegenNode.dynamicProps);
            }
          }
        }
      } else if (child.type === 12) {
        const contentType = getConstantType(child.content, context);
        if (contentType > 0) {
          if (contentType < 3) {
            canStringify = false;
          }
          if (contentType >= 2) {
            child.codegenNode = context.hoist(child.codegenNode);
            hoistedCount++;
          }
        }
      }
      if (child.type === 1) {
        const isComponent2 = child.tagType === 1;
        if (isComponent2) {
          context.scopes.vSlot++;
        }
        walk(child, context);
        if (isComponent2) {
          context.scopes.vSlot--;
        }
      } else if (child.type === 11) {
        walk(child, context, child.children.length === 1);
      } else if (child.type === 9) {
        for (let i2 = 0; i2 < child.branches.length; i2++) {
          walk(child.branches[i2], context, child.branches[i2].children.length === 1);
        }
      }
    }
    if (canStringify && hoistedCount && context.transformHoist) {
      context.transformHoist(children, context, node);
    }
    if (hoistedCount && hoistedCount === originalCount && node.type === 1 && node.tagType === 0 && node.codegenNode && node.codegenNode.type === 13 && isArray(node.codegenNode.children)) {
      node.codegenNode.children = context.hoist(createArrayExpression(node.codegenNode.children));
    }
  }
  function getConstantType(node, context) {
    const { constantCache } = context;
    switch (node.type) {
      case 1:
        if (node.tagType !== 0) {
          return 0;
        }
        const cached = constantCache.get(node);
        if (cached !== void 0) {
          return cached;
        }
        const codegenNode = node.codegenNode;
        if (codegenNode.type !== 13) {
          return 0;
        }
        const flag = getPatchFlag(codegenNode);
        if (!flag) {
          let returnType2 = 3;
          const generatedPropsType = getGeneratedPropsConstantType(node, context);
          if (generatedPropsType === 0) {
            constantCache.set(node, 0);
            return 0;
          }
          if (generatedPropsType < returnType2) {
            returnType2 = generatedPropsType;
          }
          for (let i = 0; i < node.children.length; i++) {
            const childType = getConstantType(node.children[i], context);
            if (childType === 0) {
              constantCache.set(node, 0);
              return 0;
            }
            if (childType < returnType2) {
              returnType2 = childType;
            }
          }
          if (returnType2 > 1) {
            for (let i = 0; i < node.props.length; i++) {
              const p2 = node.props[i];
              if (p2.type === 7 && p2.name === "bind" && p2.exp) {
                const expType = getConstantType(p2.exp, context);
                if (expType === 0) {
                  constantCache.set(node, 0);
                  return 0;
                }
                if (expType < returnType2) {
                  returnType2 = expType;
                }
              }
            }
          }
          if (codegenNode.isBlock) {
            context.removeHelper(OPEN_BLOCK);
            context.removeHelper(getVNodeBlockHelper(context.inSSR, codegenNode.isComponent));
            codegenNode.isBlock = false;
            context.helper(getVNodeHelper(context.inSSR, codegenNode.isComponent));
          }
          constantCache.set(node, returnType2);
          return returnType2;
        } else {
          constantCache.set(node, 0);
          return 0;
        }
      case 2:
      case 3:
        return 3;
      case 9:
      case 11:
      case 10:
        return 0;
      case 5:
      case 12:
        return getConstantType(node.content, context);
      case 4:
        return node.constType;
      case 8:
        let returnType = 3;
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i];
          if (isString(child) || isSymbol(child)) {
            continue;
          }
          const childType = getConstantType(child, context);
          if (childType === 0) {
            return 0;
          } else if (childType < returnType) {
            returnType = childType;
          }
        }
        return returnType;
      default:
        if (true)
          ;
        return 0;
    }
  }
  function getConstantTypeOfHelperCall(value2, context) {
    if (value2.type === 14 && !isString(value2.callee) && allowHoistedHelperSet.has(value2.callee)) {
      const arg = value2.arguments[0];
      if (arg.type === 4) {
        return getConstantType(arg, context);
      } else if (arg.type === 14) {
        return getConstantTypeOfHelperCall(arg, context);
      }
    }
    return 0;
  }
  function getGeneratedPropsConstantType(node, context) {
    let returnType = 3;
    const props2 = getNodeProps(node);
    if (props2 && props2.type === 15) {
      const { properties } = props2;
      for (let i = 0; i < properties.length; i++) {
        const { key: key2, value: value2 } = properties[i];
        const keyType = getConstantType(key2, context);
        if (keyType === 0) {
          return keyType;
        }
        if (keyType < returnType) {
          returnType = keyType;
        }
        let valueType;
        if (value2.type === 4) {
          valueType = getConstantType(value2, context);
        } else if (value2.type === 14) {
          valueType = getConstantTypeOfHelperCall(value2, context);
        } else {
          valueType = 0;
        }
        if (valueType === 0) {
          return valueType;
        }
        if (valueType < returnType) {
          returnType = valueType;
        }
      }
    }
    return returnType;
  }
  function getNodeProps(node) {
    const codegenNode = node.codegenNode;
    if (codegenNode.type === 13) {
      return codegenNode.props;
    }
  }
  function getPatchFlag(node) {
    const flag = node.patchFlag;
    return flag ? parseInt(flag, 10) : void 0;
  }
  function createTransformContext(root, { filename = "", prefixIdentifiers = false, hoistStatic: hoistStatic2 = false, cacheHandlers = false, nodeTransforms = [], directiveTransforms = {}, transformHoist = null, isBuiltInComponent = NOOP, isCustomElement = NOOP, expressionPlugins = [], scopeId = null, slotted = true, ssr = false, inSSR = false, ssrCssVars = ``, bindingMetadata = EMPTY_OBJ, inline = false, isTS = false, onError = defaultOnError, onWarn = defaultOnWarn, compatConfig }) {
    const nameMatch = filename.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/);
    const context = {
      selfName: nameMatch && capitalize(camelize(nameMatch[1])),
      prefixIdentifiers,
      hoistStatic: hoistStatic2,
      cacheHandlers,
      nodeTransforms,
      directiveTransforms,
      transformHoist,
      isBuiltInComponent,
      isCustomElement,
      expressionPlugins,
      scopeId,
      slotted,
      ssr,
      inSSR,
      ssrCssVars,
      bindingMetadata,
      inline,
      isTS,
      onError,
      onWarn,
      compatConfig,
      root,
      helpers: new Map(),
      components: new Set(),
      directives: new Set(),
      hoists: [],
      imports: [],
      constantCache: new Map(),
      temps: 0,
      cached: 0,
      identifiers: Object.create(null),
      scopes: {
        vFor: 0,
        vSlot: 0,
        vPre: 0,
        vOnce: 0
      },
      parent: null,
      currentNode: root,
      childIndex: 0,
      inVOnce: false,
      helper(name) {
        const count = context.helpers.get(name) || 0;
        context.helpers.set(name, count + 1);
        return name;
      },
      removeHelper(name) {
        const count = context.helpers.get(name);
        if (count) {
          const currentCount = count - 1;
          if (!currentCount) {
            context.helpers.delete(name);
          } else {
            context.helpers.set(name, currentCount);
          }
        }
      },
      helperString(name) {
        return `_${helperNameMap[context.helper(name)]}`;
      },
      replaceNode(node) {
        if (true) {
          if (!context.currentNode) {
            throw new Error(`Node being replaced is already removed.`);
          }
          if (!context.parent) {
            throw new Error(`Cannot replace root node.`);
          }
        }
        context.parent.children[context.childIndex] = context.currentNode = node;
      },
      removeNode(node) {
        if (!context.parent) {
          throw new Error(`Cannot remove root node.`);
        }
        const list = context.parent.children;
        const removalIndex = node ? list.indexOf(node) : context.currentNode ? context.childIndex : -1;
        if (removalIndex < 0) {
          throw new Error(`node being removed is not a child of current parent`);
        }
        if (!node || node === context.currentNode) {
          context.currentNode = null;
          context.onNodeRemoved();
        } else {
          if (context.childIndex > removalIndex) {
            context.childIndex--;
            context.onNodeRemoved();
          }
        }
        context.parent.children.splice(removalIndex, 1);
      },
      onNodeRemoved: () => {
      },
      addIdentifiers(exp) {
      },
      removeIdentifiers(exp) {
      },
      hoist(exp) {
        if (isString(exp))
          exp = createSimpleExpression(exp);
        context.hoists.push(exp);
        const identifier = createSimpleExpression(`_hoisted_${context.hoists.length}`, false, exp.loc, 2);
        identifier.hoisted = exp;
        return identifier;
      },
      cache(exp, isVNode2 = false) {
        return createCacheExpression(context.cached++, exp, isVNode2);
      }
    };
    {
      context.filters = new Set();
    }
    return context;
  }
  function transform(root, options) {
    const context = createTransformContext(root, options);
    traverseNode(root, context);
    if (options.hoistStatic) {
      hoistStatic(root, context);
    }
    if (!options.ssr) {
      createRootCodegen(root, context);
    }
    root.helpers = [...context.helpers.keys()];
    root.components = [...context.components];
    root.directives = [...context.directives];
    root.imports = context.imports;
    root.hoists = context.hoists;
    root.temps = context.temps;
    root.cached = context.cached;
    {
      root.filters = [...context.filters];
    }
  }
  function createRootCodegen(root, context) {
    const { helper } = context;
    const { children } = root;
    if (children.length === 1) {
      const child = children[0];
      if (isSingleElementRoot(root, child) && child.codegenNode) {
        const codegenNode = child.codegenNode;
        if (codegenNode.type === 13) {
          makeBlock(codegenNode, context);
        }
        root.codegenNode = codegenNode;
      } else {
        root.codegenNode = child;
      }
    } else if (children.length > 1) {
      let patchFlag = 64;
      let patchFlagText = PatchFlagNames[64];
      if (children.filter((c) => c.type !== 3).length === 1) {
        patchFlag |= 2048;
        patchFlagText += `, ${PatchFlagNames[2048]}`;
      }
      root.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, root.children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, void 0, false);
    } else
      ;
  }
  function traverseChildren(parent, context) {
    let i = 0;
    const nodeRemoved = () => {
      i--;
    };
    for (; i < parent.children.length; i++) {
      const child = parent.children[i];
      if (isString(child))
        continue;
      context.parent = parent;
      context.childIndex = i;
      context.onNodeRemoved = nodeRemoved;
      traverseNode(child, context);
    }
  }
  function traverseNode(node, context) {
    context.currentNode = node;
    const { nodeTransforms } = context;
    const exitFns = [];
    for (let i2 = 0; i2 < nodeTransforms.length; i2++) {
      const onExit = nodeTransforms[i2](node, context);
      if (onExit) {
        if (isArray(onExit)) {
          exitFns.push(...onExit);
        } else {
          exitFns.push(onExit);
        }
      }
      if (!context.currentNode) {
        return;
      } else {
        node = context.currentNode;
      }
    }
    switch (node.type) {
      case 3:
        if (!context.ssr) {
          context.helper(CREATE_COMMENT);
        }
        break;
      case 5:
        if (!context.ssr) {
          context.helper(TO_DISPLAY_STRING);
        }
        break;
      case 9:
        for (let i2 = 0; i2 < node.branches.length; i2++) {
          traverseNode(node.branches[i2], context);
        }
        break;
      case 10:
      case 11:
      case 1:
      case 0:
        traverseChildren(node, context);
        break;
    }
    context.currentNode = node;
    let i = exitFns.length;
    while (i--) {
      exitFns[i]();
    }
  }
  function createStructuralDirectiveTransform(name, fn) {
    const matches2 = isString(name) ? (n) => n === name : (n) => name.test(n);
    return (node, context) => {
      if (node.type === 1) {
        const { props: props2 } = node;
        if (node.tagType === 3 && props2.some(isVSlot)) {
          return;
        }
        const exitFns = [];
        for (let i = 0; i < props2.length; i++) {
          const prop = props2[i];
          if (prop.type === 7 && matches2(prop.name)) {
            props2.splice(i, 1);
            i--;
            const onExit = fn(node, prop, context);
            if (onExit)
              exitFns.push(onExit);
          }
        }
        return exitFns;
      }
    };
  }
  function createCodegenContext(ast, { mode = "function", prefixIdentifiers = mode === "module", sourceMap = false, filename = `template.vue.html`, scopeId = null, optimizeImports = false, runtimeGlobalName = `Vue`, runtimeModuleName = `vue`, ssr = false, isTS = false, inSSR = false }) {
    const context = {
      mode,
      prefixIdentifiers,
      sourceMap,
      filename,
      scopeId,
      optimizeImports,
      runtimeGlobalName,
      runtimeModuleName,
      ssr,
      isTS,
      inSSR,
      source: ast.loc.source,
      code: ``,
      column: 1,
      line: 1,
      offset: 0,
      indentLevel: 0,
      pure: false,
      map: void 0,
      helper(key2) {
        return `_${helperNameMap[key2]}`;
      },
      push(code, node) {
        context.code += code;
      },
      indent() {
        newline(++context.indentLevel);
      },
      deindent(withoutNewLine = false) {
        if (withoutNewLine) {
          --context.indentLevel;
        } else {
          newline(--context.indentLevel);
        }
      },
      newline() {
        newline(context.indentLevel);
      }
    };
    function newline(n) {
      context.push("\n" + `  `.repeat(n));
    }
    return context;
  }
  function generate(ast, options = {}) {
    const context = createCodegenContext(ast, options);
    if (options.onContextCreated)
      options.onContextCreated(context);
    const { mode, push, prefixIdentifiers, indent, deindent, newline, scopeId, ssr } = context;
    const hasHelpers = ast.helpers.length > 0;
    const useWithBlock = !prefixIdentifiers && mode !== "module";
    const preambleContext = context;
    {
      genFunctionPreamble(ast, preambleContext);
    }
    const functionName = ssr ? `ssrRender` : `render`;
    const args = ssr ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
    const signature = args.join(", ");
    {
      push(`function ${functionName}(${signature}) {`);
    }
    indent();
    if (useWithBlock) {
      push(`with (_ctx) {`);
      indent();
      if (hasHelpers) {
        push(`const { ${ast.helpers.map((s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`).join(", ")} } = _Vue`);
        push(`
`);
        newline();
      }
    }
    if (ast.components.length) {
      genAssets(ast.components, "component", context);
      if (ast.directives.length || ast.temps > 0) {
        newline();
      }
    }
    if (ast.directives.length) {
      genAssets(ast.directives, "directive", context);
      if (ast.temps > 0) {
        newline();
      }
    }
    if (ast.filters && ast.filters.length) {
      newline();
      genAssets(ast.filters, "filter", context);
      newline();
    }
    if (ast.temps > 0) {
      push(`let `);
      for (let i = 0; i < ast.temps; i++) {
        push(`${i > 0 ? `, ` : ``}_temp${i}`);
      }
    }
    if (ast.components.length || ast.directives.length || ast.temps) {
      push(`
`);
      newline();
    }
    if (!ssr) {
      push(`return `);
    }
    if (ast.codegenNode) {
      genNode(ast.codegenNode, context);
    } else {
      push(`null`);
    }
    if (useWithBlock) {
      deindent();
      push(`}`);
    }
    deindent();
    push(`}`);
    return {
      ast,
      code: context.code,
      preamble: ``,
      map: context.map ? context.map.toJSON() : void 0
    };
  }
  function genFunctionPreamble(ast, context) {
    const { ssr, prefixIdentifiers, push, newline, runtimeModuleName, runtimeGlobalName } = context;
    const VueBinding = runtimeGlobalName;
    const aliasHelper = (s2) => `${helperNameMap[s2]}: _${helperNameMap[s2]}`;
    if (ast.helpers.length > 0) {
      {
        push(`const _Vue = ${VueBinding}
`);
        if (ast.hoists.length) {
          const staticHelpers = [
            CREATE_VNODE,
            CREATE_ELEMENT_VNODE,
            CREATE_COMMENT,
            CREATE_TEXT,
            CREATE_STATIC
          ].filter((helper) => ast.helpers.includes(helper)).map(aliasHelper).join(", ");
          push(`const { ${staticHelpers} } = _Vue
`);
        }
      }
    }
    genHoists(ast.hoists, context);
    newline();
    push(`return `);
  }
  function genAssets(assets, type2, { helper, push, newline, isTS }) {
    const resolver = helper(type2 === "filter" ? RESOLVE_FILTER : type2 === "component" ? RESOLVE_COMPONENT : RESOLVE_DIRECTIVE);
    for (let i = 0; i < assets.length; i++) {
      let id2 = assets[i];
      const maybeSelfReference = id2.endsWith("__self");
      if (maybeSelfReference) {
        id2 = id2.slice(0, -6);
      }
      push(`const ${toValidAssetId(id2, type2)} = ${resolver}(${JSON.stringify(id2)}${maybeSelfReference ? `, true` : ``})${isTS ? `!` : ``}`);
      if (i < assets.length - 1) {
        newline();
      }
    }
  }
  function genHoists(hoists, context) {
    if (!hoists.length) {
      return;
    }
    context.pure = true;
    const { push, newline, helper, scopeId, mode } = context;
    newline();
    hoists.forEach((exp, i) => {
      if (exp) {
        push(`const _hoisted_${i + 1} = `);
        genNode(exp, context);
        newline();
      }
    });
    context.pure = false;
  }
  function isText$1(n) {
    return isString(n) || n.type === 4 || n.type === 2 || n.type === 5 || n.type === 8;
  }
  function genNodeListAsArray(nodes, context) {
    const multilines = nodes.length > 3 || nodes.some((n) => isArray(n) || !isText$1(n));
    context.push(`[`);
    multilines && context.indent();
    genNodeList(nodes, context, multilines);
    multilines && context.deindent();
    context.push(`]`);
  }
  function genNodeList(nodes, context, multilines = false, comma2 = true) {
    const { push, newline } = context;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (isString(node)) {
        push(node);
      } else if (isArray(node)) {
        genNodeListAsArray(node, context);
      } else {
        genNode(node, context);
      }
      if (i < nodes.length - 1) {
        if (multilines) {
          comma2 && push(",");
          newline();
        } else {
          comma2 && push(", ");
        }
      }
    }
  }
  function genNode(node, context) {
    if (isString(node)) {
      context.push(node);
      return;
    }
    if (isSymbol(node)) {
      context.push(context.helper(node));
      return;
    }
    switch (node.type) {
      case 1:
      case 9:
      case 11:
        assert(node.codegenNode != null, `Codegen node is missing for element/if/for node. Apply appropriate transforms first.`);
        genNode(node.codegenNode, context);
        break;
      case 2:
        genText(node, context);
        break;
      case 4:
        genExpression(node, context);
        break;
      case 5:
        genInterpolation(node, context);
        break;
      case 12:
        genNode(node.codegenNode, context);
        break;
      case 8:
        genCompoundExpression(node, context);
        break;
      case 3:
        genComment(node, context);
        break;
      case 13:
        genVNodeCall(node, context);
        break;
      case 14:
        genCallExpression(node, context);
        break;
      case 15:
        genObjectExpression(node, context);
        break;
      case 17:
        genArrayExpression(node, context);
        break;
      case 18:
        genFunctionExpression(node, context);
        break;
      case 19:
        genConditionalExpression(node, context);
        break;
      case 20:
        genCacheExpression(node, context);
        break;
      case 21:
        genNodeList(node.body, context, true, false);
        break;
      case 22:
        break;
      case 23:
        break;
      case 24:
        break;
      case 25:
        break;
      case 26:
        break;
      case 10:
        break;
      default:
        if (true) {
          assert(false, `unhandled codegen node type: ${node.type}`);
          const exhaustiveCheck = node;
          return exhaustiveCheck;
        }
    }
  }
  function genText(node, context) {
    context.push(JSON.stringify(node.content), node);
  }
  function genExpression(node, context) {
    const { content, isStatic } = node;
    context.push(isStatic ? JSON.stringify(content) : content, node);
  }
  function genInterpolation(node, context) {
    const { push, helper, pure: pure2 } = context;
    if (pure2)
      push(PURE_ANNOTATION);
    push(`${helper(TO_DISPLAY_STRING)}(`);
    genNode(node.content, context);
    push(`)`);
  }
  function genCompoundExpression(node, context) {
    for (let i = 0; i < node.children.length; i++) {
      const child = node.children[i];
      if (isString(child)) {
        context.push(child);
      } else {
        genNode(child, context);
      }
    }
  }
  function genExpressionAsPropertyKey(node, context) {
    const { push } = context;
    if (node.type === 8) {
      push(`[`);
      genCompoundExpression(node, context);
      push(`]`);
    } else if (node.isStatic) {
      const text = isSimpleIdentifier(node.content) ? node.content : JSON.stringify(node.content);
      push(text, node);
    } else {
      push(`[${node.content}]`, node);
    }
  }
  function genComment(node, context) {
    const { push, helper, pure: pure2 } = context;
    if (pure2) {
      push(PURE_ANNOTATION);
    }
    push(`${helper(CREATE_COMMENT)}(${JSON.stringify(node.content)})`, node);
  }
  function genVNodeCall(node, context) {
    const { push, helper, pure: pure2 } = context;
    const { tag, props: props2, children, patchFlag, dynamicProps, directives: directives2, isBlock, disableTracking, isComponent: isComponent2 } = node;
    if (directives2) {
      push(helper(WITH_DIRECTIVES) + `(`);
    }
    if (isBlock) {
      push(`(${helper(OPEN_BLOCK)}(${disableTracking ? `true` : ``}), `);
    }
    if (pure2) {
      push(PURE_ANNOTATION);
    }
    const callHelper = isBlock ? getVNodeBlockHelper(context.inSSR, isComponent2) : getVNodeHelper(context.inSSR, isComponent2);
    push(helper(callHelper) + `(`, node);
    genNodeList(genNullableArgs([tag, props2, children, patchFlag, dynamicProps]), context);
    push(`)`);
    if (isBlock) {
      push(`)`);
    }
    if (directives2) {
      push(`, `);
      genNode(directives2, context);
      push(`)`);
    }
  }
  function genNullableArgs(args) {
    let i = args.length;
    while (i--) {
      if (args[i] != null)
        break;
    }
    return args.slice(0, i + 1).map((arg) => arg || `null`);
  }
  function genCallExpression(node, context) {
    const { push, helper, pure: pure2 } = context;
    const callee = isString(node.callee) ? node.callee : helper(node.callee);
    if (pure2) {
      push(PURE_ANNOTATION);
    }
    push(callee + `(`, node);
    genNodeList(node.arguments, context);
    push(`)`);
  }
  function genObjectExpression(node, context) {
    const { push, indent, deindent, newline } = context;
    const { properties } = node;
    if (!properties.length) {
      push(`{}`, node);
      return;
    }
    const multilines = properties.length > 1 || properties.some((p2) => p2.value.type !== 4);
    push(multilines ? `{` : `{ `);
    multilines && indent();
    for (let i = 0; i < properties.length; i++) {
      const { key: key2, value: value2 } = properties[i];
      genExpressionAsPropertyKey(key2, context);
      push(`: `);
      genNode(value2, context);
      if (i < properties.length - 1) {
        push(`,`);
        newline();
      }
    }
    multilines && deindent();
    push(multilines ? `}` : ` }`);
  }
  function genArrayExpression(node, context) {
    genNodeListAsArray(node.elements, context);
  }
  function genFunctionExpression(node, context) {
    const { push, indent, deindent } = context;
    const { params, returns, body, newline, isSlot } = node;
    if (isSlot) {
      push(`_${helperNameMap[WITH_CTX]}(`);
    }
    push(`(`, node);
    if (isArray(params)) {
      genNodeList(params, context);
    } else if (params) {
      genNode(params, context);
    }
    push(`) => `);
    if (newline || body) {
      push(`{`);
      indent();
    }
    if (returns) {
      if (newline) {
        push(`return `);
      }
      if (isArray(returns)) {
        genNodeListAsArray(returns, context);
      } else {
        genNode(returns, context);
      }
    } else if (body) {
      genNode(body, context);
    }
    if (newline || body) {
      deindent();
      push(`}`);
    }
    if (isSlot) {
      if (node.isNonScopedSlot) {
        push(`, undefined, true`);
      }
      push(`)`);
    }
  }
  function genConditionalExpression(node, context) {
    const { test, consequent, alternate, newline: needNewline } = node;
    const { push, indent, deindent, newline } = context;
    if (test.type === 4) {
      const needsParens = !isSimpleIdentifier(test.content);
      needsParens && push(`(`);
      genExpression(test, context);
      needsParens && push(`)`);
    } else {
      push(`(`);
      genNode(test, context);
      push(`)`);
    }
    needNewline && indent();
    context.indentLevel++;
    needNewline || push(` `);
    push(`? `);
    genNode(consequent, context);
    context.indentLevel--;
    needNewline && newline();
    needNewline || push(` `);
    push(`: `);
    const isNested = alternate.type === 19;
    if (!isNested) {
      context.indentLevel++;
    }
    genNode(alternate, context);
    if (!isNested) {
      context.indentLevel--;
    }
    needNewline && deindent(true);
  }
  function genCacheExpression(node, context) {
    const { push, helper, indent, deindent, newline } = context;
    push(`_cache[${node.index}] || (`);
    if (node.isVNode) {
      indent();
      push(`${helper(SET_BLOCK_TRACKING)}(-1),`);
      newline();
    }
    push(`_cache[${node.index}] = `);
    genNode(node.value, context);
    if (node.isVNode) {
      push(`,`);
      newline();
      push(`${helper(SET_BLOCK_TRACKING)}(1),`);
      newline();
      push(`_cache[${node.index}]`);
      deindent();
    }
    push(`)`);
  }
  function validateBrowserExpression(node, context, asParams = false, asRawStatements = false) {
    const exp = node.content;
    if (!exp.trim()) {
      return;
    }
    try {
      new Function(asRawStatements ? ` ${exp} ` : `return ${asParams ? `(${exp}) => {}` : `(${exp})`}`);
    } catch (e) {
      let message = e.message;
      const keywordMatch = exp.replace(stripStringRE, "").match(prohibitedKeywordRE);
      if (keywordMatch) {
        message = `avoid using JavaScript keyword as property name: "${keywordMatch[0]}"`;
      }
      context.onError(createCompilerError(44, node.loc, void 0, message));
    }
  }
  function processExpression(node, context, asParams = false, asRawStatements = false, localVars = Object.create(context.identifiers)) {
    {
      if (true) {
        validateBrowserExpression(node, context, asParams, asRawStatements);
      }
      return node;
    }
  }
  function processIf(node, dir, context, processCodegen) {
    if (dir.name !== "else" && (!dir.exp || !dir.exp.content.trim())) {
      const loc = dir.exp ? dir.exp.loc : node.loc;
      context.onError(createCompilerError(28, dir.loc));
      dir.exp = createSimpleExpression(`true`, false, loc);
    }
    if (dir.exp) {
      validateBrowserExpression(dir.exp, context);
    }
    if (dir.name === "if") {
      const branch = createIfBranch(node, dir);
      const ifNode = {
        type: 9,
        loc: node.loc,
        branches: [branch]
      };
      context.replaceNode(ifNode);
      if (processCodegen) {
        return processCodegen(ifNode, branch, true);
      }
    } else {
      const siblings = context.parent.children;
      const comments = [];
      let i = siblings.indexOf(node);
      while (i-- >= -1) {
        const sibling = siblings[i];
        if (sibling && sibling.type === 3) {
          context.removeNode(sibling);
          comments.unshift(sibling);
          continue;
        }
        if (sibling && sibling.type === 2 && !sibling.content.trim().length) {
          context.removeNode(sibling);
          continue;
        }
        if (sibling && sibling.type === 9) {
          context.removeNode();
          const branch = createIfBranch(node, dir);
          if (comments.length && !(context.parent && context.parent.type === 1 && isBuiltInType(context.parent.tag, "transition"))) {
            branch.children = [...comments, ...branch.children];
          }
          if (true) {
            const key2 = branch.userKey;
            if (key2) {
              sibling.branches.forEach(({ userKey }) => {
                if (isSameKey(userKey, key2)) {
                  context.onError(createCompilerError(29, branch.userKey.loc));
                }
              });
            }
          }
          sibling.branches.push(branch);
          const onExit = processCodegen && processCodegen(sibling, branch, false);
          traverseNode(branch, context);
          if (onExit)
            onExit();
          context.currentNode = null;
        } else {
          context.onError(createCompilerError(30, node.loc));
        }
        break;
      }
    }
  }
  function createIfBranch(node, dir) {
    return {
      type: 10,
      loc: node.loc,
      condition: dir.name === "else" ? void 0 : dir.exp,
      children: node.tagType === 3 && !findDir(node, "for") ? node.children : [node],
      userKey: findProp(node, `key`)
    };
  }
  function createCodegenNodeForBranch(branch, keyIndex, context) {
    if (branch.condition) {
      return createConditionalExpression(branch.condition, createChildrenCodegenNode(branch, keyIndex, context), createCallExpression(context.helper(CREATE_COMMENT), [
        true ? '"v-if"' : '""',
        "true"
      ]));
    } else {
      return createChildrenCodegenNode(branch, keyIndex, context);
    }
  }
  function createChildrenCodegenNode(branch, keyIndex, context) {
    const { helper } = context;
    const keyProperty = createObjectProperty(`key`, createSimpleExpression(`${keyIndex}`, false, locStub, 2));
    const { children } = branch;
    const firstChild = children[0];
    const needFragmentWrapper = children.length !== 1 || firstChild.type !== 1;
    if (needFragmentWrapper) {
      if (children.length === 1 && firstChild.type === 11) {
        const vnodeCall = firstChild.codegenNode;
        injectProp(vnodeCall, keyProperty, context);
        return vnodeCall;
      } else {
        let patchFlag = 64;
        let patchFlagText = PatchFlagNames[64];
        if (children.filter((c) => c.type !== 3).length === 1) {
          patchFlag |= 2048;
          patchFlagText += `, ${PatchFlagNames[2048]}`;
        }
        return createVNodeCall(context, helper(FRAGMENT), createObjectExpression([keyProperty]), children, patchFlag + (true ? ` /* ${patchFlagText} */` : ``), void 0, void 0, true, false, false, branch.loc);
      }
    } else {
      const ret = firstChild.codegenNode;
      const vnodeCall = getMemoedVNodeCall(ret);
      if (vnodeCall.type === 13) {
        makeBlock(vnodeCall, context);
      }
      injectProp(vnodeCall, keyProperty, context);
      return ret;
    }
  }
  function isSameKey(a, b) {
    if (!a || a.type !== b.type) {
      return false;
    }
    if (a.type === 6) {
      if (a.value.content !== b.value.content) {
        return false;
      }
    } else {
      const exp = a.exp;
      const branchExp = b.exp;
      if (exp.type !== branchExp.type) {
        return false;
      }
      if (exp.type !== 4 || exp.isStatic !== branchExp.isStatic || exp.content !== branchExp.content) {
        return false;
      }
    }
    return true;
  }
  function getParentCondition(node) {
    while (true) {
      if (node.type === 19) {
        if (node.alternate.type === 19) {
          node = node.alternate;
        } else {
          return node;
        }
      } else if (node.type === 20) {
        node = node.value;
      }
    }
  }
  function processFor(node, dir, context, processCodegen) {
    if (!dir.exp) {
      context.onError(createCompilerError(31, dir.loc));
      return;
    }
    const parseResult = parseForExpression(dir.exp, context);
    if (!parseResult) {
      context.onError(createCompilerError(32, dir.loc));
      return;
    }
    const { addIdentifiers, removeIdentifiers, scopes } = context;
    const { source, value: value2, key: key2, index } = parseResult;
    const forNode = {
      type: 11,
      loc: dir.loc,
      source,
      valueAlias: value2,
      keyAlias: key2,
      objectIndexAlias: index,
      parseResult,
      children: isTemplateNode(node) ? node.children : [node]
    };
    context.replaceNode(forNode);
    scopes.vFor++;
    const onExit = processCodegen && processCodegen(forNode);
    return () => {
      scopes.vFor--;
      if (onExit)
        onExit();
    };
  }
  function parseForExpression(input, context) {
    const loc = input.loc;
    const exp = input.content;
    const inMatch = exp.match(forAliasRE);
    if (!inMatch)
      return;
    const [, LHS, RHS] = inMatch;
    const result = {
      source: createAliasExpression(loc, RHS.trim(), exp.indexOf(RHS, LHS.length)),
      value: void 0,
      key: void 0,
      index: void 0
    };
    if (true) {
      validateBrowserExpression(result.source, context);
    }
    let valueContent = LHS.trim().replace(stripParensRE, "").trim();
    const trimmedOffset = LHS.indexOf(valueContent);
    const iteratorMatch = valueContent.match(forIteratorRE);
    if (iteratorMatch) {
      valueContent = valueContent.replace(forIteratorRE, "").trim();
      const keyContent = iteratorMatch[1].trim();
      let keyOffset;
      if (keyContent) {
        keyOffset = exp.indexOf(keyContent, trimmedOffset + valueContent.length);
        result.key = createAliasExpression(loc, keyContent, keyOffset);
        if (true) {
          validateBrowserExpression(result.key, context, true);
        }
      }
      if (iteratorMatch[2]) {
        const indexContent = iteratorMatch[2].trim();
        if (indexContent) {
          result.index = createAliasExpression(loc, indexContent, exp.indexOf(indexContent, result.key ? keyOffset + keyContent.length : trimmedOffset + valueContent.length));
          if (true) {
            validateBrowserExpression(result.index, context, true);
          }
        }
      }
    }
    if (valueContent) {
      result.value = createAliasExpression(loc, valueContent, trimmedOffset);
      if (true) {
        validateBrowserExpression(result.value, context, true);
      }
    }
    return result;
  }
  function createAliasExpression(range2, content, offset2) {
    return createSimpleExpression(content, false, getInnerRange(range2, offset2, content.length));
  }
  function createForLoopParams({ value: value2, key: key2, index }, memoArgs = []) {
    return createParamsList([value2, key2, index, ...memoArgs]);
  }
  function createParamsList(args) {
    let i = args.length;
    while (i--) {
      if (args[i])
        break;
    }
    return args.slice(0, i + 1).map((arg, i2) => arg || createSimpleExpression(`_`.repeat(i2 + 1), false));
  }
  function buildSlots(node, context, buildSlotFn = buildClientSlotFn) {
    context.helper(WITH_CTX);
    const { children, loc } = node;
    const slotsProperties = [];
    const dynamicSlots = [];
    let hasDynamicSlots = context.scopes.vSlot > 0 || context.scopes.vFor > 0;
    const onComponentSlot = findDir(node, "slot", true);
    if (onComponentSlot) {
      const { arg, exp } = onComponentSlot;
      if (arg && !isStaticExp(arg)) {
        hasDynamicSlots = true;
      }
      slotsProperties.push(createObjectProperty(arg || createSimpleExpression("default", true), buildSlotFn(exp, children, loc)));
    }
    let hasTemplateSlots = false;
    let hasNamedDefaultSlot = false;
    const implicitDefaultChildren = [];
    const seenSlotNames = new Set();
    for (let i = 0; i < children.length; i++) {
      const slotElement = children[i];
      let slotDir;
      if (!isTemplateNode(slotElement) || !(slotDir = findDir(slotElement, "slot", true))) {
        if (slotElement.type !== 3) {
          implicitDefaultChildren.push(slotElement);
        }
        continue;
      }
      if (onComponentSlot) {
        context.onError(createCompilerError(37, slotDir.loc));
        break;
      }
      hasTemplateSlots = true;
      const { children: slotChildren, loc: slotLoc } = slotElement;
      const { arg: slotName = createSimpleExpression(`default`, true), exp: slotProps, loc: dirLoc } = slotDir;
      let staticSlotName;
      if (isStaticExp(slotName)) {
        staticSlotName = slotName ? slotName.content : `default`;
      } else {
        hasDynamicSlots = true;
      }
      const slotFunction = buildSlotFn(slotProps, slotChildren, slotLoc);
      let vIf;
      let vElse;
      let vFor;
      if (vIf = findDir(slotElement, "if")) {
        hasDynamicSlots = true;
        dynamicSlots.push(createConditionalExpression(vIf.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback));
      } else if (vElse = findDir(slotElement, /^else(-if)?$/, true)) {
        let j = i;
        let prev;
        while (j--) {
          prev = children[j];
          if (prev.type !== 3) {
            break;
          }
        }
        if (prev && isTemplateNode(prev) && findDir(prev, "if")) {
          children.splice(i, 1);
          i--;
          let conditional = dynamicSlots[dynamicSlots.length - 1];
          while (conditional.alternate.type === 19) {
            conditional = conditional.alternate;
          }
          conditional.alternate = vElse.exp ? createConditionalExpression(vElse.exp, buildDynamicSlot(slotName, slotFunction), defaultFallback) : buildDynamicSlot(slotName, slotFunction);
        } else {
          context.onError(createCompilerError(30, vElse.loc));
        }
      } else if (vFor = findDir(slotElement, "for")) {
        hasDynamicSlots = true;
        const parseResult = vFor.parseResult || parseForExpression(vFor.exp, context);
        if (parseResult) {
          dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST), [
            parseResult.source,
            createFunctionExpression(createForLoopParams(parseResult), buildDynamicSlot(slotName, slotFunction), true)
          ]));
        } else {
          context.onError(createCompilerError(32, vFor.loc));
        }
      } else {
        if (staticSlotName) {
          if (seenSlotNames.has(staticSlotName)) {
            context.onError(createCompilerError(38, dirLoc));
            continue;
          }
          seenSlotNames.add(staticSlotName);
          if (staticSlotName === "default") {
            hasNamedDefaultSlot = true;
          }
        }
        slotsProperties.push(createObjectProperty(slotName, slotFunction));
      }
    }
    if (!onComponentSlot) {
      const buildDefaultSlotProperty = (props2, children2) => {
        const fn = buildSlotFn(props2, children2, loc);
        if (context.compatConfig) {
          fn.isNonScopedSlot = true;
        }
        return createObjectProperty(`default`, fn);
      };
      if (!hasTemplateSlots) {
        slotsProperties.push(buildDefaultSlotProperty(void 0, children));
      } else if (implicitDefaultChildren.length && implicitDefaultChildren.some((node2) => isNonWhitespaceContent(node2))) {
        if (hasNamedDefaultSlot) {
          context.onError(createCompilerError(39, implicitDefaultChildren[0].loc));
        } else {
          slotsProperties.push(buildDefaultSlotProperty(void 0, implicitDefaultChildren));
        }
      }
    }
    const slotFlag = hasDynamicSlots ? 2 : hasForwardedSlots(node.children) ? 3 : 1;
    let slots = createObjectExpression(slotsProperties.concat(createObjectProperty(`_`, createSimpleExpression(slotFlag + (true ? ` /* ${slotFlagsText[slotFlag]} */` : ``), false))), loc);
    if (dynamicSlots.length) {
      slots = createCallExpression(context.helper(CREATE_SLOTS), [
        slots,
        createArrayExpression(dynamicSlots)
      ]);
    }
    return {
      slots,
      hasDynamicSlots
    };
  }
  function buildDynamicSlot(name, fn) {
    return createObjectExpression([
      createObjectProperty(`name`, name),
      createObjectProperty(`fn`, fn)
    ]);
  }
  function hasForwardedSlots(children) {
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      switch (child.type) {
        case 1:
          if (child.tagType === 2 || hasForwardedSlots(child.children)) {
            return true;
          }
          break;
        case 9:
          if (hasForwardedSlots(child.branches))
            return true;
          break;
        case 10:
        case 11:
          if (hasForwardedSlots(child.children))
            return true;
          break;
      }
    }
    return false;
  }
  function isNonWhitespaceContent(node) {
    if (node.type !== 2 && node.type !== 12)
      return true;
    return node.type === 2 ? !!node.content.trim() : isNonWhitespaceContent(node.content);
  }
  function resolveComponentType(node, context, ssr = false) {
    let { tag } = node;
    const isExplicitDynamic = isComponentTag(tag);
    const isProp = findProp(node, "is");
    if (isProp) {
      if (isExplicitDynamic || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context)) {
        const exp = isProp.type === 6 ? isProp.value && createSimpleExpression(isProp.value.content, true) : isProp.exp;
        if (exp) {
          return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
            exp
          ]);
        }
      } else if (isProp.type === 6 && isProp.value.content.startsWith("vue:")) {
        tag = isProp.value.content.slice(4);
      }
    }
    const isDir = !isExplicitDynamic && findDir(node, "is");
    if (isDir && isDir.exp) {
      return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT), [
        isDir.exp
      ]);
    }
    const builtIn = isCoreComponent(tag) || context.isBuiltInComponent(tag);
    if (builtIn) {
      if (!ssr)
        context.helper(builtIn);
      return builtIn;
    }
    context.helper(RESOLVE_COMPONENT);
    context.components.add(tag);
    return toValidAssetId(tag, `component`);
  }
  function buildProps(node, context, props2 = node.props, ssr = false) {
    const { tag, loc: elementLoc } = node;
    const isComponent2 = node.tagType === 1;
    let properties = [];
    const mergeArgs = [];
    const runtimeDirectives = [];
    let patchFlag = 0;
    let hasRef = false;
    let hasClassBinding = false;
    let hasStyleBinding = false;
    let hasHydrationEventBinding = false;
    let hasDynamicKeys = false;
    let hasVnodeHook = false;
    const dynamicPropNames = [];
    const analyzePatchFlag = ({ key: key2, value: value2 }) => {
      if (isStaticExp(key2)) {
        const name = key2.content;
        const isEventHandler = isOn(name);
        if (!isComponent2 && isEventHandler && name.toLowerCase() !== "onclick" && name !== "onUpdate:modelValue" && !isReservedProp(name)) {
          hasHydrationEventBinding = true;
        }
        if (isEventHandler && isReservedProp(name)) {
          hasVnodeHook = true;
        }
        if (value2.type === 20 || (value2.type === 4 || value2.type === 8) && getConstantType(value2, context) > 0) {
          return;
        }
        if (name === "ref") {
          hasRef = true;
        } else if (name === "class") {
          hasClassBinding = true;
        } else if (name === "style") {
          hasStyleBinding = true;
        } else if (name !== "key" && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
        if (isComponent2 && (name === "class" || name === "style") && !dynamicPropNames.includes(name)) {
          dynamicPropNames.push(name);
        }
      } else {
        hasDynamicKeys = true;
      }
    };
    for (let i = 0; i < props2.length; i++) {
      const prop = props2[i];
      if (prop.type === 6) {
        const { loc, name, value: value2 } = prop;
        let valueNode = createSimpleExpression(value2 ? value2.content : "", true, value2 ? value2.loc : loc);
        if (name === "ref") {
          hasRef = true;
        }
        if (name === "is" && (isComponentTag(tag) || value2 && value2.content.startsWith("vue:") || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
          continue;
        }
        properties.push(createObjectProperty(createSimpleExpression(name, true, getInnerRange(loc, 0, name.length)), valueNode));
      } else {
        const { name, arg, exp, loc } = prop;
        const isVBind = name === "bind";
        const isVOn = name === "on";
        if (name === "slot") {
          if (!isComponent2) {
            context.onError(createCompilerError(40, loc));
          }
          continue;
        }
        if (name === "once" || name === "memo") {
          continue;
        }
        if (name === "is" || isVBind && isBindKey(arg, "is") && (isComponentTag(tag) || isCompatEnabled("COMPILER_IS_ON_ELEMENT", context))) {
          continue;
        }
        if (isVOn && ssr) {
          continue;
        }
        if (!arg && (isVBind || isVOn)) {
          hasDynamicKeys = true;
          if (exp) {
            if (properties.length) {
              mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
              properties = [];
            }
            if (isVBind) {
              {
                if (true) {
                  const hasOverridableKeys = mergeArgs.some((arg2) => {
                    if (arg2.type === 15) {
                      return arg2.properties.some(({ key: key2 }) => {
                        if (key2.type !== 4 || !key2.isStatic) {
                          return true;
                        }
                        return key2.content !== "class" && key2.content !== "style" && !isOn(key2.content);
                      });
                    } else {
                      return true;
                    }
                  });
                  if (hasOverridableKeys) {
                    checkCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context, loc);
                  }
                }
                if (isCompatEnabled("COMPILER_V_BIND_OBJECT_ORDER", context)) {
                  mergeArgs.unshift(exp);
                  continue;
                }
              }
              mergeArgs.push(exp);
            } else {
              mergeArgs.push({
                type: 14,
                loc,
                callee: context.helper(TO_HANDLERS),
                arguments: [exp]
              });
            }
          } else {
            context.onError(createCompilerError(isVBind ? 34 : 35, loc));
          }
          continue;
        }
        const directiveTransform = context.directiveTransforms[name];
        if (directiveTransform) {
          const { props: props3, needRuntime } = directiveTransform(prop, node, context);
          !ssr && props3.forEach(analyzePatchFlag);
          properties.push(...props3);
          if (needRuntime) {
            runtimeDirectives.push(prop);
            if (isSymbol(needRuntime)) {
              directiveImportMap.set(prop, needRuntime);
            }
          }
        } else {
          runtimeDirectives.push(prop);
        }
      }
      if (prop.type === 6 && prop.name === "ref" && context.scopes.vFor > 0 && checkCompatEnabled("COMPILER_V_FOR_REF", context, prop.loc)) {
        properties.push(createObjectProperty(createSimpleExpression("refInFor", true), createSimpleExpression("true", false)));
      }
    }
    let propsExpression = void 0;
    if (mergeArgs.length) {
      if (properties.length) {
        mergeArgs.push(createObjectExpression(dedupeProperties(properties), elementLoc));
      }
      if (mergeArgs.length > 1) {
        propsExpression = createCallExpression(context.helper(MERGE_PROPS), mergeArgs, elementLoc);
      } else {
        propsExpression = mergeArgs[0];
      }
    } else if (properties.length) {
      propsExpression = createObjectExpression(dedupeProperties(properties), elementLoc);
    }
    if (hasDynamicKeys) {
      patchFlag |= 16;
    } else {
      if (hasClassBinding && !isComponent2) {
        patchFlag |= 2;
      }
      if (hasStyleBinding && !isComponent2) {
        patchFlag |= 4;
      }
      if (dynamicPropNames.length) {
        patchFlag |= 8;
      }
      if (hasHydrationEventBinding) {
        patchFlag |= 32;
      }
    }
    if ((patchFlag === 0 || patchFlag === 32) && (hasRef || hasVnodeHook || runtimeDirectives.length > 0)) {
      patchFlag |= 512;
    }
    if (!context.inSSR && propsExpression) {
      switch (propsExpression.type) {
        case 15:
          let classKeyIndex = -1;
          let styleKeyIndex = -1;
          let hasDynamicKey = false;
          for (let i = 0; i < propsExpression.properties.length; i++) {
            const key2 = propsExpression.properties[i].key;
            if (isStaticExp(key2)) {
              if (key2.content === "class") {
                classKeyIndex = i;
              } else if (key2.content === "style") {
                styleKeyIndex = i;
              }
            } else if (!key2.isHandlerKey) {
              hasDynamicKey = true;
            }
          }
          const classProp = propsExpression.properties[classKeyIndex];
          const styleProp = propsExpression.properties[styleKeyIndex];
          if (!hasDynamicKey) {
            if (classProp && !isStaticExp(classProp.value)) {
              classProp.value = createCallExpression(context.helper(NORMALIZE_CLASS), [classProp.value]);
            }
            if (styleProp && !isStaticExp(styleProp.value) && (hasStyleBinding || styleProp.value.type === 17)) {
              styleProp.value = createCallExpression(context.helper(NORMALIZE_STYLE), [styleProp.value]);
            }
          } else {
            propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [propsExpression]);
          }
          break;
        case 14:
          break;
        default:
          propsExpression = createCallExpression(context.helper(NORMALIZE_PROPS), [
            createCallExpression(context.helper(GUARD_REACTIVE_PROPS), [
              propsExpression
            ])
          ]);
          break;
      }
    }
    return {
      props: propsExpression,
      directives: runtimeDirectives,
      patchFlag,
      dynamicPropNames
    };
  }
  function dedupeProperties(properties) {
    const knownProps = new Map();
    const deduped = [];
    for (let i = 0; i < properties.length; i++) {
      const prop = properties[i];
      if (prop.key.type === 8 || !prop.key.isStatic) {
        deduped.push(prop);
        continue;
      }
      const name = prop.key.content;
      const existing = knownProps.get(name);
      if (existing) {
        if (name === "style" || name === "class" || name.startsWith("on")) {
          mergeAsArray2(existing, prop);
        }
      } else {
        knownProps.set(name, prop);
        deduped.push(prop);
      }
    }
    return deduped;
  }
  function mergeAsArray2(existing, incoming) {
    if (existing.value.type === 17) {
      existing.value.elements.push(incoming.value);
    } else {
      existing.value = createArrayExpression([existing.value, incoming.value], existing.loc);
    }
  }
  function buildDirectiveArgs(dir, context) {
    const dirArgs = [];
    const runtime = directiveImportMap.get(dir);
    if (runtime) {
      dirArgs.push(context.helperString(runtime));
    } else {
      {
        context.helper(RESOLVE_DIRECTIVE);
        context.directives.add(dir.name);
        dirArgs.push(toValidAssetId(dir.name, `directive`));
      }
    }
    const { loc } = dir;
    if (dir.exp)
      dirArgs.push(dir.exp);
    if (dir.arg) {
      if (!dir.exp) {
        dirArgs.push(`void 0`);
      }
      dirArgs.push(dir.arg);
    }
    if (Object.keys(dir.modifiers).length) {
      if (!dir.arg) {
        if (!dir.exp) {
          dirArgs.push(`void 0`);
        }
        dirArgs.push(`void 0`);
      }
      const trueExpression = createSimpleExpression(`true`, false, loc);
      dirArgs.push(createObjectExpression(dir.modifiers.map((modifier) => createObjectProperty(modifier, trueExpression)), loc));
    }
    return createArrayExpression(dirArgs, dir.loc);
  }
  function stringifyDynamicPropNames(props2) {
    let propsNamesString = `[`;
    for (let i = 0, l = props2.length; i < l; i++) {
      propsNamesString += JSON.stringify(props2[i]);
      if (i < l - 1)
        propsNamesString += ", ";
    }
    return propsNamesString + `]`;
  }
  function isComponentTag(tag) {
    return tag[0].toLowerCase() + tag.slice(1) === "component";
  }
  function processSlotOutlet(node, context) {
    let slotName = `"default"`;
    let slotProps = void 0;
    const nonNameProps = [];
    for (let i = 0; i < node.props.length; i++) {
      const p2 = node.props[i];
      if (p2.type === 6) {
        if (p2.value) {
          if (p2.name === "name") {
            slotName = JSON.stringify(p2.value.content);
          } else {
            p2.name = camelize2(p2.name);
            nonNameProps.push(p2);
          }
        }
      } else {
        if (p2.name === "bind" && isBindKey(p2.arg, "name")) {
          if (p2.exp)
            slotName = p2.exp;
        } else {
          if (p2.name === "bind" && p2.arg && isStaticExp(p2.arg)) {
            p2.arg.content = camelize2(p2.arg.content);
          }
          nonNameProps.push(p2);
        }
      }
    }
    if (nonNameProps.length > 0) {
      const { props: props2, directives: directives2 } = buildProps(node, context, nonNameProps);
      slotProps = props2;
      if (directives2.length) {
        context.onError(createCompilerError(36, directives2[0].loc));
      }
    }
    return {
      slotName,
      slotProps
    };
  }
  function createTransformProps(props2 = []) {
    return { props: props2 };
  }
  function rewriteFilter(node, context) {
    if (node.type === 4) {
      parseFilter(node, context);
    } else {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        if (typeof child !== "object")
          continue;
        if (child.type === 4) {
          parseFilter(child, context);
        } else if (child.type === 8) {
          rewriteFilter(node, context);
        } else if (child.type === 5) {
          rewriteFilter(child.content, context);
        }
      }
    }
  }
  function parseFilter(node, context) {
    const exp = node.content;
    let inSingle = false;
    let inDouble = false;
    let inTemplateString = false;
    let inRegex = false;
    let curly = 0;
    let square = 0;
    let paren = 0;
    let lastFilterIndex = 0;
    let c, prev, i, expression, filters = [];
    for (i = 0; i < exp.length; i++) {
      prev = c;
      c = exp.charCodeAt(i);
      if (inSingle) {
        if (c === 39 && prev !== 92)
          inSingle = false;
      } else if (inDouble) {
        if (c === 34 && prev !== 92)
          inDouble = false;
      } else if (inTemplateString) {
        if (c === 96 && prev !== 92)
          inTemplateString = false;
      } else if (inRegex) {
        if (c === 47 && prev !== 92)
          inRegex = false;
      } else if (c === 124 && exp.charCodeAt(i + 1) !== 124 && exp.charCodeAt(i - 1) !== 124 && !curly && !square && !paren) {
        if (expression === void 0) {
          lastFilterIndex = i + 1;
          expression = exp.slice(0, i).trim();
        } else {
          pushFilter();
        }
      } else {
        switch (c) {
          case 34:
            inDouble = true;
            break;
          case 39:
            inSingle = true;
            break;
          case 96:
            inTemplateString = true;
            break;
          case 40:
            paren++;
            break;
          case 41:
            paren--;
            break;
          case 91:
            square++;
            break;
          case 93:
            square--;
            break;
          case 123:
            curly++;
            break;
          case 125:
            curly--;
            break;
        }
        if (c === 47) {
          let j = i - 1;
          let p2;
          for (; j >= 0; j--) {
            p2 = exp.charAt(j);
            if (p2 !== " ")
              break;
          }
          if (!p2 || !validDivisionCharRE.test(p2)) {
            inRegex = true;
          }
        }
      }
    }
    if (expression === void 0) {
      expression = exp.slice(0, i).trim();
    } else if (lastFilterIndex !== 0) {
      pushFilter();
    }
    function pushFilter() {
      filters.push(exp.slice(lastFilterIndex, i).trim());
      lastFilterIndex = i + 1;
    }
    if (filters.length) {
      warnDeprecation("COMPILER_FILTER", context, node.loc);
      for (i = 0; i < filters.length; i++) {
        expression = wrapFilter(expression, filters[i], context);
      }
      node.content = expression;
    }
  }
  function wrapFilter(exp, filter, context) {
    context.helper(RESOLVE_FILTER);
    const i = filter.indexOf("(");
    if (i < 0) {
      context.filters.add(filter);
      return `${toValidAssetId(filter, "filter")}(${exp})`;
    } else {
      const name = filter.slice(0, i);
      const args = filter.slice(i + 1);
      context.filters.add(name);
      return `${toValidAssetId(name, "filter")}(${exp}${args !== ")" ? "," + args : args}`;
    }
  }
  function getBaseTransformPreset(prefixIdentifiers) {
    return [
      [
        transformOnce,
        transformIf,
        transformMemo,
        transformFor,
        ...[transformFilter],
        ...true ? [transformExpression] : [],
        transformSlotOutlet,
        transformElement,
        trackSlotScopes,
        transformText
      ],
      {
        on: transformOn,
        bind: transformBind,
        model: transformModel
      }
    ];
  }
  function baseCompile(template, options = {}) {
    const onError = options.onError || defaultOnError;
    const isModuleMode = options.mode === "module";
    {
      if (options.prefixIdentifiers === true) {
        onError(createCompilerError(46));
      } else if (isModuleMode) {
        onError(createCompilerError(47));
      }
    }
    const prefixIdentifiers = false;
    if (options.cacheHandlers) {
      onError(createCompilerError(48));
    }
    if (options.scopeId && !isModuleMode) {
      onError(createCompilerError(49));
    }
    const ast = isString(template) ? baseParse(template, options) : template;
    const [nodeTransforms, directiveTransforms] = getBaseTransformPreset();
    transform(ast, extend({}, options, {
      prefixIdentifiers,
      nodeTransforms: [
        ...nodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend({}, directiveTransforms, options.directiveTransforms || {})
    }));
    return generate(ast, extend({}, options, {
      prefixIdentifiers
    }));
  }
  var import_pako, errorMessages, FRAGMENT, TELEPORT, SUSPENSE, KEEP_ALIVE, BASE_TRANSITION, OPEN_BLOCK, CREATE_BLOCK, CREATE_ELEMENT_BLOCK, CREATE_VNODE, CREATE_ELEMENT_VNODE, CREATE_COMMENT, CREATE_TEXT, CREATE_STATIC, RESOLVE_COMPONENT, RESOLVE_DYNAMIC_COMPONENT, RESOLVE_DIRECTIVE, RESOLVE_FILTER, WITH_DIRECTIVES, RENDER_LIST, RENDER_SLOT, CREATE_SLOTS, TO_DISPLAY_STRING, MERGE_PROPS, NORMALIZE_CLASS, NORMALIZE_STYLE, NORMALIZE_PROPS, GUARD_REACTIVE_PROPS, TO_HANDLERS, CAMELIZE, CAPITALIZE, TO_HANDLER_KEY, SET_BLOCK_TRACKING, PUSH_SCOPE_ID, POP_SCOPE_ID, WITH_CTX, UNREF, IS_REF, WITH_MEMO, IS_MEMO_SAME, helperNameMap, locStub, isStaticExp, isBuiltInType, nonIdentifierRE, isSimpleIdentifier, validFirstIdentCharRE, validIdentCharRE, whitespaceRE, isMemberExpression, propsHelperSet, deprecationData2, decodeRE, decodeMap, defaultParserOptions, isSpecialTemplateDirective, allowHoistedHelperSet, PURE_ANNOTATION, prohibitedKeywordRE, stripStringRE, transformExpression, transformIf, transformFor, forAliasRE, forIteratorRE, stripParensRE, defaultFallback, trackSlotScopes, buildClientSlotFn, directiveImportMap, transformElement, cacheStringFunction2, camelizeRE2, camelize2, transformSlotOutlet, fnExpRE, transformOn, transformBind, injectPrefix, transformText, seen, transformOnce, transformModel, validDivisionCharRE, transformFilter, seen$1, transformMemo, noopDirectiveTransform;
  var init_compiler_core_esm_bundler = __esm({
    "node_modules/@vue/compiler-dom/node_modules/@vue/compiler-core/dist/compiler-core.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_shared_esm_bundler();
      init_shared_esm_bundler();
      errorMessages = {
        [0]: "Illegal comment.",
        [1]: "CDATA section is allowed only in XML context.",
        [2]: "Duplicate attribute.",
        [3]: "End tag cannot have attributes.",
        [4]: "Illegal '/' in tags.",
        [5]: "Unexpected EOF in tag.",
        [6]: "Unexpected EOF in CDATA section.",
        [7]: "Unexpected EOF in comment.",
        [8]: "Unexpected EOF in script.",
        [9]: "Unexpected EOF in tag.",
        [10]: "Incorrectly closed comment.",
        [11]: "Incorrectly opened comment.",
        [12]: "Illegal tag name. Use '&lt;' to print '<'.",
        [13]: "Attribute value was expected.",
        [14]: "End tag name was expected.",
        [15]: "Whitespace was expected.",
        [16]: "Unexpected '<!--' in comment.",
        [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
        [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
        [19]: "Attribute name cannot start with '='.",
        [21]: "'<?' is allowed only in XML context.",
        [20]: `Unexpected null character.`,
        [22]: "Illegal '/' in tags.",
        [23]: "Invalid end tag.",
        [24]: "Element is missing end tag.",
        [25]: "Interpolation end sign was not found.",
        [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
        [26]: "Legal directive name was expected.",
        [28]: `v-if/v-else-if is missing expression.`,
        [29]: `v-if/else branches must use unique keys.`,
        [30]: `v-else/v-else-if has no adjacent v-if.`,
        [31]: `v-for is missing expression.`,
        [32]: `v-for has invalid expression.`,
        [33]: `<template v-for> key should be placed on the <template> tag.`,
        [34]: `v-bind is missing expression.`,
        [35]: `v-on is missing expression.`,
        [36]: `Unexpected custom directive on <slot> outlet.`,
        [37]: `Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.`,
        [38]: `Duplicate slot names found. `,
        [39]: `Extraneous children found when component already has explicitly named default slot. These children will be ignored.`,
        [40]: `v-slot can only be used on components or <template> tags.`,
        [41]: `v-model is missing expression.`,
        [42]: `v-model value must be a valid JavaScript member expression.`,
        [43]: `v-model cannot be used on v-for or v-slot scope variables because they are not writable.`,
        [44]: `Error parsing JavaScript expression: `,
        [45]: `<KeepAlive> expects exactly one child component.`,
        [46]: `"prefixIdentifiers" option is not supported in this build of compiler.`,
        [47]: `ES module mode is not supported in this build of compiler.`,
        [48]: `"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.`,
        [49]: `"scopeId" option is only supported in module mode.`,
        [50]: ``
      };
      FRAGMENT = Symbol(true ? `Fragment` : ``);
      TELEPORT = Symbol(true ? `Teleport` : ``);
      SUSPENSE = Symbol(true ? `Suspense` : ``);
      KEEP_ALIVE = Symbol(true ? `KeepAlive` : ``);
      BASE_TRANSITION = Symbol(true ? `BaseTransition` : ``);
      OPEN_BLOCK = Symbol(true ? `openBlock` : ``);
      CREATE_BLOCK = Symbol(true ? `createBlock` : ``);
      CREATE_ELEMENT_BLOCK = Symbol(true ? `createElementBlock` : ``);
      CREATE_VNODE = Symbol(true ? `createVNode` : ``);
      CREATE_ELEMENT_VNODE = Symbol(true ? `createElementVNode` : ``);
      CREATE_COMMENT = Symbol(true ? `createCommentVNode` : ``);
      CREATE_TEXT = Symbol(true ? `createTextVNode` : ``);
      CREATE_STATIC = Symbol(true ? `createStaticVNode` : ``);
      RESOLVE_COMPONENT = Symbol(true ? `resolveComponent` : ``);
      RESOLVE_DYNAMIC_COMPONENT = Symbol(true ? `resolveDynamicComponent` : ``);
      RESOLVE_DIRECTIVE = Symbol(true ? `resolveDirective` : ``);
      RESOLVE_FILTER = Symbol(true ? `resolveFilter` : ``);
      WITH_DIRECTIVES = Symbol(true ? `withDirectives` : ``);
      RENDER_LIST = Symbol(true ? `renderList` : ``);
      RENDER_SLOT = Symbol(true ? `renderSlot` : ``);
      CREATE_SLOTS = Symbol(true ? `createSlots` : ``);
      TO_DISPLAY_STRING = Symbol(true ? `toDisplayString` : ``);
      MERGE_PROPS = Symbol(true ? `mergeProps` : ``);
      NORMALIZE_CLASS = Symbol(true ? `normalizeClass` : ``);
      NORMALIZE_STYLE = Symbol(true ? `normalizeStyle` : ``);
      NORMALIZE_PROPS = Symbol(true ? `normalizeProps` : ``);
      GUARD_REACTIVE_PROPS = Symbol(true ? `guardReactiveProps` : ``);
      TO_HANDLERS = Symbol(true ? `toHandlers` : ``);
      CAMELIZE = Symbol(true ? `camelize` : ``);
      CAPITALIZE = Symbol(true ? `capitalize` : ``);
      TO_HANDLER_KEY = Symbol(true ? `toHandlerKey` : ``);
      SET_BLOCK_TRACKING = Symbol(true ? `setBlockTracking` : ``);
      PUSH_SCOPE_ID = Symbol(true ? `pushScopeId` : ``);
      POP_SCOPE_ID = Symbol(true ? `popScopeId` : ``);
      WITH_CTX = Symbol(true ? `withCtx` : ``);
      UNREF = Symbol(true ? `unref` : ``);
      IS_REF = Symbol(true ? `isRef` : ``);
      WITH_MEMO = Symbol(true ? `withMemo` : ``);
      IS_MEMO_SAME = Symbol(true ? `isMemoSame` : ``);
      helperNameMap = {
        [FRAGMENT]: `Fragment`,
        [TELEPORT]: `Teleport`,
        [SUSPENSE]: `Suspense`,
        [KEEP_ALIVE]: `KeepAlive`,
        [BASE_TRANSITION]: `BaseTransition`,
        [OPEN_BLOCK]: `openBlock`,
        [CREATE_BLOCK]: `createBlock`,
        [CREATE_ELEMENT_BLOCK]: `createElementBlock`,
        [CREATE_VNODE]: `createVNode`,
        [CREATE_ELEMENT_VNODE]: `createElementVNode`,
        [CREATE_COMMENT]: `createCommentVNode`,
        [CREATE_TEXT]: `createTextVNode`,
        [CREATE_STATIC]: `createStaticVNode`,
        [RESOLVE_COMPONENT]: `resolveComponent`,
        [RESOLVE_DYNAMIC_COMPONENT]: `resolveDynamicComponent`,
        [RESOLVE_DIRECTIVE]: `resolveDirective`,
        [RESOLVE_FILTER]: `resolveFilter`,
        [WITH_DIRECTIVES]: `withDirectives`,
        [RENDER_LIST]: `renderList`,
        [RENDER_SLOT]: `renderSlot`,
        [CREATE_SLOTS]: `createSlots`,
        [TO_DISPLAY_STRING]: `toDisplayString`,
        [MERGE_PROPS]: `mergeProps`,
        [NORMALIZE_CLASS]: `normalizeClass`,
        [NORMALIZE_STYLE]: `normalizeStyle`,
        [NORMALIZE_PROPS]: `normalizeProps`,
        [GUARD_REACTIVE_PROPS]: `guardReactiveProps`,
        [TO_HANDLERS]: `toHandlers`,
        [CAMELIZE]: `camelize`,
        [CAPITALIZE]: `capitalize`,
        [TO_HANDLER_KEY]: `toHandlerKey`,
        [SET_BLOCK_TRACKING]: `setBlockTracking`,
        [PUSH_SCOPE_ID]: `pushScopeId`,
        [POP_SCOPE_ID]: `popScopeId`,
        [WITH_CTX]: `withCtx`,
        [UNREF]: `unref`,
        [IS_REF]: `isRef`,
        [WITH_MEMO]: `withMemo`,
        [IS_MEMO_SAME]: `isMemoSame`
      };
      locStub = {
        source: "",
        start: { line: 1, column: 1, offset: 0 },
        end: { line: 1, column: 1, offset: 0 }
      };
      isStaticExp = (p2) => p2.type === 4 && p2.isStatic;
      isBuiltInType = (tag, expected) => tag === expected || tag === hyphenate(expected);
      nonIdentifierRE = /^\d|[^\$\w]/;
      isSimpleIdentifier = (name) => !nonIdentifierRE.test(name);
      validFirstIdentCharRE = /[A-Za-z_$\xA0-\uFFFF]/;
      validIdentCharRE = /[\.\?\w$\xA0-\uFFFF]/;
      whitespaceRE = /\s+[.[]\s*|\s*[.[]\s+/g;
      isMemberExpression = (path) => {
        path = path.trim().replace(whitespaceRE, (s2) => s2.trim());
        let state = 0;
        let stateStack = [];
        let currentOpenBracketCount = 0;
        let currentOpenParensCount = 0;
        let currentStringType = null;
        for (let i = 0; i < path.length; i++) {
          const char = path.charAt(i);
          switch (state) {
            case 0:
              if (char === "[") {
                stateStack.push(state);
                state = 1;
                currentOpenBracketCount++;
              } else if (char === "(") {
                stateStack.push(state);
                state = 2;
                currentOpenParensCount++;
              } else if (!(i === 0 ? validFirstIdentCharRE : validIdentCharRE).test(char)) {
                return false;
              }
              break;
            case 1:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `[`) {
                currentOpenBracketCount++;
              } else if (char === `]`) {
                if (!--currentOpenBracketCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 2:
              if (char === `'` || char === `"` || char === "`") {
                stateStack.push(state);
                state = 3;
                currentStringType = char;
              } else if (char === `(`) {
                currentOpenParensCount++;
              } else if (char === `)`) {
                if (i === path.length - 1) {
                  return false;
                }
                if (!--currentOpenParensCount) {
                  state = stateStack.pop();
                }
              }
              break;
            case 3:
              if (char === currentStringType) {
                state = stateStack.pop();
                currentStringType = null;
              }
              break;
          }
        }
        return !currentOpenBracketCount && !currentOpenParensCount;
      };
      propsHelperSet = new Set([NORMALIZE_PROPS, GUARD_REACTIVE_PROPS]);
      deprecationData2 = {
        ["COMPILER_IS_ON_ELEMENT"]: {
          message: `Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".`,
          link: `https://v3.vuejs.org/guide/migration/custom-elements-interop.html`
        },
        ["COMPILER_V_BIND_SYNC"]: {
          message: (key2) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${key2}.sync\` should be changed to \`v-model:${key2}\`.`,
          link: `https://v3.vuejs.org/guide/migration/v-model.html`
        },
        ["COMPILER_V_BIND_PROP"]: {
          message: `.prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate.`
        },
        ["COMPILER_V_BIND_OBJECT_ORDER"]: {
          message: `v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.`,
          link: `https://v3.vuejs.org/guide/migration/v-bind.html`
        },
        ["COMPILER_V_ON_NATIVE"]: {
          message: `.native modifier for v-on has been removed as is no longer necessary.`,
          link: `https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html`
        },
        ["COMPILER_V_IF_V_FOR_PRECEDENCE"]: {
          message: `v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.`,
          link: `https://v3.vuejs.org/guide/migration/v-if-v-for.html`
        },
        ["COMPILER_V_FOR_REF"]: {
          message: `Ref usage on v-for no longer creates array ref values in Vue 3. Consider using function refs or refactor to avoid ref usage altogether.`,
          link: `https://v3.vuejs.org/guide/migration/array-refs.html`
        },
        ["COMPILER_NATIVE_TEMPLATE"]: {
          message: `<template> with no special directives will render as a native template element instead of its inner content in Vue 3.`
        },
        ["COMPILER_INLINE_TEMPLATE"]: {
          message: `"inline-template" has been removed in Vue 3.`,
          link: `https://v3.vuejs.org/guide/migration/inline-template-attribute.html`
        },
        ["COMPILER_FILTER"]: {
          message: `filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.`,
          link: `https://v3.vuejs.org/guide/migration/filters.html`
        }
      };
      decodeRE = /&(gt|lt|amp|apos|quot);/g;
      decodeMap = {
        gt: ">",
        lt: "<",
        amp: "&",
        apos: "'",
        quot: '"'
      };
      defaultParserOptions = {
        delimiters: [`{{`, `}}`],
        getNamespace: () => 0,
        getTextMode: () => 0,
        isVoidTag: NO,
        isPreTag: NO,
        isCustomElement: NO,
        decodeEntities: (rawText) => rawText.replace(decodeRE, (_, p1) => decodeMap[p1]),
        onError: defaultOnError,
        onWarn: defaultOnWarn,
        comments: true
      };
      isSpecialTemplateDirective = /* @__PURE__ */ makeMap(`if,else,else-if,for,slot`);
      allowHoistedHelperSet = new Set([
        NORMALIZE_CLASS,
        NORMALIZE_STYLE,
        NORMALIZE_PROPS,
        GUARD_REACTIVE_PROPS
      ]);
      PURE_ANNOTATION = `/*#__PURE__*/`;
      prohibitedKeywordRE = new RegExp("\\b" + "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments,typeof,void".split(",").join("\\b|\\b") + "\\b");
      stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
      transformExpression = (node, context) => {
        if (node.type === 5) {
          node.content = processExpression(node.content, context);
        } else if (node.type === 1) {
          for (let i = 0; i < node.props.length; i++) {
            const dir = node.props[i];
            if (dir.type === 7 && dir.name !== "for") {
              const exp = dir.exp;
              const arg = dir.arg;
              if (exp && exp.type === 4 && !(dir.name === "on" && arg)) {
                dir.exp = processExpression(exp, context, dir.name === "slot");
              }
              if (arg && arg.type === 4 && !arg.isStatic) {
                dir.arg = processExpression(arg, context);
              }
            }
          }
        }
      };
      transformIf = createStructuralDirectiveTransform(/^(if|else|else-if)$/, (node, dir, context) => {
        return processIf(node, dir, context, (ifNode, branch, isRoot) => {
          const siblings = context.parent.children;
          let i = siblings.indexOf(ifNode);
          let key2 = 0;
          while (i-- >= 0) {
            const sibling = siblings[i];
            if (sibling && sibling.type === 9) {
              key2 += sibling.branches.length;
            }
          }
          return () => {
            if (isRoot) {
              ifNode.codegenNode = createCodegenNodeForBranch(branch, key2, context);
            } else {
              const parentCondition = getParentCondition(ifNode.codegenNode);
              parentCondition.alternate = createCodegenNodeForBranch(branch, key2 + ifNode.branches.length - 1, context);
            }
          };
        });
      });
      transformFor = createStructuralDirectiveTransform("for", (node, dir, context) => {
        const { helper, removeHelper } = context;
        return processFor(node, dir, context, (forNode) => {
          const renderExp = createCallExpression(helper(RENDER_LIST), [
            forNode.source
          ]);
          const memo = findDir(node, "memo");
          const keyProp = findProp(node, `key`);
          const keyExp = keyProp && (keyProp.type === 6 ? createSimpleExpression(keyProp.value.content, true) : keyProp.exp);
          const keyProperty = keyProp ? createObjectProperty(`key`, keyExp) : null;
          const isStableFragment = forNode.source.type === 4 && forNode.source.constType > 0;
          const fragmentFlag = isStableFragment ? 64 : keyProp ? 128 : 256;
          forNode.codegenNode = createVNodeCall(context, helper(FRAGMENT), void 0, renderExp, fragmentFlag + (true ? ` /* ${PatchFlagNames[fragmentFlag]} */` : ``), void 0, void 0, true, !isStableFragment, false, node.loc);
          return () => {
            let childBlock;
            const isTemplate = isTemplateNode(node);
            const { children } = forNode;
            if (isTemplate) {
              node.children.some((c) => {
                if (c.type === 1) {
                  const key2 = findProp(c, "key");
                  if (key2) {
                    context.onError(createCompilerError(33, key2.loc));
                    return true;
                  }
                }
              });
            }
            const needFragmentWrapper = children.length !== 1 || children[0].type !== 1;
            const slotOutlet = isSlotOutlet(node) ? node : isTemplate && node.children.length === 1 && isSlotOutlet(node.children[0]) ? node.children[0] : null;
            if (slotOutlet) {
              childBlock = slotOutlet.codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
            } else if (needFragmentWrapper) {
              childBlock = createVNodeCall(context, helper(FRAGMENT), keyProperty ? createObjectExpression([keyProperty]) : void 0, node.children, 64 + (true ? ` /* ${PatchFlagNames[64]} */` : ``), void 0, void 0, true, void 0, false);
            } else {
              childBlock = children[0].codegenNode;
              if (isTemplate && keyProperty) {
                injectProp(childBlock, keyProperty, context);
              }
              if (childBlock.isBlock !== !isStableFragment) {
                if (childBlock.isBlock) {
                  removeHelper(OPEN_BLOCK);
                  removeHelper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
                } else {
                  removeHelper(getVNodeHelper(context.inSSR, childBlock.isComponent));
                }
              }
              childBlock.isBlock = !isStableFragment;
              if (childBlock.isBlock) {
                helper(OPEN_BLOCK);
                helper(getVNodeBlockHelper(context.inSSR, childBlock.isComponent));
              } else {
                helper(getVNodeHelper(context.inSSR, childBlock.isComponent));
              }
            }
            if (memo) {
              const loop = createFunctionExpression(createForLoopParams(forNode.parseResult, [
                createSimpleExpression(`_cached`)
              ]));
              loop.body = createBlockStatement([
                createCompoundExpression([`const _memo = (`, memo.exp, `)`]),
                createCompoundExpression([
                  `if (_cached`,
                  ...keyExp ? [` && _cached.key === `, keyExp] : [],
                  ` && ${context.helperString(IS_MEMO_SAME)}(_cached, _memo)) return _cached`
                ]),
                createCompoundExpression([`const _item = `, childBlock]),
                createSimpleExpression(`_item.memo = _memo`),
                createSimpleExpression(`return _item`)
              ]);
              renderExp.arguments.push(loop, createSimpleExpression(`_cache`), createSimpleExpression(String(context.cached++)));
            } else {
              renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult), childBlock, true));
            }
          };
        });
      });
      forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
      forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
      stripParensRE = /^\(|\)$/g;
      defaultFallback = createSimpleExpression(`undefined`, false);
      trackSlotScopes = (node, context) => {
        if (node.type === 1 && (node.tagType === 1 || node.tagType === 3)) {
          const vSlot = findDir(node, "slot");
          if (vSlot) {
            vSlot.exp;
            context.scopes.vSlot++;
            return () => {
              context.scopes.vSlot--;
            };
          }
        }
      };
      buildClientSlotFn = (props2, children, loc) => createFunctionExpression(props2, children, false, true, children.length ? children[0].loc : loc);
      directiveImportMap = new WeakMap();
      transformElement = (node, context) => {
        return function postTransformElement() {
          node = context.currentNode;
          if (!(node.type === 1 && (node.tagType === 0 || node.tagType === 1))) {
            return;
          }
          const { tag, props: props2 } = node;
          const isComponent2 = node.tagType === 1;
          let vnodeTag = isComponent2 ? resolveComponentType(node, context) : `"${tag}"`;
          const isDynamicComponent = isObject(vnodeTag) && vnodeTag.callee === RESOLVE_DYNAMIC_COMPONENT;
          let vnodeProps;
          let vnodeChildren;
          let vnodePatchFlag;
          let patchFlag = 0;
          let vnodeDynamicProps;
          let dynamicPropNames;
          let vnodeDirectives;
          let shouldUseBlock = isDynamicComponent || vnodeTag === TELEPORT || vnodeTag === SUSPENSE || !isComponent2 && (tag === "svg" || tag === "foreignObject" || findProp(node, "key", true));
          if (props2.length > 0) {
            const propsBuildResult = buildProps(node, context);
            vnodeProps = propsBuildResult.props;
            patchFlag = propsBuildResult.patchFlag;
            dynamicPropNames = propsBuildResult.dynamicPropNames;
            const directives2 = propsBuildResult.directives;
            vnodeDirectives = directives2 && directives2.length ? createArrayExpression(directives2.map((dir) => buildDirectiveArgs(dir, context))) : void 0;
          }
          if (node.children.length > 0) {
            if (vnodeTag === KEEP_ALIVE) {
              shouldUseBlock = true;
              patchFlag |= 1024;
              if (node.children.length > 1) {
                context.onError(createCompilerError(45, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
            }
            const shouldBuildAsSlots = isComponent2 && vnodeTag !== TELEPORT && vnodeTag !== KEEP_ALIVE;
            if (shouldBuildAsSlots) {
              const { slots, hasDynamicSlots } = buildSlots(node, context);
              vnodeChildren = slots;
              if (hasDynamicSlots) {
                patchFlag |= 1024;
              }
            } else if (node.children.length === 1 && vnodeTag !== TELEPORT) {
              const child = node.children[0];
              const type2 = child.type;
              const hasDynamicTextChild = type2 === 5 || type2 === 8;
              if (hasDynamicTextChild && getConstantType(child, context) === 0) {
                patchFlag |= 1;
              }
              if (hasDynamicTextChild || type2 === 2) {
                vnodeChildren = child;
              } else {
                vnodeChildren = node.children;
              }
            } else {
              vnodeChildren = node.children;
            }
          }
          if (patchFlag !== 0) {
            if (true) {
              if (patchFlag < 0) {
                vnodePatchFlag = patchFlag + ` /* ${PatchFlagNames[patchFlag]} */`;
              } else {
                const flagNames = Object.keys(PatchFlagNames).map(Number).filter((n) => n > 0 && patchFlag & n).map((n) => PatchFlagNames[n]).join(`, `);
                vnodePatchFlag = patchFlag + ` /* ${flagNames} */`;
              }
            } else {
              vnodePatchFlag = String(patchFlag);
            }
            if (dynamicPropNames && dynamicPropNames.length) {
              vnodeDynamicProps = stringifyDynamicPropNames(dynamicPropNames);
            }
          }
          node.codegenNode = createVNodeCall(context, vnodeTag, vnodeProps, vnodeChildren, vnodePatchFlag, vnodeDynamicProps, vnodeDirectives, !!shouldUseBlock, false, isComponent2, node.loc);
        };
      };
      true ? Object.freeze({}) : {};
      true ? Object.freeze([]) : [];
      cacheStringFunction2 = (fn) => {
        const cache = Object.create(null);
        return (str) => {
          const hit = cache[str];
          return hit || (cache[str] = fn(str));
        };
      };
      camelizeRE2 = /-(\w)/g;
      camelize2 = cacheStringFunction2((str) => {
        return str.replace(camelizeRE2, (_, c) => c ? c.toUpperCase() : "");
      });
      transformSlotOutlet = (node, context) => {
        if (isSlotOutlet(node)) {
          const { children, loc } = node;
          const { slotName, slotProps } = processSlotOutlet(node, context);
          const slotArgs = [
            context.prefixIdentifiers ? `_ctx.$slots` : `$slots`,
            slotName
          ];
          if (slotProps) {
            slotArgs.push(slotProps);
          }
          if (children.length) {
            if (!slotProps) {
              slotArgs.push(`{}`);
            }
            slotArgs.push(createFunctionExpression([], children, false, false, loc));
          }
          if (context.scopeId && !context.slotted) {
            if (!slotProps) {
              slotArgs.push(`{}`);
            }
            if (!children.length) {
              slotArgs.push(`undefined`);
            }
            slotArgs.push(`true`);
          }
          node.codegenNode = createCallExpression(context.helper(RENDER_SLOT), slotArgs, loc);
        }
      };
      fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/;
      transformOn = (dir, node, context, augmentor) => {
        const { loc, modifiers, arg } = dir;
        if (!dir.exp && !modifiers.length) {
          context.onError(createCompilerError(35, loc));
        }
        let eventName;
        if (arg.type === 4) {
          if (arg.isStatic) {
            const rawName = arg.content;
            eventName = createSimpleExpression(toHandlerKey(camelize(rawName)), true, arg.loc);
          } else {
            eventName = createCompoundExpression([
              `${context.helperString(TO_HANDLER_KEY)}(`,
              arg,
              `)`
            ]);
          }
        } else {
          eventName = arg;
          eventName.children.unshift(`${context.helperString(TO_HANDLER_KEY)}(`);
          eventName.children.push(`)`);
        }
        let exp = dir.exp;
        if (exp && !exp.content.trim()) {
          exp = void 0;
        }
        let shouldCache = context.cacheHandlers && !exp && !context.inVOnce;
        if (exp) {
          const isMemberExp = isMemberExpression(exp.content);
          const isInlineStatement = !(isMemberExp || fnExpRE.test(exp.content));
          const hasMultipleStatements = exp.content.includes(`;`);
          if (true) {
            validateBrowserExpression(exp, context, false, hasMultipleStatements);
          }
          if (isInlineStatement || shouldCache && isMemberExp) {
            exp = createCompoundExpression([
              `${isInlineStatement ? `$event` : `${``}(...args)`} => ${hasMultipleStatements ? `{` : `(`}`,
              exp,
              hasMultipleStatements ? `}` : `)`
            ]);
          }
        }
        let ret = {
          props: [
            createObjectProperty(eventName, exp || createSimpleExpression(`() => {}`, false, loc))
          ]
        };
        if (augmentor) {
          ret = augmentor(ret);
        }
        if (shouldCache) {
          ret.props[0].value = context.cache(ret.props[0].value);
        }
        ret.props.forEach((p2) => p2.key.isHandlerKey = true);
        return ret;
      };
      transformBind = (dir, _node, context) => {
        const { exp, modifiers, loc } = dir;
        const arg = dir.arg;
        if (arg.type !== 4) {
          arg.children.unshift(`(`);
          arg.children.push(`) || ""`);
        } else if (!arg.isStatic) {
          arg.content = `${arg.content} || ""`;
        }
        if (modifiers.includes("camel")) {
          if (arg.type === 4) {
            if (arg.isStatic) {
              arg.content = camelize(arg.content);
            } else {
              arg.content = `${context.helperString(CAMELIZE)}(${arg.content})`;
            }
          } else {
            arg.children.unshift(`${context.helperString(CAMELIZE)}(`);
            arg.children.push(`)`);
          }
        }
        if (!context.inSSR) {
          if (modifiers.includes("prop")) {
            injectPrefix(arg, ".");
          }
          if (modifiers.includes("attr")) {
            injectPrefix(arg, "^");
          }
        }
        if (!exp || exp.type === 4 && !exp.content.trim()) {
          context.onError(createCompilerError(34, loc));
          return {
            props: [createObjectProperty(arg, createSimpleExpression("", true, loc))]
          };
        }
        return {
          props: [createObjectProperty(arg, exp)]
        };
      };
      injectPrefix = (arg, prefix) => {
        if (arg.type === 4) {
          if (arg.isStatic) {
            arg.content = prefix + arg.content;
          } else {
            arg.content = `\`${prefix}\${${arg.content}}\``;
          }
        } else {
          arg.children.unshift(`'${prefix}' + (`);
          arg.children.push(`)`);
        }
      };
      transformText = (node, context) => {
        if (node.type === 0 || node.type === 1 || node.type === 11 || node.type === 10) {
          return () => {
            const children = node.children;
            let currentContainer = void 0;
            let hasText = false;
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (isText(child)) {
                hasText = true;
                for (let j = i + 1; j < children.length; j++) {
                  const next = children[j];
                  if (isText(next)) {
                    if (!currentContainer) {
                      currentContainer = children[i] = {
                        type: 8,
                        loc: child.loc,
                        children: [child]
                      };
                    }
                    currentContainer.children.push(` + `, next);
                    children.splice(j, 1);
                    j--;
                  } else {
                    currentContainer = void 0;
                    break;
                  }
                }
              }
            }
            if (!hasText || children.length === 1 && (node.type === 0 || node.type === 1 && node.tagType === 0 && !node.props.find((p2) => p2.type === 7 && !context.directiveTransforms[p2.name]) && !(node.tag === "template"))) {
              return;
            }
            for (let i = 0; i < children.length; i++) {
              const child = children[i];
              if (isText(child) || child.type === 8) {
                const callArgs = [];
                if (child.type !== 2 || child.content !== " ") {
                  callArgs.push(child);
                }
                if (!context.ssr && getConstantType(child, context) === 0) {
                  callArgs.push(1 + (true ? ` /* ${PatchFlagNames[1]} */` : ``));
                }
                children[i] = {
                  type: 12,
                  content: child,
                  loc: child.loc,
                  codegenNode: createCallExpression(context.helper(CREATE_TEXT), callArgs)
                };
              }
            }
          };
        }
      };
      seen = new WeakSet();
      transformOnce = (node, context) => {
        if (node.type === 1 && findDir(node, "once", true)) {
          if (seen.has(node) || context.inVOnce) {
            return;
          }
          seen.add(node);
          context.inVOnce = true;
          context.helper(SET_BLOCK_TRACKING);
          return () => {
            context.inVOnce = false;
            const cur = context.currentNode;
            if (cur.codegenNode) {
              cur.codegenNode = context.cache(cur.codegenNode, true);
            }
          };
        }
      };
      transformModel = (dir, node, context) => {
        const { exp, arg } = dir;
        if (!exp) {
          context.onError(createCompilerError(41, dir.loc));
          return createTransformProps();
        }
        const rawExp = exp.loc.source;
        const expString = exp.type === 4 ? exp.content : rawExp;
        context.bindingMetadata[rawExp];
        const maybeRef = false;
        if (!expString.trim() || !isMemberExpression(expString) && !maybeRef) {
          context.onError(createCompilerError(42, exp.loc));
          return createTransformProps();
        }
        const propName = arg ? arg : createSimpleExpression("modelValue", true);
        const eventName = arg ? isStaticExp(arg) ? `onUpdate:${arg.content}` : createCompoundExpression(['"onUpdate:" + ', arg]) : `onUpdate:modelValue`;
        let assignmentExp;
        const eventArg = context.isTS ? `($event: any)` : `$event`;
        {
          assignmentExp = createCompoundExpression([
            `${eventArg} => (`,
            exp,
            ` = $event)`
          ]);
        }
        const props2 = [
          createObjectProperty(propName, dir.exp),
          createObjectProperty(eventName, assignmentExp)
        ];
        if (dir.modifiers.length && node.tagType === 1) {
          const modifiers = dir.modifiers.map((m) => (isSimpleIdentifier(m) ? m : JSON.stringify(m)) + `: true`).join(`, `);
          const modifiersKey = arg ? isStaticExp(arg) ? `${arg.content}Modifiers` : createCompoundExpression([arg, ' + "Modifiers"']) : `modelModifiers`;
          props2.push(createObjectProperty(modifiersKey, createSimpleExpression(`{ ${modifiers} }`, false, dir.loc, 2)));
        }
        return createTransformProps(props2);
      };
      validDivisionCharRE = /[\w).+\-_$\]]/;
      transformFilter = (node, context) => {
        if (!isCompatEnabled("COMPILER_FILTER", context)) {
          return;
        }
        if (node.type === 5) {
          rewriteFilter(node.content, context);
        }
        if (node.type === 1) {
          node.props.forEach((prop) => {
            if (prop.type === 7 && prop.name !== "for" && prop.exp) {
              rewriteFilter(prop.exp, context);
            }
          });
        }
      };
      seen$1 = new WeakSet();
      transformMemo = (node, context) => {
        if (node.type === 1) {
          const dir = findDir(node, "memo");
          if (!dir || seen$1.has(node)) {
            return;
          }
          seen$1.add(node);
          return () => {
            const codegenNode = node.codegenNode || context.currentNode.codegenNode;
            if (codegenNode && codegenNode.type === 13) {
              if (node.tagType !== 1) {
                makeBlock(codegenNode, context);
              }
              node.codegenNode = createCallExpression(context.helper(WITH_MEMO), [
                dir.exp,
                createFunctionExpression(void 0, codegenNode),
                `_cache`,
                String(context.cached++)
              ]);
            }
          };
        }
      };
      noopDirectiveTransform = () => ({ props: [] });
    }
  });

  // node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js
  function decodeHtmlBrowser(raw, asAttr = false) {
    if (!decoder) {
      decoder = document.createElement("div");
    }
    if (asAttr) {
      decoder.innerHTML = `<div foo="${raw.replace(/"/g, "&quot;")}">`;
      return decoder.children[0].getAttribute("foo");
    } else {
      decoder.innerHTML = raw;
      return decoder.textContent;
    }
  }
  function createDOMCompilerError(code, loc) {
    return createCompilerError(code, loc, true ? DOMErrorMessages : void 0);
  }
  function hasMultipleChildren(node) {
    const children = node.children = node.children.filter((c) => c.type !== 3);
    const child = children[0];
    return children.length !== 1 || child.type === 11 || child.type === 9 && child.branches.some(hasMultipleChildren);
  }
  function compile2(template, options = {}) {
    return baseCompile(template, extend({}, parserOptions, options, {
      nodeTransforms: [
        ignoreSideEffectTags,
        ...DOMNodeTransforms,
        ...options.nodeTransforms || []
      ],
      directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),
      transformHoist: null
    }));
  }
  var import_pako, V_MODEL_RADIO, V_MODEL_CHECKBOX, V_MODEL_TEXT, V_MODEL_SELECT, V_MODEL_DYNAMIC, V_ON_WITH_MODIFIERS, V_ON_WITH_KEYS, V_SHOW, TRANSITION2, TRANSITION_GROUP, decoder, isRawTextContainer, parserOptions, transformStyle, parseInlineCSS, DOMErrorMessages, transformVHtml, transformVText, transformModel2, isEventOptionModifier, isNonKeyModifier, maybeKeyModifier, isKeyboardEvent, resolveModifiers, transformClick, transformOn2, transformShow, warnTransitionChildren, ignoreSideEffectTags, DOMNodeTransforms, DOMDirectiveTransforms;
  var init_compiler_dom_esm_bundler = __esm({
    "node_modules/@vue/compiler-dom/dist/compiler-dom.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_compiler_core_esm_bundler();
      init_compiler_core_esm_bundler();
      init_shared_esm_bundler();
      V_MODEL_RADIO = Symbol(true ? `vModelRadio` : ``);
      V_MODEL_CHECKBOX = Symbol(true ? `vModelCheckbox` : ``);
      V_MODEL_TEXT = Symbol(true ? `vModelText` : ``);
      V_MODEL_SELECT = Symbol(true ? `vModelSelect` : ``);
      V_MODEL_DYNAMIC = Symbol(true ? `vModelDynamic` : ``);
      V_ON_WITH_MODIFIERS = Symbol(true ? `vOnModifiersGuard` : ``);
      V_ON_WITH_KEYS = Symbol(true ? `vOnKeysGuard` : ``);
      V_SHOW = Symbol(true ? `vShow` : ``);
      TRANSITION2 = Symbol(true ? `Transition` : ``);
      TRANSITION_GROUP = Symbol(true ? `TransitionGroup` : ``);
      registerRuntimeHelpers({
        [V_MODEL_RADIO]: `vModelRadio`,
        [V_MODEL_CHECKBOX]: `vModelCheckbox`,
        [V_MODEL_TEXT]: `vModelText`,
        [V_MODEL_SELECT]: `vModelSelect`,
        [V_MODEL_DYNAMIC]: `vModelDynamic`,
        [V_ON_WITH_MODIFIERS]: `withModifiers`,
        [V_ON_WITH_KEYS]: `withKeys`,
        [V_SHOW]: `vShow`,
        [TRANSITION2]: `Transition`,
        [TRANSITION_GROUP]: `TransitionGroup`
      });
      isRawTextContainer = /* @__PURE__ */ makeMap("style,iframe,script,noscript", true);
      parserOptions = {
        isVoidTag,
        isNativeTag: (tag) => isHTMLTag(tag) || isSVGTag(tag),
        isPreTag: (tag) => tag === "pre",
        decodeEntities: decodeHtmlBrowser,
        isBuiltInComponent: (tag) => {
          if (isBuiltInType(tag, `Transition`)) {
            return TRANSITION2;
          } else if (isBuiltInType(tag, `TransitionGroup`)) {
            return TRANSITION_GROUP;
          }
        },
        getNamespace(tag, parent) {
          let ns = parent ? parent.ns : 0;
          if (parent && ns === 2) {
            if (parent.tag === "annotation-xml") {
              if (tag === "svg") {
                return 1;
              }
              if (parent.props.some((a) => a.type === 6 && a.name === "encoding" && a.value != null && (a.value.content === "text/html" || a.value.content === "application/xhtml+xml"))) {
                ns = 0;
              }
            } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== "mglyph" && tag !== "malignmark") {
              ns = 0;
            }
          } else if (parent && ns === 1) {
            if (parent.tag === "foreignObject" || parent.tag === "desc" || parent.tag === "title") {
              ns = 0;
            }
          }
          if (ns === 0) {
            if (tag === "svg") {
              return 1;
            }
            if (tag === "math") {
              return 2;
            }
          }
          return ns;
        },
        getTextMode({ tag, ns }) {
          if (ns === 0) {
            if (tag === "textarea" || tag === "title") {
              return 1;
            }
            if (isRawTextContainer(tag)) {
              return 2;
            }
          }
          return 0;
        }
      };
      transformStyle = (node) => {
        if (node.type === 1) {
          node.props.forEach((p2, i) => {
            if (p2.type === 6 && p2.name === "style" && p2.value) {
              node.props[i] = {
                type: 7,
                name: `bind`,
                arg: createSimpleExpression(`style`, true, p2.loc),
                exp: parseInlineCSS(p2.value.content, p2.loc),
                modifiers: [],
                loc: p2.loc
              };
            }
          });
        }
      };
      parseInlineCSS = (cssText, loc) => {
        const normalized = parseStringStyle(cssText);
        return createSimpleExpression(JSON.stringify(normalized), false, loc, 3);
      };
      DOMErrorMessages = {
        [50]: `v-html is missing expression.`,
        [51]: `v-html will override element children.`,
        [52]: `v-text is missing expression.`,
        [53]: `v-text will override element children.`,
        [54]: `v-model can only be used on <input>, <textarea> and <select> elements.`,
        [55]: `v-model argument is not supported on plain elements.`,
        [56]: `v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.`,
        [57]: `Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.`,
        [58]: `v-show is missing expression.`,
        [59]: `<Transition> expects exactly one child element or component.`,
        [60]: `Tags with side effect (<script> and <style>) are ignored in client component templates.`
      };
      transformVHtml = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(createDOMCompilerError(50, loc));
        }
        if (node.children.length) {
          context.onError(createDOMCompilerError(51, loc));
          node.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`innerHTML`, true, loc), exp || createSimpleExpression("", true))
          ]
        };
      };
      transformVText = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(createDOMCompilerError(52, loc));
        }
        if (node.children.length) {
          context.onError(createDOMCompilerError(53, loc));
          node.children.length = 0;
        }
        return {
          props: [
            createObjectProperty(createSimpleExpression(`textContent`, true), exp ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression("", true))
          ]
        };
      };
      transformModel2 = (dir, node, context) => {
        const baseResult = transformModel(dir, node, context);
        if (!baseResult.props.length || node.tagType === 1) {
          return baseResult;
        }
        if (dir.arg) {
          context.onError(createDOMCompilerError(55, dir.arg.loc));
        }
        function checkDuplicatedValue() {
          const value2 = findProp(node, "value");
          if (value2) {
            context.onError(createDOMCompilerError(57, value2.loc));
          }
        }
        const { tag } = node;
        const isCustomElement = context.isCustomElement(tag);
        if (tag === "input" || tag === "textarea" || tag === "select" || isCustomElement) {
          let directiveToUse = V_MODEL_TEXT;
          let isInvalidType = false;
          if (tag === "input" || isCustomElement) {
            const type2 = findProp(node, `type`);
            if (type2) {
              if (type2.type === 7) {
                directiveToUse = V_MODEL_DYNAMIC;
              } else if (type2.value) {
                switch (type2.value.content) {
                  case "radio":
                    directiveToUse = V_MODEL_RADIO;
                    break;
                  case "checkbox":
                    directiveToUse = V_MODEL_CHECKBOX;
                    break;
                  case "file":
                    isInvalidType = true;
                    context.onError(createDOMCompilerError(56, dir.loc));
                    break;
                  default:
                    checkDuplicatedValue();
                    break;
                }
              }
            } else if (hasDynamicKeyVBind(node)) {
              directiveToUse = V_MODEL_DYNAMIC;
            } else {
              checkDuplicatedValue();
            }
          } else if (tag === "select") {
            directiveToUse = V_MODEL_SELECT;
          } else {
            checkDuplicatedValue();
          }
          if (!isInvalidType) {
            baseResult.needRuntime = context.helper(directiveToUse);
          }
        } else {
          context.onError(createDOMCompilerError(54, dir.loc));
        }
        baseResult.props = baseResult.props.filter((p2) => !(p2.key.type === 4 && p2.key.content === "modelValue"));
        return baseResult;
      };
      isEventOptionModifier = /* @__PURE__ */ makeMap(`passive,once,capture`);
      isNonKeyModifier = /* @__PURE__ */ makeMap(`stop,prevent,self,ctrl,shift,alt,meta,exact,middle`);
      maybeKeyModifier = /* @__PURE__ */ makeMap("left,right");
      isKeyboardEvent = /* @__PURE__ */ makeMap(`onkeyup,onkeydown,onkeypress`, true);
      resolveModifiers = (key2, modifiers, context, loc) => {
        const keyModifiers = [];
        const nonKeyModifiers = [];
        const eventOptionModifiers = [];
        for (let i = 0; i < modifiers.length; i++) {
          const modifier = modifiers[i];
          if (modifier === "native" && checkCompatEnabled("COMPILER_V_ON_NATIVE", context, loc)) {
            eventOptionModifiers.push(modifier);
          } else if (isEventOptionModifier(modifier)) {
            eventOptionModifiers.push(modifier);
          } else {
            if (maybeKeyModifier(modifier)) {
              if (isStaticExp(key2)) {
                if (isKeyboardEvent(key2.content)) {
                  keyModifiers.push(modifier);
                } else {
                  nonKeyModifiers.push(modifier);
                }
              } else {
                keyModifiers.push(modifier);
                nonKeyModifiers.push(modifier);
              }
            } else {
              if (isNonKeyModifier(modifier)) {
                nonKeyModifiers.push(modifier);
              } else {
                keyModifiers.push(modifier);
              }
            }
          }
        }
        return {
          keyModifiers,
          nonKeyModifiers,
          eventOptionModifiers
        };
      };
      transformClick = (key2, event3) => {
        const isStaticClick = isStaticExp(key2) && key2.content.toLowerCase() === "onclick";
        return isStaticClick ? createSimpleExpression(event3, true) : key2.type !== 4 ? createCompoundExpression([
          `(`,
          key2,
          `) === "onClick" ? "${event3}" : (`,
          key2,
          `)`
        ]) : key2;
      };
      transformOn2 = (dir, node, context) => {
        return transformOn(dir, node, context, (baseResult) => {
          const { modifiers } = dir;
          if (!modifiers.length)
            return baseResult;
          let { key: key2, value: handlerExp } = baseResult.props[0];
          const { keyModifiers, nonKeyModifiers, eventOptionModifiers } = resolveModifiers(key2, modifiers, context, dir.loc);
          if (nonKeyModifiers.includes("right")) {
            key2 = transformClick(key2, `onContextmenu`);
          }
          if (nonKeyModifiers.includes("middle")) {
            key2 = transformClick(key2, `onMouseup`);
          }
          if (nonKeyModifiers.length) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [
              handlerExp,
              JSON.stringify(nonKeyModifiers)
            ]);
          }
          if (keyModifiers.length && (!isStaticExp(key2) || isKeyboardEvent(key2.content))) {
            handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [
              handlerExp,
              JSON.stringify(keyModifiers)
            ]);
          }
          if (eventOptionModifiers.length) {
            const modifierPostfix = eventOptionModifiers.map(capitalize).join("");
            key2 = isStaticExp(key2) ? createSimpleExpression(`${key2.content}${modifierPostfix}`, true) : createCompoundExpression([`(`, key2, `) + "${modifierPostfix}"`]);
          }
          return {
            props: [createObjectProperty(key2, handlerExp)]
          };
        });
      };
      transformShow = (dir, node, context) => {
        const { exp, loc } = dir;
        if (!exp) {
          context.onError(createDOMCompilerError(58, loc));
        }
        return {
          props: [],
          needRuntime: context.helper(V_SHOW)
        };
      };
      warnTransitionChildren = (node, context) => {
        if (node.type === 1 && node.tagType === 1) {
          const component = context.isBuiltInComponent(node.tag);
          if (component === TRANSITION2) {
            return () => {
              if (node.children.length && hasMultipleChildren(node)) {
                context.onError(createDOMCompilerError(59, {
                  start: node.children[0].loc.start,
                  end: node.children[node.children.length - 1].loc.end,
                  source: ""
                }));
              }
            };
          }
        }
      };
      ignoreSideEffectTags = (node, context) => {
        if (node.type === 1 && node.tagType === 0 && (node.tag === "script" || node.tag === "style")) {
          context.onError(createDOMCompilerError(60, node.loc));
          context.removeNode();
        }
      };
      DOMNodeTransforms = [
        transformStyle,
        ...true ? [warnTransitionChildren] : []
      ];
      DOMDirectiveTransforms = {
        cloak: noopDirectiveTransform,
        html: transformVHtml,
        text: transformVText,
        model: transformModel2,
        on: transformOn2,
        show: transformShow
      };
    }
  });

  // node_modules/vue/dist/vue.esm-bundler.js
  var vue_esm_bundler_exports = {};
  __export(vue_esm_bundler_exports, {
    BaseTransition: () => BaseTransition,
    Comment: () => Comment,
    EffectScope: () => EffectScope,
    Fragment: () => Fragment,
    KeepAlive: () => KeepAlive,
    ReactiveEffect: () => ReactiveEffect,
    Static: () => Static,
    Suspense: () => Suspense,
    Teleport: () => Teleport,
    Text: () => Text,
    Transition: () => Transition,
    TransitionGroup: () => TransitionGroup,
    VueElement: () => VueElement,
    callWithAsyncErrorHandling: () => callWithAsyncErrorHandling,
    callWithErrorHandling: () => callWithErrorHandling,
    camelize: () => camelize,
    capitalize: () => capitalize,
    cloneVNode: () => cloneVNode,
    compatUtils: () => compatUtils,
    compile: () => compileToFunction,
    computed: () => computed2,
    createApp: () => createApp2,
    createBlock: () => createBlock,
    createCommentVNode: () => createCommentVNode,
    createElementBlock: () => createElementBlock,
    createElementVNode: () => createBaseVNode,
    createHydrationRenderer: () => createHydrationRenderer,
    createRenderer: () => createRenderer,
    createSSRApp: () => createSSRApp,
    createSlots: () => createSlots,
    createStaticVNode: () => createStaticVNode,
    createTextVNode: () => createTextVNode,
    createVNode: () => createVNode,
    customRef: () => customRef,
    defineAsyncComponent: () => defineAsyncComponent,
    defineComponent: () => defineComponent2,
    defineCustomElement: () => defineCustomElement,
    defineEmits: () => defineEmits,
    defineExpose: () => defineExpose,
    defineProps: () => defineProps,
    defineSSRCustomElement: () => defineSSRCustomElement,
    devtools: () => devtools,
    effect: () => effect,
    effectScope: () => effectScope,
    getCurrentInstance: () => getCurrentInstance,
    getCurrentScope: () => getCurrentScope,
    getTransitionRawChildren: () => getTransitionRawChildren,
    guardReactiveProps: () => guardReactiveProps,
    h: () => h,
    handleError: () => handleError,
    hydrate: () => hydrate,
    initCustomFormatter: () => initCustomFormatter,
    inject: () => inject2,
    isMemoSame: () => isMemoSame,
    isProxy: () => isProxy,
    isReactive: () => isReactive,
    isReadonly: () => isReadonly,
    isRef: () => isRef,
    isRuntimeOnly: () => isRuntimeOnly,
    isVNode: () => isVNode,
    markRaw: () => markRaw,
    mergeDefaults: () => mergeDefaults,
    mergeProps: () => mergeProps,
    nextTick: () => nextTick2,
    normalizeClass: () => normalizeClass,
    normalizeProps: () => normalizeProps,
    normalizeStyle: () => normalizeStyle,
    onActivated: () => onActivated,
    onBeforeMount: () => onBeforeMount,
    onBeforeUnmount: () => onBeforeUnmount2,
    onBeforeUpdate: () => onBeforeUpdate,
    onDeactivated: () => onDeactivated,
    onErrorCaptured: () => onErrorCaptured,
    onMounted: () => onMounted2,
    onRenderTracked: () => onRenderTracked,
    onRenderTriggered: () => onRenderTriggered,
    onScopeDispose: () => onScopeDispose,
    onServerPrefetch: () => onServerPrefetch,
    onUnmounted: () => onUnmounted,
    onUpdated: () => onUpdated,
    openBlock: () => openBlock,
    popScopeId: () => popScopeId,
    provide: () => provide2,
    proxyRefs: () => proxyRefs,
    pushScopeId: () => pushScopeId,
    queuePostFlushCb: () => queuePostFlushCb,
    reactive: () => reactive2,
    readonly: () => readonly,
    ref: () => ref,
    registerRuntimeCompiler: () => registerRuntimeCompiler,
    render: () => render,
    renderList: () => renderList,
    renderSlot: () => renderSlot,
    resolveComponent: () => resolveComponent,
    resolveDirective: () => resolveDirective,
    resolveDynamicComponent: () => resolveDynamicComponent,
    resolveFilter: () => resolveFilter,
    resolveTransitionHooks: () => resolveTransitionHooks,
    setBlockTracking: () => setBlockTracking,
    setDevtoolsHook: () => setDevtoolsHook,
    setTransitionHooks: () => setTransitionHooks,
    shallowReactive: () => shallowReactive,
    shallowReadonly: () => shallowReadonly,
    shallowRef: () => shallowRef,
    ssrContextKey: () => ssrContextKey,
    ssrUtils: () => ssrUtils,
    stop: () => stop,
    toDisplayString: () => toDisplayString,
    toHandlerKey: () => toHandlerKey,
    toHandlers: () => toHandlers,
    toRaw: () => toRaw,
    toRef: () => toRef,
    toRefs: () => toRefs,
    transformVNodeArgs: () => transformVNodeArgs,
    triggerRef: () => triggerRef,
    unref: () => unref,
    useAttrs: () => useAttrs,
    useCssModule: () => useCssModule,
    useCssVars: () => useCssVars,
    useSSRContext: () => useSSRContext,
    useSlots: () => useSlots,
    useTransitionState: () => useTransitionState,
    vModelCheckbox: () => vModelCheckbox,
    vModelDynamic: () => vModelDynamic,
    vModelRadio: () => vModelRadio,
    vModelSelect: () => vModelSelect,
    vModelText: () => vModelText,
    vShow: () => vShow,
    version: () => version,
    warn: () => warn2,
    watch: () => watch,
    watchEffect: () => watchEffect,
    watchPostEffect: () => watchPostEffect,
    watchSyncEffect: () => watchSyncEffect,
    withAsyncContext: () => withAsyncContext,
    withCtx: () => withCtx,
    withDefaults: () => withDefaults,
    withDirectives: () => withDirectives,
    withKeys: () => withKeys,
    withMemo: () => withMemo,
    withModifiers: () => withModifiers,
    withScopeId: () => withScopeId
  });
  function initDev() {
    {
      initCustomFormatter();
    }
  }
  function compileToFunction(template, options) {
    if (!isString(template)) {
      if (template.nodeType) {
        template = template.innerHTML;
      } else {
        warn2(`invalid template option: `, template);
        return NOOP;
      }
    }
    const key2 = template;
    const cached = compileCache[key2];
    if (cached) {
      return cached;
    }
    if (template[0] === "#") {
      const el = document.querySelector(template);
      if (!el) {
        warn2(`Template element not found or is empty: ${template}`);
      }
      template = el ? el.innerHTML : ``;
    }
    const { code } = compile2(template, extend({
      hoistStatic: true,
      onError: true ? onError : void 0,
      onWarn: true ? (e) => onError(e, true) : NOOP
    }, options));
    function onError(err, asWarning = false) {
      const message = asWarning ? err.message : `Template compilation error: ${err.message}`;
      const codeFrame = err.loc && generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);
      warn2(codeFrame ? `${message}
${codeFrame}` : message);
    }
    const render3 = new Function("Vue", code)(runtime_dom_esm_bundler_exports);
    render3._rc = true;
    return compileCache[key2] = render3;
  }
  var import_pako, compileCache;
  var init_vue_esm_bundler = __esm({
    "node_modules/vue/dist/vue.esm-bundler.js"() {
      import_pako = __toModule(require_pako());
      init_runtime_dom_esm_bundler();
      init_runtime_dom_esm_bundler();
      init_runtime_dom_esm_bundler();
      init_compiler_dom_esm_bundler();
      init_shared_esm_bundler();
      if (true) {
        initDev();
      }
      compileCache = Object.create(null);
      registerRuntimeCompiler(compileToFunction);
    }
  });

  // yehat/ecs.js
  function isObject3(item2) {
    return item2 && typeof item2 === "object" && !Array.isArray(item2);
  }
  function mergeDeep(target2, ...sources) {
    if (!sources.length)
      return target2;
    const source = sources.shift();
    if (isObject3(target2) && isObject3(source)) {
      for (const key2 in source) {
        if (isObject3(source[key2])) {
          if (!target2[key2])
            Object.assign(target2, { [key2]: {} });
          mergeDeep(target2[key2], source[key2]);
        } else {
          Object.assign(target2, { [key2]: source[key2] });
        }
      }
    }
    return mergeDeep(target2, ...sources);
  }
  var import_pako, logging, loadEntity2, Component, install, bindMethods, ecs2, Entity, define2, declareType;
  var init_ecs = __esm({
    "yehat/ecs.js"() {
      import_pako = __toModule(require_pako());
      init_vue_esm_bundler();
      logging = {
        loading: 0,
        loadingRoster: 1,
        loadingVerbose: 0,
        bindMethods: 0,
        enchanting: 0,
        enchantingVerbose: 0,
        traceCreate: 0,
        traceTypeDeclared: 0
      };
      loadEntity2 = (a = []) => ({ id: id2, prefix = "yehat1", exclude = [], ...rest }) => {
        const saveLocalCompo = a.find((compo) => !!compo.saveLocal);
        const saveLocal = saveLocalCompo ? saveLocalCompo.saveLocal : null;
        if (logging.traceSaving)
          console.trace("[ECS]saveLocal", saveLocal);
        let initial;
        let d = 0;
        if (saveLocal && saveLocal.forceUpgrade) {
          const stored = JSON.parse(localStorage[`${prefix}-${id2}`] || "{}");
          for (let key2 in stored) {
            if (~saveLocal.forceUpgrade.indexOf(key2)) {
              delete stored[key2];
              d++;
            }
          }
          initial = { ...rest, ...stored };
        } else {
          initial = { ...rest, ...JSON.parse(localStorage[`${prefix}-${id2}`] || "{}") };
        }
        if (logging.loading)
          core.log("loadEntity def", a, "direct", { id: id2, ...rest }, "saved", JSON.parse(localStorage[`${prefix}-${id2}`] || "{}"), "merged", initial);
        let b = { id: id2 };
        let fn = [];
        for (let key2 in a) {
          let component = a[key2];
          for (let name in component) {
            if (typeof component[name] == "object" && !Array.isArray(component[name])) {
              if (name == "websocketConfig")
                console.log("!websocketConfig current", b[name], "component", component[name], "initial", initial[name]);
              b[name] = { ...b[name] || {}, ...component[name], ...initial[name] || {} };
            } else if (typeof component[name] == "object" && Array.isArray(component[name])) {
              b[name] = initial[name] || component[name];
            } else {
              b[name] = initial[name] || component[name];
            }
          }
        }
        if (saveLocal && saveLocal.arbitrary) {
          for (let keyUnfamous in initial) {
            if (b[keyUnfamous])
              continue;
            b[keyUnfamous] = mergeDeep({}, initial[keyUnfamous]);
          }
        }
        const en = reactive2(b);
        if (d)
          core.log(`[ECS]Loading Entity ${en.meta ? en.meta.type : en.id}, ${d} keys upgraded.`);
        bindMethods({ entity: en, exclude });
        if (!ecs2.root[en.id]) {
          ecs2.root[en.id] = en;
          ecs2.totalCount++;
        } else {
          ecs2.root[en.id] = en;
        }
        return en;
      };
      Component = (name, structure) => {
        if (typeof structure == "object") {
          if (Array.isArray(structure)) {
            return (a = []) => ({
              [name]: [...structure, ...a]
            });
          } else {
            return (a = {}) => ({
              [name]: mergeDeep({}, structure, a)
            });
          }
        } else {
          return (v) => ({
            [name]: v || structure
          });
        }
      };
      install = (e) => (a, context) => {
        a.forEach((fn) => {
          const chant = fn(e, context);
          for (let i in chant) {
            e[i] = chant[i];
          }
          return e;
        });
        return e;
      };
      bindMethods = ({ entity, exclude = [], only }) => {
        [{ install }].map((enchantMethod) => {
          const name = Object.keys(enchantMethod)[0];
          const fn = enchantMethod[name];
          entity[name] = fn(entity);
        });
        let c = 0, ci = 0;
        let ca = [];
        for (let k2 in entity) {
          if (~exclude.indexOf(k2))
            continue;
          if (only && k2 != only)
            continue;
          let component = entity[k2];
          if (typeof component != "object" || Array.isArray(component))
            continue;
          for (let key2 in component) {
            let v = component[key2];
            if (typeof v == "function") {
              let returns = v(entity);
              if (typeof returns == "undefined") {
                delete entity[k2][key2];
                if (logging.enchantingVerbose)
                  core.log("[ECS]Initialized passed and removed.", `${entity.meta.name}[${entity.id}].${k2}.${key2}`);
                ci++;
              } else {
                entity[k2][key2] = returns;
                c++;
              }
              ca.push(`${k2}.${key2}`);
            }
          }
        }
        if (logging.bindMethods)
          console.log("[ECS]Entity", entity.meta.name, `methods bound ${c}:`, ca.join(", "), `initializers executed ${ci}`, entity);
        return entity;
      };
      ecs2 = {
        version: "A-0.5",
        compo: {},
        compopedia: {},
        types: {},
        typeopedia: {},
        typeTags: {},
        root: reactive2({}),
        totalCount: 0,
        prefix: "yehat1",
        define: (name, def2, compopedia = { details: "No details." }) => {
          ecs2.compo[name] = Component(name, def2);
          ecs2.compopedia[name] = compopedia;
          return ecs2.compo[name];
        },
        declareType: (name, def2 = [], typeopedia = {}, init = (a) => a) => {
          if (logging.traceTypeDeclared)
            console.trace(`[ECS typeDeclared ${name}]`);
          ecs2.types[name] = typeof def2 == "function" ? def2 : ({ id: id2, ...rest }) => init(loadEntity2(def2)({ id: id2 || core.slug(), ...rest }));
          ecs2.typeopedia[name] = { details: "No details.", tags: [], ...typeopedia };
          return ecs2.types[name];
        },
        declareCompoSet: (name, def2 = [], typeopedia = {}) => {
          ecs2.types[name] = def2;
          ecs2.typeopedia[name] = { details: "No details.", tags: [], ...typeopedia };
          return ecs2.types[name];
        },
        create: (type2, { id: id2, ...a } = {}) => {
          if (logging.traceCreate)
            console.trace(`[ECS create ${type2}${id2 ? " " + id2 : ""}]`);
          if (!ecs2.types[type2])
            throw `[ECS]Cannot create ${type2}`;
          const entity = ecs2.types[type2]({ id: id2, ...a });
          entity.type = type2;
          return entity;
        },
        enforce: (type2, { id: id2, ...a } = {}) => {
          if (ecs2.root[id2]) {
            ecs2.root[id2] = mergeDeep(ecs2.root[id2], a);
            return ecs2.root[id2];
          } else {
            return ecs2.create(type2, { id: id2, ...a });
          }
        },
        remove: ({ id: id2 }) => {
          delete ecs2.root[id2];
        },
        install: (e, a, env = {}) => {
          let c = 0, m = 0;
          a.forEach((fn) => {
            const chant = fn(e, env);
            for (let i in chant) {
              e[i] = chant[i];
              m++;
            }
            c++;
          });
          if (logging.enchanting)
            core.log(`[ECS] ${e.meta ? e.meta.name : "Unknown"} ${c} Enchantments installed: ${m} methods in total.`);
        },
        loadLocalInstance: (id2) => {
          const roster = JSON.parse(localStorage[`${ecs2.prefix}-local-roster`] || "{}");
          let type2 = roster[id2];
          try {
            if (!ecs2.types[type2]) {
              console.trace(`[ECS]Unknown type: ${type2}`);
              return;
            }
            const item2 = ecs2.create(type2, { id: id2 });
            if (logging.loadingRoster) {
              core.log(`[ECS]Single Local Instance Loaded ${pure.itemToken(item2)}.`);
            }
            return item2;
          } catch (e) {
            core.log(`[ECS]Failed to load Local Instance ${id2} with type ${type2}.`, e);
          }
          return null;
        },
        loadLocalInstances: () => {
          const roster = JSON.parse(localStorage[`${ecs2.prefix}-local-roster`] || "{}");
          let c = 0, skipped = 0, ca = [];
          Object.keys(roster).map((id2) => {
            let type2 = roster[id2];
            try {
              if (!ecs2.types[type2]) {
                core.log(`[ECS]Unknow type: ${type2}`);
                return;
              }
              if (!ecs2.root[id2]) {
                ecs2.create(type2, { id: id2 });
                c++;
              } else {
                skipped++;
              }
              if (logging.loadingVerbose)
                ca.push(ecs2.root[id2].meta ? ecs2.root[id2].meta.name : "-Unknown-");
            } catch (e) {
              core.log(`[ECS]Failed to load Local Instance ${id2} with type ${type2}.`, e);
            }
          });
          if (logging.loadingRoster) {
            if (logging.loadingVerbose) {
              core.log(`[ECS]${c} Local Instances Loaded: ${ca.join(", ")}, skipped: ${skipped}.`);
            } else {
              core.log(`[ECS]${c} Local Instances Loaded: ${c}, skipped: ${skipped}.`);
            }
          }
        },
        erase: ({ entityID }) => {
          const roster = JSON.parse(localStorage[`${ecs2.prefix}-local-roster`] || "{}");
          if (roster[entityID]) {
            delete roster[entityID];
            localStorage[`${ecs2.prefix}-local-roster`] = JSON.stringify(roster);
            core.log(`[ECS]Entity ${entityID} deleted from roster.`);
          } else {
            core.log(`[ECS]Entity ${entityID} was not in roster.`);
          }
          delete localStorage[`${ecs2.prefix}-${entityID}`];
        },
        bindMethods,
        loadEntity: loadEntity2,
        addComponent: (entity, compo) => {
          const name = Object.keys(compo)[0];
          if (!name)
            throw "ecs.addComponent, no component passed as the 2rd parameter.";
          entity[name] = compo[name];
          bindMethods({ entity, only: name });
        },
        enchantments: {
          connections: [
            (item2) => {
              console.log("[ECS]T5 Connections", item2);
              if (item2.connections) {
                item2.c = computed2(() => {
                  console.log("[ECS]Recomputing connections", item2.meta.name, Object.keys(item2.connections).length);
                  const a = {};
                  for (let key2 in item2.connections) {
                    a[key2] = ecs2.root[item2.connections[key2]];
                  }
                  return a;
                });
                console.log("[ECS]T5 Connections Installed", item2.meta ? item2.meta.name : "- Unknown -");
              }
            }
          ]
        },
        find: (p2) => Object.values(ecs2.root).filter(p2),
        findOne: (p2) => ecs2.find(p2)[0] || null,
        by: (p2, { map: map2, sort, process: process2 } = {}) => computed2(() => {
          const a = ecs2.find(p2);
          let b;
          if (!map2 && !sort) {
            b = a;
          } else if (map2 && !sort) {
            b = a.map(map2);
          } else if (!map2 && sort) {
            b = a.sort(sort);
          } else if (map2 && sort) {
            b = a.sort(sort).map(map2);
          }
          return process2 ? process2(b) : b;
        }),
        byOne: (p2) => computed2(() => ecs2.findOne(p2)),
        byQuery: (query, options) => {
          return ecs2.by(ecs2.queryToPredicate(query), options);
        },
        queryToPredicate: (query) => {
          return new Function("v", `return (${query});`);
        },
        one: (type2, body) => computed2(() => {
          if (ecs2.root[body.id])
            return ecs2.root[body.id];
          ecs2.create(type2, body);
          return ecs2.root[body.id];
        }),
        singleton: (p2) => computed2(() => ecs2.find(p2)[0]),
        boot: (a, { common, dropNulls } = {}) => {
          let created = 0, updated = 0, skipped = 0, failed = 0;
          const items = a.map((item2) => {
            try {
              const { id: id2, type: type2, ...rest } = { ...common || {}, ...item2 };
              if (!ecs2.types[type2]) {
                core.log(`[ECS]Booting file skipping unknown type: ${type2} id: ${id2}`);
                skipped++;
                return null;
              }
              if (ecs2.root[id2]) {
                if (!ecs2.root[id2].type || ecs2.root[id2].type == type2) {
                  ecs2.root[id2] = mergeDeep(ecs2.root[id2], a);
                  updated++;
                } else {
                  delete ecs2.root[id2];
                  ecs2.create(type2, { id: id2, ...rest });
                  created++;
                }
              } else {
                ecs2.create(type2, { id: id2, ...rest });
                created++;
              }
              return ecs2.root[id2];
            } catch (e) {
              core.log(`[ECS]Booting file exception on item ${item2.id}`, e);
              failed++;
              return null;
            }
          });
          if (logging.booting && !failed)
            core.log(`[ECS]Booting file complete created ${created} updated ${updated} skipped ${skipped} failed ${failed}.`);
          if (dropNulls)
            return items.filter((v) => !!v);
          return items;
        },
        toJSON: (item2) => {
          const { c, ...rest } = item2;
          return JSON.stringify(rest, null, 2);
        },
        mergeDeep,
        box: (entities, { onlyRoster, ...options } = {}) => {
          const roster = {};
          const stat = {
            skipped: 0,
            packedRoot: 0,
            packedContained: 0,
            packedTotal: 0
          };
          for (let entity of entities) {
            if (!entity.saveLocal) {
              stat.skipped++;
              continue;
            }
            roster[entity.id] = entity.saveLocal.json();
            roster[entity.id].type = entity.type;
            let { roster: contains, stat: innerStat } = ecs2.box(ecs2.find((v) => v.located && v.located.rel === entity.id));
            let count = Object.keys(contains).length;
            if (count) {
              roster[entity.id].contains = contains;
            }
            stat.packedTotal += innerStat.packedTotal;
            stat.packedContained += innerStat.packedContained;
            stat.packedTotal++;
            stat.packedRoot++;
          }
          if (onlyRoster) {
            return roster;
          } else {
            return { roster, stat };
          }
        },
        unbox: (roster) => {
          const stat = {
            loaded: 0,
            skipped: 0,
            ids: []
          };
          for (let id2 in roster) {
            let { contains, ...item2 } = roster[id2];
            let { type: type2 } = item2;
            if (type2 && ecs2.types[type2]) {
              ecs2.create(type2, { id: id2, ...item2 });
              stat.ids.push(id2);
              stat.loaded++;
            } else {
              core.log(`[ECS]Cannot create type ${type2} -> skipped.`);
              stat.skipped++;
            }
            if (contains) {
              let { loaded, skipped, ids } = ecs2.unbox(contains);
              stat.ids = [...stat.ids, ...ids];
              stat.loaded += loaded;
              stat.skipped += skipped;
            }
          }
          return stat;
        },
        unboxJSON: (json) => {
          const dtStart = +new Date();
          const { roster, stat, meta } = JSON.parse(json);
          core.log(`[ECS]Unboxing Cargo1 (raw size: ${json.length})`, meta);
          console.table(stat);
          const dtParsed = +new Date();
          const { loaded, skipped, ids } = ecs2.unbox(roster);
          const dtEnd = +new Date();
          const timeParsing = dtParsed - dtStart;
          const timeUnboxing = dtEnd - dtParsed;
          const timeTotal = dtEnd - dtStart;
          const speed = timeTotal ? json.length / timeTotal * 1e3 / 1024 : 0;
          core.log("Speed: ", speed.toFixed(3), "Kb / second");
          console.table({ loaded, skipped, timeParsing, timeUnboxing, timeTotal, speed });
          return ids.map((id2) => ecs2.root[id2]);
        },
        makeI: (lang_compo) => computed2(() => lang_compo[core.yehat.lang]),
        bootSource: async ({ compo, types, roster, stat, meta, components: components2 }) => {
          core.log(`[ECS]bootSource`, { compo, types, roster, stat, meta });
          let cCompo = 0, cType = 0;
          if (compo) {
            for (let name in compo) {
              let { hull, ...tail } = compo[name];
              let description = { details: "- No details", ...tail };
              ecs2.define(name, hull, description);
              cCompo++;
            }
          }
          if (types) {
            for (let name in types) {
              let { hull, ...tail } = types[name];
              let description = { details: "- No details -", ...tail };
              ecs2.declareType(name, hull(), description);
              cType++;
            }
          }
          let componentsLoaded = 0;
          if (components2) {
            const p2 = [];
            for (let name in components2) {
              let base64 = components2[name];
              p2.push(core.vcom.compile(pako.inflate(pure.base64ToBytesArr(base64), { to: "string" }), name));
            }
            await Promise.all(p2).then((r) => componentsLoaded = r.length).catch((e) => {
              core.log(`[ECS]bootSource Exception on loading components`, e);
            });
          }
          let loaded = 0;
          let skipped = 0;
          if (roster) {
            core.log(`[ECS]Unboxing`, meta);
            if (stat)
              console.table(stat);
            const { loaded: l, skipped: s2 } = ecs2.unbox(roster);
            loaded = l;
            skipped = s2;
          }
          console.table({ components: cCompo, types: cType, componentsLoaded, entities: loaded, "entities skipped": skipped });
        },
        sizes: (entities = null) => {
          const a = (entities || Object.values(ecs2.root)).map((item2) => {
            const { c, ...rest } = item2;
            return { id: item2.id, size: JSON.stringify(rest).length };
          }).sort((a2, b) => b.size - a2.size);
          console.table(a);
          return a;
        }
      };
      Entity = ecs2.declareType("Entity", [], {
        details: "[ The ONE and THE ONLY TRUE AUTHENTHIC ENTITY FACTORY as a Legacy ]-[ Lvl 5 ]"
      });
      define2 = ecs2.define;
      declareType = ecs2.declareType;
    }
  });

  // node_modules/parseuri/index.js
  var require_parseuri = __commonJS({
    "node_modules/parseuri/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
      var parts = [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ];
      module.exports = function parseuri(str) {
        var src = str, b = str.indexOf("["), e = str.indexOf("]");
        if (b != -1 && e != -1) {
          str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
        }
        var m = re.exec(str || ""), uri = {}, i = 14;
        while (i--) {
          uri[parts[i]] = m[i] || "";
        }
        if (b != -1 && e != -1) {
          uri.source = src;
          uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
          uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
          uri.ipv6uri = true;
        }
        uri.pathNames = pathNames(uri, uri["path"]);
        uri.queryKey = queryKey(uri, uri["query"]);
        return uri;
      };
      function pathNames(obj, path) {
        var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
        if (path.substr(0, 1) == "/" || path.length === 0) {
          names.splice(0, 1);
        }
        if (path.substr(path.length - 1, 1) == "/") {
          names.splice(names.length - 1, 1);
        }
        return names;
      }
      function queryKey(uri, query) {
        var data = {};
        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
          if ($1) {
            data[$1] = $2;
          }
        });
        return data;
      }
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var s2 = 1e3;
      var m = s2 * 60;
      var h3 = m * 60;
      var d = h3 * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type2 = typeof val;
        if (type2 === "string" && val.length > 0) {
          return parse2(val);
        } else if (type2 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse2(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type2 = (match[2] || "ms").toLowerCase();
        switch (type2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h3;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s2;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h3) {
          return Math.round(ms / h3) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s2) {
          return Math.round(ms / s2) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h3) {
          return plural(ms, msAbs, h3, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s2) {
          return plural(ms, msAbs, s2, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy2;
        Object.keys(env).forEach((key2) => {
          createDebug[key2] = env[key2];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter2 = createDebug.formatters[format2];
              if (typeof formatter2 === "function") {
                const val = args[index];
                match = formatter2.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend3;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend3(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy2() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "node_modules/debug/src/browser.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/socket.io-client/build/url.js
  var require_url = __commonJS({
    "node_modules/socket.io-client/build/url.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.url = void 0;
      var parseuri = require_parseuri();
      var debug = require_browser()("socket.io-client:url");
      function url(uri, path = "", loc) {
        let obj = uri;
        loc = loc || typeof location !== "undefined" && location;
        if (uri == null)
          uri = loc.protocol + "//" + loc.host;
        if (typeof uri === "string") {
          if (uri.charAt(0) === "/") {
            if (uri.charAt(1) === "/") {
              uri = loc.protocol + uri;
            } else {
              uri = loc.host + uri;
            }
          }
          if (!/^(https?|wss?):\/\//.test(uri)) {
            debug("protocol-less url %s", uri);
            if (typeof loc !== "undefined") {
              uri = loc.protocol + "//" + uri;
            } else {
              uri = "https://" + uri;
            }
          }
          debug("parse %s", uri);
          obj = parseuri(uri);
        }
        if (!obj.port) {
          if (/^(http|ws)$/.test(obj.protocol)) {
            obj.port = "80";
          } else if (/^(http|ws)s$/.test(obj.protocol)) {
            obj.port = "443";
          }
        }
        obj.path = obj.path || "/";
        const ipv6 = obj.host.indexOf(":") !== -1;
        const host = ipv6 ? "[" + obj.host + "]" : obj.host;
        obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
        obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
        return obj;
      }
      exports.url = url;
    }
  });

  // node_modules/has-cors/index.js
  var require_has_cors = __commonJS({
    "node_modules/has-cors/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      try {
        module.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
      } catch (err) {
        module.exports = false;
      }
    }
  });

  // node_modules/engine.io-client/lib/globalThis.browser.js
  var require_globalThis_browser = __commonJS({
    "node_modules/engine.io-client/lib/globalThis.browser.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      module.exports = (() => {
        if (typeof self !== "undefined") {
          return self;
        } else if (typeof window !== "undefined") {
          return window;
        } else {
          return Function("return this")();
        }
      })();
    }
  });

  // node_modules/engine.io-client/lib/xmlhttprequest.js
  var require_xmlhttprequest = __commonJS({
    "node_modules/engine.io-client/lib/xmlhttprequest.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var hasCORS = require_has_cors();
      var globalThis2 = require_globalThis_browser();
      module.exports = function(opts) {
        const xdomain = opts.xdomain;
        const xscheme = opts.xscheme;
        const enablesXDR = opts.enablesXDR;
        try {
          if (typeof XMLHttpRequest !== "undefined" && (!xdomain || hasCORS)) {
            return new XMLHttpRequest();
          }
        } catch (e) {
        }
        try {
          if (typeof XDomainRequest !== "undefined" && !xscheme && enablesXDR) {
            return new XDomainRequest();
          }
        } catch (e) {
        }
        if (!xdomain) {
          try {
            return new globalThis2[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
          } catch (e) {
          }
        }
      };
    }
  });

  // node_modules/engine.io-parser/lib/commons.js
  var require_commons = __commonJS({
    "node_modules/engine.io-parser/lib/commons.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var PACKET_TYPES = Object.create(null);
      PACKET_TYPES["open"] = "0";
      PACKET_TYPES["close"] = "1";
      PACKET_TYPES["ping"] = "2";
      PACKET_TYPES["pong"] = "3";
      PACKET_TYPES["message"] = "4";
      PACKET_TYPES["upgrade"] = "5";
      PACKET_TYPES["noop"] = "6";
      var PACKET_TYPES_REVERSE = Object.create(null);
      Object.keys(PACKET_TYPES).forEach((key2) => {
        PACKET_TYPES_REVERSE[PACKET_TYPES[key2]] = key2;
      });
      var ERROR_PACKET = { type: "error", data: "parser error" };
      module.exports = {
        PACKET_TYPES,
        PACKET_TYPES_REVERSE,
        ERROR_PACKET
      };
    }
  });

  // node_modules/engine.io-parser/lib/encodePacket.browser.js
  var require_encodePacket_browser = __commonJS({
    "node_modules/engine.io-parser/lib/encodePacket.browser.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var { PACKET_TYPES } = require_commons();
      var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
      var withNativeArrayBuffer = typeof ArrayBuffer === "function";
      var isView = (obj) => {
        return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
      };
      var encodePacket = ({ type: type2, data }, supportsBinary, callback) => {
        if (withNativeBlob && data instanceof Blob) {
          if (supportsBinary) {
            return callback(data);
          } else {
            return encodeBlobAsBase64(data, callback);
          }
        } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
          if (supportsBinary) {
            return callback(data);
          } else {
            return encodeBlobAsBase64(new Blob([data]), callback);
          }
        }
        return callback(PACKET_TYPES[type2] + (data || ""));
      };
      var encodeBlobAsBase64 = (data, callback) => {
        const fileReader = new FileReader();
        fileReader.onload = function() {
          const content = fileReader.result.split(",")[1];
          callback("b" + content);
        };
        return fileReader.readAsDataURL(data);
      };
      module.exports = encodePacket;
    }
  });

  // node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
  var require_base64_arraybuffer = __commonJS({
    "node_modules/base64-arraybuffer/lib/base64-arraybuffer.js"(exports) {
      var import_pako = __toModule(require_pako());
      (function(chars) {
        "use strict";
        exports.encode = function(arraybuffer) {
          var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
          for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
            base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
            base64 += chars[bytes[i + 2] & 63];
          }
          if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + "=";
          } else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + "==";
          }
          return base64;
        };
        exports.decode = function(base64) {
          var bufferLength = base64.length * 0.75, len = base64.length, i, p2 = 0, encoded1, encoded2, encoded3, encoded4;
          if (base64[base64.length - 1] === "=") {
            bufferLength--;
            if (base64[base64.length - 2] === "=") {
              bufferLength--;
            }
          }
          var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
          for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
            bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
            bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
          }
          return arraybuffer;
        };
      })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
    }
  });

  // node_modules/engine.io-parser/lib/decodePacket.browser.js
  var require_decodePacket_browser = __commonJS({
    "node_modules/engine.io-parser/lib/decodePacket.browser.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var { PACKET_TYPES_REVERSE, ERROR_PACKET } = require_commons();
      var withNativeArrayBuffer = typeof ArrayBuffer === "function";
      var base64decoder;
      if (withNativeArrayBuffer) {
        base64decoder = require_base64_arraybuffer();
      }
      var decodePacket = (encodedPacket, binaryType) => {
        if (typeof encodedPacket !== "string") {
          return {
            type: "message",
            data: mapBinary(encodedPacket, binaryType)
          };
        }
        const type2 = encodedPacket.charAt(0);
        if (type2 === "b") {
          return {
            type: "message",
            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
          };
        }
        const packetType = PACKET_TYPES_REVERSE[type2];
        if (!packetType) {
          return ERROR_PACKET;
        }
        return encodedPacket.length > 1 ? {
          type: PACKET_TYPES_REVERSE[type2],
          data: encodedPacket.substring(1)
        } : {
          type: PACKET_TYPES_REVERSE[type2]
        };
      };
      var decodeBase64Packet = (data, binaryType) => {
        if (base64decoder) {
          const decoded = base64decoder.decode(data);
          return mapBinary(decoded, binaryType);
        } else {
          return { base64: true, data };
        }
      };
      var mapBinary = (data, binaryType) => {
        switch (binaryType) {
          case "blob":
            return data instanceof ArrayBuffer ? new Blob([data]) : data;
          case "arraybuffer":
          default:
            return data;
        }
      };
      module.exports = decodePacket;
    }
  });

  // node_modules/engine.io-parser/lib/index.js
  var require_lib = __commonJS({
    "node_modules/engine.io-parser/lib/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var encodePacket = require_encodePacket_browser();
      var decodePacket = require_decodePacket_browser();
      var SEPARATOR = String.fromCharCode(30);
      var encodePayload = (packets, callback) => {
        const length = packets.length;
        const encodedPackets = new Array(length);
        let count = 0;
        packets.forEach((packet, i) => {
          encodePacket(packet, false, (encodedPacket) => {
            encodedPackets[i] = encodedPacket;
            if (++count === length) {
              callback(encodedPackets.join(SEPARATOR));
            }
          });
        });
      };
      var decodePayload = (encodedPayload, binaryType) => {
        const encodedPackets = encodedPayload.split(SEPARATOR);
        const packets = [];
        for (let i = 0; i < encodedPackets.length; i++) {
          const decodedPacket = decodePacket(encodedPackets[i], binaryType);
          packets.push(decodedPacket);
          if (decodedPacket.type === "error") {
            break;
          }
        }
        return packets;
      };
      module.exports = {
        protocol: 4,
        encodePacket,
        encodePayload,
        decodePacket,
        decodePayload
      };
    }
  });

  // node_modules/component-emitter/index.js
  var require_component_emitter = __commonJS({
    "node_modules/component-emitter/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      if (typeof module !== "undefined") {
        module.exports = Emitter;
      }
      function Emitter(obj) {
        if (obj)
          return mixin(obj);
      }
      function mixin(obj) {
        for (var key2 in Emitter.prototype) {
          obj[key2] = Emitter.prototype[key2];
        }
        return obj;
      }
      Emitter.prototype.on = Emitter.prototype.addEventListener = function(event3, fn) {
        this._callbacks = this._callbacks || {};
        (this._callbacks["$" + event3] = this._callbacks["$" + event3] || []).push(fn);
        return this;
      };
      Emitter.prototype.once = function(event3, fn) {
        function on() {
          this.off(event3, on);
          fn.apply(this, arguments);
        }
        on.fn = fn;
        this.on(event3, on);
        return this;
      };
      Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event3, fn) {
        this._callbacks = this._callbacks || {};
        if (arguments.length == 0) {
          this._callbacks = {};
          return this;
        }
        var callbacks = this._callbacks["$" + event3];
        if (!callbacks)
          return this;
        if (arguments.length == 1) {
          delete this._callbacks["$" + event3];
          return this;
        }
        var cb;
        for (var i = 0; i < callbacks.length; i++) {
          cb = callbacks[i];
          if (cb === fn || cb.fn === fn) {
            callbacks.splice(i, 1);
            break;
          }
        }
        if (callbacks.length === 0) {
          delete this._callbacks["$" + event3];
        }
        return this;
      };
      Emitter.prototype.emit = function(event3) {
        this._callbacks = this._callbacks || {};
        var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event3];
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
        if (callbacks) {
          callbacks = callbacks.slice(0);
          for (var i = 0, len = callbacks.length; i < len; ++i) {
            callbacks[i].apply(this, args);
          }
        }
        return this;
      };
      Emitter.prototype.listeners = function(event3) {
        this._callbacks = this._callbacks || {};
        return this._callbacks["$" + event3] || [];
      };
      Emitter.prototype.hasListeners = function(event3) {
        return !!this.listeners(event3).length;
      };
    }
  });

  // node_modules/engine.io-client/lib/util.js
  var require_util = __commonJS({
    "node_modules/engine.io-client/lib/util.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var globalThis2 = require_globalThis_browser();
      module.exports.pick = (obj, ...attr) => {
        return attr.reduce((acc, k2) => {
          if (obj.hasOwnProperty(k2)) {
            acc[k2] = obj[k2];
          }
          return acc;
        }, {});
      };
      var NATIVE_SET_TIMEOUT = setTimeout;
      var NATIVE_CLEAR_TIMEOUT = clearTimeout;
      module.exports.installTimerFunctions = (obj, opts) => {
        if (opts.useNativeTimers) {
          obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis2);
          obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis2);
        } else {
          obj.setTimeoutFn = setTimeout.bind(globalThis2);
          obj.clearTimeoutFn = clearTimeout.bind(globalThis2);
        }
      };
    }
  });

  // node_modules/engine.io-client/lib/transport.js
  var require_transport = __commonJS({
    "node_modules/engine.io-client/lib/transport.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var parser = require_lib();
      var Emitter = require_component_emitter();
      var { installTimerFunctions } = require_util();
      var debug = require_browser()("engine.io-client:transport");
      var Transport = class extends Emitter {
        constructor(opts) {
          super();
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.query = opts.query;
          this.readyState = "";
          this.socket = opts.socket;
        }
        onError(msg, desc) {
          const err = new Error(msg);
          err.type = "TransportError";
          err.description = desc;
          this.emit("error", err);
          return this;
        }
        open() {
          if (this.readyState === "closed" || this.readyState === "") {
            this.readyState = "opening";
            this.doOpen();
          }
          return this;
        }
        close() {
          if (this.readyState === "opening" || this.readyState === "open") {
            this.doClose();
            this.onClose();
          }
          return this;
        }
        send(packets) {
          if (this.readyState === "open") {
            this.write(packets);
          } else {
            debug("transport is not open, discarding packets");
          }
        }
        onOpen() {
          this.readyState = "open";
          this.writable = true;
          this.emit("open");
        }
        onData(data) {
          const packet = parser.decodePacket(data, this.socket.binaryType);
          this.onPacket(packet);
        }
        onPacket(packet) {
          this.emit("packet", packet);
        }
        onClose() {
          this.readyState = "closed";
          this.emit("close");
        }
      };
      module.exports = Transport;
    }
  });

  // node_modules/parseqs/index.js
  var require_parseqs = __commonJS({
    "node_modules/parseqs/index.js"(exports) {
      var import_pako = __toModule(require_pako());
      exports.encode = function(obj) {
        var str = "";
        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (str.length)
              str += "&";
            str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
          }
        }
        return str;
      };
      exports.decode = function(qs) {
        var qry = {};
        var pairs = qs.split("&");
        for (var i = 0, l = pairs.length; i < l; i++) {
          var pair = pairs[i].split("=");
          qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return qry;
      };
    }
  });

  // node_modules/yeast/index.js
  var require_yeast = __commonJS({
    "node_modules/yeast/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      "use strict";
      var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
      var length = 64;
      var map2 = {};
      var seed = 0;
      var i = 0;
      var prev;
      function encode2(num) {
        var encoded = "";
        do {
          encoded = alphabet[num % length] + encoded;
          num = Math.floor(num / length);
        } while (num > 0);
        return encoded;
      }
      function decode2(str) {
        var decoded = 0;
        for (i = 0; i < str.length; i++) {
          decoded = decoded * length + map2[str.charAt(i)];
        }
        return decoded;
      }
      function yeast() {
        var now = encode2(+new Date());
        if (now !== prev)
          return seed = 0, prev = now;
        return now + "." + encode2(seed++);
      }
      for (; i < length; i++)
        map2[alphabet[i]] = i;
      yeast.encode = encode2;
      yeast.decode = decode2;
      module.exports = yeast;
    }
  });

  // node_modules/engine.io-client/lib/transports/polling.js
  var require_polling = __commonJS({
    "node_modules/engine.io-client/lib/transports/polling.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var Transport = require_transport();
      var parseqs = require_parseqs();
      var parser = require_lib();
      var yeast = require_yeast();
      var debug = require_browser()("engine.io-client:polling");
      var Polling = class extends Transport {
        get name() {
          return "polling";
        }
        doOpen() {
          this.poll();
        }
        pause(onPause) {
          this.readyState = "pausing";
          const pause = () => {
            debug("paused");
            this.readyState = "paused";
            onPause();
          };
          if (this.polling || !this.writable) {
            let total = 0;
            if (this.polling) {
              debug("we are currently polling - waiting to pause");
              total++;
              this.once("pollComplete", function() {
                debug("pre-pause polling complete");
                --total || pause();
              });
            }
            if (!this.writable) {
              debug("we are currently writing - waiting to pause");
              total++;
              this.once("drain", function() {
                debug("pre-pause writing complete");
                --total || pause();
              });
            }
          } else {
            pause();
          }
        }
        poll() {
          debug("polling");
          this.polling = true;
          this.doPoll();
          this.emit("poll");
        }
        onData(data) {
          debug("polling got data %s", data);
          const callback = (packet) => {
            if (this.readyState === "opening" && packet.type === "open") {
              this.onOpen();
            }
            if (packet.type === "close") {
              this.onClose();
              return false;
            }
            this.onPacket(packet);
          };
          parser.decodePayload(data, this.socket.binaryType).forEach(callback);
          if (this.readyState !== "closed") {
            this.polling = false;
            this.emit("pollComplete");
            if (this.readyState === "open") {
              this.poll();
            } else {
              debug('ignoring poll - transport state "%s"', this.readyState);
            }
          }
        }
        doClose() {
          const close = () => {
            debug("writing close packet");
            this.write([{ type: "close" }]);
          };
          if (this.readyState === "open") {
            debug("transport open - closing");
            close();
          } else {
            debug("transport not open - deferring close");
            this.once("open", close);
          }
        }
        write(packets) {
          this.writable = false;
          parser.encodePayload(packets, (data) => {
            this.doWrite(data, () => {
              this.writable = true;
              this.emit("drain");
            });
          });
        }
        uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "https" : "http";
          let port = "";
          if (this.opts.timestampRequests !== false) {
            query[this.opts.timestampParam] = yeast();
          }
          if (!this.supportsBinary && !query.sid) {
            query.b64 = 1;
          }
          query = parseqs.encode(query);
          if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
            port = ":" + this.opts.port;
          }
          if (query.length) {
            query = "?" + query;
          }
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
        }
      };
      module.exports = Polling;
    }
  });

  // node_modules/engine.io-client/lib/transports/polling-xhr.js
  var require_polling_xhr = __commonJS({
    "node_modules/engine.io-client/lib/transports/polling-xhr.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var XMLHttpRequest2 = require_xmlhttprequest();
      var Polling = require_polling();
      var Emitter = require_component_emitter();
      var { pick, installTimerFunctions } = require_util();
      var globalThis2 = require_globalThis_browser();
      var debug = require_browser()("engine.io-client:polling-xhr");
      function empty() {
      }
      var hasXHR2 = function() {
        const xhr3 = new XMLHttpRequest2({ xdomain: false });
        return xhr3.responseType != null;
      }();
      var XHR = class extends Polling {
        constructor(opts) {
          super(opts);
          if (typeof location !== "undefined") {
            const isSSL = location.protocol === "https:";
            let port = location.port;
            if (!port) {
              port = isSSL ? 443 : 80;
            }
            this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
            this.xs = opts.secure !== isSSL;
          }
          const forceBase64 = opts && opts.forceBase64;
          this.supportsBinary = hasXHR2 && !forceBase64;
        }
        request(opts = {}) {
          Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
          return new Request(this.uri(), opts);
        }
        doWrite(data, fn) {
          const req = this.request({
            method: "POST",
            data
          });
          req.on("success", fn);
          req.on("error", (err) => {
            this.onError("xhr post error", err);
          });
        }
        doPoll() {
          debug("xhr poll");
          const req = this.request();
          req.on("data", this.onData.bind(this));
          req.on("error", (err) => {
            this.onError("xhr poll error", err);
          });
          this.pollXhr = req;
        }
      };
      var Request = class extends Emitter {
        constructor(uri, opts) {
          super();
          installTimerFunctions(this, opts);
          this.opts = opts;
          this.method = opts.method || "GET";
          this.uri = uri;
          this.async = opts.async !== false;
          this.data = opts.data !== void 0 ? opts.data : null;
          this.create();
        }
        create() {
          const opts = pick(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
          opts.xdomain = !!this.opts.xd;
          opts.xscheme = !!this.opts.xs;
          const xhr3 = this.xhr = new XMLHttpRequest2(opts);
          try {
            debug("xhr open %s: %s", this.method, this.uri);
            xhr3.open(this.method, this.uri, this.async);
            try {
              if (this.opts.extraHeaders) {
                xhr3.setDisableHeaderCheck && xhr3.setDisableHeaderCheck(true);
                for (let i in this.opts.extraHeaders) {
                  if (this.opts.extraHeaders.hasOwnProperty(i)) {
                    xhr3.setRequestHeader(i, this.opts.extraHeaders[i]);
                  }
                }
              }
            } catch (e) {
            }
            if (this.method === "POST") {
              try {
                xhr3.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
              } catch (e) {
              }
            }
            try {
              xhr3.setRequestHeader("Accept", "*/*");
            } catch (e) {
            }
            if ("withCredentials" in xhr3) {
              xhr3.withCredentials = this.opts.withCredentials;
            }
            if (this.opts.requestTimeout) {
              xhr3.timeout = this.opts.requestTimeout;
            }
            if (this.hasXDR()) {
              xhr3.onload = () => {
                this.onLoad();
              };
              xhr3.onerror = () => {
                this.onError(xhr3.responseText);
              };
            } else {
              xhr3.onreadystatechange = () => {
                if (xhr3.readyState !== 4)
                  return;
                if (xhr3.status === 200 || xhr3.status === 1223) {
                  this.onLoad();
                } else {
                  this.setTimeoutFn(() => {
                    this.onError(typeof xhr3.status === "number" ? xhr3.status : 0);
                  }, 0);
                }
              };
            }
            debug("xhr data %s", this.data);
            xhr3.send(this.data);
          } catch (e) {
            this.setTimeoutFn(() => {
              this.onError(e);
            }, 0);
            return;
          }
          if (typeof document !== "undefined") {
            this.index = Request.requestsCount++;
            Request.requests[this.index] = this;
          }
        }
        onSuccess() {
          this.emit("success");
          this.cleanup();
        }
        onData(data) {
          this.emit("data", data);
          this.onSuccess();
        }
        onError(err) {
          this.emit("error", err);
          this.cleanup(true);
        }
        cleanup(fromError) {
          if (typeof this.xhr === "undefined" || this.xhr === null) {
            return;
          }
          if (this.hasXDR()) {
            this.xhr.onload = this.xhr.onerror = empty;
          } else {
            this.xhr.onreadystatechange = empty;
          }
          if (fromError) {
            try {
              this.xhr.abort();
            } catch (e) {
            }
          }
          if (typeof document !== "undefined") {
            delete Request.requests[this.index];
          }
          this.xhr = null;
        }
        onLoad() {
          const data = this.xhr.responseText;
          if (data !== null) {
            this.onData(data);
          }
        }
        hasXDR() {
          return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
        }
        abort() {
          this.cleanup();
        }
      };
      Request.requestsCount = 0;
      Request.requests = {};
      if (typeof document !== "undefined") {
        if (typeof attachEvent === "function") {
          attachEvent("onunload", unloadHandler);
        } else if (typeof addEventListener === "function") {
          const terminationEvent = "onpagehide" in globalThis2 ? "pagehide" : "unload";
          addEventListener(terminationEvent, unloadHandler, false);
        }
      }
      function unloadHandler() {
        for (let i in Request.requests) {
          if (Request.requests.hasOwnProperty(i)) {
            Request.requests[i].abort();
          }
        }
      }
      module.exports = XHR;
      module.exports.Request = Request;
    }
  });

  // node_modules/engine.io-client/lib/transports/polling-jsonp.js
  var require_polling_jsonp = __commonJS({
    "node_modules/engine.io-client/lib/transports/polling-jsonp.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var Polling = require_polling();
      var globalThis2 = require_globalThis_browser();
      var rNewline = /\n/g;
      var rEscapedNewline = /\\n/g;
      var callbacks;
      var JSONPPolling = class extends Polling {
        constructor(opts) {
          super(opts);
          this.query = this.query || {};
          if (!callbacks) {
            callbacks = globalThis2.___eio = globalThis2.___eio || [];
          }
          this.index = callbacks.length;
          callbacks.push(this.onData.bind(this));
          this.query.j = this.index;
        }
        get supportsBinary() {
          return false;
        }
        doClose() {
          if (this.script) {
            this.script.onerror = () => {
            };
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          if (this.form) {
            this.form.parentNode.removeChild(this.form);
            this.form = null;
            this.iframe = null;
          }
          super.doClose();
        }
        doPoll() {
          const script = document.createElement("script");
          if (this.script) {
            this.script.parentNode.removeChild(this.script);
            this.script = null;
          }
          script.async = true;
          script.src = this.uri();
          script.onerror = (e) => {
            this.onError("jsonp poll error", e);
          };
          const insertAt = document.getElementsByTagName("script")[0];
          if (insertAt) {
            insertAt.parentNode.insertBefore(script, insertAt);
          } else {
            (document.head || document.body).appendChild(script);
          }
          this.script = script;
          const isUAgecko = typeof navigator !== "undefined" && /gecko/i.test(navigator.userAgent);
          if (isUAgecko) {
            this.setTimeoutFn(function() {
              const iframe = document.createElement("iframe");
              document.body.appendChild(iframe);
              document.body.removeChild(iframe);
            }, 100);
          }
        }
        doWrite(data, fn) {
          let iframe;
          if (!this.form) {
            const form = document.createElement("form");
            const area = document.createElement("textarea");
            const id2 = this.iframeId = "eio_iframe_" + this.index;
            form.className = "socketio";
            form.style.position = "absolute";
            form.style.top = "-1000px";
            form.style.left = "-1000px";
            form.target = id2;
            form.method = "POST";
            form.setAttribute("accept-charset", "utf-8");
            area.name = "d";
            form.appendChild(area);
            document.body.appendChild(form);
            this.form = form;
            this.area = area;
          }
          this.form.action = this.uri();
          function complete() {
            initIframe();
            fn();
          }
          const initIframe = () => {
            if (this.iframe) {
              try {
                this.form.removeChild(this.iframe);
              } catch (e) {
                this.onError("jsonp polling iframe removal error", e);
              }
            }
            try {
              const html = '<iframe src="javascript:0" name="' + this.iframeId + '">';
              iframe = document.createElement(html);
            } catch (e) {
              iframe = document.createElement("iframe");
              iframe.name = this.iframeId;
              iframe.src = "javascript:0";
            }
            iframe.id = this.iframeId;
            this.form.appendChild(iframe);
            this.iframe = iframe;
          };
          initIframe();
          data = data.replace(rEscapedNewline, "\\\n");
          this.area.value = data.replace(rNewline, "\\n");
          try {
            this.form.submit();
          } catch (e) {
          }
          if (this.iframe.attachEvent) {
            this.iframe.onreadystatechange = () => {
              if (this.iframe.readyState === "complete") {
                complete();
              }
            };
          } else {
            this.iframe.onload = complete;
          }
        }
      };
      module.exports = JSONPPolling;
    }
  });

  // node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js
  var require_websocket_constructor_browser = __commonJS({
    "node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var globalThis2 = require_globalThis_browser();
      var nextTick4 = (() => {
        const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
        if (isPromiseAvailable) {
          return (cb) => Promise.resolve().then(cb);
        } else {
          return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
        }
      })();
      module.exports = {
        WebSocket: globalThis2.WebSocket || globalThis2.MozWebSocket,
        usingBrowserWebSocket: true,
        defaultBinaryType: "arraybuffer",
        nextTick: nextTick4
      };
    }
  });

  // node_modules/engine.io-client/lib/transports/websocket.js
  var require_websocket = __commonJS({
    "node_modules/engine.io-client/lib/transports/websocket.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var Transport = require_transport();
      var parser = require_lib();
      var parseqs = require_parseqs();
      var yeast = require_yeast();
      var { pick } = require_util();
      var {
        WebSocket,
        usingBrowserWebSocket,
        defaultBinaryType,
        nextTick: nextTick4
      } = require_websocket_constructor_browser();
      var debug = require_browser()("engine.io-client:websocket");
      var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
      var WS = class extends Transport {
        constructor(opts) {
          super(opts);
          this.supportsBinary = !opts.forceBase64;
        }
        get name() {
          return "websocket";
        }
        doOpen() {
          if (!this.check()) {
            return;
          }
          const uri = this.uri();
          const protocols = this.opts.protocols;
          const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
          if (this.opts.extraHeaders) {
            opts.headers = this.opts.extraHeaders;
          }
          try {
            this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);
          } catch (err) {
            return this.emit("error", err);
          }
          this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
          this.addEventListeners();
        }
        addEventListeners() {
          this.ws.onopen = () => {
            if (this.opts.autoUnref) {
              this.ws._socket.unref();
            }
            this.onOpen();
          };
          this.ws.onclose = this.onClose.bind(this);
          this.ws.onmessage = (ev) => this.onData(ev.data);
          this.ws.onerror = (e) => this.onError("websocket error", e);
        }
        write(packets) {
          this.writable = false;
          for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const lastPacket = i === packets.length - 1;
            parser.encodePacket(packet, this.supportsBinary, (data) => {
              const opts = {};
              if (!usingBrowserWebSocket) {
                if (packet.options) {
                  opts.compress = packet.options.compress;
                }
                if (this.opts.perMessageDeflate) {
                  const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
                  if (len < this.opts.perMessageDeflate.threshold) {
                    opts.compress = false;
                  }
                }
              }
              try {
                if (usingBrowserWebSocket) {
                  this.ws.send(data);
                } else {
                  this.ws.send(data, opts);
                }
              } catch (e) {
                debug("websocket closed before onclose event");
              }
              if (lastPacket) {
                nextTick4(() => {
                  this.writable = true;
                  this.emit("drain");
                }, this.setTimeoutFn);
              }
            });
          }
        }
        onClose() {
          Transport.prototype.onClose.call(this);
        }
        doClose() {
          if (typeof this.ws !== "undefined") {
            this.ws.close();
            this.ws = null;
          }
        }
        uri() {
          let query = this.query || {};
          const schema = this.opts.secure ? "wss" : "ws";
          let port = "";
          if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
            port = ":" + this.opts.port;
          }
          if (this.opts.timestampRequests) {
            query[this.opts.timestampParam] = yeast();
          }
          if (!this.supportsBinary) {
            query.b64 = 1;
          }
          query = parseqs.encode(query);
          if (query.length) {
            query = "?" + query;
          }
          const ipv6 = this.opts.hostname.indexOf(":") !== -1;
          return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
        }
        check() {
          return !!WebSocket && !("__initialize" in WebSocket && this.name === WS.prototype.name);
        }
      };
      module.exports = WS;
    }
  });

  // node_modules/engine.io-client/lib/transports/index.js
  var require_transports = __commonJS({
    "node_modules/engine.io-client/lib/transports/index.js"(exports) {
      var import_pako = __toModule(require_pako());
      var XMLHttpRequest2 = require_xmlhttprequest();
      var XHR = require_polling_xhr();
      var JSONP = require_polling_jsonp();
      var websocket = require_websocket();
      exports.polling = polling;
      exports.websocket = websocket;
      function polling(opts) {
        let xhr3;
        let xd = false;
        let xs = false;
        const jsonp = opts.jsonp !== false;
        if (typeof location !== "undefined") {
          const isSSL = location.protocol === "https:";
          let port = location.port;
          if (!port) {
            port = isSSL ? 443 : 80;
          }
          xd = opts.hostname !== location.hostname || port !== opts.port;
          xs = opts.secure !== isSSL;
        }
        opts.xdomain = xd;
        opts.xscheme = xs;
        xhr3 = new XMLHttpRequest2(opts);
        if ("open" in xhr3 && !opts.forceJSONP) {
          return new XHR(opts);
        } else {
          if (!jsonp)
            throw new Error("JSONP disabled");
          return new JSONP(opts);
        }
      }
    }
  });

  // node_modules/engine.io-client/lib/socket.js
  var require_socket = __commonJS({
    "node_modules/engine.io-client/lib/socket.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var transports = require_transports();
      var Emitter = require_component_emitter();
      var debug = require_browser()("engine.io-client:socket");
      var parser = require_lib();
      var parseuri = require_parseuri();
      var parseqs = require_parseqs();
      var { installTimerFunctions } = require_util();
      var Socket2 = class extends Emitter {
        constructor(uri, opts = {}) {
          super();
          if (uri && typeof uri === "object") {
            opts = uri;
            uri = null;
          }
          if (uri) {
            uri = parseuri(uri);
            opts.hostname = uri.host;
            opts.secure = uri.protocol === "https" || uri.protocol === "wss";
            opts.port = uri.port;
            if (uri.query)
              opts.query = uri.query;
          } else if (opts.host) {
            opts.hostname = parseuri(opts.host).host;
          }
          installTimerFunctions(this, opts);
          this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
          if (opts.hostname && !opts.port) {
            opts.port = this.secure ? "443" : "80";
          }
          this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
          this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
          this.transports = opts.transports || ["polling", "websocket"];
          this.readyState = "";
          this.writeBuffer = [];
          this.prevBufferLen = 0;
          this.opts = Object.assign({
            path: "/engine.io",
            agent: false,
            withCredentials: false,
            upgrade: true,
            jsonp: true,
            timestampParam: "t",
            rememberUpgrade: false,
            rejectUnauthorized: true,
            perMessageDeflate: {
              threshold: 1024
            },
            transportOptions: {},
            closeOnBeforeunload: true
          }, opts);
          this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
          if (typeof this.opts.query === "string") {
            this.opts.query = parseqs.decode(this.opts.query);
          }
          this.id = null;
          this.upgrades = null;
          this.pingInterval = null;
          this.pingTimeout = null;
          this.pingTimeoutTimer = null;
          if (typeof addEventListener === "function") {
            if (this.opts.closeOnBeforeunload) {
              addEventListener("beforeunload", () => {
                if (this.transport) {
                  this.transport.removeAllListeners();
                  this.transport.close();
                }
              }, false);
            }
            if (this.hostname !== "localhost") {
              this.offlineEventListener = () => {
                this.onClose("transport close");
              };
              addEventListener("offline", this.offlineEventListener, false);
            }
          }
          this.open();
        }
        createTransport(name) {
          debug('creating transport "%s"', name);
          const query = clone2(this.opts.query);
          query.EIO = parser.protocol;
          query.transport = name;
          if (this.id)
            query.sid = this.id;
          const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
            query,
            socket: this,
            hostname: this.hostname,
            secure: this.secure,
            port: this.port
          });
          debug("options: %j", opts);
          return new transports[name](opts);
        }
        open() {
          let transport;
          if (this.opts.rememberUpgrade && Socket2.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
            transport = "websocket";
          } else if (this.transports.length === 0) {
            this.setTimeoutFn(() => {
              this.emit("error", "No transports available");
            }, 0);
            return;
          } else {
            transport = this.transports[0];
          }
          this.readyState = "opening";
          try {
            transport = this.createTransport(transport);
          } catch (e) {
            debug("error while creating transport: %s", e);
            this.transports.shift();
            this.open();
            return;
          }
          transport.open();
          this.setTransport(transport);
        }
        setTransport(transport) {
          debug("setting transport %s", transport.name);
          if (this.transport) {
            debug("clearing existing transport %s", this.transport.name);
            this.transport.removeAllListeners();
          }
          this.transport = transport;
          transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", () => {
            this.onClose("transport close");
          });
        }
        probe(name) {
          debug('probing transport "%s"', name);
          let transport = this.createTransport(name, { probe: 1 });
          let failed = false;
          Socket2.priorWebsocketSuccess = false;
          const onTransportOpen = () => {
            if (failed)
              return;
            debug('probe transport "%s" opened', name);
            transport.send([{ type: "ping", data: "probe" }]);
            transport.once("packet", (msg) => {
              if (failed)
                return;
              if (msg.type === "pong" && msg.data === "probe") {
                debug('probe transport "%s" pong', name);
                this.upgrading = true;
                this.emit("upgrading", transport);
                if (!transport)
                  return;
                Socket2.priorWebsocketSuccess = transport.name === "websocket";
                debug('pausing current transport "%s"', this.transport.name);
                this.transport.pause(() => {
                  if (failed)
                    return;
                  if (this.readyState === "closed")
                    return;
                  debug("changing transport and sending upgrade packet");
                  cleanup();
                  this.setTransport(transport);
                  transport.send([{ type: "upgrade" }]);
                  this.emit("upgrade", transport);
                  transport = null;
                  this.upgrading = false;
                  this.flush();
                });
              } else {
                debug('probe transport "%s" failed', name);
                const err = new Error("probe error");
                err.transport = transport.name;
                this.emit("upgradeError", err);
              }
            });
          };
          function freezeTransport() {
            if (failed)
              return;
            failed = true;
            cleanup();
            transport.close();
            transport = null;
          }
          const onerror = (err) => {
            const error = new Error("probe error: " + err);
            error.transport = transport.name;
            freezeTransport();
            debug('probe transport "%s" failed because of error: %s', name, err);
            this.emit("upgradeError", error);
          };
          function onTransportClose() {
            onerror("transport closed");
          }
          function onclose() {
            onerror("socket closed");
          }
          function onupgrade(to) {
            if (transport && to.name !== transport.name) {
              debug('"%s" works - aborting "%s"', to.name, transport.name);
              freezeTransport();
            }
          }
          const cleanup = () => {
            transport.removeListener("open", onTransportOpen);
            transport.removeListener("error", onerror);
            transport.removeListener("close", onTransportClose);
            this.removeListener("close", onclose);
            this.removeListener("upgrading", onupgrade);
          };
          transport.once("open", onTransportOpen);
          transport.once("error", onerror);
          transport.once("close", onTransportClose);
          this.once("close", onclose);
          this.once("upgrading", onupgrade);
          transport.open();
        }
        onOpen() {
          debug("socket open");
          this.readyState = "open";
          Socket2.priorWebsocketSuccess = this.transport.name === "websocket";
          this.emit("open");
          this.flush();
          if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
            debug("starting upgrade probes");
            let i = 0;
            const l = this.upgrades.length;
            for (; i < l; i++) {
              this.probe(this.upgrades[i]);
            }
          }
        }
        onPacket(packet) {
          if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
            this.emit("packet", packet);
            this.emit("heartbeat");
            switch (packet.type) {
              case "open":
                this.onHandshake(JSON.parse(packet.data));
                break;
              case "ping":
                this.resetPingTimeout();
                this.sendPacket("pong");
                this.emit("ping");
                this.emit("pong");
                break;
              case "error":
                const err = new Error("server error");
                err.code = packet.data;
                this.onError(err);
                break;
              case "message":
                this.emit("data", packet.data);
                this.emit("message", packet.data);
                break;
            }
          } else {
            debug('packet received with socket readyState "%s"', this.readyState);
          }
        }
        onHandshake(data) {
          this.emit("handshake", data);
          this.id = data.sid;
          this.transport.query.sid = data.sid;
          this.upgrades = this.filterUpgrades(data.upgrades);
          this.pingInterval = data.pingInterval;
          this.pingTimeout = data.pingTimeout;
          this.onOpen();
          if (this.readyState === "closed")
            return;
          this.resetPingTimeout();
        }
        resetPingTimeout() {
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.pingTimeoutTimer = this.setTimeoutFn(() => {
            this.onClose("ping timeout");
          }, this.pingInterval + this.pingTimeout);
          if (this.opts.autoUnref) {
            this.pingTimeoutTimer.unref();
          }
        }
        onDrain() {
          this.writeBuffer.splice(0, this.prevBufferLen);
          this.prevBufferLen = 0;
          if (this.writeBuffer.length === 0) {
            this.emit("drain");
          } else {
            this.flush();
          }
        }
        flush() {
          if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
            debug("flushing %d packets in socket", this.writeBuffer.length);
            this.transport.send(this.writeBuffer);
            this.prevBufferLen = this.writeBuffer.length;
            this.emit("flush");
          }
        }
        write(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
        }
        send(msg, options, fn) {
          this.sendPacket("message", msg, options, fn);
          return this;
        }
        sendPacket(type2, data, options, fn) {
          if (typeof data === "function") {
            fn = data;
            data = void 0;
          }
          if (typeof options === "function") {
            fn = options;
            options = null;
          }
          if (this.readyState === "closing" || this.readyState === "closed") {
            return;
          }
          options = options || {};
          options.compress = options.compress !== false;
          const packet = {
            type: type2,
            data,
            options
          };
          this.emit("packetCreate", packet);
          this.writeBuffer.push(packet);
          if (fn)
            this.once("flush", fn);
          this.flush();
        }
        close() {
          const close = () => {
            this.onClose("forced close");
            debug("socket closing - telling transport to close");
            this.transport.close();
          };
          const cleanupAndClose = () => {
            this.removeListener("upgrade", cleanupAndClose);
            this.removeListener("upgradeError", cleanupAndClose);
            close();
          };
          const waitForUpgrade = () => {
            this.once("upgrade", cleanupAndClose);
            this.once("upgradeError", cleanupAndClose);
          };
          if (this.readyState === "opening" || this.readyState === "open") {
            this.readyState = "closing";
            if (this.writeBuffer.length) {
              this.once("drain", () => {
                if (this.upgrading) {
                  waitForUpgrade();
                } else {
                  close();
                }
              });
            } else if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          }
          return this;
        }
        onError(err) {
          debug("socket error %j", err);
          Socket2.priorWebsocketSuccess = false;
          this.emit("error", err);
          this.onClose("transport error", err);
        }
        onClose(reason, desc) {
          if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
            debug('socket close with reason: "%s"', reason);
            this.clearTimeoutFn(this.pingIntervalTimer);
            this.clearTimeoutFn(this.pingTimeoutTimer);
            this.transport.removeAllListeners("close");
            this.transport.close();
            this.transport.removeAllListeners();
            if (typeof removeEventListener === "function") {
              removeEventListener("offline", this.offlineEventListener, false);
            }
            this.readyState = "closed";
            this.id = null;
            this.emit("close", reason, desc);
            this.writeBuffer = [];
            this.prevBufferLen = 0;
          }
        }
        filterUpgrades(upgrades) {
          const filteredUpgrades = [];
          let i = 0;
          const j = upgrades.length;
          for (; i < j; i++) {
            if (~this.transports.indexOf(upgrades[i]))
              filteredUpgrades.push(upgrades[i]);
          }
          return filteredUpgrades;
        }
      };
      Socket2.priorWebsocketSuccess = false;
      Socket2.protocol = parser.protocol;
      function clone2(obj) {
        const o = {};
        for (let i in obj) {
          if (obj.hasOwnProperty(i)) {
            o[i] = obj[i];
          }
        }
        return o;
      }
      module.exports = Socket2;
    }
  });

  // node_modules/engine.io-client/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/engine.io-client/lib/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      var Socket2 = require_socket();
      module.exports = (uri, opts) => new Socket2(uri, opts);
      module.exports.Socket = Socket2;
      module.exports.protocol = Socket2.protocol;
      module.exports.Transport = require_transport();
      module.exports.transports = require_transports();
      module.exports.parser = require_lib();
    }
  });

  // node_modules/socket.io-parser/dist/is-binary.js
  var require_is_binary = __commonJS({
    "node_modules/socket.io-parser/dist/is-binary.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.hasBinary = exports.isBinary = void 0;
      var withNativeArrayBuffer = typeof ArrayBuffer === "function";
      var isView = (obj) => {
        return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
      };
      var toString2 = Object.prototype.toString;
      var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString2.call(Blob) === "[object BlobConstructor]";
      var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString2.call(File) === "[object FileConstructor]";
      function isBinary(obj) {
        return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
      }
      exports.isBinary = isBinary;
      function hasBinary(obj, toJSON) {
        if (!obj || typeof obj !== "object") {
          return false;
        }
        if (Array.isArray(obj)) {
          for (let i = 0, l = obj.length; i < l; i++) {
            if (hasBinary(obj[i])) {
              return true;
            }
          }
          return false;
        }
        if (isBinary(obj)) {
          return true;
        }
        if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
          return hasBinary(obj.toJSON(), true);
        }
        for (const key2 in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key2) && hasBinary(obj[key2])) {
            return true;
          }
        }
        return false;
      }
      exports.hasBinary = hasBinary;
    }
  });

  // node_modules/socket.io-parser/dist/binary.js
  var require_binary = __commonJS({
    "node_modules/socket.io-parser/dist/binary.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.reconstructPacket = exports.deconstructPacket = void 0;
      var is_binary_1 = require_is_binary();
      function deconstructPacket(packet) {
        const buffers = [];
        const packetData = packet.data;
        const pack = packet;
        pack.data = _deconstructPacket(packetData, buffers);
        pack.attachments = buffers.length;
        return { packet: pack, buffers };
      }
      exports.deconstructPacket = deconstructPacket;
      function _deconstructPacket(data, buffers) {
        if (!data)
          return data;
        if (is_binary_1.isBinary(data)) {
          const placeholder = { _placeholder: true, num: buffers.length };
          buffers.push(data);
          return placeholder;
        } else if (Array.isArray(data)) {
          const newData = new Array(data.length);
          for (let i = 0; i < data.length; i++) {
            newData[i] = _deconstructPacket(data[i], buffers);
          }
          return newData;
        } else if (typeof data === "object" && !(data instanceof Date)) {
          const newData = {};
          for (const key2 in data) {
            if (data.hasOwnProperty(key2)) {
              newData[key2] = _deconstructPacket(data[key2], buffers);
            }
          }
          return newData;
        }
        return data;
      }
      function reconstructPacket(packet, buffers) {
        packet.data = _reconstructPacket(packet.data, buffers);
        packet.attachments = void 0;
        return packet;
      }
      exports.reconstructPacket = reconstructPacket;
      function _reconstructPacket(data, buffers) {
        if (!data)
          return data;
        if (data && data._placeholder) {
          return buffers[data.num];
        } else if (Array.isArray(data)) {
          for (let i = 0; i < data.length; i++) {
            data[i] = _reconstructPacket(data[i], buffers);
          }
        } else if (typeof data === "object") {
          for (const key2 in data) {
            if (data.hasOwnProperty(key2)) {
              data[key2] = _reconstructPacket(data[key2], buffers);
            }
          }
        }
        return data;
      }
    }
  });

  // node_modules/socket.io-parser/dist/index.js
  var require_dist = __commonJS({
    "node_modules/socket.io-parser/dist/index.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
      var Emitter = require_component_emitter();
      var binary_1 = require_binary();
      var is_binary_1 = require_is_binary();
      var debug = require_browser()("socket.io-parser");
      exports.protocol = 5;
      var PacketType;
      (function(PacketType2) {
        PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
        PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
        PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
        PacketType2[PacketType2["ACK"] = 3] = "ACK";
        PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
        PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
        PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
      })(PacketType = exports.PacketType || (exports.PacketType = {}));
      var Encoder = class {
        encode(obj) {
          debug("encoding packet %j", obj);
          if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
            if (is_binary_1.hasBinary(obj)) {
              obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
              return this.encodeAsBinary(obj);
            }
          }
          return [this.encodeAsString(obj)];
        }
        encodeAsString(obj) {
          let str = "" + obj.type;
          if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
            str += obj.attachments + "-";
          }
          if (obj.nsp && obj.nsp !== "/") {
            str += obj.nsp + ",";
          }
          if (obj.id != null) {
            str += obj.id;
          }
          if (obj.data != null) {
            str += JSON.stringify(obj.data);
          }
          debug("encoded %j as %s", obj, str);
          return str;
        }
        encodeAsBinary(obj) {
          const deconstruction = binary_1.deconstructPacket(obj);
          const pack = this.encodeAsString(deconstruction.packet);
          const buffers = deconstruction.buffers;
          buffers.unshift(pack);
          return buffers;
        }
      };
      exports.Encoder = Encoder;
      var Decoder = class extends Emitter {
        constructor() {
          super();
        }
        add(obj) {
          let packet;
          if (typeof obj === "string") {
            packet = this.decodeString(obj);
            if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
              this.reconstructor = new BinaryReconstructor(packet);
              if (packet.attachments === 0) {
                super.emit("decoded", packet);
              }
            } else {
              super.emit("decoded", packet);
            }
          } else if (is_binary_1.isBinary(obj) || obj.base64) {
            if (!this.reconstructor) {
              throw new Error("got binary data when not reconstructing a packet");
            } else {
              packet = this.reconstructor.takeBinaryData(obj);
              if (packet) {
                this.reconstructor = null;
                super.emit("decoded", packet);
              }
            }
          } else {
            throw new Error("Unknown type: " + obj);
          }
        }
        decodeString(str) {
          let i = 0;
          const p2 = {
            type: Number(str.charAt(0))
          };
          if (PacketType[p2.type] === void 0) {
            throw new Error("unknown packet type " + p2.type);
          }
          if (p2.type === PacketType.BINARY_EVENT || p2.type === PacketType.BINARY_ACK) {
            const start = i + 1;
            while (str.charAt(++i) !== "-" && i != str.length) {
            }
            const buf2 = str.substring(start, i);
            if (buf2 != Number(buf2) || str.charAt(i) !== "-") {
              throw new Error("Illegal attachments");
            }
            p2.attachments = Number(buf2);
          }
          if (str.charAt(i + 1) === "/") {
            const start = i + 1;
            while (++i) {
              const c = str.charAt(i);
              if (c === ",")
                break;
              if (i === str.length)
                break;
            }
            p2.nsp = str.substring(start, i);
          } else {
            p2.nsp = "/";
          }
          const next = str.charAt(i + 1);
          if (next !== "" && Number(next) == next) {
            const start = i + 1;
            while (++i) {
              const c = str.charAt(i);
              if (c == null || Number(c) != c) {
                --i;
                break;
              }
              if (i === str.length)
                break;
            }
            p2.id = Number(str.substring(start, i + 1));
          }
          if (str.charAt(++i)) {
            const payload = tryParse(str.substr(i));
            if (Decoder.isPayloadValid(p2.type, payload)) {
              p2.data = payload;
            } else {
              throw new Error("invalid payload");
            }
          }
          debug("decoded %s as %j", str, p2);
          return p2;
        }
        static isPayloadValid(type2, payload) {
          switch (type2) {
            case PacketType.CONNECT:
              return typeof payload === "object";
            case PacketType.DISCONNECT:
              return payload === void 0;
            case PacketType.CONNECT_ERROR:
              return typeof payload === "string" || typeof payload === "object";
            case PacketType.EVENT:
            case PacketType.BINARY_EVENT:
              return Array.isArray(payload) && payload.length > 0;
            case PacketType.ACK:
            case PacketType.BINARY_ACK:
              return Array.isArray(payload);
          }
        }
        destroy() {
          if (this.reconstructor) {
            this.reconstructor.finishedReconstruction();
          }
        }
      };
      exports.Decoder = Decoder;
      function tryParse(str) {
        try {
          return JSON.parse(str);
        } catch (e) {
          return false;
        }
      }
      var BinaryReconstructor = class {
        constructor(packet) {
          this.packet = packet;
          this.buffers = [];
          this.reconPack = packet;
        }
        takeBinaryData(binData) {
          this.buffers.push(binData);
          if (this.buffers.length === this.reconPack.attachments) {
            const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
            this.finishedReconstruction();
            return packet;
          }
          return null;
        }
        finishedReconstruction() {
          this.reconPack = null;
          this.buffers = [];
        }
      };
    }
  });

  // node_modules/socket.io-client/build/on.js
  var require_on = __commonJS({
    "node_modules/socket.io-client/build/on.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.on = void 0;
      function on(obj, ev, fn) {
        obj.on(ev, fn);
        return function subDestroy() {
          obj.off(ev, fn);
        };
      }
      exports.on = on;
    }
  });

  // node_modules/socket.io-client/build/typed-events.js
  var require_typed_events = __commonJS({
    "node_modules/socket.io-client/build/typed-events.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.StrictEventEmitter = void 0;
      var Emitter = require_component_emitter();
      var StrictEventEmitter = class extends Emitter {
        on(ev, listener) {
          super.on(ev, listener);
          return this;
        }
        once(ev, listener) {
          super.once(ev, listener);
          return this;
        }
        emit(ev, ...args) {
          super.emit(ev, ...args);
          return this;
        }
        emitReserved(ev, ...args) {
          super.emit(ev, ...args);
          return this;
        }
        listeners(event3) {
          return super.listeners(event3);
        }
      };
      exports.StrictEventEmitter = StrictEventEmitter;
    }
  });

  // node_modules/socket.io-client/build/socket.js
  var require_socket2 = __commonJS({
    "node_modules/socket.io-client/build/socket.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Socket = void 0;
      var socket_io_parser_1 = require_dist();
      var on_1 = require_on();
      var typed_events_1 = require_typed_events();
      var debug = require_browser()("socket.io-client:socket");
      var RESERVED_EVENTS = Object.freeze({
        connect: 1,
        connect_error: 1,
        disconnect: 1,
        disconnecting: 1,
        newListener: 1,
        removeListener: 1
      });
      var Socket2 = class extends typed_events_1.StrictEventEmitter {
        constructor(io2, nsp, opts) {
          super();
          this.connected = false;
          this.disconnected = true;
          this.receiveBuffer = [];
          this.sendBuffer = [];
          this.ids = 0;
          this.acks = {};
          this.flags = {};
          this.io = io2;
          this.nsp = nsp;
          if (opts && opts.auth) {
            this.auth = opts.auth;
          }
          if (this.io._autoConnect)
            this.open();
        }
        subEvents() {
          if (this.subs)
            return;
          const io2 = this.io;
          this.subs = [
            (0, on_1.on)(io2, "open", this.onopen.bind(this)),
            (0, on_1.on)(io2, "packet", this.onpacket.bind(this)),
            (0, on_1.on)(io2, "error", this.onerror.bind(this)),
            (0, on_1.on)(io2, "close", this.onclose.bind(this))
          ];
        }
        get active() {
          return !!this.subs;
        }
        connect() {
          if (this.connected)
            return this;
          this.subEvents();
          if (!this.io["_reconnecting"])
            this.io.open();
          if (this.io._readyState === "open")
            this.onopen();
          return this;
        }
        open() {
          return this.connect();
        }
        send(...args) {
          args.unshift("message");
          this.emit.apply(this, args);
          return this;
        }
        emit(ev, ...args) {
          if (RESERVED_EVENTS.hasOwnProperty(ev)) {
            throw new Error('"' + ev + '" is a reserved event name');
          }
          args.unshift(ev);
          const packet = {
            type: socket_io_parser_1.PacketType.EVENT,
            data: args
          };
          packet.options = {};
          packet.options.compress = this.flags.compress !== false;
          if (typeof args[args.length - 1] === "function") {
            debug("emitting packet with ack id %d", this.ids);
            this.acks[this.ids] = args.pop();
            packet.id = this.ids++;
          }
          const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
          const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
          if (discardPacket) {
            debug("discard packet as the transport is not currently writable");
          } else if (this.connected) {
            this.packet(packet);
          } else {
            this.sendBuffer.push(packet);
          }
          this.flags = {};
          return this;
        }
        packet(packet) {
          packet.nsp = this.nsp;
          this.io._packet(packet);
        }
        onopen() {
          debug("transport is open - connecting");
          if (typeof this.auth == "function") {
            this.auth((data) => {
              this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
            });
          } else {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
          }
        }
        onerror(err) {
          if (!this.connected) {
            this.emitReserved("connect_error", err);
          }
        }
        onclose(reason) {
          debug("close (%s)", reason);
          this.connected = false;
          this.disconnected = true;
          delete this.id;
          this.emitReserved("disconnect", reason);
        }
        onpacket(packet) {
          const sameNamespace = packet.nsp === this.nsp;
          if (!sameNamespace)
            return;
          switch (packet.type) {
            case socket_io_parser_1.PacketType.CONNECT:
              if (packet.data && packet.data.sid) {
                const id2 = packet.data.sid;
                this.onconnect(id2);
              } else {
                this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
              }
              break;
            case socket_io_parser_1.PacketType.EVENT:
              this.onevent(packet);
              break;
            case socket_io_parser_1.PacketType.BINARY_EVENT:
              this.onevent(packet);
              break;
            case socket_io_parser_1.PacketType.ACK:
              this.onack(packet);
              break;
            case socket_io_parser_1.PacketType.BINARY_ACK:
              this.onack(packet);
              break;
            case socket_io_parser_1.PacketType.DISCONNECT:
              this.ondisconnect();
              break;
            case socket_io_parser_1.PacketType.CONNECT_ERROR:
              const err = new Error(packet.data.message);
              err.data = packet.data.data;
              this.emitReserved("connect_error", err);
              break;
          }
        }
        onevent(packet) {
          const args = packet.data || [];
          debug("emitting event %j", args);
          if (packet.id != null) {
            debug("attaching ack callback to event");
            args.push(this.ack(packet.id));
          }
          if (this.connected) {
            this.emitEvent(args);
          } else {
            this.receiveBuffer.push(Object.freeze(args));
          }
        }
        emitEvent(args) {
          if (this._anyListeners && this._anyListeners.length) {
            const listeners = this._anyListeners.slice();
            for (const listener of listeners) {
              listener.apply(this, args);
            }
          }
          super.emit.apply(this, args);
        }
        ack(id2) {
          const self2 = this;
          let sent = false;
          return function(...args) {
            if (sent)
              return;
            sent = true;
            debug("sending ack %j", args);
            self2.packet({
              type: socket_io_parser_1.PacketType.ACK,
              id: id2,
              data: args
            });
          };
        }
        onack(packet) {
          const ack = this.acks[packet.id];
          if (typeof ack === "function") {
            debug("calling ack %s with %j", packet.id, packet.data);
            ack.apply(this, packet.data);
            delete this.acks[packet.id];
          } else {
            debug("bad ack %s", packet.id);
          }
        }
        onconnect(id2) {
          debug("socket connected with id %s", id2);
          this.id = id2;
          this.connected = true;
          this.disconnected = false;
          this.emitBuffered();
          this.emitReserved("connect");
        }
        emitBuffered() {
          this.receiveBuffer.forEach((args) => this.emitEvent(args));
          this.receiveBuffer = [];
          this.sendBuffer.forEach((packet) => this.packet(packet));
          this.sendBuffer = [];
        }
        ondisconnect() {
          debug("server disconnect (%s)", this.nsp);
          this.destroy();
          this.onclose("io server disconnect");
        }
        destroy() {
          if (this.subs) {
            this.subs.forEach((subDestroy) => subDestroy());
            this.subs = void 0;
          }
          this.io["_destroy"](this);
        }
        disconnect() {
          if (this.connected) {
            debug("performing disconnect (%s)", this.nsp);
            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
          }
          this.destroy();
          if (this.connected) {
            this.onclose("io client disconnect");
          }
          return this;
        }
        close() {
          return this.disconnect();
        }
        compress(compress) {
          this.flags.compress = compress;
          return this;
        }
        get volatile() {
          this.flags.volatile = true;
          return this;
        }
        onAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.push(listener);
          return this;
        }
        prependAny(listener) {
          this._anyListeners = this._anyListeners || [];
          this._anyListeners.unshift(listener);
          return this;
        }
        offAny(listener) {
          if (!this._anyListeners) {
            return this;
          }
          if (listener) {
            const listeners = this._anyListeners;
            for (let i = 0; i < listeners.length; i++) {
              if (listener === listeners[i]) {
                listeners.splice(i, 1);
                return this;
              }
            }
          } else {
            this._anyListeners = [];
          }
          return this;
        }
        listenersAny() {
          return this._anyListeners || [];
        }
      };
      exports.Socket = Socket2;
    }
  });

  // node_modules/backo2/index.js
  var require_backo2 = __commonJS({
    "node_modules/backo2/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      module.exports = Backoff;
      function Backoff(opts) {
        opts = opts || {};
        this.ms = opts.min || 100;
        this.max = opts.max || 1e4;
        this.factor = opts.factor || 2;
        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
        this.attempts = 0;
      }
      Backoff.prototype.duration = function() {
        var ms = this.ms * Math.pow(this.factor, this.attempts++);
        if (this.jitter) {
          var rand = Math.random();
          var deviation = Math.floor(rand * this.jitter * ms);
          ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
        }
        return Math.min(ms, this.max) | 0;
      };
      Backoff.prototype.reset = function() {
        this.attempts = 0;
      };
      Backoff.prototype.setMin = function(min) {
        this.ms = min;
      };
      Backoff.prototype.setMax = function(max) {
        this.max = max;
      };
      Backoff.prototype.setJitter = function(jitter) {
        this.jitter = jitter;
      };
    }
  });

  // node_modules/socket.io-client/build/manager.js
  var require_manager = __commonJS({
    "node_modules/socket.io-client/build/manager.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Manager = void 0;
      var eio = require_lib2();
      var util_1 = require_util();
      var socket_1 = require_socket2();
      var parser = require_dist();
      var on_1 = require_on();
      var Backoff = require_backo2();
      var typed_events_1 = require_typed_events();
      var debug = require_browser()("socket.io-client:manager");
      var Manager2 = class extends typed_events_1.StrictEventEmitter {
        constructor(uri, opts) {
          var _a2;
          super();
          this.nsps = {};
          this.subs = [];
          if (uri && typeof uri === "object") {
            opts = uri;
            uri = void 0;
          }
          opts = opts || {};
          opts.path = opts.path || "/socket.io";
          this.opts = opts;
          (0, util_1.installTimerFunctions)(this, opts);
          this.reconnection(opts.reconnection !== false);
          this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
          this.reconnectionDelay(opts.reconnectionDelay || 1e3);
          this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
          this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
          this.backoff = new Backoff({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          });
          this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
          this._readyState = "closed";
          this.uri = uri;
          const _parser = opts.parser || parser;
          this.encoder = new _parser.Encoder();
          this.decoder = new _parser.Decoder();
          this._autoConnect = opts.autoConnect !== false;
          if (this._autoConnect)
            this.open();
        }
        reconnection(v) {
          if (!arguments.length)
            return this._reconnection;
          this._reconnection = !!v;
          return this;
        }
        reconnectionAttempts(v) {
          if (v === void 0)
            return this._reconnectionAttempts;
          this._reconnectionAttempts = v;
          return this;
        }
        reconnectionDelay(v) {
          var _a2;
          if (v === void 0)
            return this._reconnectionDelay;
          this._reconnectionDelay = v;
          (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
          return this;
        }
        randomizationFactor(v) {
          var _a2;
          if (v === void 0)
            return this._randomizationFactor;
          this._randomizationFactor = v;
          (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
          return this;
        }
        reconnectionDelayMax(v) {
          var _a2;
          if (v === void 0)
            return this._reconnectionDelayMax;
          this._reconnectionDelayMax = v;
          (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
          return this;
        }
        timeout(v) {
          if (!arguments.length)
            return this._timeout;
          this._timeout = v;
          return this;
        }
        maybeReconnectOnOpen() {
          if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
            this.reconnect();
          }
        }
        open(fn) {
          debug("readyState %s", this._readyState);
          if (~this._readyState.indexOf("open"))
            return this;
          debug("opening %s", this.uri);
          this.engine = eio(this.uri, this.opts);
          const socket = this.engine;
          const self2 = this;
          this._readyState = "opening";
          this.skipReconnect = false;
          const openSubDestroy = (0, on_1.on)(socket, "open", function() {
            self2.onopen();
            fn && fn();
          });
          const errorSub = (0, on_1.on)(socket, "error", (err) => {
            debug("error");
            self2.cleanup();
            self2._readyState = "closed";
            this.emitReserved("error", err);
            if (fn) {
              fn(err);
            } else {
              self2.maybeReconnectOnOpen();
            }
          });
          if (this._timeout !== false) {
            const timeout2 = this._timeout;
            debug("connect attempt will timeout after %d", timeout2);
            if (timeout2 === 0) {
              openSubDestroy();
            }
            const timer2 = this.setTimeoutFn(() => {
              debug("connect attempt timed out after %d", timeout2);
              openSubDestroy();
              socket.close();
              socket.emit("error", new Error("timeout"));
            }, timeout2);
            if (this.opts.autoUnref) {
              timer2.unref();
            }
            this.subs.push(function subDestroy() {
              clearTimeout(timer2);
            });
          }
          this.subs.push(openSubDestroy);
          this.subs.push(errorSub);
          return this;
        }
        connect(fn) {
          return this.open(fn);
        }
        onopen() {
          debug("open");
          this.cleanup();
          this._readyState = "open";
          this.emitReserved("open");
          const socket = this.engine;
          this.subs.push((0, on_1.on)(socket, "ping", this.onping.bind(this)), (0, on_1.on)(socket, "data", this.ondata.bind(this)), (0, on_1.on)(socket, "error", this.onerror.bind(this)), (0, on_1.on)(socket, "close", this.onclose.bind(this)), (0, on_1.on)(this.decoder, "decoded", this.ondecoded.bind(this)));
        }
        onping() {
          this.emitReserved("ping");
        }
        ondata(data) {
          this.decoder.add(data);
        }
        ondecoded(packet) {
          this.emitReserved("packet", packet);
        }
        onerror(err) {
          debug("error", err);
          this.emitReserved("error", err);
        }
        socket(nsp, opts) {
          let socket = this.nsps[nsp];
          if (!socket) {
            socket = new socket_1.Socket(this, nsp, opts);
            this.nsps[nsp] = socket;
          }
          return socket;
        }
        _destroy(socket) {
          const nsps = Object.keys(this.nsps);
          for (const nsp of nsps) {
            const socket2 = this.nsps[nsp];
            if (socket2.active) {
              debug("socket %s is still active, skipping close", nsp);
              return;
            }
          }
          this._close();
        }
        _packet(packet) {
          debug("writing packet %j", packet);
          const encodedPackets = this.encoder.encode(packet);
          for (let i = 0; i < encodedPackets.length; i++) {
            this.engine.write(encodedPackets[i], packet.options);
          }
        }
        cleanup() {
          debug("cleanup");
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs.length = 0;
          this.decoder.destroy();
        }
        _close() {
          debug("disconnect");
          this.skipReconnect = true;
          this._reconnecting = false;
          if (this._readyState === "opening") {
            this.cleanup();
          }
          this.backoff.reset();
          this._readyState = "closed";
          if (this.engine)
            this.engine.close();
        }
        disconnect() {
          return this._close();
        }
        onclose(reason) {
          debug("onclose");
          this.cleanup();
          this.backoff.reset();
          this._readyState = "closed";
          this.emitReserved("close", reason);
          if (this._reconnection && !this.skipReconnect) {
            this.reconnect();
          }
        }
        reconnect() {
          if (this._reconnecting || this.skipReconnect)
            return this;
          const self2 = this;
          if (this.backoff.attempts >= this._reconnectionAttempts) {
            debug("reconnect failed");
            this.backoff.reset();
            this.emitReserved("reconnect_failed");
            this._reconnecting = false;
          } else {
            const delay = this.backoff.duration();
            debug("will wait %dms before reconnect attempt", delay);
            this._reconnecting = true;
            const timer2 = this.setTimeoutFn(() => {
              if (self2.skipReconnect)
                return;
              debug("attempting reconnect");
              this.emitReserved("reconnect_attempt", self2.backoff.attempts);
              if (self2.skipReconnect)
                return;
              self2.open((err) => {
                if (err) {
                  debug("reconnect attempt error");
                  self2._reconnecting = false;
                  self2.reconnect();
                  this.emitReserved("reconnect_error", err);
                } else {
                  debug("reconnect success");
                  self2.onreconnect();
                }
              });
            }, delay);
            if (this.opts.autoUnref) {
              timer2.unref();
            }
            this.subs.push(function subDestroy() {
              clearTimeout(timer2);
            });
          }
        }
        onreconnect() {
          const attempt = this.backoff.attempts;
          this._reconnecting = false;
          this.backoff.reset();
          this.emitReserved("reconnect", attempt);
        }
      };
      exports.Manager = Manager2;
    }
  });

  // node_modules/socket.io-client/build/index.js
  var require_build = __commonJS({
    "node_modules/socket.io-client/build/index.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.io = exports.Socket = exports.Manager = exports.protocol = void 0;
      var url_1 = require_url();
      var manager_1 = require_manager();
      var debug = require_browser()("socket.io-client");
      module.exports = exports = lookup;
      var cache = exports.managers = {};
      function lookup(uri, opts) {
        if (typeof uri === "object") {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        const parsed2 = (0, url_1.url)(uri, opts.path || "/socket.io");
        const source = parsed2.source;
        const id2 = parsed2.id;
        const path = parsed2.path;
        const sameNamespace = cache[id2] && path in cache[id2]["nsps"];
        const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
        let io2;
        if (newConnection) {
          debug("ignoring socket cache for %s", source);
          io2 = new manager_1.Manager(source, opts);
        } else {
          if (!cache[id2]) {
            debug("new io instance for %s", source);
            cache[id2] = new manager_1.Manager(source, opts);
          }
          io2 = cache[id2];
        }
        if (parsed2.query && !opts.query) {
          opts.query = parsed2.queryKey;
        }
        return io2.socket(parsed2.path, opts);
      }
      exports.io = lookup;
      var socket_io_parser_1 = require_dist();
      Object.defineProperty(exports, "protocol", { enumerable: true, get: function() {
        return socket_io_parser_1.protocol;
      } });
      exports.connect = lookup;
      var manager_2 = require_manager();
      Object.defineProperty(exports, "Manager", { enumerable: true, get: function() {
        return manager_2.Manager;
      } });
      var socket_1 = require_socket2();
      Object.defineProperty(exports, "Socket", { enumerable: true, get: function() {
        return socket_1.Socket;
      } });
      exports.default = lookup;
    }
  });

  // node_modules/vue3-sfc-loader/dist/vue3-sfc-loader.js
  var require_vue3_sfc_loader = __commonJS({
    "node_modules/vue3-sfc-loader/dist/vue3-sfc-loader.js"(exports, module) {
      var import_pako = __toModule(require_pako());
      !function(e, t) {
        typeof exports == "object" && typeof module == "object" ? module.exports = t() : typeof define == "function" && define.amd ? define([], t) : typeof exports == "object" ? exports["vue3-sfc-loader"] = t() : e["vue3-sfc-loader"] = t();
      }(self, function() {
        return (() => {
          var e = [(e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = { react: true, assertNode: true, createTypeAnnotationBasedOnTypeof: true, createUnionTypeAnnotation: true, createFlowUnionType: true, createTSUnionType: true, cloneNode: true, clone: true, cloneDeep: true, cloneDeepWithoutLoc: true, cloneWithoutLoc: true, addComment: true, addComments: true, inheritInnerComments: true, inheritLeadingComments: true, inheritsComments: true, inheritTrailingComments: true, removeComments: true, ensureBlock: true, toBindingIdentifierName: true, toBlock: true, toComputedKey: true, toExpression: true, toIdentifier: true, toKeyAlias: true, toSequenceExpression: true, toStatement: true, valueToNode: true, appendToMemberExpression: true, inherits: true, prependToMemberExpression: true, removeProperties: true, removePropertiesDeep: true, removeTypeDuplicates: true, getBindingIdentifiers: true, getOuterBindingIdentifiers: true, traverse: true, traverseFast: true, shallowEqual: true, is: true, isBinding: true, isBlockScoped: true, isImmutable: true, isLet: true, isNode: true, isNodesEquivalent: true, isPlaceholderType: true, isReferenced: true, isScope: true, isSpecifierDefault: true, isType: true, isValidES3Identifier: true, isValidIdentifier: true, isVar: true, matchesPattern: true, validate: true, buildMatchMemberExpression: true };
            Object.defineProperty(t2, "assertNode", { enumerable: true, get: function() {
              return a.default;
            } }), Object.defineProperty(t2, "createTypeAnnotationBasedOnTypeof", { enumerable: true, get: function() {
              return c.default;
            } }), Object.defineProperty(t2, "createUnionTypeAnnotation", { enumerable: true, get: function() {
              return u.default;
            } }), Object.defineProperty(t2, "createFlowUnionType", { enumerable: true, get: function() {
              return u.default;
            } }), Object.defineProperty(t2, "createTSUnionType", { enumerable: true, get: function() {
              return p2.default;
            } }), Object.defineProperty(t2, "cloneNode", { enumerable: true, get: function() {
              return h3.default;
            } }), Object.defineProperty(t2, "clone", { enumerable: true, get: function() {
              return m.default;
            } }), Object.defineProperty(t2, "cloneDeep", { enumerable: true, get: function() {
              return y.default;
            } }), Object.defineProperty(t2, "cloneDeepWithoutLoc", { enumerable: true, get: function() {
              return g.default;
            } }), Object.defineProperty(t2, "cloneWithoutLoc", { enumerable: true, get: function() {
              return b.default;
            } }), Object.defineProperty(t2, "addComment", { enumerable: true, get: function() {
              return v.default;
            } }), Object.defineProperty(t2, "addComments", { enumerable: true, get: function() {
              return E.default;
            } }), Object.defineProperty(t2, "inheritInnerComments", { enumerable: true, get: function() {
              return x.default;
            } }), Object.defineProperty(t2, "inheritLeadingComments", { enumerable: true, get: function() {
              return S.default;
            } }), Object.defineProperty(t2, "inheritsComments", { enumerable: true, get: function() {
              return T.default;
            } }), Object.defineProperty(t2, "inheritTrailingComments", { enumerable: true, get: function() {
              return w.default;
            } }), Object.defineProperty(t2, "removeComments", { enumerable: true, get: function() {
              return P.default;
            } }), Object.defineProperty(t2, "ensureBlock", { enumerable: true, get: function() {
              return C.default;
            } }), Object.defineProperty(t2, "toBindingIdentifierName", { enumerable: true, get: function() {
              return I.default;
            } }), Object.defineProperty(t2, "toBlock", { enumerable: true, get: function() {
              return k2.default;
            } }), Object.defineProperty(t2, "toComputedKey", { enumerable: true, get: function() {
              return N.default;
            } }), Object.defineProperty(t2, "toExpression", { enumerable: true, get: function() {
              return _.default;
            } }), Object.defineProperty(t2, "toIdentifier", { enumerable: true, get: function() {
              return j.default;
            } }), Object.defineProperty(t2, "toKeyAlias", { enumerable: true, get: function() {
              return D.default;
            } }), Object.defineProperty(t2, "toSequenceExpression", { enumerable: true, get: function() {
              return L.default;
            } }), Object.defineProperty(t2, "toStatement", { enumerable: true, get: function() {
              return M.default;
            } }), Object.defineProperty(t2, "valueToNode", { enumerable: true, get: function() {
              return B.default;
            } }), Object.defineProperty(t2, "appendToMemberExpression", { enumerable: true, get: function() {
              return F.default;
            } }), Object.defineProperty(t2, "inherits", { enumerable: true, get: function() {
              return U.default;
            } }), Object.defineProperty(t2, "prependToMemberExpression", { enumerable: true, get: function() {
              return $.default;
            } }), Object.defineProperty(t2, "removeProperties", { enumerable: true, get: function() {
              return q.default;
            } }), Object.defineProperty(t2, "removePropertiesDeep", { enumerable: true, get: function() {
              return V.default;
            } }), Object.defineProperty(t2, "removeTypeDuplicates", { enumerable: true, get: function() {
              return W.default;
            } }), Object.defineProperty(t2, "getBindingIdentifiers", { enumerable: true, get: function() {
              return K.default;
            } }), Object.defineProperty(t2, "getOuterBindingIdentifiers", { enumerable: true, get: function() {
              return G.default;
            } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
              return H.default;
            } }), Object.defineProperty(t2, "traverseFast", { enumerable: true, get: function() {
              return J.default;
            } }), Object.defineProperty(t2, "shallowEqual", { enumerable: true, get: function() {
              return Y.default;
            } }), Object.defineProperty(t2, "is", { enumerable: true, get: function() {
              return X.default;
            } }), Object.defineProperty(t2, "isBinding", { enumerable: true, get: function() {
              return z.default;
            } }), Object.defineProperty(t2, "isBlockScoped", { enumerable: true, get: function() {
              return Q.default;
            } }), Object.defineProperty(t2, "isImmutable", { enumerable: true, get: function() {
              return Z.default;
            } }), Object.defineProperty(t2, "isLet", { enumerable: true, get: function() {
              return ee.default;
            } }), Object.defineProperty(t2, "isNode", { enumerable: true, get: function() {
              return te.default;
            } }), Object.defineProperty(t2, "isNodesEquivalent", { enumerable: true, get: function() {
              return re.default;
            } }), Object.defineProperty(t2, "isPlaceholderType", { enumerable: true, get: function() {
              return ne.default;
            } }), Object.defineProperty(t2, "isReferenced", { enumerable: true, get: function() {
              return se.default;
            } }), Object.defineProperty(t2, "isScope", { enumerable: true, get: function() {
              return ie.default;
            } }), Object.defineProperty(t2, "isSpecifierDefault", { enumerable: true, get: function() {
              return oe.default;
            } }), Object.defineProperty(t2, "isType", { enumerable: true, get: function() {
              return ae.default;
            } }), Object.defineProperty(t2, "isValidES3Identifier", { enumerable: true, get: function() {
              return le.default;
            } }), Object.defineProperty(t2, "isValidIdentifier", { enumerable: true, get: function() {
              return ce.default;
            } }), Object.defineProperty(t2, "isVar", { enumerable: true, get: function() {
              return ue.default;
            } }), Object.defineProperty(t2, "matchesPattern", { enumerable: true, get: function() {
              return pe.default;
            } }), Object.defineProperty(t2, "validate", { enumerable: true, get: function() {
              return fe.default;
            } }), Object.defineProperty(t2, "buildMatchMemberExpression", { enumerable: true, get: function() {
              return de.default;
            } }), t2.react = void 0;
            var s2 = r2(363), i = r2(364), o = r2(365), a = r2(375), l = r2(376);
            Object.keys(l).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return l[e3];
              } }));
            });
            var c = r2(377), u = r2(378), p2 = r2(379), f = r2(6);
            Object.keys(f).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return f[e3];
              } }));
            });
            var d = r2(381);
            Object.keys(d).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return d[e3];
              } }));
            });
            var h3 = r2(26), m = r2(382), y = r2(383), g = r2(384), b = r2(385), v = r2(386), E = r2(220), x = r2(221), S = r2(222), T = r2(223), w = r2(224), P = r2(387), A = r2(388);
            Object.keys(A).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === A[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return A[e3];
              } }));
            });
            var O = r2(25);
            Object.keys(O).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === O[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return O[e3];
              } }));
            });
            var C = r2(389), I = r2(390), k2 = r2(225), N = r2(391), _ = r2(392), j = r2(226), D = r2(393), L = r2(394), M = r2(396), B = r2(397), R = r2(11);
            Object.keys(R).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === R[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return R[e3];
              } }));
            });
            var F = r2(398), U = r2(399), $ = r2(400), q = r2(229), V = r2(227), W = r2(219), K = r2(64), G = r2(401), H = r2(402);
            Object.keys(H).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === H[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return H[e3];
              } }));
            });
            var J = r2(228), Y = r2(127), X = r2(62), z = r2(403), Q = r2(404), Z = r2(405), ee = r2(230), te = r2(218), re = r2(406), ne = r2(216), se = r2(407), ie = r2(408), oe = r2(409), ae = r2(129), le = r2(410), ce = r2(38), ue = r2(411), pe = r2(214), fe = r2(130), de = r2(213), he = r2(1);
            Object.keys(he).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === he[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return he[e3];
              } }));
            });
            var me = r2(412);
            Object.keys(me).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (Object.prototype.hasOwnProperty.call(n, e3) || e3 in t2 && t2[e3] === me[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return me[e3];
              } }));
            });
            const ye = { isReactComponent: s2.default, isCompatTag: i.default, buildChildren: o.default };
            t2.react = ye;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.isArrayExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ArrayExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isAssignmentExpression = function(e3, t3) {
              return !!e3 && (e3.type === "AssignmentExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBinaryExpression = function(e3, t3) {
              return !!e3 && (e3.type === "BinaryExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isInterpreterDirective = function(e3, t3) {
              return !!e3 && (e3.type === "InterpreterDirective" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDirective = function(e3, t3) {
              return !!e3 && (e3.type === "Directive" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDirectiveLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "DirectiveLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBlockStatement = function(e3, t3) {
              return !!e3 && (e3.type === "BlockStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBreakStatement = function(e3, t3) {
              return !!e3 && (e3.type === "BreakStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isCallExpression = function(e3, t3) {
              return !!e3 && (e3.type === "CallExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isCatchClause = function(e3, t3) {
              return !!e3 && (e3.type === "CatchClause" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isConditionalExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ConditionalExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isContinueStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ContinueStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDebuggerStatement = function(e3, t3) {
              return !!e3 && (e3.type === "DebuggerStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDoWhileStatement = function(e3, t3) {
              return !!e3 && (e3.type === "DoWhileStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEmptyStatement = function(e3, t3) {
              return !!e3 && (e3.type === "EmptyStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExpressionStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ExpressionStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isFile = function(e3, t3) {
              return !!e3 && (e3.type === "File" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isForInStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ForInStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isForStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ForStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isFunctionDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "FunctionDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isFunctionExpression = function(e3, t3) {
              return !!e3 && (e3.type === "FunctionExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isIdentifier = function(e3, t3) {
              return !!e3 && (e3.type === "Identifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isIfStatement = function(e3, t3) {
              return !!e3 && (e3.type === "IfStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isLabeledStatement = function(e3, t3) {
              return !!e3 && (e3.type === "LabeledStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isStringLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "StringLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNumericLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "NumericLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNullLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "NullLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBooleanLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "BooleanLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isRegExpLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "RegExpLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isLogicalExpression = function(e3, t3) {
              return !!e3 && (e3.type === "LogicalExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isMemberExpression = function(e3, t3) {
              return !!e3 && (e3.type === "MemberExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNewExpression = function(e3, t3) {
              return !!e3 && (e3.type === "NewExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isProgram = function(e3, t3) {
              return !!e3 && (e3.type === "Program" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectMethod = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectMethod" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isRestElement = function(e3, t3) {
              return !!e3 && (e3.type === "RestElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isReturnStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ReturnStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSequenceExpression = function(e3, t3) {
              return !!e3 && (e3.type === "SequenceExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isParenthesizedExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ParenthesizedExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSwitchCase = function(e3, t3) {
              return !!e3 && (e3.type === "SwitchCase" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSwitchStatement = function(e3, t3) {
              return !!e3 && (e3.type === "SwitchStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isThisExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ThisExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isThrowStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ThrowStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTryStatement = function(e3, t3) {
              return !!e3 && (e3.type === "TryStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isUnaryExpression = function(e3, t3) {
              return !!e3 && (e3.type === "UnaryExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isUpdateExpression = function(e3, t3) {
              return !!e3 && (e3.type === "UpdateExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isVariableDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "VariableDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isVariableDeclarator = function(e3, t3) {
              return !!e3 && (e3.type === "VariableDeclarator" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isWhileStatement = function(e3, t3) {
              return !!e3 && (e3.type === "WhileStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isWithStatement = function(e3, t3) {
              return !!e3 && (e3.type === "WithStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isAssignmentPattern = function(e3, t3) {
              return !!e3 && (e3.type === "AssignmentPattern" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isArrayPattern = function(e3, t3) {
              return !!e3 && (e3.type === "ArrayPattern" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isArrowFunctionExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ArrowFunctionExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassBody = function(e3, t3) {
              return !!e3 && (e3.type === "ClassBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ClassExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "ClassDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportAllDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "ExportAllDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportDefaultDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "ExportDefaultDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportNamedDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "ExportNamedDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ExportSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isForOfStatement = function(e3, t3) {
              return !!e3 && (e3.type === "ForOfStatement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImportDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "ImportDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImportDefaultSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ImportDefaultSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImportNamespaceSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ImportNamespaceSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImportSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ImportSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isMetaProperty = function(e3, t3) {
              return !!e3 && (e3.type === "MetaProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassMethod = function(e3, t3) {
              return !!e3 && (e3.type === "ClassMethod" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectPattern = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectPattern" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSpreadElement = function(e3, t3) {
              return !!e3 && (e3.type === "SpreadElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSuper = function(e3, t3) {
              return !!e3 && (e3.type === "Super" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTaggedTemplateExpression = function(e3, t3) {
              return !!e3 && (e3.type === "TaggedTemplateExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTemplateElement = function(e3, t3) {
              return !!e3 && (e3.type === "TemplateElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTemplateLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "TemplateLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isYieldExpression = function(e3, t3) {
              return !!e3 && (e3.type === "YieldExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isAwaitExpression = function(e3, t3) {
              return !!e3 && (e3.type === "AwaitExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImport = function(e3, t3) {
              return !!e3 && (e3.type === "Import" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBigIntLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "BigIntLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportNamespaceSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ExportNamespaceSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isOptionalMemberExpression = function(e3, t3) {
              return !!e3 && (e3.type === "OptionalMemberExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isOptionalCallExpression = function(e3, t3) {
              return !!e3 && (e3.type === "OptionalCallExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isAnyTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "AnyTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isArrayTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "ArrayTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBooleanTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "BooleanTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBooleanLiteralTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "BooleanLiteralTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNullLiteralTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "NullLiteralTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassImplements = function(e3, t3) {
              return !!e3 && (e3.type === "ClassImplements" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareClass = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareClass" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareFunction = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareFunction" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareInterface = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareInterface" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareModule = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareModule" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareModuleExports = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareModuleExports" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareTypeAlias = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareTypeAlias" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareOpaqueType = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareOpaqueType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareVariable = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareVariable" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareExportDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareExportDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclareExportAllDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "DeclareExportAllDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDeclaredPredicate = function(e3, t3) {
              return !!e3 && (e3.type === "DeclaredPredicate" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExistsTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "ExistsTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isFunctionTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "FunctionTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isFunctionTypeParam = function(e3, t3) {
              return !!e3 && (e3.type === "FunctionTypeParam" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isGenericTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "GenericTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isInferredPredicate = function(e3, t3) {
              return !!e3 && (e3.type === "InferredPredicate" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isInterfaceExtends = function(e3, t3) {
              return !!e3 && (e3.type === "InterfaceExtends" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isInterfaceDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "InterfaceDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isInterfaceTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "InterfaceTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isIntersectionTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "IntersectionTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isMixedTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "MixedTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEmptyTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "EmptyTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNullableTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "NullableTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNumberLiteralTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "NumberLiteralTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNumberTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "NumberTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeInternalSlot = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeInternalSlot" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeCallProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeCallProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeIndexer = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeIndexer" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isObjectTypeSpreadProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ObjectTypeSpreadProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isOpaqueType = function(e3, t3) {
              return !!e3 && (e3.type === "OpaqueType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isQualifiedTypeIdentifier = function(e3, t3) {
              return !!e3 && (e3.type === "QualifiedTypeIdentifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isStringLiteralTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "StringLiteralTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isStringTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "StringTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSymbolTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "SymbolTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isThisTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "ThisTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTupleTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "TupleTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeofTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "TypeofTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeAlias = function(e3, t3) {
              return !!e3 && (e3.type === "TypeAlias" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "TypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeCastExpression = function(e3, t3) {
              return !!e3 && (e3.type === "TypeCastExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeParameter = function(e3, t3) {
              return !!e3 && (e3.type === "TypeParameter" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeParameterDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TypeParameterDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTypeParameterInstantiation = function(e3, t3) {
              return !!e3 && (e3.type === "TypeParameterInstantiation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isUnionTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "UnionTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isVariance = function(e3, t3) {
              return !!e3 && (e3.type === "Variance" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isVoidTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "VoidTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "EnumDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumBooleanBody = function(e3, t3) {
              return !!e3 && (e3.type === "EnumBooleanBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumNumberBody = function(e3, t3) {
              return !!e3 && (e3.type === "EnumNumberBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumStringBody = function(e3, t3) {
              return !!e3 && (e3.type === "EnumStringBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumSymbolBody = function(e3, t3) {
              return !!e3 && (e3.type === "EnumSymbolBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumBooleanMember = function(e3, t3) {
              return !!e3 && (e3.type === "EnumBooleanMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumNumberMember = function(e3, t3) {
              return !!e3 && (e3.type === "EnumNumberMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumStringMember = function(e3, t3) {
              return !!e3 && (e3.type === "EnumStringMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isEnumDefaultedMember = function(e3, t3) {
              return !!e3 && (e3.type === "EnumDefaultedMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isIndexedAccessType = function(e3, t3) {
              return !!e3 && (e3.type === "IndexedAccessType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isOptionalIndexedAccessType = function(e3, t3) {
              return !!e3 && (e3.type === "OptionalIndexedAccessType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXAttribute = function(e3, t3) {
              return !!e3 && (e3.type === "JSXAttribute" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXClosingElement = function(e3, t3) {
              return !!e3 && (e3.type === "JSXClosingElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXElement = function(e3, t3) {
              return !!e3 && (e3.type === "JSXElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXEmptyExpression = function(e3, t3) {
              return !!e3 && (e3.type === "JSXEmptyExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXExpressionContainer = function(e3, t3) {
              return !!e3 && (e3.type === "JSXExpressionContainer" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXSpreadChild = function(e3, t3) {
              return !!e3 && (e3.type === "JSXSpreadChild" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXIdentifier = function(e3, t3) {
              return !!e3 && (e3.type === "JSXIdentifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXMemberExpression = function(e3, t3) {
              return !!e3 && (e3.type === "JSXMemberExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXNamespacedName = function(e3, t3) {
              return !!e3 && (e3.type === "JSXNamespacedName" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXOpeningElement = function(e3, t3) {
              return !!e3 && (e3.type === "JSXOpeningElement" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXSpreadAttribute = function(e3, t3) {
              return !!e3 && (e3.type === "JSXSpreadAttribute" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXText = function(e3, t3) {
              return !!e3 && (e3.type === "JSXText" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXFragment = function(e3, t3) {
              return !!e3 && (e3.type === "JSXFragment" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXOpeningFragment = function(e3, t3) {
              return !!e3 && (e3.type === "JSXOpeningFragment" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isJSXClosingFragment = function(e3, t3) {
              return !!e3 && (e3.type === "JSXClosingFragment" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isNoop = function(e3, t3) {
              return !!e3 && (e3.type === "Noop" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isPlaceholder = function(e3, t3) {
              return !!e3 && (e3.type === "Placeholder" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isV8IntrinsicIdentifier = function(e3, t3) {
              return !!e3 && (e3.type === "V8IntrinsicIdentifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isArgumentPlaceholder = function(e3, t3) {
              return !!e3 && (e3.type === "ArgumentPlaceholder" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isBindExpression = function(e3, t3) {
              return !!e3 && (e3.type === "BindExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ClassProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isPipelineTopicExpression = function(e3, t3) {
              return !!e3 && (e3.type === "PipelineTopicExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isPipelineBareFunction = function(e3, t3) {
              return !!e3 && (e3.type === "PipelineBareFunction" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isPipelinePrimaryTopicReference = function(e3, t3) {
              return !!e3 && (e3.type === "PipelinePrimaryTopicReference" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassPrivateProperty = function(e3, t3) {
              return !!e3 && (e3.type === "ClassPrivateProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isClassPrivateMethod = function(e3, t3) {
              return !!e3 && (e3.type === "ClassPrivateMethod" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isImportAttribute = function(e3, t3) {
              return !!e3 && (e3.type === "ImportAttribute" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDecorator = function(e3, t3) {
              return !!e3 && (e3.type === "Decorator" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDoExpression = function(e3, t3) {
              return !!e3 && (e3.type === "DoExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExportDefaultSpecifier = function(e3, t3) {
              return !!e3 && (e3.type === "ExportDefaultSpecifier" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isPrivateName = function(e3, t3) {
              return !!e3 && (e3.type === "PrivateName" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isRecordExpression = function(e3, t3) {
              return !!e3 && (e3.type === "RecordExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTupleExpression = function(e3, t3) {
              return !!e3 && (e3.type === "TupleExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isDecimalLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "DecimalLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isStaticBlock = function(e3, t3) {
              return !!e3 && (e3.type === "StaticBlock" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isModuleExpression = function(e3, t3) {
              return !!e3 && (e3.type === "ModuleExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSParameterProperty = function(e3, t3) {
              return !!e3 && (e3.type === "TSParameterProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSDeclareFunction = function(e3, t3) {
              return !!e3 && (e3.type === "TSDeclareFunction" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSDeclareMethod = function(e3, t3) {
              return !!e3 && (e3.type === "TSDeclareMethod" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSQualifiedName = function(e3, t3) {
              return !!e3 && (e3.type === "TSQualifiedName" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSCallSignatureDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSCallSignatureDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSConstructSignatureDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSConstructSignatureDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSPropertySignature = function(e3, t3) {
              return !!e3 && (e3.type === "TSPropertySignature" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSMethodSignature = function(e3, t3) {
              return !!e3 && (e3.type === "TSMethodSignature" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSIndexSignature = function(e3, t3) {
              return !!e3 && (e3.type === "TSIndexSignature" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSAnyKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSAnyKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSBooleanKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSBooleanKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSBigIntKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSBigIntKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSIntrinsicKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSIntrinsicKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNeverKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSNeverKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNullKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSNullKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNumberKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSNumberKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSObjectKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSObjectKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSStringKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSStringKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSSymbolKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSSymbolKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSUndefinedKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSUndefinedKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSUnknownKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSUnknownKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSVoidKeyword = function(e3, t3) {
              return !!e3 && (e3.type === "TSVoidKeyword" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSThisType = function(e3, t3) {
              return !!e3 && (e3.type === "TSThisType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSFunctionType = function(e3, t3) {
              return !!e3 && (e3.type === "TSFunctionType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSConstructorType = function(e3, t3) {
              return !!e3 && (e3.type === "TSConstructorType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeReference = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeReference" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypePredicate = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypePredicate" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeQuery = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeQuery" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSArrayType = function(e3, t3) {
              return !!e3 && (e3.type === "TSArrayType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTupleType = function(e3, t3) {
              return !!e3 && (e3.type === "TSTupleType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSOptionalType = function(e3, t3) {
              return !!e3 && (e3.type === "TSOptionalType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSRestType = function(e3, t3) {
              return !!e3 && (e3.type === "TSRestType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNamedTupleMember = function(e3, t3) {
              return !!e3 && (e3.type === "TSNamedTupleMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSUnionType = function(e3, t3) {
              return !!e3 && (e3.type === "TSUnionType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSIntersectionType = function(e3, t3) {
              return !!e3 && (e3.type === "TSIntersectionType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSConditionalType = function(e3, t3) {
              return !!e3 && (e3.type === "TSConditionalType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSInferType = function(e3, t3) {
              return !!e3 && (e3.type === "TSInferType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSParenthesizedType = function(e3, t3) {
              return !!e3 && (e3.type === "TSParenthesizedType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeOperator = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeOperator" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSIndexedAccessType = function(e3, t3) {
              return !!e3 && (e3.type === "TSIndexedAccessType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSMappedType = function(e3, t3) {
              return !!e3 && (e3.type === "TSMappedType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSLiteralType = function(e3, t3) {
              return !!e3 && (e3.type === "TSLiteralType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSExpressionWithTypeArguments = function(e3, t3) {
              return !!e3 && (e3.type === "TSExpressionWithTypeArguments" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSInterfaceDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSInterfaceDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSInterfaceBody = function(e3, t3) {
              return !!e3 && (e3.type === "TSInterfaceBody" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeAliasDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeAliasDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSAsExpression = function(e3, t3) {
              return !!e3 && (e3.type === "TSAsExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeAssertion = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeAssertion" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSEnumDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSEnumDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSEnumMember = function(e3, t3) {
              return !!e3 && (e3.type === "TSEnumMember" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSModuleDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSModuleDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSModuleBlock = function(e3, t3) {
              return !!e3 && (e3.type === "TSModuleBlock" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSImportType = function(e3, t3) {
              return !!e3 && (e3.type === "TSImportType" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSImportEqualsDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSImportEqualsDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSExternalModuleReference = function(e3, t3) {
              return !!e3 && (e3.type === "TSExternalModuleReference" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNonNullExpression = function(e3, t3) {
              return !!e3 && (e3.type === "TSNonNullExpression" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSExportAssignment = function(e3, t3) {
              return !!e3 && (e3.type === "TSExportAssignment" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSNamespaceExportDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSNamespaceExportDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeAnnotation = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeAnnotation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeParameterInstantiation = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeParameterInstantiation" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeParameterDeclaration = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeParameterDeclaration" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isTSTypeParameter = function(e3, t3) {
              return !!e3 && (e3.type === "TSTypeParameter" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isExpression = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ArrayExpression" || r3 === "AssignmentExpression" || r3 === "BinaryExpression" || r3 === "CallExpression" || r3 === "ConditionalExpression" || r3 === "FunctionExpression" || r3 === "Identifier" || r3 === "StringLiteral" || r3 === "NumericLiteral" || r3 === "NullLiteral" || r3 === "BooleanLiteral" || r3 === "RegExpLiteral" || r3 === "LogicalExpression" || r3 === "MemberExpression" || r3 === "NewExpression" || r3 === "ObjectExpression" || r3 === "SequenceExpression" || r3 === "ParenthesizedExpression" || r3 === "ThisExpression" || r3 === "UnaryExpression" || r3 === "UpdateExpression" || r3 === "ArrowFunctionExpression" || r3 === "ClassExpression" || r3 === "MetaProperty" || r3 === "Super" || r3 === "TaggedTemplateExpression" || r3 === "TemplateLiteral" || r3 === "YieldExpression" || r3 === "AwaitExpression" || r3 === "Import" || r3 === "BigIntLiteral" || r3 === "OptionalMemberExpression" || r3 === "OptionalCallExpression" || r3 === "TypeCastExpression" || r3 === "JSXElement" || r3 === "JSXFragment" || r3 === "BindExpression" || r3 === "PipelinePrimaryTopicReference" || r3 === "DoExpression" || r3 === "RecordExpression" || r3 === "TupleExpression" || r3 === "DecimalLiteral" || r3 === "ModuleExpression" || r3 === "TSAsExpression" || r3 === "TSTypeAssertion" || r3 === "TSNonNullExpression" || r3 === "Placeholder" && (e3.expectedNode === "Expression" || e3.expectedNode === "Identifier" || e3.expectedNode === "StringLiteral")) && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isBinary = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BinaryExpression" || r3 === "LogicalExpression") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isScopable = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BlockStatement" || r3 === "CatchClause" || r3 === "DoWhileStatement" || r3 === "ForInStatement" || r3 === "ForStatement" || r3 === "FunctionDeclaration" || r3 === "FunctionExpression" || r3 === "Program" || r3 === "ObjectMethod" || r3 === "SwitchStatement" || r3 === "WhileStatement" || r3 === "ArrowFunctionExpression" || r3 === "ClassExpression" || r3 === "ClassDeclaration" || r3 === "ForOfStatement" || r3 === "ClassMethod" || r3 === "ClassPrivateMethod" || r3 === "StaticBlock" || r3 === "TSModuleBlock" || r3 === "Placeholder" && e3.expectedNode === "BlockStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isBlockParent = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BlockStatement" || r3 === "CatchClause" || r3 === "DoWhileStatement" || r3 === "ForInStatement" || r3 === "ForStatement" || r3 === "FunctionDeclaration" || r3 === "FunctionExpression" || r3 === "Program" || r3 === "ObjectMethod" || r3 === "SwitchStatement" || r3 === "WhileStatement" || r3 === "ArrowFunctionExpression" || r3 === "ForOfStatement" || r3 === "ClassMethod" || r3 === "ClassPrivateMethod" || r3 === "StaticBlock" || r3 === "TSModuleBlock" || r3 === "Placeholder" && e3.expectedNode === "BlockStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isBlock = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BlockStatement" || r3 === "Program" || r3 === "TSModuleBlock" || r3 === "Placeholder" && e3.expectedNode === "BlockStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isStatement = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BlockStatement" || r3 === "BreakStatement" || r3 === "ContinueStatement" || r3 === "DebuggerStatement" || r3 === "DoWhileStatement" || r3 === "EmptyStatement" || r3 === "ExpressionStatement" || r3 === "ForInStatement" || r3 === "ForStatement" || r3 === "FunctionDeclaration" || r3 === "IfStatement" || r3 === "LabeledStatement" || r3 === "ReturnStatement" || r3 === "SwitchStatement" || r3 === "ThrowStatement" || r3 === "TryStatement" || r3 === "VariableDeclaration" || r3 === "WhileStatement" || r3 === "WithStatement" || r3 === "ClassDeclaration" || r3 === "ExportAllDeclaration" || r3 === "ExportDefaultDeclaration" || r3 === "ExportNamedDeclaration" || r3 === "ForOfStatement" || r3 === "ImportDeclaration" || r3 === "DeclareClass" || r3 === "DeclareFunction" || r3 === "DeclareInterface" || r3 === "DeclareModule" || r3 === "DeclareModuleExports" || r3 === "DeclareTypeAlias" || r3 === "DeclareOpaqueType" || r3 === "DeclareVariable" || r3 === "DeclareExportDeclaration" || r3 === "DeclareExportAllDeclaration" || r3 === "InterfaceDeclaration" || r3 === "OpaqueType" || r3 === "TypeAlias" || r3 === "EnumDeclaration" || r3 === "TSDeclareFunction" || r3 === "TSInterfaceDeclaration" || r3 === "TSTypeAliasDeclaration" || r3 === "TSEnumDeclaration" || r3 === "TSModuleDeclaration" || r3 === "TSImportEqualsDeclaration" || r3 === "TSExportAssignment" || r3 === "TSNamespaceExportDeclaration" || r3 === "Placeholder" && (e3.expectedNode === "Statement" || e3.expectedNode === "Declaration" || e3.expectedNode === "BlockStatement")) && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isTerminatorless = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BreakStatement" || r3 === "ContinueStatement" || r3 === "ReturnStatement" || r3 === "ThrowStatement" || r3 === "YieldExpression" || r3 === "AwaitExpression") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isCompletionStatement = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "BreakStatement" || r3 === "ContinueStatement" || r3 === "ReturnStatement" || r3 === "ThrowStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isConditional = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ConditionalExpression" || r3 === "IfStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isLoop = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "DoWhileStatement" || r3 === "ForInStatement" || r3 === "ForStatement" || r3 === "WhileStatement" || r3 === "ForOfStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isWhile = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "DoWhileStatement" || r3 === "WhileStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isExpressionWrapper = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ExpressionStatement" || r3 === "ParenthesizedExpression" || r3 === "TypeCastExpression") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFor = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ForInStatement" || r3 === "ForStatement" || r3 === "ForOfStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isForXStatement = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ForInStatement" || r3 === "ForOfStatement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFunction = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "FunctionDeclaration" || r3 === "FunctionExpression" || r3 === "ObjectMethod" || r3 === "ArrowFunctionExpression" || r3 === "ClassMethod" || r3 === "ClassPrivateMethod") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFunctionParent = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "FunctionDeclaration" || r3 === "FunctionExpression" || r3 === "ObjectMethod" || r3 === "ArrowFunctionExpression" || r3 === "ClassMethod" || r3 === "ClassPrivateMethod") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isPureish = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "FunctionDeclaration" || r3 === "FunctionExpression" || r3 === "StringLiteral" || r3 === "NumericLiteral" || r3 === "NullLiteral" || r3 === "BooleanLiteral" || r3 === "RegExpLiteral" || r3 === "ArrowFunctionExpression" || r3 === "BigIntLiteral" || r3 === "DecimalLiteral" || r3 === "Placeholder" && e3.expectedNode === "StringLiteral") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isDeclaration = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "FunctionDeclaration" || r3 === "VariableDeclaration" || r3 === "ClassDeclaration" || r3 === "ExportAllDeclaration" || r3 === "ExportDefaultDeclaration" || r3 === "ExportNamedDeclaration" || r3 === "ImportDeclaration" || r3 === "DeclareClass" || r3 === "DeclareFunction" || r3 === "DeclareInterface" || r3 === "DeclareModule" || r3 === "DeclareModuleExports" || r3 === "DeclareTypeAlias" || r3 === "DeclareOpaqueType" || r3 === "DeclareVariable" || r3 === "DeclareExportDeclaration" || r3 === "DeclareExportAllDeclaration" || r3 === "InterfaceDeclaration" || r3 === "OpaqueType" || r3 === "TypeAlias" || r3 === "EnumDeclaration" || r3 === "TSDeclareFunction" || r3 === "TSInterfaceDeclaration" || r3 === "TSTypeAliasDeclaration" || r3 === "TSEnumDeclaration" || r3 === "TSModuleDeclaration" || r3 === "Placeholder" && e3.expectedNode === "Declaration") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isPatternLike = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "Identifier" || r3 === "RestElement" || r3 === "AssignmentPattern" || r3 === "ArrayPattern" || r3 === "ObjectPattern" || r3 === "Placeholder" && (e3.expectedNode === "Pattern" || e3.expectedNode === "Identifier")) && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isLVal = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "Identifier" || r3 === "MemberExpression" || r3 === "RestElement" || r3 === "AssignmentPattern" || r3 === "ArrayPattern" || r3 === "ObjectPattern" || r3 === "TSParameterProperty" || r3 === "Placeholder" && (e3.expectedNode === "Pattern" || e3.expectedNode === "Identifier")) && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isTSEntityName = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "Identifier" || r3 === "TSQualifiedName" || r3 === "Placeholder" && e3.expectedNode === "Identifier") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isLiteral = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "StringLiteral" || r3 === "NumericLiteral" || r3 === "NullLiteral" || r3 === "BooleanLiteral" || r3 === "RegExpLiteral" || r3 === "TemplateLiteral" || r3 === "BigIntLiteral" || r3 === "DecimalLiteral" || r3 === "Placeholder" && e3.expectedNode === "StringLiteral") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isImmutable = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "StringLiteral" || r3 === "NumericLiteral" || r3 === "NullLiteral" || r3 === "BooleanLiteral" || r3 === "BigIntLiteral" || r3 === "JSXAttribute" || r3 === "JSXClosingElement" || r3 === "JSXElement" || r3 === "JSXExpressionContainer" || r3 === "JSXSpreadChild" || r3 === "JSXOpeningElement" || r3 === "JSXText" || r3 === "JSXFragment" || r3 === "JSXOpeningFragment" || r3 === "JSXClosingFragment" || r3 === "DecimalLiteral" || r3 === "Placeholder" && e3.expectedNode === "StringLiteral") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isUserWhitespacable = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ObjectMethod" || r3 === "ObjectProperty" || r3 === "ObjectTypeInternalSlot" || r3 === "ObjectTypeCallProperty" || r3 === "ObjectTypeIndexer" || r3 === "ObjectTypeProperty" || r3 === "ObjectTypeSpreadProperty") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isMethod = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ObjectMethod" || r3 === "ClassMethod" || r3 === "ClassPrivateMethod") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isObjectMember = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ObjectMethod" || r3 === "ObjectProperty") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isProperty = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ObjectProperty" || r3 === "ClassProperty" || r3 === "ClassPrivateProperty") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isUnaryLike = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "UnaryExpression" || r3 === "SpreadElement") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isPattern = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "AssignmentPattern" || r3 === "ArrayPattern" || r3 === "ObjectPattern" || r3 === "Placeholder" && e3.expectedNode === "Pattern") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isClass = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ClassExpression" || r3 === "ClassDeclaration") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isModuleDeclaration = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ExportAllDeclaration" || r3 === "ExportDefaultDeclaration" || r3 === "ExportNamedDeclaration" || r3 === "ImportDeclaration") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isExportDeclaration = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ExportAllDeclaration" || r3 === "ExportDefaultDeclaration" || r3 === "ExportNamedDeclaration") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isModuleSpecifier = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ExportSpecifier" || r3 === "ImportDefaultSpecifier" || r3 === "ImportNamespaceSpecifier" || r3 === "ImportSpecifier" || r3 === "ExportNamespaceSpecifier" || r3 === "ExportDefaultSpecifier") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFlow = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "AnyTypeAnnotation" || r3 === "ArrayTypeAnnotation" || r3 === "BooleanTypeAnnotation" || r3 === "BooleanLiteralTypeAnnotation" || r3 === "NullLiteralTypeAnnotation" || r3 === "ClassImplements" || r3 === "DeclareClass" || r3 === "DeclareFunction" || r3 === "DeclareInterface" || r3 === "DeclareModule" || r3 === "DeclareModuleExports" || r3 === "DeclareTypeAlias" || r3 === "DeclareOpaqueType" || r3 === "DeclareVariable" || r3 === "DeclareExportDeclaration" || r3 === "DeclareExportAllDeclaration" || r3 === "DeclaredPredicate" || r3 === "ExistsTypeAnnotation" || r3 === "FunctionTypeAnnotation" || r3 === "FunctionTypeParam" || r3 === "GenericTypeAnnotation" || r3 === "InferredPredicate" || r3 === "InterfaceExtends" || r3 === "InterfaceDeclaration" || r3 === "InterfaceTypeAnnotation" || r3 === "IntersectionTypeAnnotation" || r3 === "MixedTypeAnnotation" || r3 === "EmptyTypeAnnotation" || r3 === "NullableTypeAnnotation" || r3 === "NumberLiteralTypeAnnotation" || r3 === "NumberTypeAnnotation" || r3 === "ObjectTypeAnnotation" || r3 === "ObjectTypeInternalSlot" || r3 === "ObjectTypeCallProperty" || r3 === "ObjectTypeIndexer" || r3 === "ObjectTypeProperty" || r3 === "ObjectTypeSpreadProperty" || r3 === "OpaqueType" || r3 === "QualifiedTypeIdentifier" || r3 === "StringLiteralTypeAnnotation" || r3 === "StringTypeAnnotation" || r3 === "SymbolTypeAnnotation" || r3 === "ThisTypeAnnotation" || r3 === "TupleTypeAnnotation" || r3 === "TypeofTypeAnnotation" || r3 === "TypeAlias" || r3 === "TypeAnnotation" || r3 === "TypeCastExpression" || r3 === "TypeParameter" || r3 === "TypeParameterDeclaration" || r3 === "TypeParameterInstantiation" || r3 === "UnionTypeAnnotation" || r3 === "Variance" || r3 === "VoidTypeAnnotation" || r3 === "IndexedAccessType" || r3 === "OptionalIndexedAccessType") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFlowType = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "AnyTypeAnnotation" || r3 === "ArrayTypeAnnotation" || r3 === "BooleanTypeAnnotation" || r3 === "BooleanLiteralTypeAnnotation" || r3 === "NullLiteralTypeAnnotation" || r3 === "ExistsTypeAnnotation" || r3 === "FunctionTypeAnnotation" || r3 === "GenericTypeAnnotation" || r3 === "InterfaceTypeAnnotation" || r3 === "IntersectionTypeAnnotation" || r3 === "MixedTypeAnnotation" || r3 === "EmptyTypeAnnotation" || r3 === "NullableTypeAnnotation" || r3 === "NumberLiteralTypeAnnotation" || r3 === "NumberTypeAnnotation" || r3 === "ObjectTypeAnnotation" || r3 === "StringLiteralTypeAnnotation" || r3 === "StringTypeAnnotation" || r3 === "SymbolTypeAnnotation" || r3 === "ThisTypeAnnotation" || r3 === "TupleTypeAnnotation" || r3 === "TypeofTypeAnnotation" || r3 === "UnionTypeAnnotation" || r3 === "VoidTypeAnnotation" || r3 === "IndexedAccessType" || r3 === "OptionalIndexedAccessType") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFlowBaseAnnotation = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "AnyTypeAnnotation" || r3 === "BooleanTypeAnnotation" || r3 === "NullLiteralTypeAnnotation" || r3 === "MixedTypeAnnotation" || r3 === "EmptyTypeAnnotation" || r3 === "NumberTypeAnnotation" || r3 === "StringTypeAnnotation" || r3 === "SymbolTypeAnnotation" || r3 === "ThisTypeAnnotation" || r3 === "VoidTypeAnnotation") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFlowDeclaration = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "DeclareClass" || r3 === "DeclareFunction" || r3 === "DeclareInterface" || r3 === "DeclareModule" || r3 === "DeclareModuleExports" || r3 === "DeclareTypeAlias" || r3 === "DeclareOpaqueType" || r3 === "DeclareVariable" || r3 === "DeclareExportDeclaration" || r3 === "DeclareExportAllDeclaration" || r3 === "InterfaceDeclaration" || r3 === "OpaqueType" || r3 === "TypeAlias") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isFlowPredicate = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "DeclaredPredicate" || r3 === "InferredPredicate") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isEnumBody = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "EnumBooleanBody" || r3 === "EnumNumberBody" || r3 === "EnumStringBody" || r3 === "EnumSymbolBody") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isEnumMember = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "EnumBooleanMember" || r3 === "EnumNumberMember" || r3 === "EnumStringMember" || r3 === "EnumDefaultedMember") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isJSX = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "JSXAttribute" || r3 === "JSXClosingElement" || r3 === "JSXElement" || r3 === "JSXEmptyExpression" || r3 === "JSXExpressionContainer" || r3 === "JSXSpreadChild" || r3 === "JSXIdentifier" || r3 === "JSXMemberExpression" || r3 === "JSXNamespacedName" || r3 === "JSXOpeningElement" || r3 === "JSXSpreadAttribute" || r3 === "JSXText" || r3 === "JSXFragment" || r3 === "JSXOpeningFragment" || r3 === "JSXClosingFragment") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isPrivate = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "ClassPrivateProperty" || r3 === "ClassPrivateMethod" || r3 === "PrivateName") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isTSTypeElement = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "TSCallSignatureDeclaration" || r3 === "TSConstructSignatureDeclaration" || r3 === "TSPropertySignature" || r3 === "TSMethodSignature" || r3 === "TSIndexSignature") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isTSType = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "TSAnyKeyword" || r3 === "TSBooleanKeyword" || r3 === "TSBigIntKeyword" || r3 === "TSIntrinsicKeyword" || r3 === "TSNeverKeyword" || r3 === "TSNullKeyword" || r3 === "TSNumberKeyword" || r3 === "TSObjectKeyword" || r3 === "TSStringKeyword" || r3 === "TSSymbolKeyword" || r3 === "TSUndefinedKeyword" || r3 === "TSUnknownKeyword" || r3 === "TSVoidKeyword" || r3 === "TSThisType" || r3 === "TSFunctionType" || r3 === "TSConstructorType" || r3 === "TSTypeReference" || r3 === "TSTypePredicate" || r3 === "TSTypeQuery" || r3 === "TSTypeLiteral" || r3 === "TSArrayType" || r3 === "TSTupleType" || r3 === "TSOptionalType" || r3 === "TSRestType" || r3 === "TSUnionType" || r3 === "TSIntersectionType" || r3 === "TSConditionalType" || r3 === "TSInferType" || r3 === "TSParenthesizedType" || r3 === "TSTypeOperator" || r3 === "TSIndexedAccessType" || r3 === "TSMappedType" || r3 === "TSLiteralType" || r3 === "TSExpressionWithTypeArguments" || r3 === "TSImportType") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isTSBaseType = function(e3, t3) {
              if (!e3)
                return false;
              const r3 = e3.type;
              return (r3 === "TSAnyKeyword" || r3 === "TSBooleanKeyword" || r3 === "TSBigIntKeyword" || r3 === "TSIntrinsicKeyword" || r3 === "TSNeverKeyword" || r3 === "TSNullKeyword" || r3 === "TSNumberKeyword" || r3 === "TSObjectKeyword" || r3 === "TSStringKeyword" || r3 === "TSSymbolKeyword" || r3 === "TSUndefinedKeyword" || r3 === "TSUnknownKeyword" || r3 === "TSVoidKeyword" || r3 === "TSThisType" || r3 === "TSLiteralType") && (t3 === void 0 || (0, n.default)(e3, t3));
            }, t2.isNumberLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "NumberLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isRegexLiteral = function(e3, t3) {
              return !!e3 && (e3.type === "RegexLiteral" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isRestProperty = function(e3, t3) {
              return !!e3 && (e3.type === "RestProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            }, t2.isSpreadProperty = function(e3, t3) {
              return !!e3 && (e3.type === "SpreadProperty" && (t3 === void 0 || (0, n.default)(e3, t3)));
            };
            var n = r2(127);
          }, (e2, t2, r2) => {
            var n = function(e3) {
              return e3 && e3.Math == Math && e3;
            };
            e2.exports = n(typeof globalThis == "object" && globalThis) || n(typeof window == "object" && window) || n(typeof self == "object" && self) || n(typeof r2.g == "object" && r2.g) || function() {
              return this;
            }() || Function("return this")();
          }, (e2, t2, r2) => {
            const n = r2(42), { MAX_LENGTH: s2, MAX_SAFE_INTEGER: i } = r2(41), { re: o, t: a } = r2(23), l = r2(43), { compareIdentifiers: c } = r2(94);
            class u {
              constructor(e3, t3) {
                if (t3 = l(t3), e3 instanceof u) {
                  if (e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease)
                    return e3;
                  e3 = e3.version;
                } else if (typeof e3 != "string")
                  throw new TypeError(`Invalid Version: ${e3}`);
                if (e3.length > s2)
                  throw new TypeError(`version is longer than ${s2} characters`);
                n("SemVer", e3, t3), this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease;
                const r3 = e3.trim().match(t3.loose ? o[a.LOOSE] : o[a.FULL]);
                if (!r3)
                  throw new TypeError(`Invalid Version: ${e3}`);
                if (this.raw = e3, this.major = +r3[1], this.minor = +r3[2], this.patch = +r3[3], this.major > i || this.major < 0)
                  throw new TypeError("Invalid major version");
                if (this.minor > i || this.minor < 0)
                  throw new TypeError("Invalid minor version");
                if (this.patch > i || this.patch < 0)
                  throw new TypeError("Invalid patch version");
                r3[4] ? this.prerelease = r3[4].split(".").map((e4) => {
                  if (/^[0-9]+$/.test(e4)) {
                    const t4 = +e4;
                    if (t4 >= 0 && t4 < i)
                      return t4;
                  }
                  return e4;
                }) : this.prerelease = [], this.build = r3[5] ? r3[5].split(".") : [], this.format();
              }
              format() {
                return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
              }
              toString() {
                return this.version;
              }
              compare(e3) {
                if (n("SemVer.compare", this.version, this.options, e3), !(e3 instanceof u)) {
                  if (typeof e3 == "string" && e3 === this.version)
                    return 0;
                  e3 = new u(e3, this.options);
                }
                return e3.version === this.version ? 0 : this.compareMain(e3) || this.comparePre(e3);
              }
              compareMain(e3) {
                return e3 instanceof u || (e3 = new u(e3, this.options)), c(this.major, e3.major) || c(this.minor, e3.minor) || c(this.patch, e3.patch);
              }
              comparePre(e3) {
                if (e3 instanceof u || (e3 = new u(e3, this.options)), this.prerelease.length && !e3.prerelease.length)
                  return -1;
                if (!this.prerelease.length && e3.prerelease.length)
                  return 1;
                if (!this.prerelease.length && !e3.prerelease.length)
                  return 0;
                let t3 = 0;
                do {
                  const r3 = this.prerelease[t3], s3 = e3.prerelease[t3];
                  if (n("prerelease compare", t3, r3, s3), r3 === void 0 && s3 === void 0)
                    return 0;
                  if (s3 === void 0)
                    return 1;
                  if (r3 === void 0)
                    return -1;
                  if (r3 !== s3)
                    return c(r3, s3);
                } while (++t3);
              }
              compareBuild(e3) {
                e3 instanceof u || (e3 = new u(e3, this.options));
                let t3 = 0;
                do {
                  const r3 = this.build[t3], s3 = e3.build[t3];
                  if (n("prerelease compare", t3, r3, s3), r3 === void 0 && s3 === void 0)
                    return 0;
                  if (s3 === void 0)
                    return 1;
                  if (r3 === void 0)
                    return -1;
                  if (r3 !== s3)
                    return c(r3, s3);
                } while (++t3);
              }
              inc(e3, t3) {
                switch (e3) {
                  case "premajor":
                    this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", t3);
                    break;
                  case "preminor":
                    this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", t3);
                    break;
                  case "prepatch":
                    this.prerelease.length = 0, this.inc("patch", t3), this.inc("pre", t3);
                    break;
                  case "prerelease":
                    this.prerelease.length === 0 && this.inc("patch", t3), this.inc("pre", t3);
                    break;
                  case "major":
                    this.minor === 0 && this.patch === 0 && this.prerelease.length !== 0 || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                    break;
                  case "minor":
                    this.patch === 0 && this.prerelease.length !== 0 || this.minor++, this.patch = 0, this.prerelease = [];
                    break;
                  case "patch":
                    this.prerelease.length === 0 && this.patch++, this.prerelease = [];
                    break;
                  case "pre":
                    if (this.prerelease.length === 0)
                      this.prerelease = [0];
                    else {
                      let e4 = this.prerelease.length;
                      for (; --e4 >= 0; )
                        typeof this.prerelease[e4] == "number" && (this.prerelease[e4]++, e4 = -2);
                      e4 === -1 && this.prerelease.push(0);
                    }
                    t3 && (this.prerelease[0] === t3 ? isNaN(this.prerelease[1]) && (this.prerelease = [t3, 0]) : this.prerelease = [t3, 0]);
                    break;
                  default:
                    throw new Error(`invalid increment argument: ${e3}`);
                }
                return this.format(), this.raw = this.version, this;
              }
            }
            e2.exports = u;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.declare = function(e3) {
              return (t3, s3, i) => {
                var o;
                let a;
                for (const e4 of Object.keys(r2)) {
                  var l;
                  t3[e4] || (a = (l = a) != null ? l : n(t3), a[e4] = r2[e4](a));
                }
                return e3((o = a) != null ? o : t3, s3 || {}, i);
              };
            };
            const r2 = { assertVersion: (e3) => (t3) => {
              !function(e4, t4) {
                if (typeof e4 == "number") {
                  if (!Number.isInteger(e4))
                    throw new Error("Expected string or integer value.");
                  e4 = `^${e4}.0.0-0`;
                }
                if (typeof e4 != "string")
                  throw new Error("Expected string or integer value.");
                const r3 = Error.stackTraceLimit;
                let n2;
                throw typeof r3 == "number" && r3 < 25 && (Error.stackTraceLimit = 25), n2 = t4.slice(0, 2) === "7." ? new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${t4}". You'll need to update your @babel/core version.`) : new Error(`Requires Babel "${e4}", but was loaded with "${t4}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`), typeof r3 == "number" && (Error.stackTraceLimit = r3), Object.assign(n2, { code: "BABEL_VERSION_UNSUPPORTED", version: t4, range: e4 });
              }(t3, e3.version);
            }, targets: () => () => ({}), assumption: () => () => {
            } };
            function n(e3) {
              let t3 = null;
              return typeof e3.version == "string" && /^7\./.test(e3.version) && (t3 = Object.getPrototypeOf(e3), !t3 || s2(t3, "version") && s2(t3, "transform") && s2(t3, "template") && s2(t3, "types") || (t3 = null)), Object.assign({}, t3, e3);
            }
            function s2(e3, t3) {
              return Object.prototype.hasOwnProperty.call(e3, t3);
            }
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.UNIVERSAL = t2.ATTRIBUTE = t2.CLASS = t2.COMBINATOR = t2.COMMENT = t2.ID = t2.NESTING = t2.PSEUDO = t2.ROOT = t2.SELECTOR = t2.STRING = t2.TAG = void 0, t2.TAG = "tag", t2.STRING = "string", t2.SELECTOR = "selector", t2.ROOT = "root", t2.PSEUDO = "pseudo", t2.NESTING = "nesting", t2.ID = "id", t2.COMMENT = "comment", t2.COMBINATOR = "combinator", t2.CLASS = "class", t2.ATTRIBUTE = "attribute", t2.UNIVERSAL = "universal";
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.arrayExpression = function(e3) {
              return (0, n.default)("ArrayExpression", ...arguments);
            }, t2.assignmentExpression = function(e3, t3, r3) {
              return (0, n.default)("AssignmentExpression", ...arguments);
            }, t2.binaryExpression = function(e3, t3, r3) {
              return (0, n.default)("BinaryExpression", ...arguments);
            }, t2.interpreterDirective = function(e3) {
              return (0, n.default)("InterpreterDirective", ...arguments);
            }, t2.directive = function(e3) {
              return (0, n.default)("Directive", ...arguments);
            }, t2.directiveLiteral = function(e3) {
              return (0, n.default)("DirectiveLiteral", ...arguments);
            }, t2.blockStatement = function(e3, t3) {
              return (0, n.default)("BlockStatement", ...arguments);
            }, t2.breakStatement = function(e3) {
              return (0, n.default)("BreakStatement", ...arguments);
            }, t2.callExpression = function(e3, t3) {
              return (0, n.default)("CallExpression", ...arguments);
            }, t2.catchClause = function(e3, t3) {
              return (0, n.default)("CatchClause", ...arguments);
            }, t2.conditionalExpression = function(e3, t3, r3) {
              return (0, n.default)("ConditionalExpression", ...arguments);
            }, t2.continueStatement = function(e3) {
              return (0, n.default)("ContinueStatement", ...arguments);
            }, t2.debuggerStatement = function() {
              return (0, n.default)("DebuggerStatement", ...arguments);
            }, t2.doWhileStatement = function(e3, t3) {
              return (0, n.default)("DoWhileStatement", ...arguments);
            }, t2.emptyStatement = function() {
              return (0, n.default)("EmptyStatement", ...arguments);
            }, t2.expressionStatement = function(e3) {
              return (0, n.default)("ExpressionStatement", ...arguments);
            }, t2.file = function(e3, t3, r3) {
              return (0, n.default)("File", ...arguments);
            }, t2.forInStatement = function(e3, t3, r3) {
              return (0, n.default)("ForInStatement", ...arguments);
            }, t2.forStatement = function(e3, t3, r3, s2) {
              return (0, n.default)("ForStatement", ...arguments);
            }, t2.functionDeclaration = function(e3, t3, r3, s2, i) {
              return (0, n.default)("FunctionDeclaration", ...arguments);
            }, t2.functionExpression = function(e3, t3, r3, s2, i) {
              return (0, n.default)("FunctionExpression", ...arguments);
            }, t2.identifier = function(e3) {
              return (0, n.default)("Identifier", ...arguments);
            }, t2.ifStatement = function(e3, t3, r3) {
              return (0, n.default)("IfStatement", ...arguments);
            }, t2.labeledStatement = function(e3, t3) {
              return (0, n.default)("LabeledStatement", ...arguments);
            }, t2.stringLiteral = function(e3) {
              return (0, n.default)("StringLiteral", ...arguments);
            }, t2.numericLiteral = function(e3) {
              return (0, n.default)("NumericLiteral", ...arguments);
            }, t2.nullLiteral = function() {
              return (0, n.default)("NullLiteral", ...arguments);
            }, t2.booleanLiteral = function(e3) {
              return (0, n.default)("BooleanLiteral", ...arguments);
            }, t2.regExpLiteral = function(e3, t3) {
              return (0, n.default)("RegExpLiteral", ...arguments);
            }, t2.logicalExpression = function(e3, t3, r3) {
              return (0, n.default)("LogicalExpression", ...arguments);
            }, t2.memberExpression = function(e3, t3, r3, s2) {
              return (0, n.default)("MemberExpression", ...arguments);
            }, t2.newExpression = function(e3, t3) {
              return (0, n.default)("NewExpression", ...arguments);
            }, t2.program = function(e3, t3, r3, s2) {
              return (0, n.default)("Program", ...arguments);
            }, t2.objectExpression = function(e3) {
              return (0, n.default)("ObjectExpression", ...arguments);
            }, t2.objectMethod = function(e3, t3, r3, s2, i, o, a) {
              return (0, n.default)("ObjectMethod", ...arguments);
            }, t2.objectProperty = function(e3, t3, r3, s2, i) {
              return (0, n.default)("ObjectProperty", ...arguments);
            }, t2.restElement = function(e3) {
              return (0, n.default)("RestElement", ...arguments);
            }, t2.returnStatement = function(e3) {
              return (0, n.default)("ReturnStatement", ...arguments);
            }, t2.sequenceExpression = function(e3) {
              return (0, n.default)("SequenceExpression", ...arguments);
            }, t2.parenthesizedExpression = function(e3) {
              return (0, n.default)("ParenthesizedExpression", ...arguments);
            }, t2.switchCase = function(e3, t3) {
              return (0, n.default)("SwitchCase", ...arguments);
            }, t2.switchStatement = function(e3, t3) {
              return (0, n.default)("SwitchStatement", ...arguments);
            }, t2.thisExpression = function() {
              return (0, n.default)("ThisExpression", ...arguments);
            }, t2.throwStatement = function(e3) {
              return (0, n.default)("ThrowStatement", ...arguments);
            }, t2.tryStatement = function(e3, t3, r3) {
              return (0, n.default)("TryStatement", ...arguments);
            }, t2.unaryExpression = function(e3, t3, r3) {
              return (0, n.default)("UnaryExpression", ...arguments);
            }, t2.updateExpression = function(e3, t3, r3) {
              return (0, n.default)("UpdateExpression", ...arguments);
            }, t2.variableDeclaration = function(e3, t3) {
              return (0, n.default)("VariableDeclaration", ...arguments);
            }, t2.variableDeclarator = function(e3, t3) {
              return (0, n.default)("VariableDeclarator", ...arguments);
            }, t2.whileStatement = function(e3, t3) {
              return (0, n.default)("WhileStatement", ...arguments);
            }, t2.withStatement = function(e3, t3) {
              return (0, n.default)("WithStatement", ...arguments);
            }, t2.assignmentPattern = function(e3, t3) {
              return (0, n.default)("AssignmentPattern", ...arguments);
            }, t2.arrayPattern = function(e3) {
              return (0, n.default)("ArrayPattern", ...arguments);
            }, t2.arrowFunctionExpression = function(e3, t3, r3) {
              return (0, n.default)("ArrowFunctionExpression", ...arguments);
            }, t2.classBody = function(e3) {
              return (0, n.default)("ClassBody", ...arguments);
            }, t2.classExpression = function(e3, t3, r3, s2) {
              return (0, n.default)("ClassExpression", ...arguments);
            }, t2.classDeclaration = function(e3, t3, r3, s2) {
              return (0, n.default)("ClassDeclaration", ...arguments);
            }, t2.exportAllDeclaration = function(e3) {
              return (0, n.default)("ExportAllDeclaration", ...arguments);
            }, t2.exportDefaultDeclaration = function(e3) {
              return (0, n.default)("ExportDefaultDeclaration", ...arguments);
            }, t2.exportNamedDeclaration = function(e3, t3, r3) {
              return (0, n.default)("ExportNamedDeclaration", ...arguments);
            }, t2.exportSpecifier = function(e3, t3) {
              return (0, n.default)("ExportSpecifier", ...arguments);
            }, t2.forOfStatement = function(e3, t3, r3, s2) {
              return (0, n.default)("ForOfStatement", ...arguments);
            }, t2.importDeclaration = function(e3, t3) {
              return (0, n.default)("ImportDeclaration", ...arguments);
            }, t2.importDefaultSpecifier = function(e3) {
              return (0, n.default)("ImportDefaultSpecifier", ...arguments);
            }, t2.importNamespaceSpecifier = function(e3) {
              return (0, n.default)("ImportNamespaceSpecifier", ...arguments);
            }, t2.importSpecifier = function(e3, t3) {
              return (0, n.default)("ImportSpecifier", ...arguments);
            }, t2.metaProperty = function(e3, t3) {
              return (0, n.default)("MetaProperty", ...arguments);
            }, t2.classMethod = function(e3, t3, r3, s2, i, o, a, l) {
              return (0, n.default)("ClassMethod", ...arguments);
            }, t2.objectPattern = function(e3) {
              return (0, n.default)("ObjectPattern", ...arguments);
            }, t2.spreadElement = function(e3) {
              return (0, n.default)("SpreadElement", ...arguments);
            }, t2.super = function() {
              return (0, n.default)("Super", ...arguments);
            }, t2.taggedTemplateExpression = function(e3, t3) {
              return (0, n.default)("TaggedTemplateExpression", ...arguments);
            }, t2.templateElement = function(e3, t3) {
              return (0, n.default)("TemplateElement", ...arguments);
            }, t2.templateLiteral = function(e3, t3) {
              return (0, n.default)("TemplateLiteral", ...arguments);
            }, t2.yieldExpression = function(e3, t3) {
              return (0, n.default)("YieldExpression", ...arguments);
            }, t2.awaitExpression = function(e3) {
              return (0, n.default)("AwaitExpression", ...arguments);
            }, t2.import = function() {
              return (0, n.default)("Import", ...arguments);
            }, t2.bigIntLiteral = function(e3) {
              return (0, n.default)("BigIntLiteral", ...arguments);
            }, t2.exportNamespaceSpecifier = function(e3) {
              return (0, n.default)("ExportNamespaceSpecifier", ...arguments);
            }, t2.optionalMemberExpression = function(e3, t3, r3, s2) {
              return (0, n.default)("OptionalMemberExpression", ...arguments);
            }, t2.optionalCallExpression = function(e3, t3, r3) {
              return (0, n.default)("OptionalCallExpression", ...arguments);
            }, t2.anyTypeAnnotation = function() {
              return (0, n.default)("AnyTypeAnnotation", ...arguments);
            }, t2.arrayTypeAnnotation = function(e3) {
              return (0, n.default)("ArrayTypeAnnotation", ...arguments);
            }, t2.booleanTypeAnnotation = function() {
              return (0, n.default)("BooleanTypeAnnotation", ...arguments);
            }, t2.booleanLiteralTypeAnnotation = function(e3) {
              return (0, n.default)("BooleanLiteralTypeAnnotation", ...arguments);
            }, t2.nullLiteralTypeAnnotation = function() {
              return (0, n.default)("NullLiteralTypeAnnotation", ...arguments);
            }, t2.classImplements = function(e3, t3) {
              return (0, n.default)("ClassImplements", ...arguments);
            }, t2.declareClass = function(e3, t3, r3, s2) {
              return (0, n.default)("DeclareClass", ...arguments);
            }, t2.declareFunction = function(e3) {
              return (0, n.default)("DeclareFunction", ...arguments);
            }, t2.declareInterface = function(e3, t3, r3, s2) {
              return (0, n.default)("DeclareInterface", ...arguments);
            }, t2.declareModule = function(e3, t3, r3) {
              return (0, n.default)("DeclareModule", ...arguments);
            }, t2.declareModuleExports = function(e3) {
              return (0, n.default)("DeclareModuleExports", ...arguments);
            }, t2.declareTypeAlias = function(e3, t3, r3) {
              return (0, n.default)("DeclareTypeAlias", ...arguments);
            }, t2.declareOpaqueType = function(e3, t3, r3) {
              return (0, n.default)("DeclareOpaqueType", ...arguments);
            }, t2.declareVariable = function(e3) {
              return (0, n.default)("DeclareVariable", ...arguments);
            }, t2.declareExportDeclaration = function(e3, t3, r3) {
              return (0, n.default)("DeclareExportDeclaration", ...arguments);
            }, t2.declareExportAllDeclaration = function(e3) {
              return (0, n.default)("DeclareExportAllDeclaration", ...arguments);
            }, t2.declaredPredicate = function(e3) {
              return (0, n.default)("DeclaredPredicate", ...arguments);
            }, t2.existsTypeAnnotation = function() {
              return (0, n.default)("ExistsTypeAnnotation", ...arguments);
            }, t2.functionTypeAnnotation = function(e3, t3, r3, s2) {
              return (0, n.default)("FunctionTypeAnnotation", ...arguments);
            }, t2.functionTypeParam = function(e3, t3) {
              return (0, n.default)("FunctionTypeParam", ...arguments);
            }, t2.genericTypeAnnotation = function(e3, t3) {
              return (0, n.default)("GenericTypeAnnotation", ...arguments);
            }, t2.inferredPredicate = function() {
              return (0, n.default)("InferredPredicate", ...arguments);
            }, t2.interfaceExtends = function(e3, t3) {
              return (0, n.default)("InterfaceExtends", ...arguments);
            }, t2.interfaceDeclaration = function(e3, t3, r3, s2) {
              return (0, n.default)("InterfaceDeclaration", ...arguments);
            }, t2.interfaceTypeAnnotation = function(e3, t3) {
              return (0, n.default)("InterfaceTypeAnnotation", ...arguments);
            }, t2.intersectionTypeAnnotation = function(e3) {
              return (0, n.default)("IntersectionTypeAnnotation", ...arguments);
            }, t2.mixedTypeAnnotation = function() {
              return (0, n.default)("MixedTypeAnnotation", ...arguments);
            }, t2.emptyTypeAnnotation = function() {
              return (0, n.default)("EmptyTypeAnnotation", ...arguments);
            }, t2.nullableTypeAnnotation = function(e3) {
              return (0, n.default)("NullableTypeAnnotation", ...arguments);
            }, t2.numberLiteralTypeAnnotation = function(e3) {
              return (0, n.default)("NumberLiteralTypeAnnotation", ...arguments);
            }, t2.numberTypeAnnotation = function() {
              return (0, n.default)("NumberTypeAnnotation", ...arguments);
            }, t2.objectTypeAnnotation = function(e3, t3, r3, s2, i) {
              return (0, n.default)("ObjectTypeAnnotation", ...arguments);
            }, t2.objectTypeInternalSlot = function(e3, t3, r3, s2, i) {
              return (0, n.default)("ObjectTypeInternalSlot", ...arguments);
            }, t2.objectTypeCallProperty = function(e3) {
              return (0, n.default)("ObjectTypeCallProperty", ...arguments);
            }, t2.objectTypeIndexer = function(e3, t3, r3, s2) {
              return (0, n.default)("ObjectTypeIndexer", ...arguments);
            }, t2.objectTypeProperty = function(e3, t3, r3) {
              return (0, n.default)("ObjectTypeProperty", ...arguments);
            }, t2.objectTypeSpreadProperty = function(e3) {
              return (0, n.default)("ObjectTypeSpreadProperty", ...arguments);
            }, t2.opaqueType = function(e3, t3, r3, s2) {
              return (0, n.default)("OpaqueType", ...arguments);
            }, t2.qualifiedTypeIdentifier = function(e3, t3) {
              return (0, n.default)("QualifiedTypeIdentifier", ...arguments);
            }, t2.stringLiteralTypeAnnotation = function(e3) {
              return (0, n.default)("StringLiteralTypeAnnotation", ...arguments);
            }, t2.stringTypeAnnotation = function() {
              return (0, n.default)("StringTypeAnnotation", ...arguments);
            }, t2.symbolTypeAnnotation = function() {
              return (0, n.default)("SymbolTypeAnnotation", ...arguments);
            }, t2.thisTypeAnnotation = function() {
              return (0, n.default)("ThisTypeAnnotation", ...arguments);
            }, t2.tupleTypeAnnotation = function(e3) {
              return (0, n.default)("TupleTypeAnnotation", ...arguments);
            }, t2.typeofTypeAnnotation = function(e3) {
              return (0, n.default)("TypeofTypeAnnotation", ...arguments);
            }, t2.typeAlias = function(e3, t3, r3) {
              return (0, n.default)("TypeAlias", ...arguments);
            }, t2.typeAnnotation = function(e3) {
              return (0, n.default)("TypeAnnotation", ...arguments);
            }, t2.typeCastExpression = function(e3, t3) {
              return (0, n.default)("TypeCastExpression", ...arguments);
            }, t2.typeParameter = function(e3, t3, r3) {
              return (0, n.default)("TypeParameter", ...arguments);
            }, t2.typeParameterDeclaration = function(e3) {
              return (0, n.default)("TypeParameterDeclaration", ...arguments);
            }, t2.typeParameterInstantiation = function(e3) {
              return (0, n.default)("TypeParameterInstantiation", ...arguments);
            }, t2.unionTypeAnnotation = function(e3) {
              return (0, n.default)("UnionTypeAnnotation", ...arguments);
            }, t2.variance = function(e3) {
              return (0, n.default)("Variance", ...arguments);
            }, t2.voidTypeAnnotation = function() {
              return (0, n.default)("VoidTypeAnnotation", ...arguments);
            }, t2.enumDeclaration = function(e3, t3) {
              return (0, n.default)("EnumDeclaration", ...arguments);
            }, t2.enumBooleanBody = function(e3) {
              return (0, n.default)("EnumBooleanBody", ...arguments);
            }, t2.enumNumberBody = function(e3) {
              return (0, n.default)("EnumNumberBody", ...arguments);
            }, t2.enumStringBody = function(e3) {
              return (0, n.default)("EnumStringBody", ...arguments);
            }, t2.enumSymbolBody = function(e3) {
              return (0, n.default)("EnumSymbolBody", ...arguments);
            }, t2.enumBooleanMember = function(e3) {
              return (0, n.default)("EnumBooleanMember", ...arguments);
            }, t2.enumNumberMember = function(e3, t3) {
              return (0, n.default)("EnumNumberMember", ...arguments);
            }, t2.enumStringMember = function(e3, t3) {
              return (0, n.default)("EnumStringMember", ...arguments);
            }, t2.enumDefaultedMember = function(e3) {
              return (0, n.default)("EnumDefaultedMember", ...arguments);
            }, t2.indexedAccessType = function(e3, t3) {
              return (0, n.default)("IndexedAccessType", ...arguments);
            }, t2.optionalIndexedAccessType = function(e3, t3) {
              return (0, n.default)("OptionalIndexedAccessType", ...arguments);
            }, t2.jSXAttribute = t2.jsxAttribute = function(e3, t3) {
              return (0, n.default)("JSXAttribute", ...arguments);
            }, t2.jSXClosingElement = t2.jsxClosingElement = function(e3) {
              return (0, n.default)("JSXClosingElement", ...arguments);
            }, t2.jSXElement = t2.jsxElement = function(e3, t3, r3, s2) {
              return (0, n.default)("JSXElement", ...arguments);
            }, t2.jSXEmptyExpression = t2.jsxEmptyExpression = function() {
              return (0, n.default)("JSXEmptyExpression", ...arguments);
            }, t2.jSXExpressionContainer = t2.jsxExpressionContainer = function(e3) {
              return (0, n.default)("JSXExpressionContainer", ...arguments);
            }, t2.jSXSpreadChild = t2.jsxSpreadChild = function(e3) {
              return (0, n.default)("JSXSpreadChild", ...arguments);
            }, t2.jSXIdentifier = t2.jsxIdentifier = function(e3) {
              return (0, n.default)("JSXIdentifier", ...arguments);
            }, t2.jSXMemberExpression = t2.jsxMemberExpression = function(e3, t3) {
              return (0, n.default)("JSXMemberExpression", ...arguments);
            }, t2.jSXNamespacedName = t2.jsxNamespacedName = function(e3, t3) {
              return (0, n.default)("JSXNamespacedName", ...arguments);
            }, t2.jSXOpeningElement = t2.jsxOpeningElement = function(e3, t3, r3) {
              return (0, n.default)("JSXOpeningElement", ...arguments);
            }, t2.jSXSpreadAttribute = t2.jsxSpreadAttribute = function(e3) {
              return (0, n.default)("JSXSpreadAttribute", ...arguments);
            }, t2.jSXText = t2.jsxText = function(e3) {
              return (0, n.default)("JSXText", ...arguments);
            }, t2.jSXFragment = t2.jsxFragment = function(e3, t3, r3) {
              return (0, n.default)("JSXFragment", ...arguments);
            }, t2.jSXOpeningFragment = t2.jsxOpeningFragment = function() {
              return (0, n.default)("JSXOpeningFragment", ...arguments);
            }, t2.jSXClosingFragment = t2.jsxClosingFragment = function() {
              return (0, n.default)("JSXClosingFragment", ...arguments);
            }, t2.noop = function() {
              return (0, n.default)("Noop", ...arguments);
            }, t2.placeholder = function(e3, t3) {
              return (0, n.default)("Placeholder", ...arguments);
            }, t2.v8IntrinsicIdentifier = function(e3) {
              return (0, n.default)("V8IntrinsicIdentifier", ...arguments);
            }, t2.argumentPlaceholder = function() {
              return (0, n.default)("ArgumentPlaceholder", ...arguments);
            }, t2.bindExpression = function(e3, t3) {
              return (0, n.default)("BindExpression", ...arguments);
            }, t2.classProperty = function(e3, t3, r3, s2, i, o) {
              return (0, n.default)("ClassProperty", ...arguments);
            }, t2.pipelineTopicExpression = function(e3) {
              return (0, n.default)("PipelineTopicExpression", ...arguments);
            }, t2.pipelineBareFunction = function(e3) {
              return (0, n.default)("PipelineBareFunction", ...arguments);
            }, t2.pipelinePrimaryTopicReference = function() {
              return (0, n.default)("PipelinePrimaryTopicReference", ...arguments);
            }, t2.classPrivateProperty = function(e3, t3, r3, s2) {
              return (0, n.default)("ClassPrivateProperty", ...arguments);
            }, t2.classPrivateMethod = function(e3, t3, r3, s2, i) {
              return (0, n.default)("ClassPrivateMethod", ...arguments);
            }, t2.importAttribute = function(e3, t3) {
              return (0, n.default)("ImportAttribute", ...arguments);
            }, t2.decorator = function(e3) {
              return (0, n.default)("Decorator", ...arguments);
            }, t2.doExpression = function(e3, t3) {
              return (0, n.default)("DoExpression", ...arguments);
            }, t2.exportDefaultSpecifier = function(e3) {
              return (0, n.default)("ExportDefaultSpecifier", ...arguments);
            }, t2.privateName = function(e3) {
              return (0, n.default)("PrivateName", ...arguments);
            }, t2.recordExpression = function(e3) {
              return (0, n.default)("RecordExpression", ...arguments);
            }, t2.tupleExpression = function(e3) {
              return (0, n.default)("TupleExpression", ...arguments);
            }, t2.decimalLiteral = function(e3) {
              return (0, n.default)("DecimalLiteral", ...arguments);
            }, t2.staticBlock = function(e3) {
              return (0, n.default)("StaticBlock", ...arguments);
            }, t2.moduleExpression = function(e3) {
              return (0, n.default)("ModuleExpression", ...arguments);
            }, t2.tSParameterProperty = t2.tsParameterProperty = function(e3) {
              return (0, n.default)("TSParameterProperty", ...arguments);
            }, t2.tSDeclareFunction = t2.tsDeclareFunction = function(e3, t3, r3, s2) {
              return (0, n.default)("TSDeclareFunction", ...arguments);
            }, t2.tSDeclareMethod = t2.tsDeclareMethod = function(e3, t3, r3, s2, i) {
              return (0, n.default)("TSDeclareMethod", ...arguments);
            }, t2.tSQualifiedName = t2.tsQualifiedName = function(e3, t3) {
              return (0, n.default)("TSQualifiedName", ...arguments);
            }, t2.tSCallSignatureDeclaration = t2.tsCallSignatureDeclaration = function(e3, t3, r3) {
              return (0, n.default)("TSCallSignatureDeclaration", ...arguments);
            }, t2.tSConstructSignatureDeclaration = t2.tsConstructSignatureDeclaration = function(e3, t3, r3) {
              return (0, n.default)("TSConstructSignatureDeclaration", ...arguments);
            }, t2.tSPropertySignature = t2.tsPropertySignature = function(e3, t3, r3) {
              return (0, n.default)("TSPropertySignature", ...arguments);
            }, t2.tSMethodSignature = t2.tsMethodSignature = function(e3, t3, r3, s2) {
              return (0, n.default)("TSMethodSignature", ...arguments);
            }, t2.tSIndexSignature = t2.tsIndexSignature = function(e3, t3) {
              return (0, n.default)("TSIndexSignature", ...arguments);
            }, t2.tSAnyKeyword = t2.tsAnyKeyword = function() {
              return (0, n.default)("TSAnyKeyword", ...arguments);
            }, t2.tSBooleanKeyword = t2.tsBooleanKeyword = function() {
              return (0, n.default)("TSBooleanKeyword", ...arguments);
            }, t2.tSBigIntKeyword = t2.tsBigIntKeyword = function() {
              return (0, n.default)("TSBigIntKeyword", ...arguments);
            }, t2.tSIntrinsicKeyword = t2.tsIntrinsicKeyword = function() {
              return (0, n.default)("TSIntrinsicKeyword", ...arguments);
            }, t2.tSNeverKeyword = t2.tsNeverKeyword = function() {
              return (0, n.default)("TSNeverKeyword", ...arguments);
            }, t2.tSNullKeyword = t2.tsNullKeyword = function() {
              return (0, n.default)("TSNullKeyword", ...arguments);
            }, t2.tSNumberKeyword = t2.tsNumberKeyword = function() {
              return (0, n.default)("TSNumberKeyword", ...arguments);
            }, t2.tSObjectKeyword = t2.tsObjectKeyword = function() {
              return (0, n.default)("TSObjectKeyword", ...arguments);
            }, t2.tSStringKeyword = t2.tsStringKeyword = function() {
              return (0, n.default)("TSStringKeyword", ...arguments);
            }, t2.tSSymbolKeyword = t2.tsSymbolKeyword = function() {
              return (0, n.default)("TSSymbolKeyword", ...arguments);
            }, t2.tSUndefinedKeyword = t2.tsUndefinedKeyword = function() {
              return (0, n.default)("TSUndefinedKeyword", ...arguments);
            }, t2.tSUnknownKeyword = t2.tsUnknownKeyword = function() {
              return (0, n.default)("TSUnknownKeyword", ...arguments);
            }, t2.tSVoidKeyword = t2.tsVoidKeyword = function() {
              return (0, n.default)("TSVoidKeyword", ...arguments);
            }, t2.tSThisType = t2.tsThisType = function() {
              return (0, n.default)("TSThisType", ...arguments);
            }, t2.tSFunctionType = t2.tsFunctionType = function(e3, t3, r3) {
              return (0, n.default)("TSFunctionType", ...arguments);
            }, t2.tSConstructorType = t2.tsConstructorType = function(e3, t3, r3) {
              return (0, n.default)("TSConstructorType", ...arguments);
            }, t2.tSTypeReference = t2.tsTypeReference = function(e3, t3) {
              return (0, n.default)("TSTypeReference", ...arguments);
            }, t2.tSTypePredicate = t2.tsTypePredicate = function(e3, t3, r3) {
              return (0, n.default)("TSTypePredicate", ...arguments);
            }, t2.tSTypeQuery = t2.tsTypeQuery = function(e3) {
              return (0, n.default)("TSTypeQuery", ...arguments);
            }, t2.tSTypeLiteral = t2.tsTypeLiteral = function(e3) {
              return (0, n.default)("TSTypeLiteral", ...arguments);
            }, t2.tSArrayType = t2.tsArrayType = function(e3) {
              return (0, n.default)("TSArrayType", ...arguments);
            }, t2.tSTupleType = t2.tsTupleType = function(e3) {
              return (0, n.default)("TSTupleType", ...arguments);
            }, t2.tSOptionalType = t2.tsOptionalType = function(e3) {
              return (0, n.default)("TSOptionalType", ...arguments);
            }, t2.tSRestType = t2.tsRestType = function(e3) {
              return (0, n.default)("TSRestType", ...arguments);
            }, t2.tSNamedTupleMember = t2.tsNamedTupleMember = function(e3, t3, r3) {
              return (0, n.default)("TSNamedTupleMember", ...arguments);
            }, t2.tSUnionType = t2.tsUnionType = function(e3) {
              return (0, n.default)("TSUnionType", ...arguments);
            }, t2.tSIntersectionType = t2.tsIntersectionType = function(e3) {
              return (0, n.default)("TSIntersectionType", ...arguments);
            }, t2.tSConditionalType = t2.tsConditionalType = function(e3, t3, r3, s2) {
              return (0, n.default)("TSConditionalType", ...arguments);
            }, t2.tSInferType = t2.tsInferType = function(e3) {
              return (0, n.default)("TSInferType", ...arguments);
            }, t2.tSParenthesizedType = t2.tsParenthesizedType = function(e3) {
              return (0, n.default)("TSParenthesizedType", ...arguments);
            }, t2.tSTypeOperator = t2.tsTypeOperator = function(e3) {
              return (0, n.default)("TSTypeOperator", ...arguments);
            }, t2.tSIndexedAccessType = t2.tsIndexedAccessType = function(e3, t3) {
              return (0, n.default)("TSIndexedAccessType", ...arguments);
            }, t2.tSMappedType = t2.tsMappedType = function(e3, t3, r3) {
              return (0, n.default)("TSMappedType", ...arguments);
            }, t2.tSLiteralType = t2.tsLiteralType = function(e3) {
              return (0, n.default)("TSLiteralType", ...arguments);
            }, t2.tSExpressionWithTypeArguments = t2.tsExpressionWithTypeArguments = function(e3, t3) {
              return (0, n.default)("TSExpressionWithTypeArguments", ...arguments);
            }, t2.tSInterfaceDeclaration = t2.tsInterfaceDeclaration = function(e3, t3, r3, s2) {
              return (0, n.default)("TSInterfaceDeclaration", ...arguments);
            }, t2.tSInterfaceBody = t2.tsInterfaceBody = function(e3) {
              return (0, n.default)("TSInterfaceBody", ...arguments);
            }, t2.tSTypeAliasDeclaration = t2.tsTypeAliasDeclaration = function(e3, t3, r3) {
              return (0, n.default)("TSTypeAliasDeclaration", ...arguments);
            }, t2.tSAsExpression = t2.tsAsExpression = function(e3, t3) {
              return (0, n.default)("TSAsExpression", ...arguments);
            }, t2.tSTypeAssertion = t2.tsTypeAssertion = function(e3, t3) {
              return (0, n.default)("TSTypeAssertion", ...arguments);
            }, t2.tSEnumDeclaration = t2.tsEnumDeclaration = function(e3, t3) {
              return (0, n.default)("TSEnumDeclaration", ...arguments);
            }, t2.tSEnumMember = t2.tsEnumMember = function(e3, t3) {
              return (0, n.default)("TSEnumMember", ...arguments);
            }, t2.tSModuleDeclaration = t2.tsModuleDeclaration = function(e3, t3) {
              return (0, n.default)("TSModuleDeclaration", ...arguments);
            }, t2.tSModuleBlock = t2.tsModuleBlock = function(e3) {
              return (0, n.default)("TSModuleBlock", ...arguments);
            }, t2.tSImportType = t2.tsImportType = function(e3, t3, r3) {
              return (0, n.default)("TSImportType", ...arguments);
            }, t2.tSImportEqualsDeclaration = t2.tsImportEqualsDeclaration = function(e3, t3) {
              return (0, n.default)("TSImportEqualsDeclaration", ...arguments);
            }, t2.tSExternalModuleReference = t2.tsExternalModuleReference = function(e3) {
              return (0, n.default)("TSExternalModuleReference", ...arguments);
            }, t2.tSNonNullExpression = t2.tsNonNullExpression = function(e3) {
              return (0, n.default)("TSNonNullExpression", ...arguments);
            }, t2.tSExportAssignment = t2.tsExportAssignment = function(e3) {
              return (0, n.default)("TSExportAssignment", ...arguments);
            }, t2.tSNamespaceExportDeclaration = t2.tsNamespaceExportDeclaration = function(e3) {
              return (0, n.default)("TSNamespaceExportDeclaration", ...arguments);
            }, t2.tSTypeAnnotation = t2.tsTypeAnnotation = function(e3) {
              return (0, n.default)("TSTypeAnnotation", ...arguments);
            }, t2.tSTypeParameterInstantiation = t2.tsTypeParameterInstantiation = function(e3) {
              return (0, n.default)("TSTypeParameterInstantiation", ...arguments);
            }, t2.tSTypeParameterDeclaration = t2.tsTypeParameterDeclaration = function(e3) {
              return (0, n.default)("TSTypeParameterDeclaration", ...arguments);
            }, t2.tSTypeParameter = t2.tsTypeParameter = function(e3, t3, r3) {
              return (0, n.default)("TSTypeParameter", ...arguments);
            }, t2.numberLiteral = function(...e3) {
              return (0, n.default)("NumberLiteral", ...e3);
            }, t2.regexLiteral = function(...e3) {
              return (0, n.default)("RegexLiteral", ...e3);
            }, t2.restProperty = function(...e3) {
              return (0, n.default)("RestProperty", ...e3);
            }, t2.spreadProperty = function(...e3) {
              return (0, n.default)("SpreadProperty", ...e3);
            };
            var n = r2(367);
          }, (e2) => {
            var t2, r2, n = e2.exports = {};
            function s2() {
              throw new Error("setTimeout has not been defined");
            }
            function i() {
              throw new Error("clearTimeout has not been defined");
            }
            function o(e3) {
              if (t2 === setTimeout)
                return setTimeout(e3, 0);
              if ((t2 === s2 || !t2) && setTimeout)
                return t2 = setTimeout, setTimeout(e3, 0);
              try {
                return t2(e3, 0);
              } catch (r3) {
                try {
                  return t2.call(null, e3, 0);
                } catch (r4) {
                  return t2.call(this, e3, 0);
                }
              }
            }
            !function() {
              try {
                t2 = typeof setTimeout == "function" ? setTimeout : s2;
              } catch (e3) {
                t2 = s2;
              }
              try {
                r2 = typeof clearTimeout == "function" ? clearTimeout : i;
              } catch (e3) {
                r2 = i;
              }
            }();
            var a, l = [], c = false, u = -1;
            function p2() {
              c && a && (c = false, a.length ? l = a.concat(l) : u = -1, l.length && f());
            }
            function f() {
              if (!c) {
                var e3 = o(p2);
                c = true;
                for (var t3 = l.length; t3; ) {
                  for (a = l, l = []; ++u < t3; )
                    a && a[u].run();
                  u = -1, t3 = l.length;
                }
                a = null, c = false, function(e4) {
                  if (r2 === clearTimeout)
                    return clearTimeout(e4);
                  if ((r2 === i || !r2) && clearTimeout)
                    return r2 = clearTimeout, clearTimeout(e4);
                  try {
                    r2(e4);
                  } catch (t4) {
                    try {
                      return r2.call(null, e4);
                    } catch (t5) {
                      return r2.call(this, e4);
                    }
                  }
                }(e3);
              }
            }
            function d(e3, t3) {
              this.fun = e3, this.array = t3;
            }
            function h3() {
            }
            n.nextTick = function(e3) {
              var t3 = new Array(arguments.length - 1);
              if (arguments.length > 1)
                for (var r3 = 1; r3 < arguments.length; r3++)
                  t3[r3 - 1] = arguments[r3];
              l.push(new d(e3, t3)), l.length !== 1 || c || o(f);
            }, d.prototype.run = function() {
              this.fun.apply(null, this.array);
            }, n.title = "browser", n.browser = true, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = h3, n.addListener = h3, n.once = h3, n.off = h3, n.removeListener = h3, n.removeAllListeners = h3, n.emit = h3, n.prependListener = h3, n.prependOnceListener = h3, n.listeners = function(e3) {
              return [];
            }, n.binding = function(e3) {
              throw new Error("process.binding is not supported");
            }, n.cwd = function() {
              return "/";
            }, n.chdir = function(e3) {
              throw new Error("process.chdir is not supported");
            }, n.umask = function() {
              return 0;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7);
            function s2(e3) {
              if (typeof e3 != "string")
                throw new TypeError("Path must be a string. Received " + JSON.stringify(e3));
            }
            function i(e3, t3) {
              for (var r3, n2 = "", s3 = 0, i2 = -1, o2 = 0, a = 0; a <= e3.length; ++a) {
                if (a < e3.length)
                  r3 = e3.charCodeAt(a);
                else {
                  if (r3 === 47)
                    break;
                  r3 = 47;
                }
                if (r3 === 47) {
                  if (i2 === a - 1 || o2 === 1)
                    ;
                  else if (i2 !== a - 1 && o2 === 2) {
                    if (n2.length < 2 || s3 !== 2 || n2.charCodeAt(n2.length - 1) !== 46 || n2.charCodeAt(n2.length - 2) !== 46) {
                      if (n2.length > 2) {
                        var l = n2.lastIndexOf("/");
                        if (l !== n2.length - 1) {
                          l === -1 ? (n2 = "", s3 = 0) : s3 = (n2 = n2.slice(0, l)).length - 1 - n2.lastIndexOf("/"), i2 = a, o2 = 0;
                          continue;
                        }
                      } else if (n2.length === 2 || n2.length === 1) {
                        n2 = "", s3 = 0, i2 = a, o2 = 0;
                        continue;
                      }
                    }
                    t3 && (n2.length > 0 ? n2 += "/.." : n2 = "..", s3 = 2);
                  } else
                    n2.length > 0 ? n2 += "/" + e3.slice(i2 + 1, a) : n2 = e3.slice(i2 + 1, a), s3 = a - i2 - 1;
                  i2 = a, o2 = 0;
                } else
                  r3 === 46 && o2 !== -1 ? ++o2 : o2 = -1;
              }
              return n2;
            }
            var o = { resolve: function() {
              for (var e3, t3 = "", r3 = false, o2 = arguments.length - 1; o2 >= -1 && !r3; o2--) {
                var a;
                o2 >= 0 ? a = arguments[o2] : (e3 === void 0 && (e3 = n.cwd()), a = e3), s2(a), a.length !== 0 && (t3 = a + "/" + t3, r3 = a.charCodeAt(0) === 47);
              }
              return t3 = i(t3, !r3), r3 ? t3.length > 0 ? "/" + t3 : "/" : t3.length > 0 ? t3 : ".";
            }, normalize: function(e3) {
              if (s2(e3), e3.length === 0)
                return ".";
              var t3 = e3.charCodeAt(0) === 47, r3 = e3.charCodeAt(e3.length - 1) === 47;
              return (e3 = i(e3, !t3)).length !== 0 || t3 || (e3 = "."), e3.length > 0 && r3 && (e3 += "/"), t3 ? "/" + e3 : e3;
            }, isAbsolute: function(e3) {
              return s2(e3), e3.length > 0 && e3.charCodeAt(0) === 47;
            }, join: function() {
              if (arguments.length === 0)
                return ".";
              for (var e3, t3 = 0; t3 < arguments.length; ++t3) {
                var r3 = arguments[t3];
                s2(r3), r3.length > 0 && (e3 === void 0 ? e3 = r3 : e3 += "/" + r3);
              }
              return e3 === void 0 ? "." : o.normalize(e3);
            }, relative: function(e3, t3) {
              if (s2(e3), s2(t3), e3 === t3)
                return "";
              if ((e3 = o.resolve(e3)) === (t3 = o.resolve(t3)))
                return "";
              for (var r3 = 1; r3 < e3.length && e3.charCodeAt(r3) === 47; ++r3)
                ;
              for (var n2 = e3.length, i2 = n2 - r3, a = 1; a < t3.length && t3.charCodeAt(a) === 47; ++a)
                ;
              for (var l = t3.length - a, c = i2 < l ? i2 : l, u = -1, p2 = 0; p2 <= c; ++p2) {
                if (p2 === c) {
                  if (l > c) {
                    if (t3.charCodeAt(a + p2) === 47)
                      return t3.slice(a + p2 + 1);
                    if (p2 === 0)
                      return t3.slice(a + p2);
                  } else
                    i2 > c && (e3.charCodeAt(r3 + p2) === 47 ? u = p2 : p2 === 0 && (u = 0));
                  break;
                }
                var f = e3.charCodeAt(r3 + p2);
                if (f !== t3.charCodeAt(a + p2))
                  break;
                f === 47 && (u = p2);
              }
              var d = "";
              for (p2 = r3 + u + 1; p2 <= n2; ++p2)
                p2 !== n2 && e3.charCodeAt(p2) !== 47 || (d.length === 0 ? d += ".." : d += "/..");
              return d.length > 0 ? d + t3.slice(a + u) : (a += u, t3.charCodeAt(a) === 47 && ++a, t3.slice(a));
            }, _makeLong: function(e3) {
              return e3;
            }, dirname: function(e3) {
              if (s2(e3), e3.length === 0)
                return ".";
              for (var t3 = e3.charCodeAt(0), r3 = t3 === 47, n2 = -1, i2 = true, o2 = e3.length - 1; o2 >= 1; --o2)
                if ((t3 = e3.charCodeAt(o2)) === 47) {
                  if (!i2) {
                    n2 = o2;
                    break;
                  }
                } else
                  i2 = false;
              return n2 === -1 ? r3 ? "/" : "." : r3 && n2 === 1 ? "//" : e3.slice(0, n2);
            }, basename: function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "string")
                throw new TypeError('"ext" argument must be a string');
              s2(e3);
              var r3, n2 = 0, i2 = -1, o2 = true;
              if (t3 !== void 0 && t3.length > 0 && t3.length <= e3.length) {
                if (t3.length === e3.length && t3 === e3)
                  return "";
                var a = t3.length - 1, l = -1;
                for (r3 = e3.length - 1; r3 >= 0; --r3) {
                  var c = e3.charCodeAt(r3);
                  if (c === 47) {
                    if (!o2) {
                      n2 = r3 + 1;
                      break;
                    }
                  } else
                    l === -1 && (o2 = false, l = r3 + 1), a >= 0 && (c === t3.charCodeAt(a) ? --a == -1 && (i2 = r3) : (a = -1, i2 = l));
                }
                return n2 === i2 ? i2 = l : i2 === -1 && (i2 = e3.length), e3.slice(n2, i2);
              }
              for (r3 = e3.length - 1; r3 >= 0; --r3)
                if (e3.charCodeAt(r3) === 47) {
                  if (!o2) {
                    n2 = r3 + 1;
                    break;
                  }
                } else
                  i2 === -1 && (o2 = false, i2 = r3 + 1);
              return i2 === -1 ? "" : e3.slice(n2, i2);
            }, extname: function(e3) {
              s2(e3);
              for (var t3 = -1, r3 = 0, n2 = -1, i2 = true, o2 = 0, a = e3.length - 1; a >= 0; --a) {
                var l = e3.charCodeAt(a);
                if (l !== 47)
                  n2 === -1 && (i2 = false, n2 = a + 1), l === 46 ? t3 === -1 ? t3 = a : o2 !== 1 && (o2 = 1) : t3 !== -1 && (o2 = -1);
                else if (!i2) {
                  r3 = a + 1;
                  break;
                }
              }
              return t3 === -1 || n2 === -1 || o2 === 0 || o2 === 1 && t3 === n2 - 1 && t3 === r3 + 1 ? "" : e3.slice(t3, n2);
            }, format: function(e3) {
              if (e3 === null || typeof e3 != "object")
                throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof e3);
              return function(e4, t3) {
                var r3 = t3.dir || t3.root, n2 = t3.base || (t3.name || "") + (t3.ext || "");
                return r3 ? r3 === t3.root ? r3 + n2 : r3 + "/" + n2 : n2;
              }(0, e3);
            }, parse: function(e3) {
              s2(e3);
              var t3 = { root: "", dir: "", base: "", ext: "", name: "" };
              if (e3.length === 0)
                return t3;
              var r3, n2 = e3.charCodeAt(0), i2 = n2 === 47;
              i2 ? (t3.root = "/", r3 = 1) : r3 = 0;
              for (var o2 = -1, a = 0, l = -1, c = true, u = e3.length - 1, p2 = 0; u >= r3; --u)
                if ((n2 = e3.charCodeAt(u)) !== 47)
                  l === -1 && (c = false, l = u + 1), n2 === 46 ? o2 === -1 ? o2 = u : p2 !== 1 && (p2 = 1) : o2 !== -1 && (p2 = -1);
                else if (!c) {
                  a = u + 1;
                  break;
                }
              return o2 === -1 || l === -1 || p2 === 0 || p2 === 1 && o2 === l - 1 && o2 === a + 1 ? l !== -1 && (t3.base = t3.name = a === 0 && i2 ? e3.slice(1, l) : e3.slice(a, l)) : (a === 0 && i2 ? (t3.name = e3.slice(1, o2), t3.base = e3.slice(1, l)) : (t3.name = e3.slice(a, o2), t3.base = e3.slice(a, l)), t3.ext = e3.slice(o2, l)), a > 0 ? t3.dir = e3.slice(0, a - 1) : i2 && (t3.dir = "/"), t3;
            }, sep: "/", delimiter: ":", win32: null, posix: null };
            o.posix = o, e2.exports = o;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Plugin = function(e3) {
              throw new Error(`The (${e3}) Babel 5 plugin is being run with an unsupported Babel version.`);
            }, Object.defineProperty(t2, "File", { enumerable: true, get: function() {
              return n.default;
            } }), Object.defineProperty(t2, "buildExternalHelpers", { enumerable: true, get: function() {
              return s2.default;
            } }), Object.defineProperty(t2, "resolvePlugin", { enumerable: true, get: function() {
              return i.resolvePlugin;
            } }), Object.defineProperty(t2, "resolvePreset", { enumerable: true, get: function() {
              return i.resolvePreset;
            } }), Object.defineProperty(t2, "getEnv", { enumerable: true, get: function() {
              return o.getEnv;
            } }), Object.defineProperty(t2, "tokTypes", { enumerable: true, get: function() {
              return l().tokTypes;
            } }), Object.defineProperty(t2, "traverse", { enumerable: true, get: function() {
              return c().default;
            } }), Object.defineProperty(t2, "template", { enumerable: true, get: function() {
              return u().default;
            } }), Object.defineProperty(t2, "createConfigItem", { enumerable: true, get: function() {
              return p2.createConfigItem;
            } }), Object.defineProperty(t2, "createConfigItemSync", { enumerable: true, get: function() {
              return p2.createConfigItemSync;
            } }), Object.defineProperty(t2, "createConfigItemAsync", { enumerable: true, get: function() {
              return p2.createConfigItemAsync;
            } }), Object.defineProperty(t2, "loadPartialConfig", { enumerable: true, get: function() {
              return p2.loadPartialConfig;
            } }), Object.defineProperty(t2, "loadPartialConfigSync", { enumerable: true, get: function() {
              return p2.loadPartialConfigSync;
            } }), Object.defineProperty(t2, "loadPartialConfigAsync", { enumerable: true, get: function() {
              return p2.loadPartialConfigAsync;
            } }), Object.defineProperty(t2, "loadOptions", { enumerable: true, get: function() {
              return p2.loadOptions;
            } }), Object.defineProperty(t2, "loadOptionsSync", { enumerable: true, get: function() {
              return p2.loadOptionsSync;
            } }), Object.defineProperty(t2, "loadOptionsAsync", { enumerable: true, get: function() {
              return p2.loadOptionsAsync;
            } }), Object.defineProperty(t2, "transform", { enumerable: true, get: function() {
              return f.transform;
            } }), Object.defineProperty(t2, "transformSync", { enumerable: true, get: function() {
              return f.transformSync;
            } }), Object.defineProperty(t2, "transformAsync", { enumerable: true, get: function() {
              return f.transformAsync;
            } }), Object.defineProperty(t2, "transformFile", { enumerable: true, get: function() {
              return d.transformFile;
            } }), Object.defineProperty(t2, "transformFileSync", { enumerable: true, get: function() {
              return d.transformFileSync;
            } }), Object.defineProperty(t2, "transformFileAsync", { enumerable: true, get: function() {
              return d.transformFileAsync;
            } }), Object.defineProperty(t2, "transformFromAst", { enumerable: true, get: function() {
              return h3.transformFromAst;
            } }), Object.defineProperty(t2, "transformFromAstSync", { enumerable: true, get: function() {
              return h3.transformFromAstSync;
            } }), Object.defineProperty(t2, "transformFromAstAsync", { enumerable: true, get: function() {
              return h3.transformFromAstAsync;
            } }), Object.defineProperty(t2, "parse", { enumerable: true, get: function() {
              return m.parse;
            } }), Object.defineProperty(t2, "parseSync", { enumerable: true, get: function() {
              return m.parseSync;
            } }), Object.defineProperty(t2, "parseAsync", { enumerable: true, get: function() {
              return m.parseAsync;
            } }), t2.types = t2.OptionManager = t2.DEFAULT_EXTENSIONS = t2.version = void 0;
            var n = r2(126), s2 = r2(465), i = r2(77), o = r2(286);
            function a() {
              const e3 = r2(0);
              return a = function() {
                return e3;
              }, e3;
            }
            function l() {
              const e3 = r2(27);
              return l = function() {
                return e3;
              }, e3;
            }
            function c() {
              const e3 = r2(10);
              return c = function() {
                return e3;
              }, e3;
            }
            function u() {
              const e3 = r2(21);
              return u = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "types", { enumerable: true, get: function() {
              return a();
            } });
            var p2 = r2(78), f = r2(486), d = r2(498), h3 = r2(499), m = r2(500);
            t2.version = "7.14.6";
            const y = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
            t2.DEFAULT_EXTENSIONS = y, t2.OptionManager = class {
              init(e3) {
                return (0, p2.loadOptions)(e3);
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "NodePath", { enumerable: true, get: function() {
              return a.default;
            } }), Object.defineProperty(t2, "Scope", { enumerable: true, get: function() {
              return l.default;
            } }), Object.defineProperty(t2, "Hub", { enumerable: true, get: function() {
              return c.default;
            } }), t2.visitors = t2.default = void 0;
            var n = r2(362), s2 = r2(455);
            t2.visitors = s2;
            var i = r2(0), o = r2(34), a = r2(19), l = r2(231), c = r2(456);
            function u(e3, t3 = {}, r3, n2, o2) {
              if (e3) {
                if (!t3.noScope && !r3 && e3.type !== "Program" && e3.type !== "File")
                  throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${e3.type} node without passing scope and parentPath.`);
                i.VISITOR_KEYS[e3.type] && (s2.explode(t3), u.node(e3, t3, r3, n2, o2));
              }
            }
            var p2 = u;
            function f(e3, t3) {
              e3.node.type === t3.type && (t3.has = true, e3.stop());
            }
            t2.default = p2, u.visitors = s2, u.verify = s2.verify, u.explode = s2.explode, u.cheap = function(e3, t3) {
              return i.traverseFast(e3, t3);
            }, u.node = function(e3, t3, r3, s3, o2, a2) {
              const l2 = i.VISITOR_KEYS[e3.type];
              if (!l2)
                return;
              const c4 = new n.default(r3, t3, s3, o2);
              for (const t4 of l2)
                if ((!a2 || !a2[t4]) && c4.visit(e3, t4))
                  return;
            }, u.clearNode = function(e3, t3) {
              i.removeProperties(e3, t3), o.path.delete(e3);
            }, u.removeProperties = function(e3, t3) {
              return i.traverseFast(e3, u.clearNode, t3), e3;
            }, u.hasType = function(e3, t3, r3) {
              if (r3 != null && r3.includes(e3.type))
                return false;
              if (e3.type === t3)
                return true;
              const n2 = { has: false, type: t3 };
              return u(e3, { noScope: true, denylist: r3, enter: f }, null, n2), n2.has;
            }, u.cache = o;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "VISITOR_KEYS", { enumerable: true, get: function() {
              return s2.VISITOR_KEYS;
            } }), Object.defineProperty(t2, "ALIAS_KEYS", { enumerable: true, get: function() {
              return s2.ALIAS_KEYS;
            } }), Object.defineProperty(t2, "FLIPPED_ALIAS_KEYS", { enumerable: true, get: function() {
              return s2.FLIPPED_ALIAS_KEYS;
            } }), Object.defineProperty(t2, "NODE_FIELDS", { enumerable: true, get: function() {
              return s2.NODE_FIELDS;
            } }), Object.defineProperty(t2, "BUILDER_KEYS", { enumerable: true, get: function() {
              return s2.BUILDER_KEYS;
            } }), Object.defineProperty(t2, "DEPRECATED_KEYS", { enumerable: true, get: function() {
              return s2.DEPRECATED_KEYS;
            } }), Object.defineProperty(t2, "NODE_PARENT_VALIDATIONS", { enumerable: true, get: function() {
              return s2.NODE_PARENT_VALIDATIONS;
            } }), Object.defineProperty(t2, "PLACEHOLDERS", { enumerable: true, get: function() {
              return i.PLACEHOLDERS;
            } }), Object.defineProperty(t2, "PLACEHOLDERS_ALIAS", { enumerable: true, get: function() {
              return i.PLACEHOLDERS_ALIAS;
            } }), Object.defineProperty(t2, "PLACEHOLDERS_FLIPPED_ALIAS", { enumerable: true, get: function() {
              return i.PLACEHOLDERS_FLIPPED_ALIAS;
            } }), t2.TYPES = void 0;
            var n = r2(215);
            r2(128), r2(370), r2(371), r2(372), r2(373), r2(374);
            var s2 = r2(20), i = r2(217);
            n(s2.VISITOR_KEYS), n(s2.ALIAS_KEYS), n(s2.FLIPPED_ALIAS_KEYS), n(s2.NODE_FIELDS), n(s2.BUILDER_KEYS), n(s2.DEPRECATED_KEYS), n(i.PLACEHOLDERS_ALIAS), n(i.PLACEHOLDERS_FLIPPED_ALIAS);
            const o = Object.keys(s2.VISITOR_KEYS).concat(Object.keys(s2.FLIPPED_ALIAS_KEYS)).concat(Object.keys(s2.DEPRECATED_KEYS));
            t2.TYPES = o;
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3, r3) => new n(e3, r3).compare(new n(t3, r3));
          }, (e2, t2, r2) => {
            class n {
              constructor(e3, t3) {
                if (t3 = i(t3), e3 instanceof n)
                  return e3.loose === !!t3.loose && e3.includePrerelease === !!t3.includePrerelease ? e3 : new n(e3.raw, t3);
                if (e3 instanceof o)
                  return this.raw = e3.value, this.set = [[e3]], this.format(), this;
                if (this.options = t3, this.loose = !!t3.loose, this.includePrerelease = !!t3.includePrerelease, this.raw = e3, this.set = e3.split(/\s*\|\|\s*/).map((e4) => this.parseRange(e4.trim())).filter((e4) => e4.length), !this.set.length)
                  throw new TypeError(`Invalid SemVer Range: ${e3}`);
                if (this.set.length > 1) {
                  const e4 = this.set[0];
                  if (this.set = this.set.filter((e5) => !h3(e5[0])), this.set.length === 0)
                    this.set = [e4];
                  else if (this.set.length > 1) {
                    for (const e5 of this.set)
                      if (e5.length === 1 && m(e5[0])) {
                        this.set = [e5];
                        break;
                      }
                  }
                }
                this.format();
              }
              format() {
                return this.range = this.set.map((e3) => e3.join(" ").trim()).join("||").trim(), this.range;
              }
              toString() {
                return this.range;
              }
              parseRange(e3) {
                e3 = e3.trim();
                const t3 = `parseRange:${Object.keys(this.options).join(",")}:${e3}`, r3 = s2.get(t3);
                if (r3)
                  return r3;
                const n2 = this.options.loose, i2 = n2 ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
                e3 = e3.replace(i2, O(this.options.includePrerelease)), a("hyphen replace", e3), e3 = e3.replace(c[u.COMPARATORTRIM], p2), a("comparator trim", e3, c[u.COMPARATORTRIM]), e3 = (e3 = (e3 = e3.replace(c[u.TILDETRIM], f)).replace(c[u.CARETTRIM], d)).split(/\s+/).join(" ");
                const l2 = n2 ? c[u.COMPARATORLOOSE] : c[u.COMPARATOR], m2 = e3.split(" ").map((e4) => g(e4, this.options)).join(" ").split(/\s+/).map((e4) => A(e4, this.options)).filter(this.options.loose ? (e4) => !!e4.match(l2) : () => true).map((e4) => new o(e4, this.options)), y2 = (m2.length, new Map());
                for (const e4 of m2) {
                  if (h3(e4))
                    return [e4];
                  y2.set(e4.value, e4);
                }
                y2.size > 1 && y2.has("") && y2.delete("");
                const b2 = [...y2.values()];
                return s2.set(t3, b2), b2;
              }
              intersects(e3, t3) {
                if (!(e3 instanceof n))
                  throw new TypeError("a Range is required");
                return this.set.some((r3) => y(r3, t3) && e3.set.some((e4) => y(e4, t3) && r3.every((r4) => e4.every((e5) => r4.intersects(e5, t3)))));
              }
              test(e3) {
                if (!e3)
                  return false;
                if (typeof e3 == "string")
                  try {
                    e3 = new l(e3, this.options);
                  } catch (e4) {
                    return false;
                  }
                for (let t3 = 0; t3 < this.set.length; t3++)
                  if (C(this.set[t3], e3, this.options))
                    return true;
                return false;
              }
            }
            e2.exports = n;
            const s2 = new (r2(149))({ max: 1e3 }), i = r2(43), o = r2(45), a = r2(42), l = r2(3), { re: c, t: u, comparatorTrimReplace: p2, tildeTrimReplace: f, caretTrimReplace: d } = r2(23), h3 = (e3) => e3.value === "<0.0.0-0", m = (e3) => e3.value === "", y = (e3, t3) => {
              let r3 = true;
              const n2 = e3.slice();
              let s3 = n2.pop();
              for (; r3 && n2.length; )
                r3 = n2.every((e4) => s3.intersects(e4, t3)), s3 = n2.pop();
              return r3;
            }, g = (e3, t3) => (a("comp", e3, t3), e3 = x(e3, t3), a("caret", e3), e3 = v(e3, t3), a("tildes", e3), e3 = T(e3, t3), a("xrange", e3), e3 = P(e3, t3), a("stars", e3), e3), b = (e3) => !e3 || e3.toLowerCase() === "x" || e3 === "*", v = (e3, t3) => e3.trim().split(/\s+/).map((e4) => E(e4, t3)).join(" "), E = (e3, t3) => {
              const r3 = t3.loose ? c[u.TILDELOOSE] : c[u.TILDE];
              return e3.replace(r3, (t4, r4, n2, s3, i2) => {
                let o2;
                return a("tilde", e3, t4, r4, n2, s3, i2), b(r4) ? o2 = "" : b(n2) ? o2 = `>=${r4}.0.0 <${+r4 + 1}.0.0-0` : b(s3) ? o2 = `>=${r4}.${n2}.0 <${r4}.${+n2 + 1}.0-0` : i2 ? (a("replaceTilde pr", i2), o2 = `>=${r4}.${n2}.${s3}-${i2} <${r4}.${+n2 + 1}.0-0`) : o2 = `>=${r4}.${n2}.${s3} <${r4}.${+n2 + 1}.0-0`, a("tilde return", o2), o2;
              });
            }, x = (e3, t3) => e3.trim().split(/\s+/).map((e4) => S(e4, t3)).join(" "), S = (e3, t3) => {
              a("caret", e3, t3);
              const r3 = t3.loose ? c[u.CARETLOOSE] : c[u.CARET], n2 = t3.includePrerelease ? "-0" : "";
              return e3.replace(r3, (t4, r4, s3, i2, o2) => {
                let l2;
                return a("caret", e3, t4, r4, s3, i2, o2), b(r4) ? l2 = "" : b(s3) ? l2 = `>=${r4}.0.0${n2} <${+r4 + 1}.0.0-0` : b(i2) ? l2 = r4 === "0" ? `>=${r4}.${s3}.0${n2} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.0${n2} <${+r4 + 1}.0.0-0` : o2 ? (a("replaceCaret pr", o2), l2 = r4 === "0" ? s3 === "0" ? `>=${r4}.${s3}.${i2}-${o2} <${r4}.${s3}.${+i2 + 1}-0` : `>=${r4}.${s3}.${i2}-${o2} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i2}-${o2} <${+r4 + 1}.0.0-0`) : (a("no pr"), l2 = r4 === "0" ? s3 === "0" ? `>=${r4}.${s3}.${i2}${n2} <${r4}.${s3}.${+i2 + 1}-0` : `>=${r4}.${s3}.${i2}${n2} <${r4}.${+s3 + 1}.0-0` : `>=${r4}.${s3}.${i2} <${+r4 + 1}.0.0-0`), a("caret return", l2), l2;
              });
            }, T = (e3, t3) => (a("replaceXRanges", e3, t3), e3.split(/\s+/).map((e4) => w(e4, t3)).join(" ")), w = (e3, t3) => {
              e3 = e3.trim();
              const r3 = t3.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
              return e3.replace(r3, (r4, n2, s3, i2, o2, l2) => {
                a("xRange", e3, r4, n2, s3, i2, o2, l2);
                const c4 = b(s3), u2 = c4 || b(i2), p3 = u2 || b(o2), f2 = p3;
                return n2 === "=" && f2 && (n2 = ""), l2 = t3.includePrerelease ? "-0" : "", c4 ? r4 = n2 === ">" || n2 === "<" ? "<0.0.0-0" : "*" : n2 && f2 ? (u2 && (i2 = 0), o2 = 0, n2 === ">" ? (n2 = ">=", u2 ? (s3 = +s3 + 1, i2 = 0, o2 = 0) : (i2 = +i2 + 1, o2 = 0)) : n2 === "<=" && (n2 = "<", u2 ? s3 = +s3 + 1 : i2 = +i2 + 1), n2 === "<" && (l2 = "-0"), r4 = `${n2 + s3}.${i2}.${o2}${l2}`) : u2 ? r4 = `>=${s3}.0.0${l2} <${+s3 + 1}.0.0-0` : p3 && (r4 = `>=${s3}.${i2}.0${l2} <${s3}.${+i2 + 1}.0-0`), a("xRange return", r4), r4;
              });
            }, P = (e3, t3) => (a("replaceStars", e3, t3), e3.trim().replace(c[u.STAR], "")), A = (e3, t3) => (a("replaceGTE0", e3, t3), e3.trim().replace(c[t3.includePrerelease ? u.GTE0PRE : u.GTE0], "")), O = (e3) => (t3, r3, n2, s3, i2, o2, a2, l2, c4, u2, p3, f2, d2) => `${r3 = b(n2) ? "" : b(s3) ? `>=${n2}.0.0${e3 ? "-0" : ""}` : b(i2) ? `>=${n2}.${s3}.0${e3 ? "-0" : ""}` : o2 ? `>=${r3}` : `>=${r3}${e3 ? "-0" : ""}`} ${l2 = b(c4) ? "" : b(u2) ? `<${+c4 + 1}.0.0-0` : b(p3) ? `<${c4}.${+u2 + 1}.0-0` : f2 ? `<=${c4}.${u2}.${p3}-${f2}` : e3 ? `<${c4}.${u2}.${+p3 + 1}-0` : `<=${l2}`}`.trim(), C = (e3, t3, r3) => {
              for (let r4 = 0; r4 < e3.length; r4++)
                if (!e3[r4].test(t3))
                  return false;
              if (t3.prerelease.length && !r3.includePrerelease) {
                for (let r4 = 0; r4 < e3.length; r4++)
                  if (a(e3[r4].semver), e3[r4].semver !== o.ANY && e3[r4].semver.prerelease.length > 0) {
                    const n2 = e3[r4].semver;
                    if (n2.major === t3.major && n2.minor === t3.minor && n2.patch === t3.patch)
                      return true;
                  }
                return false;
              }
              return true;
            };
          }, (e2) => {
            "use strict";
            const t2 = Symbol.for("gensync:v1:start"), r2 = Symbol.for("gensync:v1:suspend"), n = "GENSYNC_OPTIONS_ERROR", s2 = "GENSYNC_RACE_NONEMPTY";
            function i(e3, t3, r3, s3) {
              if (typeof r3 === e3 || s3 && r3 === void 0)
                return;
              let i2;
              throw i2 = s3 ? `Expected opts.${t3} to be either a ${e3}, or undefined.` : `Expected opts.${t3} to be a ${e3}.`, o(i2, n);
            }
            function o(e3, t3) {
              return Object.assign(new Error(e3), { code: t3 });
            }
            function a({ name: e3, arity: n2, sync: s3, async: i2 }) {
              return d(e3, n2, function* (...e4) {
                const n3 = yield t2;
                if (!n3)
                  return s3.call(this, e4);
                let o2;
                try {
                  i2.call(this, e4, (e5) => {
                    o2 || (o2 = { value: e5 }, n3());
                  }, (e5) => {
                    o2 || (o2 = { err: e5 }, n3());
                  });
                } catch (e5) {
                  o2 = { err: e5 }, n3();
                }
                if (yield r2, o2.hasOwnProperty("err"))
                  throw o2.err;
                return o2.value;
              });
            }
            function l(e3) {
              let t3;
              for (; !({ value: t3 } = e3.next()).done; )
                u(t3, e3);
              return t3;
            }
            function c(e3, t3, r3) {
              !function n2() {
                try {
                  let r4;
                  for (; !({ value: r4 } = e3.next()).done; ) {
                    u(r4, e3);
                    let t4 = true, s3 = false;
                    const i2 = e3.next(() => {
                      t4 ? s3 = true : n2();
                    });
                    if (t4 = false, p2(i2, e3), !s3)
                      return;
                  }
                  return t3(r4);
                } catch (e4) {
                  return r3(e4);
                }
              }();
            }
            function u(e3, r3) {
              e3 !== t2 && f(r3, o(`Got unexpected yielded value in gensync generator: ${JSON.stringify(e3)}. Did you perhaps mean to use 'yield*' instead of 'yield'?`, "GENSYNC_EXPECTED_START"));
            }
            function p2({ value: e3, done: t3 }, n2) {
              (t3 || e3 !== r2) && f(n2, o(t3 ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(e3)}. If you get this, it is probably a gensync bug.`, "GENSYNC_EXPECTED_SUSPEND"));
            }
            function f(e3, t3) {
              throw e3.throw && e3.throw(t3), t3;
            }
            function d(e3, t3, r3) {
              if (typeof e3 == "string") {
                const t4 = Object.getOwnPropertyDescriptor(r3, "name");
                t4 && !t4.configurable || Object.defineProperty(r3, "name", Object.assign(t4 || {}, { configurable: true, value: e3 }));
              }
              if (typeof t3 == "number") {
                const e4 = Object.getOwnPropertyDescriptor(r3, "length");
                e4 && !e4.configurable || Object.defineProperty(r3, "length", Object.assign(e4 || {}, { configurable: true, value: t3 }));
              }
              return r3;
            }
            e2.exports = Object.assign(function(e3) {
              let t3 = e3;
              return t3 = typeof e3 != "function" ? function({ name: e4, arity: t4, sync: r3, async: s3, errback: l2 }) {
                if (i("string", "name", e4, true), i("number", "arity", t4, true), i("function", "sync", r3), i("function", "async", s3, true), i("function", "errback", l2, true), s3 && l2)
                  throw o("Expected one of either opts.async or opts.errback, but got _both_.", n);
                if (typeof e4 != "string") {
                  let t5;
                  l2 && l2.name && l2.name !== "errback" && (t5 = l2.name), s3 && s3.name && s3.name !== "async" && (t5 = s3.name.replace(/Async$/, "")), r3 && r3.name && r3.name !== "sync" && (t5 = r3.name.replace(/Sync$/, "")), typeof t5 == "string" && (e4 = t5);
                }
                return typeof t4 != "number" && (t4 = r3.length), a({ name: e4, arity: t4, sync: function(e5) {
                  return r3.apply(this, e5);
                }, async: function(e5, t5, n2) {
                  s3 ? s3.apply(this, e5).then(t5, n2) : l2 ? l2.call(this, ...e5, (e6, r4) => {
                    e6 == null ? t5(r4) : n2(e6);
                  }) : t5(r3.apply(this, e5));
                } });
              }(e3) : function(e4) {
                return d(e4.name, e4.length, function(...t4) {
                  return e4.apply(this, t4);
                });
              }(e3), Object.assign(t3, function(e4) {
                return { sync: function(...t4) {
                  return l(e4.apply(this, t4));
                }, async: function(...t4) {
                  return new Promise((r3, n2) => {
                    c(e4.apply(this, t4), r3, n2);
                  });
                }, errback: function(...t4) {
                  const r3 = t4.pop();
                  if (typeof r3 != "function")
                    throw o("Asynchronous function called without callback", "GENSYNC_ERRBACK_NO_CALLBACK");
                  let n2;
                  try {
                    n2 = e4.apply(this, t4);
                  } catch (e5) {
                    return void r3(e5);
                  }
                  c(n2, (e5) => r3(void 0, e5), (e5) => r3(e5));
                } };
              }(t3));
            }, { all: a({ name: "all", arity: 1, sync: function(e3) {
              return Array.from(e3[0]).map((e4) => l(e4));
            }, async: function(e3, t3, r3) {
              const n2 = Array.from(e3[0]);
              if (n2.length === 0)
                return void Promise.resolve().then(() => t3([]));
              let s3 = 0;
              const i2 = n2.map(() => {
              });
              n2.forEach((e4, n3) => {
                c(e4, (e5) => {
                  i2[n3] = e5, s3 += 1, s3 === i2.length && t3(i2);
                }, r3);
              });
            } }), race: a({ name: "race", arity: 1, sync: function(e3) {
              const t3 = Array.from(e3[0]);
              if (t3.length === 0)
                throw o("Must race at least 1 item", s2);
              return l(t3[0]);
            }, async: function(e3, t3, r3) {
              const n2 = Array.from(e3[0]);
              if (n2.length === 0)
                throw o("Must race at least 1 item", s2);
              for (const e4 of n2)
                c(e4, t3, r3);
            } }) });
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n = r2(91);
            function s2(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            var i = function e3(t3, r3) {
              if (typeof t3 != "object" || t3 === null)
                return t3;
              var n2 = new t3.constructor();
              for (var s3 in t3)
                if (t3.hasOwnProperty(s3)) {
                  var i2 = t3[s3];
                  s3 === "parent" && typeof i2 == "object" ? r3 && (n2[s3] = r3) : n2[s3] = i2 instanceof Array ? i2.map(function(t4) {
                    return e3(t4, n2);
                  }) : e3(i2, n2);
                }
              return n2;
            }, o = function() {
              function e3(e4) {
                e4 === void 0 && (e4 = {}), Object.assign(this, e4), this.spaces = this.spaces || {}, this.spaces.before = this.spaces.before || "", this.spaces.after = this.spaces.after || "";
              }
              var t3, r3, o2 = e3.prototype;
              return o2.remove = function() {
                return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
              }, o2.replaceWith = function() {
                if (this.parent) {
                  for (var e4 in arguments)
                    this.parent.insertBefore(this, arguments[e4]);
                  this.remove();
                }
                return this;
              }, o2.next = function() {
                return this.parent.at(this.parent.index(this) + 1);
              }, o2.prev = function() {
                return this.parent.at(this.parent.index(this) - 1);
              }, o2.clone = function(e4) {
                e4 === void 0 && (e4 = {});
                var t4 = i(this);
                for (var r4 in e4)
                  t4[r4] = e4[r4];
                return t4;
              }, o2.appendToPropertyAndEscape = function(e4, t4, r4) {
                this.raws || (this.raws = {});
                var n2 = this[e4], s3 = this.raws[e4];
                this[e4] = n2 + t4, s3 || r4 !== t4 ? this.raws[e4] = (s3 || n2) + r4 : delete this.raws[e4];
              }, o2.setPropertyAndEscape = function(e4, t4, r4) {
                this.raws || (this.raws = {}), this[e4] = t4, this.raws[e4] = r4;
              }, o2.setPropertyWithoutEscape = function(e4, t4) {
                this[e4] = t4, this.raws && delete this.raws[e4];
              }, o2.isAtPosition = function(e4, t4) {
                if (this.source && this.source.start && this.source.end)
                  return !(this.source.start.line > e4 || this.source.end.line < e4 || this.source.start.line === e4 && this.source.start.column > t4 || this.source.end.line === e4 && this.source.end.column < t4);
              }, o2.stringifyProperty = function(e4) {
                return this.raws && this.raws[e4] || this[e4];
              }, o2.valueToString = function() {
                return String(this.stringifyProperty("value"));
              }, o2.toString = function() {
                return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
              }, t3 = e3, (r3 = [{ key: "rawSpaceBefore", get: function() {
                var e4 = this.raws && this.raws.spaces && this.raws.spaces.before;
                return e4 === void 0 && (e4 = this.spaces && this.spaces.before), e4 || "";
              }, set: function(e4) {
                (0, n.ensureObject)(this, "raws", "spaces"), this.raws.spaces.before = e4;
              } }, { key: "rawSpaceAfter", get: function() {
                var e4 = this.raws && this.raws.spaces && this.raws.spaces.after;
                return e4 === void 0 && (e4 = this.spaces.after), e4 || "";
              }, set: function(e4) {
                (0, n.ensureObject)(this, "raws", "spaces"), this.raws.spaces.after = e4;
              } }]) && s2(t3.prototype, r3), e3;
            }();
            t2.default = o, e2.exports = t2.default;
          }, (e2) => {
            e2.exports = function(e3) {
              try {
                return !!e3();
              } catch (e4) {
                return true;
              }
            };
          }, (e2, t2, r2) => {
            var n = r2(109), s2 = {}.hasOwnProperty;
            e2.exports = Object.hasOwn || function(e3, t3) {
              return s2.call(n(e3), t3);
            };
          }, function(e2, t2, r2) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), Object.defineProperty(e3, n2, { enumerable: true, get: function() {
                return t3[r3];
              } });
            } : function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), e3[n2] = t3[r3];
            }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
              Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
            } : function(e3, t3) {
              e3.default = t3;
            }), i = this && this.__importStar || function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = {};
              if (e3 != null)
                for (var r3 in e3)
                  r3 !== "default" && Object.prototype.hasOwnProperty.call(e3, r3) && n(t3, e3, r3);
              return s2(t3, e3), t3;
            }, o = this && this.__importDefault || function(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            };
            Object.defineProperty(t2, "__esModule", { value: true });
            const a = i(r2(0)), l = o(r2(21)), c = o(r2(531)), u = r2(146), p2 = o(r2(167)), f = o(r2(170)), d = /\*?\s*@jsx\s+([^\s]+)/;
            t2.default = ({ types: e3 }) => ({ name: "babel-plugin-jsx", inherits: c.default, visitor: Object.assign(Object.assign(Object.assign({}, p2.default), f.default), { Program: { enter(t3, r3) {
              if (((e4) => {
                let t4 = false;
                return e4.traverse({ JSXElement(e5) {
                  t4 = true, e5.stop();
                }, JSXFragment(e5) {
                  t4 = true, e5.stop();
                } }), t4;
              })(t3)) {
                const n2 = ["createVNode", "Fragment", "resolveComponent", "withDirectives", "vShow", "vModelSelect", "vModelText", "vModelCheckbox", "vModelRadio", "vModelText", "vModelDynamic", "resolveDirective", "mergeProps", "createTextVNode", "isVNode"];
                if (u.isModule(t3)) {
                  const s4 = {};
                  n2.forEach((n3) => {
                    r3.set(n3, () => {
                      if (s4[n3])
                        return e3.cloneNode(s4[n3]);
                      const r4 = u.addNamed(t3, n3, "vue", { ensureLiveReference: true });
                      return s4[n3] = r4, r4;
                    });
                  });
                  const { enableObjectSlots: i3 = true } = r3.opts;
                  i3 && r3.set("@vue/babel-plugin-jsx/runtimeIsSlot", () => {
                    if (s4.runtimeIsSlot)
                      return s4.runtimeIsSlot;
                    const { name: e4 } = r3.get("isVNode")(), n3 = t3.scope.generateUidIdentifier("isSlot"), i4 = l.default.ast`
                  function ${n3.name}(s) {
                    return typeof s === 'function' || (Object.prototype.toString.call(s) === '[object Object]' && !${e4}(s));
                  }
                `, o2 = t3.get("body").filter((e5) => e5.isImportDeclaration()).pop();
                    return o2 && o2.insertAfter(i4), s4.runtimeIsSlot = n3, n3;
                  });
                } else {
                  let e4 = "";
                  n2.forEach((n3) => {
                    r3.set(n3, () => (e4 || (e4 = u.addNamespace(t3, "vue", { ensureLiveReference: true }).name), a.memberExpression(a.identifier(e4), a.identifier(n3))));
                  });
                }
                const { opts: { pragma: s3 = "" }, file: i2 } = r3;
                if (s3 && r3.set("createVNode", () => a.identifier(s3)), i2.ast.comments)
                  for (const e4 of i2.ast.comments) {
                    const t4 = d.exec(e4.value);
                    t4 && r3.set("createVNode", () => a.identifier(t4[1]));
                  }
              }
            }, exit(e4) {
              const t3 = e4.get("body"), r3 = new Map();
              t3.filter((e5) => a.isImportDeclaration(e5.node) && e5.node.source.value === "vue").forEach((e5) => {
                const { specifiers: t4 } = e5.node;
                let n3 = false;
                t4.forEach((e6) => {
                  !e6.loc && a.isImportSpecifier(e6) && a.isIdentifier(e6.imported) && (r3.set(e6.imported.name, e6), n3 = true);
                }), n3 && e5.remove();
              });
              const n2 = [...r3.keys()].map((e5) => r3.get(e5));
              n2.length && e4.unshiftContainer("body", a.importDeclaration(n2, a.stringLiteral("vue")));
            } } }) });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.SHOULD_SKIP = t2.SHOULD_STOP = t2.REMOVED = void 0;
            var n = r2(212), s2 = r2(65), i = r2(10), o = r2(231), a = r2(0), l = r2(34), c = r2(133), u = r2(433), p2 = r2(434), f = r2(437), d = r2(440), h3 = r2(441), m = r2(447), y = r2(448), g = r2(449), b = r2(451), v = r2(453), E = r2(454);
            const x = s2("babel");
            t2.REMOVED = 1, t2.SHOULD_STOP = 2, t2.SHOULD_SKIP = 4;
            class S {
              constructor(e3, t3) {
                this.contexts = [], this.state = null, this.opts = null, this._traverseFlags = 0, this.skipKeys = null, this.parentPath = null, this.container = null, this.listKey = null, this.key = null, this.node = null, this.type = null, this.parent = t3, this.hub = e3, this.data = null, this.context = null, this.scope = null;
              }
              static get({ hub: e3, parentPath: t3, parent: r3, container: n2, listKey: s3, key: i2 }) {
                if (!e3 && t3 && (e3 = t3.hub), !r3)
                  throw new Error("To get a node path the parent needs to exist");
                const o2 = n2[i2];
                let a2 = l.path.get(r3);
                a2 || (a2 = new Map(), l.path.set(r3, a2));
                let c4 = a2.get(o2);
                return c4 || (c4 = new S(e3, r3), o2 && a2.set(o2, c4)), c4.setup(t3, n2, s3, i2), c4;
              }
              getScope(e3) {
                return this.isScope() ? new o.default(this) : e3;
              }
              setData(e3, t3) {
                return this.data == null && (this.data = Object.create(null)), this.data[e3] = t3;
              }
              getData(e3, t3) {
                this.data == null && (this.data = Object.create(null));
                let r3 = this.data[e3];
                return r3 === void 0 && t3 !== void 0 && (r3 = this.data[e3] = t3), r3;
              }
              buildCodeFrameError(e3, t3 = SyntaxError) {
                return this.hub.buildError(this.node, e3, t3);
              }
              traverse(e3, t3) {
                (0, i.default)(this.node, e3, this.scope, t3, this);
              }
              set(e3, t3) {
                a.validate(this.node, e3, t3), this.node[e3] = t3;
              }
              getPathLocation() {
                const e3 = [];
                let t3 = this;
                do {
                  let r3 = t3.key;
                  t3.inList && (r3 = `${t3.listKey}[${r3}]`), e3.unshift(r3);
                } while (t3 = t3.parentPath);
                return e3.join(".");
              }
              debug(e3) {
                x.enabled && x(`${this.getPathLocation()} ${this.type}: ${e3}`);
              }
              toString() {
                return (0, c.default)(this.node).code;
              }
              get inList() {
                return !!this.listKey;
              }
              set inList(e3) {
                e3 || (this.listKey = null);
              }
              get parentKey() {
                return this.listKey || this.key;
              }
              get shouldSkip() {
                return !!(4 & this._traverseFlags);
              }
              set shouldSkip(e3) {
                e3 ? this._traverseFlags |= 4 : this._traverseFlags &= -5;
              }
              get shouldStop() {
                return !!(2 & this._traverseFlags);
              }
              set shouldStop(e3) {
                e3 ? this._traverseFlags |= 2 : this._traverseFlags &= -3;
              }
              get removed() {
                return !!(1 & this._traverseFlags);
              }
              set removed(e3) {
                e3 ? this._traverseFlags |= 1 : this._traverseFlags &= -2;
              }
            }
            Object.assign(S.prototype, u, p2, f, d, h3, m, y, g, b, v, E);
            for (const e3 of a.TYPES) {
              const t3 = `is${e3}`, r3 = a[t3];
              S.prototype[t3] = function(e4) {
                return r3(this.node, e4);
              }, S.prototype[`assert${e3}`] = function(t4) {
                if (!r3(this.node, t4))
                  throw new TypeError(`Expected node path of type ${e3}`);
              };
            }
            for (const e3 of Object.keys(n)) {
              if (e3[0] === "_")
                continue;
              a.TYPES.indexOf(e3) < 0 && a.TYPES.push(e3);
              const t3 = n[e3];
              S.prototype[`is${e3}`] = function(e4) {
                return t3.checkPath(this, e4);
              };
            }
            var T = S;
            t2.default = T;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.validate = d, t2.typeIs = h3, t2.validateType = function(e3) {
              return d(h3(e3));
            }, t2.validateOptional = function(e3) {
              return { validate: e3, optional: true };
            }, t2.validateOptionalType = function(e3) {
              return { validate: h3(e3), optional: true };
            }, t2.arrayOf = m, t2.arrayOfType = y, t2.validateArrayOfType = function(e3) {
              return d(y(e3));
            }, t2.assertEach = g, t2.assertOneOf = function(...e3) {
              function t3(t4, r3, n2) {
                if (e3.indexOf(n2) < 0)
                  throw new TypeError(`Property ${r3} expected value to be one of ${JSON.stringify(e3)} but got ${JSON.stringify(n2)}`);
              }
              return t3.oneOf = e3, t3;
            }, t2.assertNodeType = b, t2.assertNodeOrValueType = function(...e3) {
              function t3(t4, r3, i2) {
                for (const o2 of e3)
                  if (f(i2) === o2 || (0, n.default)(o2, i2))
                    return void (0, s2.validateChild)(t4, r3, i2);
                throw new TypeError(`Property ${r3} of ${t4.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(i2 == null ? void 0 : i2.type)}`);
              }
              return t3.oneOfNodeOrValueTypes = e3, t3;
            }, t2.assertValueType = v, t2.assertShape = function(e3) {
              function t3(t4, r3, n2) {
                const i2 = [];
                for (const r4 of Object.keys(e3))
                  try {
                    (0, s2.validateField)(t4, r4, n2[r4], e3[r4]);
                  } catch (e4) {
                    if (e4 instanceof TypeError) {
                      i2.push(e4.message);
                      continue;
                    }
                    throw e4;
                  }
                if (i2.length)
                  throw new TypeError(`Property ${r3} of ${t4.type} expected to have the following:
${i2.join("\n")}`);
              }
              return t3.shapeOf = e3, t3;
            }, t2.assertOptionalChainStart = function() {
              return function(e3) {
                var t3;
                let r3 = e3;
                for (; e3; ) {
                  const { type: e4 } = r3;
                  if (e4 !== "OptionalCallExpression") {
                    if (e4 !== "OptionalMemberExpression")
                      break;
                    if (r3.optional)
                      return;
                    r3 = r3.object;
                  } else {
                    if (r3.optional)
                      return;
                    r3 = r3.callee;
                  }
                }
                throw new TypeError(`Non-optional ${e3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(t3 = r3) == null ? void 0 : t3.type}`);
              };
            }, t2.chain = E, t2.default = function(e3, t3 = {}) {
              const r3 = t3.inherits && T[t3.inherits] || {};
              let n2 = t3.fields;
              if (!n2 && (n2 = {}, r3.fields)) {
                const e4 = Object.getOwnPropertyNames(r3.fields);
                for (const t4 of e4) {
                  const e5 = r3.fields[t4], s4 = e5.default;
                  if (Array.isArray(s4) ? s4.length > 0 : s4 && typeof s4 == "object")
                    throw new Error("field defaults can only be primitives or empty arrays currently");
                  n2[t4] = { default: Array.isArray(s4) ? [] : s4, optional: e5.optional, validate: e5.validate };
                }
              }
              const s3 = t3.visitor || r3.visitor || [], d2 = t3.aliases || r3.aliases || [], h4 = t3.builder || r3.builder || t3.visitor || [];
              for (const r4 of Object.keys(t3))
                if (x.indexOf(r4) === -1)
                  throw new Error(`Unknown type option "${r4}" on ${e3}`);
              t3.deprecatedAlias && (u[t3.deprecatedAlias] = e3);
              for (const e4 of s3.concat(h4))
                n2[e4] = n2[e4] || {};
              for (const t4 of Object.keys(n2)) {
                const r4 = n2[t4];
                r4.default !== void 0 && h4.indexOf(t4) === -1 && (r4.optional = true), r4.default === void 0 ? r4.default = null : r4.validate || r4.default == null || (r4.validate = v(f(r4.default)));
                for (const n3 of Object.keys(r4))
                  if (S.indexOf(n3) === -1)
                    throw new Error(`Unknown field key "${n3}" on ${e3}.${t4}`);
              }
              i[e3] = t3.visitor = s3, c[e3] = t3.builder = h4, l[e3] = t3.fields = n2, o[e3] = t3.aliases = d2, d2.forEach((t4) => {
                a[t4] = a[t4] || [], a[t4].push(e3);
              }), t3.validate && (p2[e3] = t3.validate), T[e3] = t3;
            }, t2.NODE_PARENT_VALIDATIONS = t2.DEPRECATED_KEYS = t2.BUILDER_KEYS = t2.NODE_FIELDS = t2.FLIPPED_ALIAS_KEYS = t2.ALIAS_KEYS = t2.VISITOR_KEYS = void 0;
            var n = r2(62), s2 = r2(130);
            const i = {};
            t2.VISITOR_KEYS = i;
            const o = {};
            t2.ALIAS_KEYS = o;
            const a = {};
            t2.FLIPPED_ALIAS_KEYS = a;
            const l = {};
            t2.NODE_FIELDS = l;
            const c = {};
            t2.BUILDER_KEYS = c;
            const u = {};
            t2.DEPRECATED_KEYS = u;
            const p2 = {};
            function f(e3) {
              return Array.isArray(e3) ? "array" : e3 === null ? "null" : typeof e3;
            }
            function d(e3) {
              return { validate: e3 };
            }
            function h3(e3) {
              return typeof e3 == "string" ? b(e3) : b(...e3);
            }
            function m(e3) {
              return E(v("array"), g(e3));
            }
            function y(e3) {
              return m(h3(e3));
            }
            function g(e3) {
              function t3(t4, r3, n2) {
                if (Array.isArray(n2))
                  for (let s3 = 0; s3 < n2.length; s3++) {
                    const i2 = `${r3}[${s3}]`, o2 = n2[s3];
                    e3(t4, i2, o2);
                  }
              }
              return t3.each = e3, t3;
            }
            function b(...e3) {
              function t3(t4, r3, i2) {
                for (const o2 of e3)
                  if ((0, n.default)(o2, i2))
                    return void (0, s2.validateChild)(t4, r3, i2);
                throw new TypeError(`Property ${r3} of ${t4.type} expected node to be of a type ${JSON.stringify(e3)} but instead got ${JSON.stringify(i2 == null ? void 0 : i2.type)}`);
              }
              return t3.oneOfNodeTypes = e3, t3;
            }
            function v(e3) {
              function t3(t4, r3, n2) {
                if (f(n2) !== e3)
                  throw new TypeError(`Property ${r3} expected type of ${e3} but got ${f(n2)}`);
              }
              return t3.type = e3, t3;
            }
            function E(...e3) {
              function t3(...t4) {
                for (const r3 of e3)
                  r3(...t4);
              }
              if (t3.chainOf = e3, e3.length >= 2 && "type" in e3[0] && e3[0].type === "array" && !("each" in e3[1]))
                throw new Error('An assertValueType("array") validator can only be followed by an assertEach(...) validator.');
              return t3;
            }
            t2.NODE_PARENT_VALIDATIONS = p2;
            const x = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"], S = ["default", "optional", "validate"], T = {};
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = t2.program = t2.expression = t2.statements = t2.statement = t2.smart = void 0;
            var n = r2(443), s2 = r2(444);
            const i = (0, s2.default)(n.smart);
            t2.smart = i;
            const o = (0, s2.default)(n.statement);
            t2.statement = o;
            const a = (0, s2.default)(n.statements);
            t2.statements = a;
            const l = (0, s2.default)(n.expression);
            t2.expression = l;
            const c = (0, s2.default)(n.program);
            t2.program = c;
            var u = Object.assign(i.bind(void 0), { smart: i, statement: o, statements: a, expression: l, program: c, ast: i.ast });
            t2.default = u;
          }, (e2, t2, r2) => {
            "use strict";
            let n, s2, i, { isClean: o, my: a } = r2(154), l = r2(47), c = r2(49), u = r2(48);
            function p2(e3) {
              return e3.map((e4) => (e4.nodes && (e4.nodes = p2(e4.nodes)), delete e4.source, e4));
            }
            function f(e3) {
              if (e3[o] = false, e3.proxyOf.nodes)
                for (let t3 of e3.proxyOf.nodes)
                  f(t3);
            }
            class d extends u {
              push(e3) {
                return e3.parent = this, this.proxyOf.nodes.push(e3), this;
              }
              each(e3) {
                if (!this.proxyOf.nodes)
                  return;
                let t3, r3, n2 = this.getIterator();
                for (; this.indexes[n2] < this.proxyOf.nodes.length && (t3 = this.indexes[n2], r3 = e3(this.proxyOf.nodes[t3], t3), r3 !== false); )
                  this.indexes[n2] += 1;
                return delete this.indexes[n2], r3;
              }
              walk(e3) {
                return this.each((t3, r3) => {
                  let n2;
                  try {
                    n2 = e3(t3, r3);
                  } catch (e4) {
                    throw t3.addToError(e4);
                  }
                  return n2 !== false && t3.walk && (n2 = t3.walk(e3)), n2;
                });
              }
              walkDecls(e3, t3) {
                return t3 ? e3 instanceof RegExp ? this.walk((r3, n2) => {
                  if (r3.type === "decl" && e3.test(r3.prop))
                    return t3(r3, n2);
                }) : this.walk((r3, n2) => {
                  if (r3.type === "decl" && r3.prop === e3)
                    return t3(r3, n2);
                }) : (t3 = e3, this.walk((e4, r3) => {
                  if (e4.type === "decl")
                    return t3(e4, r3);
                }));
              }
              walkRules(e3, t3) {
                return t3 ? e3 instanceof RegExp ? this.walk((r3, n2) => {
                  if (r3.type === "rule" && e3.test(r3.selector))
                    return t3(r3, n2);
                }) : this.walk((r3, n2) => {
                  if (r3.type === "rule" && r3.selector === e3)
                    return t3(r3, n2);
                }) : (t3 = e3, this.walk((e4, r3) => {
                  if (e4.type === "rule")
                    return t3(e4, r3);
                }));
              }
              walkAtRules(e3, t3) {
                return t3 ? e3 instanceof RegExp ? this.walk((r3, n2) => {
                  if (r3.type === "atrule" && e3.test(r3.name))
                    return t3(r3, n2);
                }) : this.walk((r3, n2) => {
                  if (r3.type === "atrule" && r3.name === e3)
                    return t3(r3, n2);
                }) : (t3 = e3, this.walk((e4, r3) => {
                  if (e4.type === "atrule")
                    return t3(e4, r3);
                }));
              }
              walkComments(e3) {
                return this.walk((t3, r3) => {
                  if (t3.type === "comment")
                    return e3(t3, r3);
                });
              }
              append(...e3) {
                for (let t3 of e3) {
                  let e4 = this.normalize(t3, this.last);
                  for (let t4 of e4)
                    this.proxyOf.nodes.push(t4);
                }
                return this.markDirty(), this;
              }
              prepend(...e3) {
                e3 = e3.reverse();
                for (let t3 of e3) {
                  let e4 = this.normalize(t3, this.first, "prepend").reverse();
                  for (let t4 of e4)
                    this.proxyOf.nodes.unshift(t4);
                  for (let t4 in this.indexes)
                    this.indexes[t4] = this.indexes[t4] + e4.length;
                }
                return this.markDirty(), this;
              }
              cleanRaws(e3) {
                if (super.cleanRaws(e3), this.nodes)
                  for (let t3 of this.nodes)
                    t3.cleanRaws(e3);
              }
              insertBefore(e3, t3) {
                let r3, n2 = (e3 = this.index(e3)) === 0 && "prepend", s3 = this.normalize(t3, this.proxyOf.nodes[e3], n2).reverse();
                for (let t4 of s3)
                  this.proxyOf.nodes.splice(e3, 0, t4);
                for (let t4 in this.indexes)
                  r3 = this.indexes[t4], e3 <= r3 && (this.indexes[t4] = r3 + s3.length);
                return this.markDirty(), this;
              }
              insertAfter(e3, t3) {
                e3 = this.index(e3);
                let r3, n2 = this.normalize(t3, this.proxyOf.nodes[e3]).reverse();
                for (let t4 of n2)
                  this.proxyOf.nodes.splice(e3 + 1, 0, t4);
                for (let t4 in this.indexes)
                  r3 = this.indexes[t4], e3 < r3 && (this.indexes[t4] = r3 + n2.length);
                return this.markDirty(), this;
              }
              removeChild(e3) {
                let t3;
                e3 = this.index(e3), this.proxyOf.nodes[e3].parent = void 0, this.proxyOf.nodes.splice(e3, 1);
                for (let r3 in this.indexes)
                  t3 = this.indexes[r3], t3 >= e3 && (this.indexes[r3] = t3 - 1);
                return this.markDirty(), this;
              }
              removeAll() {
                for (let e3 of this.proxyOf.nodes)
                  e3.parent = void 0;
                return this.proxyOf.nodes = [], this.markDirty(), this;
              }
              replaceValues(e3, t3, r3) {
                return r3 || (r3 = t3, t3 = {}), this.walkDecls((n2) => {
                  t3.props && !t3.props.includes(n2.prop) || t3.fast && !n2.value.includes(t3.fast) || (n2.value = n2.value.replace(e3, r3));
                }), this.markDirty(), this;
              }
              every(e3) {
                return this.nodes.every(e3);
              }
              some(e3) {
                return this.nodes.some(e3);
              }
              index(e3) {
                return typeof e3 == "number" ? e3 : (e3.proxyOf && (e3 = e3.proxyOf), this.proxyOf.nodes.indexOf(e3));
              }
              get first() {
                if (this.proxyOf.nodes)
                  return this.proxyOf.nodes[0];
              }
              get last() {
                if (this.proxyOf.nodes)
                  return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
              }
              normalize(e3, t3) {
                if (typeof e3 == "string")
                  e3 = p2(n(e3).nodes);
                else if (Array.isArray(e3)) {
                  e3 = e3.slice(0);
                  for (let t4 of e3)
                    t4.parent && t4.parent.removeChild(t4, "ignore");
                } else if (e3.type === "root" && this.type !== "document") {
                  e3 = e3.nodes.slice(0);
                  for (let t4 of e3)
                    t4.parent && t4.parent.removeChild(t4, "ignore");
                } else if (e3.type)
                  e3 = [e3];
                else if (e3.prop) {
                  if (e3.value === void 0)
                    throw new Error("Value field is missed in node creation");
                  typeof e3.value != "string" && (e3.value = String(e3.value)), e3 = [new l(e3)];
                } else if (e3.selector)
                  e3 = [new s2(e3)];
                else if (e3.name)
                  e3 = [new i(e3)];
                else {
                  if (!e3.text)
                    throw new Error("Unknown node type in node creation");
                  e3 = [new c(e3)];
                }
                return e3.map((e4) => (e4[a] || d.rebuild(e4), (e4 = e4.proxyOf).parent && e4.parent.removeChild(e4), e4[o] && f(e4), e4.raws.before === void 0 && t3 && t3.raws.before !== void 0 && (e4.raws.before = t3.raws.before.replace(/\S/g, "")), e4.parent = this, e4));
              }
              getProxyProcessor() {
                return { set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, t3 !== "name" && t3 !== "params" && t3 !== "selector" || e3.markDirty()), true), get: (e3, t3) => t3 === "proxyOf" ? e3 : e3[t3] ? t3 === "each" || typeof t3 == "string" && t3.startsWith("walk") ? (...r3) => e3[t3](...r3.map((e4) => typeof e4 == "function" ? (t4, r4) => e4(t4.toProxy(), r4) : e4)) : t3 === "every" || t3 === "some" ? (r3) => e3[t3]((e4, ...t4) => r3(e4.toProxy(), ...t4)) : t3 === "root" ? () => e3.root().toProxy() : t3 === "nodes" ? e3.nodes.map((e4) => e4.toProxy()) : t3 === "first" || t3 === "last" ? e3[t3].toProxy() : e3[t3] : e3[t3] };
              }
              getIterator() {
                this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
                let e3 = this.lastEach;
                return this.indexes[e3] = 0, e3;
              }
            }
            d.registerParse = (e3) => {
              n = e3;
            }, d.registerRule = (e3) => {
              s2 = e3;
            }, d.registerAtRule = (e3) => {
              i = e3;
            }, e2.exports = d, d.default = d, d.rebuild = (e3) => {
              e3.type === "atrule" ? Object.setPrototypeOf(e3, i.prototype) : e3.type === "rule" ? Object.setPrototypeOf(e3, s2.prototype) : e3.type === "decl" ? Object.setPrototypeOf(e3, l.prototype) : e3.type === "comment" && Object.setPrototypeOf(e3, c.prototype), e3[a] = true, e3.nodes && e3.nodes.forEach((e4) => {
                d.rebuild(e4);
              });
            };
          }, (e2, t2, r2) => {
            const { MAX_SAFE_COMPONENT_LENGTH: n } = r2(41), s2 = r2(42), i = (t2 = e2.exports = {}).re = [], o = t2.src = [], a = t2.t = {};
            let l = 0;
            const c = (e3, t3, r3) => {
              const n2 = l++;
              s2(n2, t3), a[e3] = n2, o[n2] = t3, i[n2] = new RegExp(t3, r3 ? "g" : void 0);
            };
            c("NUMERICIDENTIFIER", "0|[1-9]\\d*"), c("NUMERICIDENTIFIERLOOSE", "[0-9]+"), c("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*"), c("MAINVERSION", `(${o[a.NUMERICIDENTIFIER]})\\.(${o[a.NUMERICIDENTIFIER]})\\.(${o[a.NUMERICIDENTIFIER]})`), c("MAINVERSIONLOOSE", `(${o[a.NUMERICIDENTIFIERLOOSE]})\\.(${o[a.NUMERICIDENTIFIERLOOSE]})\\.(${o[a.NUMERICIDENTIFIERLOOSE]})`), c("PRERELEASEIDENTIFIER", `(?:${o[a.NUMERICIDENTIFIER]}|${o[a.NONNUMERICIDENTIFIER]})`), c("PRERELEASEIDENTIFIERLOOSE", `(?:${o[a.NUMERICIDENTIFIERLOOSE]}|${o[a.NONNUMERICIDENTIFIER]})`), c("PRERELEASE", `(?:-(${o[a.PRERELEASEIDENTIFIER]}(?:\\.${o[a.PRERELEASEIDENTIFIER]})*))`), c("PRERELEASELOOSE", `(?:-?(${o[a.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${o[a.PRERELEASEIDENTIFIERLOOSE]})*))`), c("BUILDIDENTIFIER", "[0-9A-Za-z-]+"), c("BUILD", `(?:\\+(${o[a.BUILDIDENTIFIER]}(?:\\.${o[a.BUILDIDENTIFIER]})*))`), c("FULLPLAIN", `v?${o[a.MAINVERSION]}${o[a.PRERELEASE]}?${o[a.BUILD]}?`), c("FULL", `^${o[a.FULLPLAIN]}$`), c("LOOSEPLAIN", `[v=\\s]*${o[a.MAINVERSIONLOOSE]}${o[a.PRERELEASELOOSE]}?${o[a.BUILD]}?`), c("LOOSE", `^${o[a.LOOSEPLAIN]}$`), c("GTLT", "((?:<|>)?=?)"), c("XRANGEIDENTIFIERLOOSE", `${o[a.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), c("XRANGEIDENTIFIER", `${o[a.NUMERICIDENTIFIER]}|x|X|\\*`), c("XRANGEPLAIN", `[v=\\s]*(${o[a.XRANGEIDENTIFIER]})(?:\\.(${o[a.XRANGEIDENTIFIER]})(?:\\.(${o[a.XRANGEIDENTIFIER]})(?:${o[a.PRERELEASE]})?${o[a.BUILD]}?)?)?`), c("XRANGEPLAINLOOSE", `[v=\\s]*(${o[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[a.XRANGEIDENTIFIERLOOSE]})(?:\\.(${o[a.XRANGEIDENTIFIERLOOSE]})(?:${o[a.PRERELEASELOOSE]})?${o[a.BUILD]}?)?)?`), c("XRANGE", `^${o[a.GTLT]}\\s*${o[a.XRANGEPLAIN]}$`), c("XRANGELOOSE", `^${o[a.GTLT]}\\s*${o[a.XRANGEPLAINLOOSE]}$`), c("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), c("COERCERTL", o[a.COERCE], true), c("LONETILDE", "(?:~>?)"), c("TILDETRIM", `(\\s*)${o[a.LONETILDE]}\\s+`, true), t2.tildeTrimReplace = "$1~", c("TILDE", `^${o[a.LONETILDE]}${o[a.XRANGEPLAIN]}$`), c("TILDELOOSE", `^${o[a.LONETILDE]}${o[a.XRANGEPLAINLOOSE]}$`), c("LONECARET", "(?:\\^)"), c("CARETTRIM", `(\\s*)${o[a.LONECARET]}\\s+`, true), t2.caretTrimReplace = "$1^", c("CARET", `^${o[a.LONECARET]}${o[a.XRANGEPLAIN]}$`), c("CARETLOOSE", `^${o[a.LONECARET]}${o[a.XRANGEPLAINLOOSE]}$`), c("COMPARATORLOOSE", `^${o[a.GTLT]}\\s*(${o[a.LOOSEPLAIN]})$|^$`), c("COMPARATOR", `^${o[a.GTLT]}\\s*(${o[a.FULLPLAIN]})$|^$`), c("COMPARATORTRIM", `(\\s*)${o[a.GTLT]}\\s*(${o[a.LOOSEPLAIN]}|${o[a.XRANGEPLAIN]})`, true), t2.comparatorTrimReplace = "$1$2$3", c("HYPHENRANGE", `^\\s*(${o[a.XRANGEPLAIN]})\\s+-\\s+(${o[a.XRANGEPLAIN]})\\s*$`), c("HYPHENRANGELOOSE", `^\\s*(${o[a.XRANGEPLAINLOOSE]})\\s+-\\s+(${o[a.XRANGEPLAINLOOSE]})\\s*$`), c("STAR", "(<|>)?=?\\s*\\*"), c("GTE0", "^\\s*>=\\s*0.0.0\\s*$"), c("GTE0PRE", "^\\s*>=\\s*0.0.0-0\\s*$");
          }, (e2) => {
            e2.exports = function(e3) {
              return typeof e3 == "object" ? e3 !== null : typeof e3 == "function";
            };
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.NOT_LOCAL_BINDING = t2.BLOCK_SCOPED_SYMBOL = t2.INHERIT_KEYS = t2.UNARY_OPERATORS = t2.STRING_UNARY_OPERATORS = t2.NUMBER_UNARY_OPERATORS = t2.BOOLEAN_UNARY_OPERATORS = t2.ASSIGNMENT_OPERATORS = t2.BINARY_OPERATORS = t2.NUMBER_BINARY_OPERATORS = t2.BOOLEAN_BINARY_OPERATORS = t2.COMPARISON_BINARY_OPERATORS = t2.EQUALITY_BINARY_OPERATORS = t2.BOOLEAN_NUMBER_BINARY_OPERATORS = t2.UPDATE_OPERATORS = t2.LOGICAL_OPERATORS = t2.COMMENT_KEYS = t2.FOR_INIT_KEYS = t2.FLATTENABLE_KEYS = t2.STATEMENT_OR_BLOCK_KEYS = void 0, t2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"], t2.FLATTENABLE_KEYS = ["body", "expressions"], t2.FOR_INIT_KEYS = ["left", "init"], t2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
            const r2 = ["||", "&&", "??"];
            t2.LOGICAL_OPERATORS = r2, t2.UPDATE_OPERATORS = ["++", "--"];
            const n = [">", "<", ">=", "<="];
            t2.BOOLEAN_NUMBER_BINARY_OPERATORS = n;
            const s2 = ["==", "===", "!=", "!=="];
            t2.EQUALITY_BINARY_OPERATORS = s2;
            const i = [...s2, "in", "instanceof"];
            t2.COMPARISON_BINARY_OPERATORS = i;
            const o = [...i, ...n];
            t2.BOOLEAN_BINARY_OPERATORS = o;
            const a = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
            t2.NUMBER_BINARY_OPERATORS = a;
            const l = ["+", ...a, ...o];
            t2.BINARY_OPERATORS = l;
            const c = ["=", "+=", ...a.map((e3) => e3 + "="), ...r2.map((e3) => e3 + "=")];
            t2.ASSIGNMENT_OPERATORS = c;
            const u = ["delete", "!"];
            t2.BOOLEAN_UNARY_OPERATORS = u;
            const p2 = ["+", "-", "~"];
            t2.NUMBER_UNARY_OPERATORS = p2;
            const f = ["typeof"];
            t2.STRING_UNARY_OPERATORS = f;
            const d = ["void", "throw", ...u, ...p2, ...f];
            t2.UNARY_OPERATORS = d, t2.INHERIT_KEYS = { optional: ["typeAnnotation", "typeParameters", "returnType"], force: ["start", "loc", "end"] };
            const h3 = Symbol.for("var used to be block scoped");
            t2.BLOCK_SCOPED_SYMBOL = h3;
            const m = Symbol.for("should not be considered a local binding");
            t2.NOT_LOCAL_BINDING = m;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = l;
            var n = r2(11), s2 = r2(1);
            const i = Function.call.bind(Object.prototype.hasOwnProperty);
            function o(e3, t3, r3) {
              return e3 && typeof e3.type == "string" ? l(e3, t3, r3) : e3;
            }
            function a(e3, t3, r3) {
              return Array.isArray(e3) ? e3.map((e4) => o(e4, t3, r3)) : o(e3, t3, r3);
            }
            function l(e3, t3 = true, r3 = false) {
              if (!e3)
                return e3;
              const { type: o2 } = e3, l2 = { type: e3.type };
              if ((0, s2.isIdentifier)(e3))
                l2.name = e3.name, i(e3, "optional") && typeof e3.optional == "boolean" && (l2.optional = e3.optional), i(e3, "typeAnnotation") && (l2.typeAnnotation = t3 ? a(e3.typeAnnotation, true, r3) : e3.typeAnnotation);
              else {
                if (!i(n.NODE_FIELDS, o2))
                  throw new Error(`Unknown node type: "${o2}"`);
                for (const u of Object.keys(n.NODE_FIELDS[o2]))
                  i(e3, u) && (l2[u] = t3 ? (0, s2.isFile)(e3) && u === "comments" ? c(e3.comments, t3, r3) : a(e3[u], true, r3) : e3[u]);
              }
              return i(e3, "loc") && (l2.loc = r3 ? null : e3.loc), i(e3, "leadingComments") && (l2.leadingComments = c(e3.leadingComments, t3, r3)), i(e3, "innerComments") && (l2.innerComments = c(e3.innerComments, t3, r3)), i(e3, "trailingComments") && (l2.trailingComments = c(e3.trailingComments, t3, r3)), i(e3, "extra") && (l2.extra = Object.assign({}, e3.extra)), l2;
            }
            function c(e3, t3, r3) {
              return e3 && t3 ? e3.map(({ type: e4, value: t4, loc: n2 }) => r3 ? { type: e4, value: t4, loc: null } : { type: e4, value: t4, loc: n2 }) : e3;
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            const r2 = true, n = true, s2 = true, i = true, o = true;
            class a {
              constructor(e3, t3 = {}) {
                this.label = void 0, this.keyword = void 0, this.beforeExpr = void 0, this.startsExpr = void 0, this.rightAssociative = void 0, this.isLoop = void 0, this.isAssign = void 0, this.prefix = void 0, this.postfix = void 0, this.binop = void 0, this.updateContext = void 0, this.label = e3, this.keyword = t3.keyword, this.beforeExpr = !!t3.beforeExpr, this.startsExpr = !!t3.startsExpr, this.rightAssociative = !!t3.rightAssociative, this.isLoop = !!t3.isLoop, this.isAssign = !!t3.isAssign, this.prefix = !!t3.prefix, this.postfix = !!t3.postfix, this.binop = t3.binop != null ? t3.binop : null, this.updateContext = null;
              }
            }
            const l = new Map();
            function c(e3, t3 = {}) {
              t3.keyword = e3;
              const r3 = new a(e3, t3);
              return l.set(e3, r3), r3;
            }
            function u(e3, t3) {
              return new a(e3, { beforeExpr: r2, binop: t3 });
            }
            const p2 = { num: new a("num", { startsExpr: n }), bigint: new a("bigint", { startsExpr: n }), decimal: new a("decimal", { startsExpr: n }), regexp: new a("regexp", { startsExpr: n }), string: new a("string", { startsExpr: n }), name: new a("name", { startsExpr: n }), privateName: new a("#name", { startsExpr: n }), eof: new a("eof"), bracketL: new a("[", { beforeExpr: r2, startsExpr: n }), bracketHashL: new a("#[", { beforeExpr: r2, startsExpr: n }), bracketBarL: new a("[|", { beforeExpr: r2, startsExpr: n }), bracketR: new a("]"), bracketBarR: new a("|]"), braceL: new a("{", { beforeExpr: r2, startsExpr: n }), braceBarL: new a("{|", { beforeExpr: r2, startsExpr: n }), braceHashL: new a("#{", { beforeExpr: r2, startsExpr: n }), braceR: new a("}", { beforeExpr: r2 }), braceBarR: new a("|}"), parenL: new a("(", { beforeExpr: r2, startsExpr: n }), parenR: new a(")"), comma: new a(",", { beforeExpr: r2 }), semi: new a(";", { beforeExpr: r2 }), colon: new a(":", { beforeExpr: r2 }), doubleColon: new a("::", { beforeExpr: r2 }), dot: new a("."), question: new a("?", { beforeExpr: r2 }), questionDot: new a("?."), arrow: new a("=>", { beforeExpr: r2 }), template: new a("template"), ellipsis: new a("...", { beforeExpr: r2 }), backQuote: new a("`", { startsExpr: n }), dollarBraceL: new a("${", { beforeExpr: r2, startsExpr: n }), at: new a("@"), hash: new a("#", { startsExpr: n }), interpreterDirective: new a("#!..."), eq: new a("=", { beforeExpr: r2, isAssign: i }), assign: new a("_=", { beforeExpr: r2, isAssign: i }), slashAssign: new a("_=", { beforeExpr: r2, isAssign: i }), incDec: new a("++/--", { prefix: o, postfix: true, startsExpr: n }), bang: new a("!", { beforeExpr: r2, prefix: o, startsExpr: n }), tilde: new a("~", { beforeExpr: r2, prefix: o, startsExpr: n }), pipeline: u("|>", 0), nullishCoalescing: u("??", 1), logicalOR: u("||", 1), logicalAND: u("&&", 2), bitwiseOR: u("|", 3), bitwiseXOR: u("^", 4), bitwiseAND: u("&", 5), equality: u("==/!=/===/!==", 6), relational: u("</>/<=/>=", 7), bitShift: u("<</>>/>>>", 8), plusMin: new a("+/-", { beforeExpr: r2, binop: 9, prefix: o, startsExpr: n }), modulo: new a("%", { beforeExpr: r2, binop: 10, startsExpr: n }), star: new a("*", { binop: 10 }), slash: u("/", 10), exponent: new a("**", { beforeExpr: r2, binop: 11, rightAssociative: true }), _break: c("break"), _case: c("case", { beforeExpr: r2 }), _catch: c("catch"), _continue: c("continue"), _debugger: c("debugger"), _default: c("default", { beforeExpr: r2 }), _do: c("do", { isLoop: s2, beforeExpr: r2 }), _else: c("else", { beforeExpr: r2 }), _finally: c("finally"), _for: c("for", { isLoop: s2 }), _function: c("function", { startsExpr: n }), _if: c("if"), _return: c("return", { beforeExpr: r2 }), _switch: c("switch"), _throw: c("throw", { beforeExpr: r2, prefix: o, startsExpr: n }), _try: c("try"), _var: c("var"), _const: c("const"), _while: c("while", { isLoop: s2 }), _with: c("with"), _new: c("new", { beforeExpr: r2, startsExpr: n }), _this: c("this", { startsExpr: n }), _super: c("super", { startsExpr: n }), _class: c("class", { startsExpr: n }), _extends: c("extends", { beforeExpr: r2 }), _export: c("export"), _import: c("import", { startsExpr: n }), _null: c("null", { startsExpr: n }), _true: c("true", { startsExpr: n }), _false: c("false", { startsExpr: n }), _in: c("in", { beforeExpr: r2, binop: 7 }), _instanceof: c("instanceof", { beforeExpr: r2, binop: 7 }), _typeof: c("typeof", { beforeExpr: r2, prefix: o, startsExpr: n }), _void: c("void", { beforeExpr: r2, prefix: o, startsExpr: n }), _delete: c("delete", { beforeExpr: r2, prefix: o, startsExpr: n }) }, f = /\r\n?|[\n\u2028\u2029]/, d = new RegExp(f.source, "g");
            function h3(e3) {
              switch (e3) {
                case 10:
                case 13:
                case 8232:
                case 8233:
                  return true;
                default:
                  return false;
              }
            }
            const m = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
            function y(e3) {
              switch (e3) {
                case 9:
                case 11:
                case 12:
                case 32:
                case 160:
                case 5760:
                case 8192:
                case 8193:
                case 8194:
                case 8195:
                case 8196:
                case 8197:
                case 8198:
                case 8199:
                case 8200:
                case 8201:
                case 8202:
                case 8239:
                case 8287:
                case 12288:
                case 65279:
                  return true;
                default:
                  return false;
              }
            }
            class g {
              constructor(e3, t3) {
                this.line = void 0, this.column = void 0, this.line = e3, this.column = t3;
              }
            }
            class b {
              constructor(e3, t3) {
                this.start = void 0, this.end = void 0, this.filename = void 0, this.identifierName = void 0, this.start = e3, this.end = t3;
              }
            }
            function v(e3) {
              return e3[e3.length - 1];
            }
            const E = Object.freeze({ SyntaxError: "BABEL_PARSER_SYNTAX_ERROR", SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" }), x = T({ AccessorIsGenerator: "A %0ter cannot be a generator.", ArgumentsInClass: "'arguments' is only allowed in functions and class methods.", AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.", AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.", AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.", AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.", AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.", AwaitNotInAsyncFunction: "'await' is only allowed within async functions.", BadGetterArity: "A 'get' accesor must not have any formal parameters.", BadSetterArity: "A 'set' accesor must have exactly one formal parameter.", BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.", ConstructorClassField: "Classes may not have a field named 'constructor'.", ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.", ConstructorIsAccessor: "Class constructor may not be an accessor.", ConstructorIsAsync: "Constructor can't be an async function.", ConstructorIsGenerator: "Constructor can't be a generator.", DeclarationMissingInitializer: "'%0' require an initialization value.", DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.", DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?", DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.", DecoratorSemicolon: "Decorators must not be followed by a semicolon.", DecoratorStaticBlock: "Decorators can't be used with a static block.", DeletePrivateField: "Deleting a private field is not allowed.", DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.", DuplicateConstructor: "Duplicate constructor in the same class.", DuplicateDefaultExport: "Only one default export allowed per module.", DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.", DuplicateProto: "Redefinition of __proto__ property.", DuplicateRegExpFlags: "Duplicate regular expression flag.", ElementAfterRest: "Rest element must be last element.", EscapedCharNotAnIdentifier: "Invalid Unicode escape.", ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?", ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.", ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.", ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.", ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.", GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.", IllegalBreakContinue: "Unsyntactic %0.", IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.", IllegalReturn: "'return' outside of function.", ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?', ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.", ImportCallArity: "`import()` requires exactly %0.", ImportCallNotNewExpression: "Cannot use new with import(...).", ImportCallSpreadArgument: "`...` is not allowed in `import()`.", InvalidBigIntLiteral: "Invalid BigIntLiteral.", InvalidCodePoint: "Code point out of bounds.", InvalidDecimal: "Invalid decimal.", InvalidDigit: "Expected number in radix %0.", InvalidEscapeSequence: "Bad character escape sequence.", InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.", InvalidEscapedReservedWord: "Escape sequence in keyword %0.", InvalidIdentifier: "Invalid identifier %0.", InvalidLhs: "Invalid left-hand side in %0.", InvalidLhsBinding: "Binding invalid left-hand side in %0.", InvalidNumber: "Invalid number.", InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.", InvalidOrUnexpectedToken: "Unexpected character '%0'.", InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.", InvalidPrivateFieldResolution: "Private name #%0 is not defined.", InvalidPropertyBindingPattern: "Binding member expression.", InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.", InvalidRestAssignmentPattern: "Invalid rest operator's argument.", LabelRedeclaration: "Label '%0' is already declared.", LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.", LineTerminatorBeforeArrow: "No line break is allowed before '=>'.", MalformedRegExpFlags: "Invalid regular expression flag.", MissingClassName: "A class name is required.", MissingEqInAssignment: "Only '=' operator can be used for specifying default value.", MissingSemicolon: "Missing semicolon.", MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.", MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.", ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.", ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.", ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.', ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.", ModuleExportUndefined: "Export '%0' is not defined.", MultipleDefaultsInSwitch: "Multiple default clauses.", NewlineAfterThrow: "Illegal newline after throw.", NoCatchOrFinally: "Missing catch or finally clause.", NumberIdentifier: "Identifier directly after number.", NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.", ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.", OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.", OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.", OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.", ParamDupe: "Argument name clash.", PatternHasAccessor: "Object pattern can't contain getter or setter.", PatternHasMethod: "Object pattern can't contain methods.", PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.', PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.", PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.", PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.", PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.", PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.", PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).", PrivateNameRedeclaration: "Duplicate private name #%0.", RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", RecordNoProto: "'__proto__' is not allowed in Record expressions.", RestTrailingComma: "Unexpected trailing comma after rest element.", SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.", StaticPrototype: "Classes may not have static property named prototype.", StrictDelete: "Deleting local variable in strict mode.", StrictEvalArguments: "Assigning to '%0' in strict mode.", StrictEvalArgumentsBinding: "Binding '%0' in strict mode.", StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.", StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.", StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.", StrictWith: "'with' in strict mode.", SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?", SuperPrivateField: "Private fields can't be accessed on super.", TrailingDecorator: "Decorators must be attached to a class element.", TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.", TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.", UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.", UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.', UnexpectedDigitAfterHash: "Unexpected digit after hash token.", UnexpectedImportExport: "'import' and 'export' may only appear at the top level.", UnexpectedKeyword: "Unexpected keyword '%0'.", UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.", UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.", UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.", UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.", UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).", UnexpectedReservedWord: "Unexpected reserved word '%0'.", UnexpectedSuper: "'super' is only allowed in object methods and classes.", UnexpectedToken: "Unexpected token '%0'.", UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.", UnsupportedBind: "Binding should be performed on object property.", UnsupportedDecoratorExport: "A decorated export must export a class declaration.", UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.", UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.", UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.", UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.", UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.", UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).", UnterminatedComment: "Unterminated comment.", UnterminatedRegExp: "Unterminated regular expression.", UnterminatedString: "Unterminated string constant.", UnterminatedTemplate: "Unterminated template.", VarRedeclaration: "Identifier '%0' has already been declared.", YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.", YieldInParameter: "Yield expression is not allowed in formal parameters.", ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0." }, E.SyntaxError), S = T({ ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: "module"'`, ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: "module"'` }, E.SourceTypeModuleError);
            function T(e3, t3) {
              const r3 = {};
              return Object.keys(e3).forEach((n2) => {
                r3[n2] = Object.freeze({ code: t3, reasonCode: n2, template: e3[n2] });
              }), Object.freeze(r3);
            }
            class w {
              constructor(e3, t3) {
                this.token = void 0, this.preserveSpace = void 0, this.token = e3, this.preserveSpace = !!t3;
              }
            }
            const P = { brace: new w("{"), template: new w("`", true) };
            p2.braceR.updateContext = (e3) => {
              e3.pop();
            }, p2.braceL.updateContext = p2.braceHashL.updateContext = p2.dollarBraceL.updateContext = (e3) => {
              e3.push(P.brace);
            }, p2.backQuote.updateContext = (e3) => {
              e3[e3.length - 1] === P.template ? e3.pop() : e3.push(P.template);
            };
            let A = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", O = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
            const C = new RegExp("[" + A + "]"), I = new RegExp("[" + A + O + "]");
            A = O = null;
            const k2 = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], N = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
            function _(e3, t3) {
              let r3 = 65536;
              for (let n2 = 0, s3 = t3.length; n2 < s3; n2 += 2) {
                if (r3 += t3[n2], r3 > e3)
                  return false;
                if (r3 += t3[n2 + 1], r3 >= e3)
                  return true;
              }
              return false;
            }
            function j(e3) {
              return e3 < 65 ? e3 === 36 : e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && C.test(String.fromCharCode(e3)) : _(e3, k2)));
            }
            function D(e3) {
              return e3 < 48 ? e3 === 36 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && I.test(String.fromCharCode(e3)) : _(e3, k2) || _(e3, N))));
            }
            const L = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), M = new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), B = new Set(["eval", "arguments"]);
            function R(e3, t3) {
              return t3 && e3 === "await" || e3 === "enum";
            }
            function F(e3, t3) {
              return R(e3, t3) || M.has(e3);
            }
            function U(e3) {
              return B.has(e3);
            }
            function $(e3, t3) {
              return F(e3, t3) || U(e3);
            }
            function q(e3) {
              return L.has(e3);
            }
            const V = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
            class W {
              constructor(e3) {
                this.var = new Set(), this.lexical = new Set(), this.functions = new Set(), this.flags = e3;
              }
            }
            class K {
              constructor(e3, t3) {
                this.scopeStack = [], this.undefinedExports = new Map(), this.undefinedPrivateNames = new Map(), this.raise = e3, this.inModule = t3;
              }
              get inFunction() {
                return (2 & this.currentVarScopeFlags()) > 0;
              }
              get allowSuper() {
                return (16 & this.currentThisScopeFlags()) > 0;
              }
              get allowDirectSuper() {
                return (32 & this.currentThisScopeFlags()) > 0;
              }
              get inClass() {
                return (64 & this.currentThisScopeFlags()) > 0;
              }
              get inClassAndNotInNonArrowFunction() {
                const e3 = this.currentThisScopeFlags();
                return (64 & e3) > 0 && (2 & e3) == 0;
              }
              get inStaticBlock() {
                return (128 & this.currentThisScopeFlags()) > 0;
              }
              get inNonArrowFunction() {
                return (2 & this.currentThisScopeFlags()) > 0;
              }
              get treatFunctionsAsVar() {
                return this.treatFunctionsAsVarInScope(this.currentScope());
              }
              createScope(e3) {
                return new W(e3);
              }
              enter(e3) {
                this.scopeStack.push(this.createScope(e3));
              }
              exit() {
                this.scopeStack.pop();
              }
              treatFunctionsAsVarInScope(e3) {
                return !!(2 & e3.flags || !this.inModule && 1 & e3.flags);
              }
              declareName(e3, t3, r3) {
                let n2 = this.currentScope();
                if (8 & t3 || 16 & t3)
                  this.checkRedeclarationInScope(n2, e3, t3, r3), 16 & t3 ? n2.functions.add(e3) : n2.lexical.add(e3), 8 & t3 && this.maybeExportDefined(n2, e3);
                else if (4 & t3)
                  for (let s3 = this.scopeStack.length - 1; s3 >= 0 && (n2 = this.scopeStack[s3], this.checkRedeclarationInScope(n2, e3, t3, r3), n2.var.add(e3), this.maybeExportDefined(n2, e3), !(259 & n2.flags)); --s3)
                    ;
                this.inModule && 1 & n2.flags && this.undefinedExports.delete(e3);
              }
              maybeExportDefined(e3, t3) {
                this.inModule && 1 & e3.flags && this.undefinedExports.delete(t3);
              }
              checkRedeclarationInScope(e3, t3, r3, n2) {
                this.isRedeclaredInScope(e3, t3, r3) && this.raise(n2, x.VarRedeclaration, t3);
              }
              isRedeclaredInScope(e3, t3, r3) {
                return !!(1 & r3) && (8 & r3 ? e3.lexical.has(t3) || e3.functions.has(t3) || e3.var.has(t3) : 16 & r3 ? e3.lexical.has(t3) || !this.treatFunctionsAsVarInScope(e3) && e3.var.has(t3) : e3.lexical.has(t3) && !(8 & e3.flags && e3.lexical.values().next().value === t3) || !this.treatFunctionsAsVarInScope(e3) && e3.functions.has(t3));
              }
              checkLocalExport(e3) {
                const { name: t3 } = e3, r3 = this.scopeStack[0];
                r3.lexical.has(t3) || r3.var.has(t3) || r3.functions.has(t3) || this.undefinedExports.set(t3, e3.start);
              }
              currentScope() {
                return this.scopeStack[this.scopeStack.length - 1];
              }
              currentVarScopeFlags() {
                for (let e3 = this.scopeStack.length - 1; ; e3--) {
                  const { flags: t3 } = this.scopeStack[e3];
                  if (259 & t3)
                    return t3;
                }
              }
              currentThisScopeFlags() {
                for (let e3 = this.scopeStack.length - 1; ; e3--) {
                  const { flags: t3 } = this.scopeStack[e3];
                  if (323 & t3 && !(4 & t3))
                    return t3;
                }
              }
            }
            class G extends W {
              constructor(...e3) {
                super(...e3), this.declareFunctions = new Set();
              }
            }
            class H extends K {
              createScope(e3) {
                return new G(e3);
              }
              declareName(e3, t3, r3) {
                const n2 = this.currentScope();
                if (2048 & t3)
                  return this.checkRedeclarationInScope(n2, e3, t3, r3), this.maybeExportDefined(n2, e3), void n2.declareFunctions.add(e3);
                super.declareName(...arguments);
              }
              isRedeclaredInScope(e3, t3, r3) {
                return !!super.isRedeclaredInScope(...arguments) || !!(2048 & r3) && !e3.declareFunctions.has(t3) && (e3.lexical.has(t3) || e3.functions.has(t3));
              }
              checkLocalExport(e3) {
                this.scopeStack[0].declareFunctions.has(e3.name) || super.checkLocalExport(e3);
              }
            }
            const J = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]), Y = T({ AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.", AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.", AssignReservedType: "Cannot overwrite reserved type %0.", DeclareClassElement: "The `declare` modifier can only appear on class fields.", DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.", DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.", EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.", EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.", EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.", EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.", EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.", EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.", EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.", EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.", EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.", EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.", GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.", ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.", InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.", InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.", InexactVariance: "Explicit inexact syntax cannot have variance.", InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.", MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.", NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.", NestedFlowComment: "Cannot have a flow comment inside another flow comment.", OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.", SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.", SpreadVariance: "Spread properties cannot have variance.", ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.", ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.", ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.", ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.", ThisParamNoDefault: "The `this` parameter may not have a default value.", TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.", UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.", UnexpectedReservedType: "Unexpected reserved type %0.", UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.", UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.", UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.", UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".', UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.", UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.", UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.", UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.", UnterminatedFlowComment: "Unterminated flow-comment." }, E.SyntaxError);
            function X(e3) {
              return e3.importKind === "type" || e3.importKind === "typeof";
            }
            function z(e3) {
              return (e3.type === p2.name || !!e3.type.keyword) && e3.value !== "from";
            }
            const Q = { const: "declare export var", let: "declare export var", type: "export type", interface: "export interface" }, Z = /\*?\s*@((?:no)?flow)\b/, ee = { quot: '"', amp: "&", apos: "'", lt: "<", gt: ">", nbsp: "\xA0", iexcl: "\xA1", cent: "\xA2", pound: "\xA3", curren: "\xA4", yen: "\xA5", brvbar: "\xA6", sect: "\xA7", uml: "\xA8", copy: "\xA9", ordf: "\xAA", laquo: "\xAB", not: "\xAC", shy: "\xAD", reg: "\xAE", macr: "\xAF", deg: "\xB0", plusmn: "\xB1", sup2: "\xB2", sup3: "\xB3", acute: "\xB4", micro: "\xB5", para: "\xB6", middot: "\xB7", cedil: "\xB8", sup1: "\xB9", ordm: "\xBA", raquo: "\xBB", frac14: "\xBC", frac12: "\xBD", frac34: "\xBE", iquest: "\xBF", Agrave: "\xC0", Aacute: "\xC1", Acirc: "\xC2", Atilde: "\xC3", Auml: "\xC4", Aring: "\xC5", AElig: "\xC6", Ccedil: "\xC7", Egrave: "\xC8", Eacute: "\xC9", Ecirc: "\xCA", Euml: "\xCB", Igrave: "\xCC", Iacute: "\xCD", Icirc: "\xCE", Iuml: "\xCF", ETH: "\xD0", Ntilde: "\xD1", Ograve: "\xD2", Oacute: "\xD3", Ocirc: "\xD4", Otilde: "\xD5", Ouml: "\xD6", times: "\xD7", Oslash: "\xD8", Ugrave: "\xD9", Uacute: "\xDA", Ucirc: "\xDB", Uuml: "\xDC", Yacute: "\xDD", THORN: "\xDE", szlig: "\xDF", agrave: "\xE0", aacute: "\xE1", acirc: "\xE2", atilde: "\xE3", auml: "\xE4", aring: "\xE5", aelig: "\xE6", ccedil: "\xE7", egrave: "\xE8", eacute: "\xE9", ecirc: "\xEA", euml: "\xEB", igrave: "\xEC", iacute: "\xED", icirc: "\xEE", iuml: "\xEF", eth: "\xF0", ntilde: "\xF1", ograve: "\xF2", oacute: "\xF3", ocirc: "\xF4", otilde: "\xF5", ouml: "\xF6", divide: "\xF7", oslash: "\xF8", ugrave: "\xF9", uacute: "\xFA", ucirc: "\xFB", uuml: "\xFC", yacute: "\xFD", thorn: "\xFE", yuml: "\xFF", OElig: "\u0152", oelig: "\u0153", Scaron: "\u0160", scaron: "\u0161", Yuml: "\u0178", fnof: "\u0192", circ: "\u02C6", tilde: "\u02DC", Alpha: "\u0391", Beta: "\u0392", Gamma: "\u0393", Delta: "\u0394", Epsilon: "\u0395", Zeta: "\u0396", Eta: "\u0397", Theta: "\u0398", Iota: "\u0399", Kappa: "\u039A", Lambda: "\u039B", Mu: "\u039C", Nu: "\u039D", Xi: "\u039E", Omicron: "\u039F", Pi: "\u03A0", Rho: "\u03A1", Sigma: "\u03A3", Tau: "\u03A4", Upsilon: "\u03A5", Phi: "\u03A6", Chi: "\u03A7", Psi: "\u03A8", Omega: "\u03A9", alpha: "\u03B1", beta: "\u03B2", gamma: "\u03B3", delta: "\u03B4", epsilon: "\u03B5", zeta: "\u03B6", eta: "\u03B7", theta: "\u03B8", iota: "\u03B9", kappa: "\u03BA", lambda: "\u03BB", mu: "\u03BC", nu: "\u03BD", xi: "\u03BE", omicron: "\u03BF", pi: "\u03C0", rho: "\u03C1", sigmaf: "\u03C2", sigma: "\u03C3", tau: "\u03C4", upsilon: "\u03C5", phi: "\u03C6", chi: "\u03C7", psi: "\u03C8", omega: "\u03C9", thetasym: "\u03D1", upsih: "\u03D2", piv: "\u03D6", ensp: "\u2002", emsp: "\u2003", thinsp: "\u2009", zwnj: "\u200C", zwj: "\u200D", lrm: "\u200E", rlm: "\u200F", ndash: "\u2013", mdash: "\u2014", lsquo: "\u2018", rsquo: "\u2019", sbquo: "\u201A", ldquo: "\u201C", rdquo: "\u201D", bdquo: "\u201E", dagger: "\u2020", Dagger: "\u2021", bull: "\u2022", hellip: "\u2026", permil: "\u2030", prime: "\u2032", Prime: "\u2033", lsaquo: "\u2039", rsaquo: "\u203A", oline: "\u203E", frasl: "\u2044", euro: "\u20AC", image: "\u2111", weierp: "\u2118", real: "\u211C", trade: "\u2122", alefsym: "\u2135", larr: "\u2190", uarr: "\u2191", rarr: "\u2192", darr: "\u2193", harr: "\u2194", crarr: "\u21B5", lArr: "\u21D0", uArr: "\u21D1", rArr: "\u21D2", dArr: "\u21D3", hArr: "\u21D4", forall: "\u2200", part: "\u2202", exist: "\u2203", empty: "\u2205", nabla: "\u2207", isin: "\u2208", notin: "\u2209", ni: "\u220B", prod: "\u220F", sum: "\u2211", minus: "\u2212", lowast: "\u2217", radic: "\u221A", prop: "\u221D", infin: "\u221E", ang: "\u2220", and: "\u2227", or: "\u2228", cap: "\u2229", cup: "\u222A", int: "\u222B", there4: "\u2234", sim: "\u223C", cong: "\u2245", asymp: "\u2248", ne: "\u2260", equiv: "\u2261", le: "\u2264", ge: "\u2265", sub: "\u2282", sup: "\u2283", nsub: "\u2284", sube: "\u2286", supe: "\u2287", oplus: "\u2295", otimes: "\u2297", perp: "\u22A5", sdot: "\u22C5", lceil: "\u2308", rceil: "\u2309", lfloor: "\u230A", rfloor: "\u230B", lang: "\u2329", rang: "\u232A", loz: "\u25CA", spades: "\u2660", clubs: "\u2663", hearts: "\u2665", diams: "\u2666" };
            class te {
              constructor() {
                this.strict = void 0, this.curLine = void 0, this.startLoc = void 0, this.endLoc = void 0, this.errors = [], this.potentialArrowAt = -1, this.noArrowAt = [], this.noArrowParamsConversionAt = [], this.maybeInArrowParameters = false, this.inPipeline = false, this.inType = false, this.noAnonFunctionType = false, this.inPropertyName = false, this.hasFlowComment = false, this.isAmbientContext = false, this.inAbstractClass = false, this.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null }, this.soloAwait = false, this.inFSharpPipelineDirectBody = false, this.labels = [], this.decoratorStack = [[]], this.comments = [], this.trailingComments = [], this.leadingComments = [], this.commentStack = [], this.commentPreviousNode = null, this.pos = 0, this.lineStart = 0, this.type = p2.eof, this.value = null, this.start = 0, this.end = 0, this.lastTokEndLoc = null, this.lastTokStartLoc = null, this.lastTokStart = 0, this.lastTokEnd = 0, this.context = [P.brace], this.exprAllowed = true, this.containsEsc = false, this.strictErrors = new Map(), this.tokensLength = 0;
              }
              init(e3) {
                this.strict = e3.strictMode !== false && e3.sourceType === "module", this.curLine = e3.startLine, this.startLoc = this.endLoc = this.curPosition();
              }
              curPosition() {
                return new g(this.curLine, this.pos - this.lineStart);
              }
              clone(e3) {
                const t3 = new te(), r3 = Object.keys(this);
                for (let n2 = 0, s3 = r3.length; n2 < s3; n2++) {
                  const s4 = r3[n2];
                  let i2 = this[s4];
                  !e3 && Array.isArray(i2) && (i2 = i2.slice()), t3[s4] = i2;
                }
                return t3;
              }
            }
            const re = /^[\da-fA-F]+$/, ne = /^\d+$/, se = T({ AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.", MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.", MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.", UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?", UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.", UnterminatedJsxContent: "Unterminated JSX contents.", UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?" }, E.SyntaxError);
            function ie(e3) {
              return !!e3 && (e3.type === "JSXOpeningFragment" || e3.type === "JSXClosingFragment");
            }
            function oe(e3) {
              if (e3.type === "JSXIdentifier")
                return e3.name;
              if (e3.type === "JSXNamespacedName")
                return e3.namespace.name + ":" + e3.name.name;
              if (e3.type === "JSXMemberExpression")
                return oe(e3.object) + "." + oe(e3.property);
              throw new Error("Node had unexpected type: " + e3.type);
            }
            P.j_oTag = new w("<tag"), P.j_cTag = new w("</tag"), P.j_expr = new w("<tag>...</tag>", true), p2.jsxName = new a("jsxName"), p2.jsxText = new a("jsxText", { beforeExpr: true }), p2.jsxTagStart = new a("jsxTagStart", { startsExpr: true }), p2.jsxTagEnd = new a("jsxTagEnd"), p2.jsxTagStart.updateContext = (e3) => {
              e3.push(P.j_expr, P.j_oTag);
            };
            class ae extends W {
              constructor(...e3) {
                super(...e3), this.types = new Set(), this.enums = new Set(), this.constEnums = new Set(), this.classes = new Set(), this.exportOnlyBindings = new Set();
              }
            }
            class le extends K {
              createScope(e3) {
                return new ae(e3);
              }
              declareName(e3, t3, r3) {
                const n2 = this.currentScope();
                if (1024 & t3)
                  return this.maybeExportDefined(n2, e3), void n2.exportOnlyBindings.add(e3);
                super.declareName(...arguments), 2 & t3 && (1 & t3 || (this.checkRedeclarationInScope(n2, e3, t3, r3), this.maybeExportDefined(n2, e3)), n2.types.add(e3)), 256 & t3 && n2.enums.add(e3), 512 & t3 && n2.constEnums.add(e3), 128 & t3 && n2.classes.add(e3);
              }
              isRedeclaredInScope(e3, t3, r3) {
                return e3.enums.has(t3) ? !(256 & r3) || !!(512 & r3) !== e3.constEnums.has(t3) : 128 & r3 && e3.classes.has(t3) ? !!e3.lexical.has(t3) && !!(1 & r3) : !!(2 & r3 && e3.types.has(t3)) || super.isRedeclaredInScope(...arguments);
              }
              checkLocalExport(e3) {
                const t3 = this.scopeStack[0], { name: r3 } = e3;
                t3.types.has(r3) || t3.exportOnlyBindings.has(r3) || super.checkLocalExport(e3);
              }
            }
            class ce {
              constructor() {
                this.stacks = [];
              }
              enter(e3) {
                this.stacks.push(e3);
              }
              exit() {
                this.stacks.pop();
              }
              currentFlags() {
                return this.stacks[this.stacks.length - 1];
              }
              get hasAwait() {
                return (2 & this.currentFlags()) > 0;
              }
              get hasYield() {
                return (1 & this.currentFlags()) > 0;
              }
              get hasReturn() {
                return (4 & this.currentFlags()) > 0;
              }
              get hasIn() {
                return (8 & this.currentFlags()) > 0;
              }
            }
            function ue(e3, t3) {
              return (e3 ? 2 : 0) | (t3 ? 1 : 0);
            }
            function pe(e3) {
              if (e3 == null)
                throw new Error(`Unexpected ${e3} value.`);
              return e3;
            }
            function fe(e3) {
              if (!e3)
                throw new Error("Assert fail");
            }
            const de = T({ AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.", AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.", AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.", ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.", ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.", ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.", DeclareAccessor: "'declare' is not allowed in %0ters.", DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.", DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.", DuplicateAccessibilityModifier: "Accessibility modifier already seen.", DuplicateModifier: "Duplicate modifier: '%0'.", EmptyHeritageClauseType: "'%0' list cannot be empty.", EmptyTypeArguments: "Type argument list cannot be empty.", EmptyTypeParameters: "Type parameter list cannot be empty.", ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.", ImportAliasHasImportType: "An import alias can not use 'import type'.", IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.", IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.", IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').", IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.", IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.", IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.", InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.", InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.", InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.", MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.", NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.", NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.", OptionalTypeBeforeRequired: "A required element cannot follow an optional element.", OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.", PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.", PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.", PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').", ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.", SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.", SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.", SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.", StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.", TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.", TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.", UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.", UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.", UnexpectedTypeAnnotation: "Did not expect a type annotation here.", UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.", UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.", UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.", UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0." }, E.SyntaxError);
            function he(e3) {
              return e3 === "private" || e3 === "public" || e3 === "protected";
            }
            p2.placeholder = new a("%%", { startsExpr: true });
            const me = T({ ClassNameIsRequired: "A class name is required." }, E.SyntaxError);
            function ye(e3, t3) {
              return e3.some((e4) => Array.isArray(e4) ? e4[0] === t3 : e4 === t3);
            }
            function ge(e3, t3, r3) {
              const n2 = e3.find((e4) => Array.isArray(e4) ? e4[0] === t3 : e4 === t3);
              return n2 && Array.isArray(n2) ? n2[1][r3] : null;
            }
            const be = ["minimal", "smart", "fsharp"], ve = ["hash", "bar"], Ee = { estree: (e3) => class extends e3 {
              parseRegExpLiteral({ pattern: e4, flags: t3 }) {
                let r3 = null;
                try {
                  r3 = new RegExp(e4, t3);
                } catch (e5) {
                }
                const n2 = this.estreeParseLiteral(r3);
                return n2.regex = { pattern: e4, flags: t3 }, n2;
              }
              parseBigIntLiteral(e4) {
                let t3;
                try {
                  t3 = BigInt(e4);
                } catch (e5) {
                  t3 = null;
                }
                const r3 = this.estreeParseLiteral(t3);
                return r3.bigint = String(r3.value || e4), r3;
              }
              parseDecimalLiteral(e4) {
                const t3 = this.estreeParseLiteral(null);
                return t3.decimal = String(t3.value || e4), t3;
              }
              estreeParseLiteral(e4) {
                return this.parseLiteral(e4, "Literal");
              }
              parseStringLiteral(e4) {
                return this.estreeParseLiteral(e4);
              }
              parseNumericLiteral(e4) {
                return this.estreeParseLiteral(e4);
              }
              parseNullLiteral() {
                return this.estreeParseLiteral(null);
              }
              parseBooleanLiteral(e4) {
                return this.estreeParseLiteral(e4);
              }
              directiveToStmt(e4) {
                const t3 = e4.value, r3 = this.startNodeAt(e4.start, e4.loc.start), n2 = this.startNodeAt(t3.start, t3.loc.start);
                return n2.value = t3.extra.expressionValue, n2.raw = t3.extra.raw, r3.expression = this.finishNodeAt(n2, "Literal", t3.end, t3.loc.end), r3.directive = t3.extra.raw.slice(1, -1), this.finishNodeAt(r3, "ExpressionStatement", e4.end, e4.loc.end);
              }
              initFunction(e4, t3) {
                super.initFunction(e4, t3), e4.expression = false;
              }
              checkDeclaration(e4) {
                e4 != null && this.isObjectProperty(e4) ? this.checkDeclaration(e4.value) : super.checkDeclaration(e4);
              }
              getObjectOrClassMethodParams(e4) {
                return e4.value.params;
              }
              isValidDirective(e4) {
                var t3;
                return e4.type === "ExpressionStatement" && e4.expression.type === "Literal" && typeof e4.expression.value == "string" && !((t3 = e4.expression.extra) != null && t3.parenthesized);
              }
              stmtToDirective(e4) {
                const t3 = super.stmtToDirective(e4), r3 = e4.expression.value;
                return this.addExtra(t3.value, "expressionValue", r3), t3;
              }
              parseBlockBody(e4, ...t3) {
                super.parseBlockBody(e4, ...t3);
                const r3 = e4.directives.map((e5) => this.directiveToStmt(e5));
                e4.body = r3.concat(e4.body), delete e4.directives;
              }
              pushClassMethod(e4, t3, r3, n2, s3, i2) {
                this.parseMethod(t3, r3, n2, s3, i2, "ClassMethod", true), t3.typeParameters && (t3.value.typeParameters = t3.typeParameters, delete t3.typeParameters), e4.body.push(t3);
              }
              parseMaybePrivateName(...e4) {
                const t3 = super.parseMaybePrivateName(...e4);
                return t3.type === "PrivateName" && this.getPluginOption("estree", "classFeatures") ? this.convertPrivateNameToPrivateIdentifier(t3) : t3;
              }
              convertPrivateNameToPrivateIdentifier(e4) {
                const t3 = super.getPrivateNameSV(e4);
                return delete (e4 = e4).id, e4.name = t3, e4.type = "PrivateIdentifier", e4;
              }
              isPrivateName(e4) {
                return this.getPluginOption("estree", "classFeatures") ? e4.type === "PrivateIdentifier" : super.isPrivateName(e4);
              }
              getPrivateNameSV(e4) {
                return this.getPluginOption("estree", "classFeatures") ? e4.name : super.getPrivateNameSV(e4);
              }
              parseLiteral(e4, t3) {
                const r3 = super.parseLiteral(e4, t3);
                return r3.raw = r3.extra.raw, delete r3.extra, r3;
              }
              parseFunctionBody(e4, t3, r3 = false) {
                super.parseFunctionBody(e4, t3, r3), e4.expression = e4.body.type !== "BlockStatement";
              }
              parseMethod(e4, t3, r3, n2, s3, i2, o2 = false) {
                let a2 = this.startNode();
                return a2.kind = e4.kind, a2 = super.parseMethod(a2, t3, r3, n2, s3, i2, o2), a2.type = "FunctionExpression", delete a2.kind, e4.value = a2, i2 === "ClassPrivateMethod" && (e4.computed = false), i2 = "MethodDefinition", this.finishNode(e4, i2);
              }
              parseClassProperty(...e4) {
                const t3 = super.parseClassProperty(...e4);
                return this.getPluginOption("estree", "classFeatures") && (t3.type = "PropertyDefinition"), t3;
              }
              parseClassPrivateProperty(...e4) {
                const t3 = super.parseClassPrivateProperty(...e4);
                return this.getPluginOption("estree", "classFeatures") && (t3.type = "PropertyDefinition", t3.computed = false), t3;
              }
              parseObjectMethod(e4, t3, r3, n2, s3) {
                const i2 = super.parseObjectMethod(e4, t3, r3, n2, s3);
                return i2 && (i2.type = "Property", i2.kind === "method" && (i2.kind = "init"), i2.shorthand = false), i2;
              }
              parseObjectProperty(e4, t3, r3, n2, s3) {
                const i2 = super.parseObjectProperty(e4, t3, r3, n2, s3);
                return i2 && (i2.kind = "init", i2.type = "Property"), i2;
              }
              toAssignable(e4, t3 = false) {
                return e4 != null && this.isObjectProperty(e4) ? (this.toAssignable(e4.value, t3), e4) : super.toAssignable(e4, t3);
              }
              toAssignableObjectExpressionProp(e4, ...t3) {
                e4.kind === "get" || e4.kind === "set" ? this.raise(e4.key.start, x.PatternHasAccessor) : e4.method ? this.raise(e4.key.start, x.PatternHasMethod) : super.toAssignableObjectExpressionProp(e4, ...t3);
              }
              finishCallExpression(e4, t3) {
                var r3;
                (super.finishCallExpression(e4, t3), e4.callee.type === "Import") && (e4.type = "ImportExpression", e4.source = e4.arguments[0], this.hasPlugin("importAssertions") && (e4.attributes = (r3 = e4.arguments[1]) != null ? r3 : null), delete e4.arguments, delete e4.callee);
                return e4;
              }
              toReferencedArguments(e4) {
                e4.type !== "ImportExpression" && super.toReferencedArguments(e4);
              }
              parseExport(e4) {
                switch (super.parseExport(e4), e4.type) {
                  case "ExportAllDeclaration":
                    e4.exported = null;
                    break;
                  case "ExportNamedDeclaration":
                    e4.specifiers.length === 1 && e4.specifiers[0].type === "ExportNamespaceSpecifier" && (e4.type = "ExportAllDeclaration", e4.exported = e4.specifiers[0].exported, delete e4.specifiers);
                }
                return e4;
              }
              parseSubscript(e4, t3, r3, n2, s3) {
                const i2 = super.parseSubscript(e4, t3, r3, n2, s3);
                if (s3.optionalChainMember) {
                  if (i2.type !== "OptionalMemberExpression" && i2.type !== "OptionalCallExpression" || (i2.type = i2.type.substring(8)), s3.stop) {
                    const e5 = this.startNodeAtNode(i2);
                    return e5.expression = i2, this.finishNode(e5, "ChainExpression");
                  }
                } else
                  i2.type !== "MemberExpression" && i2.type !== "CallExpression" || (i2.optional = false);
                return i2;
              }
              hasPropertyAsPrivateName(e4) {
                return e4.type === "ChainExpression" && (e4 = e4.expression), super.hasPropertyAsPrivateName(e4);
              }
              isOptionalChain(e4) {
                return e4.type === "ChainExpression";
              }
              isObjectProperty(e4) {
                return e4.type === "Property" && e4.kind === "init" && !e4.method;
              }
              isObjectMethod(e4) {
                return e4.method || e4.kind === "get" || e4.kind === "set";
              }
            }, jsx: (e3) => class extends e3 {
              jsxReadToken() {
                let e4 = "", t3 = this.state.pos;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(this.state.start, se.UnterminatedJsxContent);
                  const r3 = this.input.charCodeAt(this.state.pos);
                  switch (r3) {
                    case 60:
                    case 123:
                      return this.state.pos === this.state.start ? r3 === 60 && this.state.exprAllowed ? (++this.state.pos, this.finishToken(p2.jsxTagStart)) : super.getTokenFromCode(r3) : (e4 += this.input.slice(t3, this.state.pos), this.finishToken(p2.jsxText, e4));
                    case 38:
                      e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadEntity(), t3 = this.state.pos;
                      break;
                    case 62:
                    case 125:
                    default:
                      h3(r3) ? (e4 += this.input.slice(t3, this.state.pos), e4 += this.jsxReadNewLine(true), t3 = this.state.pos) : ++this.state.pos;
                  }
                }
              }
              jsxReadNewLine(e4) {
                const t3 = this.input.charCodeAt(this.state.pos);
                let r3;
                return ++this.state.pos, t3 === 13 && this.input.charCodeAt(this.state.pos) === 10 ? (++this.state.pos, r3 = e4 ? "\n" : "\r\n") : r3 = String.fromCharCode(t3), ++this.state.curLine, this.state.lineStart = this.state.pos, r3;
              }
              jsxReadString(e4) {
                let t3 = "", r3 = ++this.state.pos;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(this.state.start, x.UnterminatedString);
                  const n2 = this.input.charCodeAt(this.state.pos);
                  if (n2 === e4)
                    break;
                  n2 === 38 ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadEntity(), r3 = this.state.pos) : h3(n2) ? (t3 += this.input.slice(r3, this.state.pos), t3 += this.jsxReadNewLine(false), r3 = this.state.pos) : ++this.state.pos;
                }
                return t3 += this.input.slice(r3, this.state.pos++), this.finishToken(p2.string, t3);
              }
              jsxReadEntity() {
                let e4, t3 = "", r3 = 0, n2 = this.input[this.state.pos];
                const s3 = ++this.state.pos;
                for (; this.state.pos < this.length && r3++ < 10; ) {
                  if (n2 = this.input[this.state.pos++], n2 === ";") {
                    t3[0] === "#" ? t3[1] === "x" ? (t3 = t3.substr(2), re.test(t3) && (e4 = String.fromCodePoint(parseInt(t3, 16)))) : (t3 = t3.substr(1), ne.test(t3) && (e4 = String.fromCodePoint(parseInt(t3, 10)))) : e4 = ee[t3];
                    break;
                  }
                  t3 += n2;
                }
                return e4 || (this.state.pos = s3, "&");
              }
              jsxReadWord() {
                let e4;
                const t3 = this.state.pos;
                do {
                  e4 = this.input.charCodeAt(++this.state.pos);
                } while (D(e4) || e4 === 45);
                return this.finishToken(p2.jsxName, this.input.slice(t3, this.state.pos));
              }
              jsxParseIdentifier() {
                const e4 = this.startNode();
                return this.match(p2.jsxName) ? e4.name = this.state.value : this.state.type.keyword ? e4.name = this.state.type.keyword : this.unexpected(), this.next(), this.finishNode(e4, "JSXIdentifier");
              }
              jsxParseNamespacedName() {
                const e4 = this.state.start, t3 = this.state.startLoc, r3 = this.jsxParseIdentifier();
                if (!this.eat(p2.colon))
                  return r3;
                const n2 = this.startNodeAt(e4, t3);
                return n2.namespace = r3, n2.name = this.jsxParseIdentifier(), this.finishNode(n2, "JSXNamespacedName");
              }
              jsxParseElementName() {
                const e4 = this.state.start, t3 = this.state.startLoc;
                let r3 = this.jsxParseNamespacedName();
                if (r3.type === "JSXNamespacedName")
                  return r3;
                for (; this.eat(p2.dot); ) {
                  const n2 = this.startNodeAt(e4, t3);
                  n2.object = r3, n2.property = this.jsxParseIdentifier(), r3 = this.finishNode(n2, "JSXMemberExpression");
                }
                return r3;
              }
              jsxParseAttributeValue() {
                let e4;
                switch (this.state.type) {
                  case p2.braceL:
                    return e4 = this.startNode(), this.next(), e4 = this.jsxParseExpressionContainer(e4), e4.expression.type === "JSXEmptyExpression" && this.raise(e4.start, se.AttributeIsEmpty), e4;
                  case p2.jsxTagStart:
                  case p2.string:
                    return this.parseExprAtom();
                  default:
                    throw this.raise(this.state.start, se.UnsupportedJsxValue);
                }
              }
              jsxParseEmptyExpression() {
                const e4 = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
                return this.finishNodeAt(e4, "JSXEmptyExpression", this.state.start, this.state.startLoc);
              }
              jsxParseSpreadChild(e4) {
                return this.next(), e4.expression = this.parseExpression(), this.expect(p2.braceR), this.finishNode(e4, "JSXSpreadChild");
              }
              jsxParseExpressionContainer(e4) {
                if (this.match(p2.braceR))
                  e4.expression = this.jsxParseEmptyExpression();
                else {
                  const t3 = this.parseExpression();
                  e4.expression = t3;
                }
                return this.expect(p2.braceR), this.finishNode(e4, "JSXExpressionContainer");
              }
              jsxParseAttribute() {
                const e4 = this.startNode();
                return this.eat(p2.braceL) ? (this.expect(p2.ellipsis), e4.argument = this.parseMaybeAssignAllowIn(), this.expect(p2.braceR), this.finishNode(e4, "JSXSpreadAttribute")) : (e4.name = this.jsxParseNamespacedName(), e4.value = this.eat(p2.eq) ? this.jsxParseAttributeValue() : null, this.finishNode(e4, "JSXAttribute"));
              }
              jsxParseOpeningElementAt(e4, t3) {
                const r3 = this.startNodeAt(e4, t3);
                return this.match(p2.jsxTagEnd) ? (this.expect(p2.jsxTagEnd), this.finishNode(r3, "JSXOpeningFragment")) : (r3.name = this.jsxParseElementName(), this.jsxParseOpeningElementAfterName(r3));
              }
              jsxParseOpeningElementAfterName(e4) {
                const t3 = [];
                for (; !this.match(p2.slash) && !this.match(p2.jsxTagEnd); )
                  t3.push(this.jsxParseAttribute());
                return e4.attributes = t3, e4.selfClosing = this.eat(p2.slash), this.expect(p2.jsxTagEnd), this.finishNode(e4, "JSXOpeningElement");
              }
              jsxParseClosingElementAt(e4, t3) {
                const r3 = this.startNodeAt(e4, t3);
                return this.match(p2.jsxTagEnd) ? (this.expect(p2.jsxTagEnd), this.finishNode(r3, "JSXClosingFragment")) : (r3.name = this.jsxParseElementName(), this.expect(p2.jsxTagEnd), this.finishNode(r3, "JSXClosingElement"));
              }
              jsxParseElementAt(e4, t3) {
                const r3 = this.startNodeAt(e4, t3), n2 = [], s3 = this.jsxParseOpeningElementAt(e4, t3);
                let i2 = null;
                if (!s3.selfClosing) {
                  e:
                    for (; ; )
                      switch (this.state.type) {
                        case p2.jsxTagStart:
                          if (e4 = this.state.start, t3 = this.state.startLoc, this.next(), this.eat(p2.slash)) {
                            i2 = this.jsxParseClosingElementAt(e4, t3);
                            break e;
                          }
                          n2.push(this.jsxParseElementAt(e4, t3));
                          break;
                        case p2.jsxText:
                          n2.push(this.parseExprAtom());
                          break;
                        case p2.braceL: {
                          const e5 = this.startNode();
                          this.next(), this.match(p2.ellipsis) ? n2.push(this.jsxParseSpreadChild(e5)) : n2.push(this.jsxParseExpressionContainer(e5));
                          break;
                        }
                        default:
                          throw this.unexpected();
                      }
                  ie(s3) && !ie(i2) ? this.raise(i2.start, se.MissingClosingTagFragment) : !ie(s3) && ie(i2) ? this.raise(i2.start, se.MissingClosingTagElement, oe(s3.name)) : ie(s3) || ie(i2) || oe(i2.name) !== oe(s3.name) && this.raise(i2.start, se.MissingClosingTagElement, oe(s3.name));
                }
                if (ie(s3) ? (r3.openingFragment = s3, r3.closingFragment = i2) : (r3.openingElement = s3, r3.closingElement = i2), r3.children = n2, this.isRelational("<"))
                  throw this.raise(this.state.start, se.UnwrappedAdjacentJSXElements);
                return ie(s3) ? this.finishNode(r3, "JSXFragment") : this.finishNode(r3, "JSXElement");
              }
              jsxParseElement() {
                const e4 = this.state.start, t3 = this.state.startLoc;
                return this.next(), this.jsxParseElementAt(e4, t3);
              }
              parseExprAtom(e4) {
                return this.match(p2.jsxText) ? this.parseLiteral(this.state.value, "JSXText") : this.match(p2.jsxTagStart) ? this.jsxParseElement() : this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33 ? (this.finishToken(p2.jsxTagStart), this.jsxParseElement()) : super.parseExprAtom(e4);
              }
              createLookaheadState(e4) {
                const t3 = super.createLookaheadState(e4);
                return t3.inPropertyName = e4.inPropertyName, t3;
              }
              getTokenFromCode(e4) {
                if (this.state.inPropertyName)
                  return super.getTokenFromCode(e4);
                const t3 = this.curContext();
                if (t3 === P.j_expr)
                  return this.jsxReadToken();
                if (t3 === P.j_oTag || t3 === P.j_cTag) {
                  if (j(e4))
                    return this.jsxReadWord();
                  if (e4 === 62)
                    return ++this.state.pos, this.finishToken(p2.jsxTagEnd);
                  if ((e4 === 34 || e4 === 39) && t3 === P.j_oTag)
                    return this.jsxReadString(e4);
                }
                return e4 === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33 ? (++this.state.pos, this.finishToken(p2.jsxTagStart)) : super.getTokenFromCode(e4);
              }
              updateContext(e4) {
                super.updateContext(e4);
                const { context: t3, type: r3 } = this.state;
                if (r3 === p2.slash && e4 === p2.jsxTagStart)
                  t3.splice(-2, 2, P.j_cTag), this.state.exprAllowed = false;
                else if (r3 === p2.jsxTagEnd) {
                  const r4 = t3.pop();
                  r4 === P.j_oTag && e4 === p2.slash || r4 === P.j_cTag ? (t3.pop(), this.state.exprAllowed = t3[t3.length - 1] === P.j_expr) : this.state.exprAllowed = true;
                } else
                  !r3.keyword || e4 !== p2.dot && e4 !== p2.questionDot ? this.state.exprAllowed = r3.beforeExpr : this.state.exprAllowed = false;
              }
            }, flow: (e3) => class extends e3 {
              constructor(...e4) {
                super(...e4), this.flowPragma = void 0;
              }
              getScopeHandler() {
                return H;
              }
              shouldParseTypes() {
                return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
              }
              shouldParseEnums() {
                return !!this.getPluginOption("flow", "enums");
              }
              finishToken(e4, t3) {
                return e4 !== p2.string && e4 !== p2.semi && e4 !== p2.interpreterDirective && this.flowPragma === void 0 && (this.flowPragma = null), super.finishToken(e4, t3);
              }
              addComment(e4) {
                if (this.flowPragma === void 0) {
                  const t3 = Z.exec(e4.value);
                  if (t3)
                    if (t3[1] === "flow")
                      this.flowPragma = "flow";
                    else {
                      if (t3[1] !== "noflow")
                        throw new Error("Unexpected flow pragma");
                      this.flowPragma = "noflow";
                    }
                }
                return super.addComment(e4);
              }
              flowParseTypeInitialiser(e4) {
                const t3 = this.state.inType;
                this.state.inType = true, this.expect(e4 || p2.colon);
                const r3 = this.flowParseType();
                return this.state.inType = t3, r3;
              }
              flowParsePredicate() {
                const e4 = this.startNode(), t3 = this.state.start;
                return this.next(), this.expectContextual("checks"), this.state.lastTokStart > t3 + 1 && this.raise(t3, Y.UnexpectedSpaceBetweenModuloChecks), this.eat(p2.parenL) ? (e4.value = this.parseExpression(), this.expect(p2.parenR), this.finishNode(e4, "DeclaredPredicate")) : this.finishNode(e4, "InferredPredicate");
              }
              flowParseTypeAndPredicateInitialiser() {
                const e4 = this.state.inType;
                this.state.inType = true, this.expect(p2.colon);
                let t3 = null, r3 = null;
                return this.match(p2.modulo) ? (this.state.inType = e4, r3 = this.flowParsePredicate()) : (t3 = this.flowParseType(), this.state.inType = e4, this.match(p2.modulo) && (r3 = this.flowParsePredicate())), [t3, r3];
              }
              flowParseDeclareClass(e4) {
                return this.next(), this.flowParseInterfaceish(e4, true), this.finishNode(e4, "DeclareClass");
              }
              flowParseDeclareFunction(e4) {
                this.next();
                const t3 = e4.id = this.parseIdentifier(), r3 = this.startNode(), n2 = this.startNode();
                this.isRelational("<") ? r3.typeParameters = this.flowParseTypeParameterDeclaration() : r3.typeParameters = null, this.expect(p2.parenL);
                const s3 = this.flowParseFunctionTypeParams();
                return r3.params = s3.params, r3.rest = s3.rest, r3.this = s3._this, this.expect(p2.parenR), [r3.returnType, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), n2.typeAnnotation = this.finishNode(r3, "FunctionTypeAnnotation"), t3.typeAnnotation = this.finishNode(n2, "TypeAnnotation"), this.resetEndLocation(t3), this.semicolon(), this.scope.declareName(e4.id.name, 2048, e4.id.start), this.finishNode(e4, "DeclareFunction");
              }
              flowParseDeclare(e4, t3) {
                if (this.match(p2._class))
                  return this.flowParseDeclareClass(e4);
                if (this.match(p2._function))
                  return this.flowParseDeclareFunction(e4);
                if (this.match(p2._var))
                  return this.flowParseDeclareVariable(e4);
                if (this.eatContextual("module"))
                  return this.match(p2.dot) ? this.flowParseDeclareModuleExports(e4) : (t3 && this.raise(this.state.lastTokStart, Y.NestedDeclareModule), this.flowParseDeclareModule(e4));
                if (this.isContextual("type"))
                  return this.flowParseDeclareTypeAlias(e4);
                if (this.isContextual("opaque"))
                  return this.flowParseDeclareOpaqueType(e4);
                if (this.isContextual("interface"))
                  return this.flowParseDeclareInterface(e4);
                if (this.match(p2._export))
                  return this.flowParseDeclareExportDeclaration(e4, t3);
                throw this.unexpected();
              }
              flowParseDeclareVariable(e4) {
                return this.next(), e4.id = this.flowParseTypeAnnotatableIdentifier(true), this.scope.declareName(e4.id.name, 5, e4.id.start), this.semicolon(), this.finishNode(e4, "DeclareVariable");
              }
              flowParseDeclareModule(e4) {
                this.scope.enter(0), this.match(p2.string) ? e4.id = this.parseExprAtom() : e4.id = this.parseIdentifier();
                const t3 = e4.body = this.startNode(), r3 = t3.body = [];
                for (this.expect(p2.braceL); !this.match(p2.braceR); ) {
                  let e5 = this.startNode();
                  this.match(p2._import) ? (this.next(), this.isContextual("type") || this.match(p2._typeof) || this.raise(this.state.lastTokStart, Y.InvalidNonTypeImportInDeclareModule), this.parseImport(e5)) : (this.expectContextual("declare", Y.UnsupportedStatementInDeclareModule), e5 = this.flowParseDeclare(e5, true)), r3.push(e5);
                }
                this.scope.exit(), this.expect(p2.braceR), this.finishNode(t3, "BlockStatement");
                let n2 = null, s3 = false;
                return r3.forEach((e5) => {
                  !function(e6) {
                    return e6.type === "DeclareExportAllDeclaration" || e6.type === "DeclareExportDeclaration" && (!e6.declaration || e6.declaration.type !== "TypeAlias" && e6.declaration.type !== "InterfaceDeclaration");
                  }(e5) ? e5.type === "DeclareModuleExports" && (s3 && this.raise(e5.start, Y.DuplicateDeclareModuleExports), n2 === "ES" && this.raise(e5.start, Y.AmbiguousDeclareModuleKind), n2 = "CommonJS", s3 = true) : (n2 === "CommonJS" && this.raise(e5.start, Y.AmbiguousDeclareModuleKind), n2 = "ES");
                }), e4.kind = n2 || "CommonJS", this.finishNode(e4, "DeclareModule");
              }
              flowParseDeclareExportDeclaration(e4, t3) {
                if (this.expect(p2._export), this.eat(p2._default))
                  return this.match(p2._function) || this.match(p2._class) ? e4.declaration = this.flowParseDeclare(this.startNode()) : (e4.declaration = this.flowParseType(), this.semicolon()), e4.default = true, this.finishNode(e4, "DeclareExportDeclaration");
                if (this.match(p2._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !t3) {
                  const e5 = this.state.value, t4 = Q[e5];
                  throw this.raise(this.state.start, Y.UnsupportedDeclareExportKind, e5, t4);
                }
                if (this.match(p2._var) || this.match(p2._function) || this.match(p2._class) || this.isContextual("opaque"))
                  return e4.declaration = this.flowParseDeclare(this.startNode()), e4.default = false, this.finishNode(e4, "DeclareExportDeclaration");
                if (this.match(p2.star) || this.match(p2.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque"))
                  return (e4 = this.parseExport(e4)).type === "ExportNamedDeclaration" && (e4.type = "ExportDeclaration", e4.default = false, delete e4.exportKind), e4.type = "Declare" + e4.type, e4;
                throw this.unexpected();
              }
              flowParseDeclareModuleExports(e4) {
                return this.next(), this.expectContextual("exports"), e4.typeAnnotation = this.flowParseTypeAnnotation(), this.semicolon(), this.finishNode(e4, "DeclareModuleExports");
              }
              flowParseDeclareTypeAlias(e4) {
                return this.next(), this.flowParseTypeAlias(e4), e4.type = "DeclareTypeAlias", e4;
              }
              flowParseDeclareOpaqueType(e4) {
                return this.next(), this.flowParseOpaqueType(e4, true), e4.type = "DeclareOpaqueType", e4;
              }
              flowParseDeclareInterface(e4) {
                return this.next(), this.flowParseInterfaceish(e4), this.finishNode(e4, "DeclareInterface");
              }
              flowParseInterfaceish(e4, t3 = false) {
                if (e4.id = this.flowParseRestrictedIdentifier(!t3, true), this.scope.declareName(e4.id.name, t3 ? 17 : 9, e4.id.start), this.isRelational("<") ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.extends = [], e4.implements = [], e4.mixins = [], this.eat(p2._extends))
                  do {
                    e4.extends.push(this.flowParseInterfaceExtends());
                  } while (!t3 && this.eat(p2.comma));
                if (this.isContextual("mixins")) {
                  this.next();
                  do {
                    e4.mixins.push(this.flowParseInterfaceExtends());
                  } while (this.eat(p2.comma));
                }
                if (this.isContextual("implements")) {
                  this.next();
                  do {
                    e4.implements.push(this.flowParseInterfaceExtends());
                  } while (this.eat(p2.comma));
                }
                e4.body = this.flowParseObjectType({ allowStatic: t3, allowExact: false, allowSpread: false, allowProto: t3, allowInexact: false });
              }
              flowParseInterfaceExtends() {
                const e4 = this.startNode();
                return e4.id = this.flowParseQualifiedTypeIdentifier(), this.isRelational("<") ? e4.typeParameters = this.flowParseTypeParameterInstantiation() : e4.typeParameters = null, this.finishNode(e4, "InterfaceExtends");
              }
              flowParseInterface(e4) {
                return this.flowParseInterfaceish(e4), this.finishNode(e4, "InterfaceDeclaration");
              }
              checkNotUnderscore(e4) {
                e4 === "_" && this.raise(this.state.start, Y.UnexpectedReservedUnderscore);
              }
              checkReservedType(e4, t3, r3) {
                J.has(e4) && this.raise(t3, r3 ? Y.AssignReservedType : Y.UnexpectedReservedType, e4);
              }
              flowParseRestrictedIdentifier(e4, t3) {
                return this.checkReservedType(this.state.value, this.state.start, t3), this.parseIdentifier(e4);
              }
              flowParseTypeAlias(e4) {
                return e4.id = this.flowParseRestrictedIdentifier(false, true), this.scope.declareName(e4.id.name, 9, e4.id.start), this.isRelational("<") ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.right = this.flowParseTypeInitialiser(p2.eq), this.semicolon(), this.finishNode(e4, "TypeAlias");
              }
              flowParseOpaqueType(e4, t3) {
                return this.expectContextual("type"), e4.id = this.flowParseRestrictedIdentifier(true, true), this.scope.declareName(e4.id.name, 9, e4.id.start), this.isRelational("<") ? e4.typeParameters = this.flowParseTypeParameterDeclaration() : e4.typeParameters = null, e4.supertype = null, this.match(p2.colon) && (e4.supertype = this.flowParseTypeInitialiser(p2.colon)), e4.impltype = null, t3 || (e4.impltype = this.flowParseTypeInitialiser(p2.eq)), this.semicolon(), this.finishNode(e4, "OpaqueType");
              }
              flowParseTypeParameter(e4 = false) {
                const t3 = this.state.start, r3 = this.startNode(), n2 = this.flowParseVariance(), s3 = this.flowParseTypeAnnotatableIdentifier();
                return r3.name = s3.name, r3.variance = n2, r3.bound = s3.typeAnnotation, this.match(p2.eq) ? (this.eat(p2.eq), r3.default = this.flowParseType()) : e4 && this.raise(t3, Y.MissingTypeParamDefault), this.finishNode(r3, "TypeParameter");
              }
              flowParseTypeParameterDeclaration() {
                const e4 = this.state.inType, t3 = this.startNode();
                t3.params = [], this.state.inType = true, this.isRelational("<") || this.match(p2.jsxTagStart) ? this.next() : this.unexpected();
                let r3 = false;
                do {
                  const e5 = this.flowParseTypeParameter(r3);
                  t3.params.push(e5), e5.default && (r3 = true), this.isRelational(">") || this.expect(p2.comma);
                } while (!this.isRelational(">"));
                return this.expectRelational(">"), this.state.inType = e4, this.finishNode(t3, "TypeParameterDeclaration");
              }
              flowParseTypeParameterInstantiation() {
                const e4 = this.startNode(), t3 = this.state.inType;
                e4.params = [], this.state.inType = true, this.expectRelational("<");
                const r3 = this.state.noAnonFunctionType;
                for (this.state.noAnonFunctionType = false; !this.isRelational(">"); )
                  e4.params.push(this.flowParseType()), this.isRelational(">") || this.expect(p2.comma);
                return this.state.noAnonFunctionType = r3, this.expectRelational(">"), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
              }
              flowParseTypeParameterInstantiationCallOrNew() {
                const e4 = this.startNode(), t3 = this.state.inType;
                for (e4.params = [], this.state.inType = true, this.expectRelational("<"); !this.isRelational(">"); )
                  e4.params.push(this.flowParseTypeOrImplicitInstantiation()), this.isRelational(">") || this.expect(p2.comma);
                return this.expectRelational(">"), this.state.inType = t3, this.finishNode(e4, "TypeParameterInstantiation");
              }
              flowParseInterfaceType() {
                const e4 = this.startNode();
                if (this.expectContextual("interface"), e4.extends = [], this.eat(p2._extends))
                  do {
                    e4.extends.push(this.flowParseInterfaceExtends());
                  } while (this.eat(p2.comma));
                return e4.body = this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: false, allowProto: false, allowInexact: false }), this.finishNode(e4, "InterfaceTypeAnnotation");
              }
              flowParseObjectPropertyKey() {
                return this.match(p2.num) || this.match(p2.string) ? this.parseExprAtom() : this.parseIdentifier(true);
              }
              flowParseObjectTypeIndexer(e4, t3, r3) {
                return e4.static = t3, this.lookahead().type === p2.colon ? (e4.id = this.flowParseObjectPropertyKey(), e4.key = this.flowParseTypeInitialiser()) : (e4.id = null, e4.key = this.flowParseType()), this.expect(p2.bracketR), e4.value = this.flowParseTypeInitialiser(), e4.variance = r3, this.finishNode(e4, "ObjectTypeIndexer");
              }
              flowParseObjectTypeInternalSlot(e4, t3) {
                return e4.static = t3, e4.id = this.flowParseObjectPropertyKey(), this.expect(p2.bracketR), this.expect(p2.bracketR), this.isRelational("<") || this.match(p2.parenL) ? (e4.method = true, e4.optional = false, e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.start, e4.loc.start))) : (e4.method = false, this.eat(p2.question) && (e4.optional = true), e4.value = this.flowParseTypeInitialiser()), this.finishNode(e4, "ObjectTypeInternalSlot");
              }
              flowParseObjectTypeMethodish(e4) {
                for (e4.params = [], e4.rest = null, e4.typeParameters = null, e4.this = null, this.isRelational("<") && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), this.expect(p2.parenL), this.match(p2._this) && (e4.this = this.flowParseFunctionTypeParam(true), e4.this.name = null, this.match(p2.parenR) || this.expect(p2.comma)); !this.match(p2.parenR) && !this.match(p2.ellipsis); )
                  e4.params.push(this.flowParseFunctionTypeParam(false)), this.match(p2.parenR) || this.expect(p2.comma);
                return this.eat(p2.ellipsis) && (e4.rest = this.flowParseFunctionTypeParam(false)), this.expect(p2.parenR), e4.returnType = this.flowParseTypeInitialiser(), this.finishNode(e4, "FunctionTypeAnnotation");
              }
              flowParseObjectTypeCallProperty(e4, t3) {
                const r3 = this.startNode();
                return e4.static = t3, e4.value = this.flowParseObjectTypeMethodish(r3), this.finishNode(e4, "ObjectTypeCallProperty");
              }
              flowParseObjectType({ allowStatic: e4, allowExact: t3, allowSpread: r3, allowProto: n2, allowInexact: s3 }) {
                const i2 = this.state.inType;
                this.state.inType = true;
                const o2 = this.startNode();
                let a2, l2;
                o2.callProperties = [], o2.properties = [], o2.indexers = [], o2.internalSlots = [];
                let c4 = false;
                for (t3 && this.match(p2.braceBarL) ? (this.expect(p2.braceBarL), a2 = p2.braceBarR, l2 = true) : (this.expect(p2.braceL), a2 = p2.braceR, l2 = false), o2.exact = l2; !this.match(a2); ) {
                  let t4 = false, i3 = null, a3 = null;
                  const u3 = this.startNode();
                  if (n2 && this.isContextual("proto")) {
                    const t5 = this.lookahead();
                    t5.type !== p2.colon && t5.type !== p2.question && (this.next(), i3 = this.state.start, e4 = false);
                  }
                  if (e4 && this.isContextual("static")) {
                    const e5 = this.lookahead();
                    e5.type !== p2.colon && e5.type !== p2.question && (this.next(), t4 = true);
                  }
                  const f2 = this.flowParseVariance();
                  if (this.eat(p2.bracketL))
                    i3 != null && this.unexpected(i3), this.eat(p2.bracketL) ? (f2 && this.unexpected(f2.start), o2.internalSlots.push(this.flowParseObjectTypeInternalSlot(u3, t4))) : o2.indexers.push(this.flowParseObjectTypeIndexer(u3, t4, f2));
                  else if (this.match(p2.parenL) || this.isRelational("<"))
                    i3 != null && this.unexpected(i3), f2 && this.unexpected(f2.start), o2.callProperties.push(this.flowParseObjectTypeCallProperty(u3, t4));
                  else {
                    let e5 = "init";
                    if (this.isContextual("get") || this.isContextual("set")) {
                      const t5 = this.lookahead();
                      t5.type !== p2.name && t5.type !== p2.string && t5.type !== p2.num || (e5 = this.state.value, this.next());
                    }
                    const n3 = this.flowParseObjectTypeProperty(u3, t4, i3, f2, e5, r3, s3 != null ? s3 : !l2);
                    n3 === null ? (c4 = true, a3 = this.state.lastTokStart) : o2.properties.push(n3);
                  }
                  this.flowObjectTypeSemicolon(), !a3 || this.match(p2.braceR) || this.match(p2.braceBarR) || this.raise(a3, Y.UnexpectedExplicitInexactInObject);
                }
                this.expect(a2), r3 && (o2.inexact = c4);
                const u2 = this.finishNode(o2, "ObjectTypeAnnotation");
                return this.state.inType = i2, u2;
              }
              flowParseObjectTypeProperty(e4, t3, r3, n2, s3, i2, o2) {
                if (this.eat(p2.ellipsis))
                  return this.match(p2.comma) || this.match(p2.semi) || this.match(p2.braceR) || this.match(p2.braceBarR) ? (i2 ? o2 || this.raise(this.state.lastTokStart, Y.InexactInsideExact) : this.raise(this.state.lastTokStart, Y.InexactInsideNonObject), n2 && this.raise(n2.start, Y.InexactVariance), null) : (i2 || this.raise(this.state.lastTokStart, Y.UnexpectedSpreadType), r3 != null && this.unexpected(r3), n2 && this.raise(n2.start, Y.SpreadVariance), e4.argument = this.flowParseType(), this.finishNode(e4, "ObjectTypeSpreadProperty"));
                {
                  e4.key = this.flowParseObjectPropertyKey(), e4.static = t3, e4.proto = r3 != null, e4.kind = s3;
                  let o3 = false;
                  return this.isRelational("<") || this.match(p2.parenL) ? (e4.method = true, r3 != null && this.unexpected(r3), n2 && this.unexpected(n2.start), e4.value = this.flowParseObjectTypeMethodish(this.startNodeAt(e4.start, e4.loc.start)), s3 !== "get" && s3 !== "set" || this.flowCheckGetterSetterParams(e4), !i2 && e4.key.name === "constructor" && e4.value.this && this.raise(e4.value.this.start, Y.ThisParamBannedInConstructor)) : (s3 !== "init" && this.unexpected(), e4.method = false, this.eat(p2.question) && (o3 = true), e4.value = this.flowParseTypeInitialiser(), e4.variance = n2), e4.optional = o3, this.finishNode(e4, "ObjectTypeProperty");
                }
              }
              flowCheckGetterSetterParams(e4) {
                const t3 = e4.kind === "get" ? 0 : 1, r3 = e4.start, n2 = e4.value.params.length + (e4.value.rest ? 1 : 0);
                e4.value.this && this.raise(e4.value.this.start, e4.kind === "get" ? Y.GetterMayNotHaveThisParam : Y.SetterMayNotHaveThisParam), n2 !== t3 && (e4.kind === "get" ? this.raise(r3, x.BadGetterArity) : this.raise(r3, x.BadSetterArity)), e4.kind === "set" && e4.value.rest && this.raise(r3, x.BadSetterRestParameter);
              }
              flowObjectTypeSemicolon() {
                this.eat(p2.semi) || this.eat(p2.comma) || this.match(p2.braceR) || this.match(p2.braceBarR) || this.unexpected();
              }
              flowParseQualifiedTypeIdentifier(e4, t3, r3) {
                e4 = e4 || this.state.start, t3 = t3 || this.state.startLoc;
                let n2 = r3 || this.flowParseRestrictedIdentifier(true);
                for (; this.eat(p2.dot); ) {
                  const r4 = this.startNodeAt(e4, t3);
                  r4.qualification = n2, r4.id = this.flowParseRestrictedIdentifier(true), n2 = this.finishNode(r4, "QualifiedTypeIdentifier");
                }
                return n2;
              }
              flowParseGenericType(e4, t3, r3) {
                const n2 = this.startNodeAt(e4, t3);
                return n2.typeParameters = null, n2.id = this.flowParseQualifiedTypeIdentifier(e4, t3, r3), this.isRelational("<") && (n2.typeParameters = this.flowParseTypeParameterInstantiation()), this.finishNode(n2, "GenericTypeAnnotation");
              }
              flowParseTypeofType() {
                const e4 = this.startNode();
                return this.expect(p2._typeof), e4.argument = this.flowParsePrimaryType(), this.finishNode(e4, "TypeofTypeAnnotation");
              }
              flowParseTupleType() {
                const e4 = this.startNode();
                for (e4.types = [], this.expect(p2.bracketL); this.state.pos < this.length && !this.match(p2.bracketR) && (e4.types.push(this.flowParseType()), !this.match(p2.bracketR)); )
                  this.expect(p2.comma);
                return this.expect(p2.bracketR), this.finishNode(e4, "TupleTypeAnnotation");
              }
              flowParseFunctionTypeParam(e4) {
                let t3 = null, r3 = false, n2 = null;
                const s3 = this.startNode(), i2 = this.lookahead(), o2 = this.state.type === p2._this;
                return i2.type === p2.colon || i2.type === p2.question ? (o2 && !e4 && this.raise(s3.start, Y.ThisParamMustBeFirst), t3 = this.parseIdentifier(o2), this.eat(p2.question) && (r3 = true, o2 && this.raise(s3.start, Y.ThisParamMayNotBeOptional)), n2 = this.flowParseTypeInitialiser()) : n2 = this.flowParseType(), s3.name = t3, s3.optional = r3, s3.typeAnnotation = n2, this.finishNode(s3, "FunctionTypeParam");
              }
              reinterpretTypeAsFunctionTypeParam(e4) {
                const t3 = this.startNodeAt(e4.start, e4.loc.start);
                return t3.name = null, t3.optional = false, t3.typeAnnotation = e4, this.finishNode(t3, "FunctionTypeParam");
              }
              flowParseFunctionTypeParams(e4 = []) {
                let t3 = null, r3 = null;
                for (this.match(p2._this) && (r3 = this.flowParseFunctionTypeParam(true), r3.name = null, this.match(p2.parenR) || this.expect(p2.comma)); !this.match(p2.parenR) && !this.match(p2.ellipsis); )
                  e4.push(this.flowParseFunctionTypeParam(false)), this.match(p2.parenR) || this.expect(p2.comma);
                return this.eat(p2.ellipsis) && (t3 = this.flowParseFunctionTypeParam(false)), { params: e4, rest: t3, _this: r3 };
              }
              flowIdentToTypeAnnotation(e4, t3, r3, n2) {
                switch (n2.name) {
                  case "any":
                    return this.finishNode(r3, "AnyTypeAnnotation");
                  case "bool":
                  case "boolean":
                    return this.finishNode(r3, "BooleanTypeAnnotation");
                  case "mixed":
                    return this.finishNode(r3, "MixedTypeAnnotation");
                  case "empty":
                    return this.finishNode(r3, "EmptyTypeAnnotation");
                  case "number":
                    return this.finishNode(r3, "NumberTypeAnnotation");
                  case "string":
                    return this.finishNode(r3, "StringTypeAnnotation");
                  case "symbol":
                    return this.finishNode(r3, "SymbolTypeAnnotation");
                  default:
                    return this.checkNotUnderscore(n2.name), this.flowParseGenericType(e4, t3, n2);
                }
              }
              flowParsePrimaryType() {
                const e4 = this.state.start, t3 = this.state.startLoc, r3 = this.startNode();
                let n2, s3, i2 = false;
                const o2 = this.state.noAnonFunctionType;
                switch (this.state.type) {
                  case p2.name:
                    return this.isContextual("interface") ? this.flowParseInterfaceType() : this.flowIdentToTypeAnnotation(e4, t3, r3, this.parseIdentifier());
                  case p2.braceL:
                    return this.flowParseObjectType({ allowStatic: false, allowExact: false, allowSpread: true, allowProto: false, allowInexact: true });
                  case p2.braceBarL:
                    return this.flowParseObjectType({ allowStatic: false, allowExact: true, allowSpread: true, allowProto: false, allowInexact: false });
                  case p2.bracketL:
                    return this.state.noAnonFunctionType = false, s3 = this.flowParseTupleType(), this.state.noAnonFunctionType = o2, s3;
                  case p2.relational:
                    if (this.state.value === "<")
                      return r3.typeParameters = this.flowParseTypeParameterDeclaration(), this.expect(p2.parenL), n2 = this.flowParseFunctionTypeParams(), r3.params = n2.params, r3.rest = n2.rest, r3.this = n2._this, this.expect(p2.parenR), this.expect(p2.arrow), r3.returnType = this.flowParseType(), this.finishNode(r3, "FunctionTypeAnnotation");
                    break;
                  case p2.parenL:
                    if (this.next(), !this.match(p2.parenR) && !this.match(p2.ellipsis))
                      if (this.match(p2.name) || this.match(p2._this)) {
                        const e5 = this.lookahead().type;
                        i2 = e5 !== p2.question && e5 !== p2.colon;
                      } else
                        i2 = true;
                    if (i2) {
                      if (this.state.noAnonFunctionType = false, s3 = this.flowParseType(), this.state.noAnonFunctionType = o2, this.state.noAnonFunctionType || !(this.match(p2.comma) || this.match(p2.parenR) && this.lookahead().type === p2.arrow))
                        return this.expect(p2.parenR), s3;
                      this.eat(p2.comma);
                    }
                    return n2 = s3 ? this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(s3)]) : this.flowParseFunctionTypeParams(), r3.params = n2.params, r3.rest = n2.rest, r3.this = n2._this, this.expect(p2.parenR), this.expect(p2.arrow), r3.returnType = this.flowParseType(), r3.typeParameters = null, this.finishNode(r3, "FunctionTypeAnnotation");
                  case p2.string:
                    return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
                  case p2._true:
                  case p2._false:
                    return r3.value = this.match(p2._true), this.next(), this.finishNode(r3, "BooleanLiteralTypeAnnotation");
                  case p2.plusMin:
                    if (this.state.value === "-") {
                      if (this.next(), this.match(p2.num))
                        return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", r3);
                      if (this.match(p2.bigint))
                        return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", r3);
                      throw this.raise(this.state.start, Y.UnexpectedSubtractionOperand);
                    }
                    throw this.unexpected();
                  case p2.num:
                    return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
                  case p2.bigint:
                    return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
                  case p2._void:
                    return this.next(), this.finishNode(r3, "VoidTypeAnnotation");
                  case p2._null:
                    return this.next(), this.finishNode(r3, "NullLiteralTypeAnnotation");
                  case p2._this:
                    return this.next(), this.finishNode(r3, "ThisTypeAnnotation");
                  case p2.star:
                    return this.next(), this.finishNode(r3, "ExistsTypeAnnotation");
                  default:
                    if (this.state.type.keyword === "typeof")
                      return this.flowParseTypeofType();
                    if (this.state.type.keyword) {
                      const e5 = this.state.type.label;
                      return this.next(), super.createIdentifier(r3, e5);
                    }
                }
                throw this.unexpected();
              }
              flowParsePostfixType() {
                const e4 = this.state.start, t3 = this.state.startLoc;
                let r3 = this.flowParsePrimaryType(), n2 = false;
                for (; (this.match(p2.bracketL) || this.match(p2.questionDot)) && !this.canInsertSemicolon(); ) {
                  const s3 = this.startNodeAt(e4, t3), i2 = this.eat(p2.questionDot);
                  n2 = n2 || i2, this.expect(p2.bracketL), !i2 && this.match(p2.bracketR) ? (s3.elementType = r3, this.next(), r3 = this.finishNode(s3, "ArrayTypeAnnotation")) : (s3.objectType = r3, s3.indexType = this.flowParseType(), this.expect(p2.bracketR), n2 ? (s3.optional = i2, r3 = this.finishNode(s3, "OptionalIndexedAccessType")) : r3 = this.finishNode(s3, "IndexedAccessType"));
                }
                return r3;
              }
              flowParsePrefixType() {
                const e4 = this.startNode();
                return this.eat(p2.question) ? (e4.typeAnnotation = this.flowParsePrefixType(), this.finishNode(e4, "NullableTypeAnnotation")) : this.flowParsePostfixType();
              }
              flowParseAnonFunctionWithoutParens() {
                const e4 = this.flowParsePrefixType();
                if (!this.state.noAnonFunctionType && this.eat(p2.arrow)) {
                  const t3 = this.startNodeAt(e4.start, e4.loc.start);
                  return t3.params = [this.reinterpretTypeAsFunctionTypeParam(e4)], t3.rest = null, t3.this = null, t3.returnType = this.flowParseType(), t3.typeParameters = null, this.finishNode(t3, "FunctionTypeAnnotation");
                }
                return e4;
              }
              flowParseIntersectionType() {
                const e4 = this.startNode();
                this.eat(p2.bitwiseAND);
                const t3 = this.flowParseAnonFunctionWithoutParens();
                for (e4.types = [t3]; this.eat(p2.bitwiseAND); )
                  e4.types.push(this.flowParseAnonFunctionWithoutParens());
                return e4.types.length === 1 ? t3 : this.finishNode(e4, "IntersectionTypeAnnotation");
              }
              flowParseUnionType() {
                const e4 = this.startNode();
                this.eat(p2.bitwiseOR);
                const t3 = this.flowParseIntersectionType();
                for (e4.types = [t3]; this.eat(p2.bitwiseOR); )
                  e4.types.push(this.flowParseIntersectionType());
                return e4.types.length === 1 ? t3 : this.finishNode(e4, "UnionTypeAnnotation");
              }
              flowParseType() {
                const e4 = this.state.inType;
                this.state.inType = true;
                const t3 = this.flowParseUnionType();
                return this.state.inType = e4, t3;
              }
              flowParseTypeOrImplicitInstantiation() {
                if (this.state.type === p2.name && this.state.value === "_") {
                  const e4 = this.state.start, t3 = this.state.startLoc, r3 = this.parseIdentifier();
                  return this.flowParseGenericType(e4, t3, r3);
                }
                return this.flowParseType();
              }
              flowParseTypeAnnotation() {
                const e4 = this.startNode();
                return e4.typeAnnotation = this.flowParseTypeInitialiser(), this.finishNode(e4, "TypeAnnotation");
              }
              flowParseTypeAnnotatableIdentifier(e4) {
                const t3 = e4 ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
                return this.match(p2.colon) && (t3.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(t3)), t3;
              }
              typeCastToParameter(e4) {
                return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.end, e4.typeAnnotation.loc.end), e4.expression;
              }
              flowParseVariance() {
                let e4 = null;
                return this.match(p2.plusMin) && (e4 = this.startNode(), this.state.value === "+" ? e4.kind = "plus" : e4.kind = "minus", this.next(), this.finishNode(e4, "Variance")), e4;
              }
              parseFunctionBody(e4, t3, r3 = false) {
                return t3 ? this.forwardNoArrowParamsConversionAt(e4, () => super.parseFunctionBody(e4, true, r3)) : super.parseFunctionBody(e4, false, r3);
              }
              parseFunctionBodyAndFinish(e4, t3, r3 = false) {
                if (this.match(p2.colon)) {
                  const t4 = this.startNode();
                  [t4.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), e4.returnType = t4.typeAnnotation ? this.finishNode(t4, "TypeAnnotation") : null;
                }
                super.parseFunctionBodyAndFinish(e4, t3, r3);
              }
              parseStatement(e4, t3) {
                if (this.state.strict && this.match(p2.name) && this.state.value === "interface") {
                  const e5 = this.lookahead();
                  if (e5.type === p2.name || q(e5.value)) {
                    const e6 = this.startNode();
                    return this.next(), this.flowParseInterface(e6);
                  }
                } else if (this.shouldParseEnums() && this.isContextual("enum")) {
                  const e5 = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(e5);
                }
                const r3 = super.parseStatement(e4, t3);
                return this.flowPragma !== void 0 || this.isValidDirective(r3) || (this.flowPragma = null), r3;
              }
              parseExpressionStatement(e4, t3) {
                if (t3.type === "Identifier") {
                  if (t3.name === "declare") {
                    if (this.match(p2._class) || this.match(p2.name) || this.match(p2._function) || this.match(p2._var) || this.match(p2._export))
                      return this.flowParseDeclare(e4);
                  } else if (this.match(p2.name)) {
                    if (t3.name === "interface")
                      return this.flowParseInterface(e4);
                    if (t3.name === "type")
                      return this.flowParseTypeAlias(e4);
                    if (t3.name === "opaque")
                      return this.flowParseOpaqueType(e4, false);
                  }
                }
                return super.parseExpressionStatement(e4, t3);
              }
              shouldParseExportDeclaration() {
                return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || super.shouldParseExportDeclaration();
              }
              isExportDefaultSpecifier() {
                return (!this.match(p2.name) || !(this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) && super.isExportDefaultSpecifier();
              }
              parseExportDefaultExpression() {
                if (this.shouldParseEnums() && this.isContextual("enum")) {
                  const e4 = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(e4);
                }
                return super.parseExportDefaultExpression();
              }
              parseConditional(e4, t3, r3, n2) {
                if (!this.match(p2.question))
                  return e4;
                if (this.state.maybeInArrowParameters) {
                  const s4 = this.tryParse(() => super.parseConditional(e4, t3, r3));
                  return s4.node ? (s4.error && (this.state = s4.failState), s4.node) : (s4.error && super.setOptionalParametersError(n2, s4.error), e4);
                }
                this.expect(p2.question);
                const s3 = this.state.clone(), i2 = this.state.noArrowAt, o2 = this.startNodeAt(t3, r3);
                let { consequent: a2, failed: l2 } = this.tryParseConditionalConsequent(), [c4, u2] = this.getArrowLikeExpressions(a2);
                if (l2 || u2.length > 0) {
                  const e5 = [...i2];
                  if (u2.length > 0) {
                    this.state = s3, this.state.noArrowAt = e5;
                    for (let t4 = 0; t4 < u2.length; t4++)
                      e5.push(u2[t4].start);
                    ({ consequent: a2, failed: l2 } = this.tryParseConditionalConsequent()), [c4, u2] = this.getArrowLikeExpressions(a2);
                  }
                  l2 && c4.length > 1 && this.raise(s3.start, Y.AmbiguousConditionalArrow), l2 && c4.length === 1 && (this.state = s3, this.state.noArrowAt = e5.concat(c4[0].start), { consequent: a2, failed: l2 } = this.tryParseConditionalConsequent());
                }
                return this.getArrowLikeExpressions(a2, true), this.state.noArrowAt = i2, this.expect(p2.colon), o2.test = e4, o2.consequent = a2, o2.alternate = this.forwardNoArrowParamsConversionAt(o2, () => this.parseMaybeAssign(void 0, void 0)), this.finishNode(o2, "ConditionalExpression");
              }
              tryParseConditionalConsequent() {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                const e4 = this.parseMaybeAssignAllowIn(), t3 = !this.match(p2.colon);
                return this.state.noArrowParamsConversionAt.pop(), { consequent: e4, failed: t3 };
              }
              getArrowLikeExpressions(e4, t3) {
                const r3 = [e4], n2 = [];
                for (; r3.length !== 0; ) {
                  const e5 = r3.pop();
                  e5.type === "ArrowFunctionExpression" ? (e5.typeParameters || !e5.returnType ? this.finishArrowValidation(e5) : n2.push(e5), r3.push(e5.body)) : e5.type === "ConditionalExpression" && (r3.push(e5.consequent), r3.push(e5.alternate));
                }
                return t3 ? (n2.forEach((e5) => this.finishArrowValidation(e5)), [n2, []]) : function(e5, t4) {
                  const r4 = [], n3 = [];
                  for (let s3 = 0; s3 < e5.length; s3++)
                    (t4(e5[s3]) ? r4 : n3).push(e5[s3]);
                  return [r4, n3];
                }(n2, (e5) => e5.params.every((e6) => this.isAssignable(e6, true)));
              }
              finishArrowValidation(e4) {
                var t3;
                this.toAssignableList(e4.params, (t3 = e4.extra) == null ? void 0 : t3.trailingComma, false), this.scope.enter(6), super.checkParams(e4, false, true), this.scope.exit();
              }
              forwardNoArrowParamsConversionAt(e4, t3) {
                let r3;
                return this.state.noArrowParamsConversionAt.indexOf(e4.start) !== -1 ? (this.state.noArrowParamsConversionAt.push(this.state.start), r3 = t3(), this.state.noArrowParamsConversionAt.pop()) : r3 = t3(), r3;
              }
              parseParenItem(e4, t3, r3) {
                if (e4 = super.parseParenItem(e4, t3, r3), this.eat(p2.question) && (e4.optional = true, this.resetEndLocation(e4)), this.match(p2.colon)) {
                  const n2 = this.startNodeAt(t3, r3);
                  return n2.expression = e4, n2.typeAnnotation = this.flowParseTypeAnnotation(), this.finishNode(n2, "TypeCastExpression");
                }
                return e4;
              }
              assertModuleNodeAllowed(e4) {
                e4.type === "ImportDeclaration" && (e4.importKind === "type" || e4.importKind === "typeof") || e4.type === "ExportNamedDeclaration" && e4.exportKind === "type" || e4.type === "ExportAllDeclaration" && e4.exportKind === "type" || super.assertModuleNodeAllowed(e4);
              }
              parseExport(e4) {
                const t3 = super.parseExport(e4);
                return t3.type !== "ExportNamedDeclaration" && t3.type !== "ExportAllDeclaration" || (t3.exportKind = t3.exportKind || "value"), t3;
              }
              parseExportDeclaration(e4) {
                if (this.isContextual("type")) {
                  e4.exportKind = "type";
                  const t3 = this.startNode();
                  return this.next(), this.match(p2.braceL) ? (e4.specifiers = this.parseExportSpecifiers(), this.parseExportFrom(e4), null) : this.flowParseTypeAlias(t3);
                }
                if (this.isContextual("opaque")) {
                  e4.exportKind = "type";
                  const t3 = this.startNode();
                  return this.next(), this.flowParseOpaqueType(t3, false);
                }
                if (this.isContextual("interface")) {
                  e4.exportKind = "type";
                  const t3 = this.startNode();
                  return this.next(), this.flowParseInterface(t3);
                }
                if (this.shouldParseEnums() && this.isContextual("enum")) {
                  e4.exportKind = "value";
                  const t3 = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(t3);
                }
                return super.parseExportDeclaration(e4);
              }
              eatExportStar(e4) {
                return !!super.eatExportStar(...arguments) || !(!this.isContextual("type") || this.lookahead().type !== p2.star) && (e4.exportKind = "type", this.next(), this.next(), true);
              }
              maybeParseExportNamespaceSpecifier(e4) {
                const t3 = this.state.start, r3 = super.maybeParseExportNamespaceSpecifier(e4);
                return r3 && e4.exportKind === "type" && this.unexpected(t3), r3;
              }
              parseClassId(e4, t3, r3) {
                super.parseClassId(e4, t3, r3), this.isRelational("<") && (e4.typeParameters = this.flowParseTypeParameterDeclaration());
              }
              parseClassMember(e4, t3, r3) {
                const n2 = this.state.start;
                if (this.isContextual("declare")) {
                  if (this.parseClassMemberFromModifier(e4, t3))
                    return;
                  t3.declare = true;
                }
                super.parseClassMember(e4, t3, r3), t3.declare && (t3.type !== "ClassProperty" && t3.type !== "ClassPrivateProperty" && t3.type !== "PropertyDefinition" ? this.raise(n2, Y.DeclareClassElement) : t3.value && this.raise(t3.value.start, Y.DeclareClassFieldInitializer));
              }
              isIterator(e4) {
                return e4 === "iterator" || e4 === "asyncIterator";
              }
              readIterator() {
                const e4 = super.readWord1(), t3 = "@@" + e4;
                this.isIterator(e4) && this.state.inType || this.raise(this.state.pos, x.InvalidIdentifier, t3), this.finishToken(p2.name, t3);
              }
              getTokenFromCode(e4) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                return e4 === 123 && t3 === 124 ? this.finishOp(p2.braceBarL, 2) : !this.state.inType || e4 !== 62 && e4 !== 60 ? this.state.inType && e4 === 63 ? t3 === 46 ? this.finishOp(p2.questionDot, 2) : this.finishOp(p2.question, 1) : function(e5, t4) {
                  return e5 === 64 && t4 === 64;
                }(e4, t3) ? (this.state.pos += 2, this.readIterator()) : super.getTokenFromCode(e4) : this.finishOp(p2.relational, 1);
              }
              isAssignable(e4, t3) {
                switch (e4.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                    return true;
                  case "ObjectExpression": {
                    const t4 = e4.properties.length - 1;
                    return e4.properties.every((e5, r3) => e5.type !== "ObjectMethod" && (r3 === t4 || e5.type === "SpreadElement") && this.isAssignable(e5));
                  }
                  case "ObjectProperty":
                    return this.isAssignable(e4.value);
                  case "SpreadElement":
                    return this.isAssignable(e4.argument);
                  case "ArrayExpression":
                    return e4.elements.every((e5) => this.isAssignable(e5));
                  case "AssignmentExpression":
                    return e4.operator === "=";
                  case "ParenthesizedExpression":
                  case "TypeCastExpression":
                    return this.isAssignable(e4.expression);
                  case "MemberExpression":
                  case "OptionalMemberExpression":
                    return !t3;
                  default:
                    return false;
                }
              }
              toAssignable(e4, t3 = false) {
                return e4.type === "TypeCastExpression" ? super.toAssignable(this.typeCastToParameter(e4), t3) : super.toAssignable(e4, t3);
              }
              toAssignableList(e4, t3, r3) {
                for (let t4 = 0; t4 < e4.length; t4++) {
                  const r4 = e4[t4];
                  (r4 == null ? void 0 : r4.type) === "TypeCastExpression" && (e4[t4] = this.typeCastToParameter(r4));
                }
                return super.toAssignableList(e4, t3, r3);
              }
              toReferencedList(e4, t3) {
                for (let n2 = 0; n2 < e4.length; n2++) {
                  var r3;
                  const s3 = e4[n2];
                  !s3 || s3.type !== "TypeCastExpression" || (r3 = s3.extra) != null && r3.parenthesized || !(e4.length > 1) && t3 || this.raise(s3.typeAnnotation.start, Y.TypeCastInPattern);
                }
                return e4;
              }
              parseArrayLike(e4, t3, r3, n2) {
                const s3 = super.parseArrayLike(e4, t3, r3, n2);
                return t3 && !this.state.maybeInArrowParameters && this.toReferencedList(s3.elements), s3;
              }
              checkLVal(e4, ...t3) {
                if (e4.type !== "TypeCastExpression")
                  return super.checkLVal(e4, ...t3);
              }
              parseClassProperty(e4) {
                return this.match(p2.colon) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassProperty(e4);
              }
              parseClassPrivateProperty(e4) {
                return this.match(p2.colon) && (e4.typeAnnotation = this.flowParseTypeAnnotation()), super.parseClassPrivateProperty(e4);
              }
              isClassMethod() {
                return this.isRelational("<") || super.isClassMethod();
              }
              isClassProperty() {
                return this.match(p2.colon) || super.isClassProperty();
              }
              isNonstaticConstructor(e4) {
                return !this.match(p2.colon) && super.isNonstaticConstructor(e4);
              }
              pushClassMethod(e4, t3, r3, n2, s3, i2) {
                if (t3.variance && this.unexpected(t3.variance.start), delete t3.variance, this.isRelational("<") && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassMethod(e4, t3, r3, n2, s3, i2), t3.params && s3) {
                  const e5 = t3.params;
                  e5.length > 0 && this.isThisParam(e5[0]) && this.raise(t3.start, Y.ThisParamBannedInConstructor);
                } else if (t3.type === "MethodDefinition" && s3 && t3.value.params) {
                  const e5 = t3.value.params;
                  e5.length > 0 && this.isThisParam(e5[0]) && this.raise(t3.start, Y.ThisParamBannedInConstructor);
                }
              }
              pushClassPrivateMethod(e4, t3, r3, n2) {
                t3.variance && this.unexpected(t3.variance.start), delete t3.variance, this.isRelational("<") && (t3.typeParameters = this.flowParseTypeParameterDeclaration()), super.pushClassPrivateMethod(e4, t3, r3, n2);
              }
              parseClassSuper(e4) {
                if (super.parseClassSuper(e4), e4.superClass && this.isRelational("<") && (e4.superTypeParameters = this.flowParseTypeParameterInstantiation()), this.isContextual("implements")) {
                  this.next();
                  const t3 = e4.implements = [];
                  do {
                    const e5 = this.startNode();
                    e5.id = this.flowParseRestrictedIdentifier(true), this.isRelational("<") ? e5.typeParameters = this.flowParseTypeParameterInstantiation() : e5.typeParameters = null, t3.push(this.finishNode(e5, "ClassImplements"));
                  } while (this.eat(p2.comma));
                }
              }
              checkGetterSetterParams(e4) {
                super.checkGetterSetterParams(e4);
                const t3 = this.getObjectOrClassMethodParams(e4);
                if (t3.length > 0) {
                  const r3 = t3[0];
                  this.isThisParam(r3) && e4.kind === "get" ? this.raise(r3.start, Y.GetterMayNotHaveThisParam) : this.isThisParam(r3) && this.raise(r3.start, Y.SetterMayNotHaveThisParam);
                }
              }
              parsePropertyName(e4, t3) {
                const r3 = this.flowParseVariance(), n2 = super.parsePropertyName(e4, t3);
                return e4.variance = r3, n2;
              }
              parseObjPropValue(e4, t3, r3, n2, s3, i2, o2, a2) {
                let l2;
                e4.variance && this.unexpected(e4.variance.start), delete e4.variance, this.isRelational("<") && !o2 && (l2 = this.flowParseTypeParameterDeclaration(), this.match(p2.parenL) || this.unexpected()), super.parseObjPropValue(e4, t3, r3, n2, s3, i2, o2, a2), l2 && ((e4.value || e4).typeParameters = l2);
              }
              parseAssignableListItemTypes(e4) {
                return this.eat(p2.question) && (e4.type !== "Identifier" && this.raise(e4.start, Y.OptionalBindingPattern), this.isThisParam(e4) && this.raise(e4.start, Y.ThisParamMayNotBeOptional), e4.optional = true), this.match(p2.colon) ? e4.typeAnnotation = this.flowParseTypeAnnotation() : this.isThisParam(e4) && this.raise(e4.start, Y.ThisParamAnnotationRequired), this.match(p2.eq) && this.isThisParam(e4) && this.raise(e4.start, Y.ThisParamNoDefault), this.resetEndLocation(e4), e4;
              }
              parseMaybeDefault(e4, t3, r3) {
                const n2 = super.parseMaybeDefault(e4, t3, r3);
                return n2.type === "AssignmentPattern" && n2.typeAnnotation && n2.right.start < n2.typeAnnotation.start && this.raise(n2.typeAnnotation.start, Y.TypeBeforeInitializer), n2;
              }
              shouldParseDefaultImport(e4) {
                return X(e4) ? z(this.state) : super.shouldParseDefaultImport(e4);
              }
              parseImportSpecifierLocal(e4, t3, r3, n2) {
                t3.local = X(e4) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier(), this.checkLVal(t3.local, n2, 9), e4.specifiers.push(this.finishNode(t3, r3));
              }
              maybeParseDefaultImportSpecifier(e4) {
                e4.importKind = "value";
                let t3 = null;
                if (this.match(p2._typeof) ? t3 = "typeof" : this.isContextual("type") && (t3 = "type"), t3) {
                  const r3 = this.lookahead();
                  t3 === "type" && r3.type === p2.star && this.unexpected(r3.start), (z(r3) || r3.type === p2.braceL || r3.type === p2.star) && (this.next(), e4.importKind = t3);
                }
                return super.maybeParseDefaultImportSpecifier(e4);
              }
              parseImportSpecifier(e4) {
                const t3 = this.startNode(), r3 = this.match(p2.string), n2 = this.parseModuleExportName();
                let s3 = null;
                n2.type === "Identifier" && (n2.name === "type" ? s3 = "type" : n2.name === "typeof" && (s3 = "typeof"));
                let i2 = false;
                if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
                  const e5 = this.parseIdentifier(true);
                  s3 === null || this.match(p2.name) || this.state.type.keyword ? (t3.imported = n2, t3.importKind = null, t3.local = this.parseIdentifier()) : (t3.imported = e5, t3.importKind = s3, t3.local = e5.__clone());
                } else if (s3 !== null && (this.match(p2.name) || this.state.type.keyword))
                  t3.imported = this.parseIdentifier(true), t3.importKind = s3, this.eatContextual("as") ? t3.local = this.parseIdentifier() : (i2 = true, t3.local = t3.imported.__clone());
                else {
                  if (r3)
                    throw this.raise(t3.start, x.ImportBindingIsString, n2.value);
                  i2 = true, t3.imported = n2, t3.importKind = null, t3.local = t3.imported.__clone();
                }
                const o2 = X(e4), a2 = X(t3);
                o2 && a2 && this.raise(t3.start, Y.ImportTypeShorthandOnlyInPureImport), (o2 || a2) && this.checkReservedType(t3.local.name, t3.local.start, true), !i2 || o2 || a2 || this.checkReservedWord(t3.local.name, t3.start, true, true), this.checkLVal(t3.local, "import specifier", 9), e4.specifiers.push(this.finishNode(t3, "ImportSpecifier"));
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case p2._this:
                    return this.parseIdentifier(true);
                  default:
                    return super.parseBindingAtom();
                }
              }
              parseFunctionParams(e4, t3) {
                const r3 = e4.kind;
                r3 !== "get" && r3 !== "set" && this.isRelational("<") && (e4.typeParameters = this.flowParseTypeParameterDeclaration()), super.parseFunctionParams(e4, t3);
              }
              parseVarId(e4, t3) {
                super.parseVarId(e4, t3), this.match(p2.colon) && (e4.id.typeAnnotation = this.flowParseTypeAnnotation(), this.resetEndLocation(e4.id));
              }
              parseAsyncArrowFromCallExpression(e4, t3) {
                if (this.match(p2.colon)) {
                  const t4 = this.state.noAnonFunctionType;
                  this.state.noAnonFunctionType = true, e4.returnType = this.flowParseTypeAnnotation(), this.state.noAnonFunctionType = t4;
                }
                return super.parseAsyncArrowFromCallExpression(e4, t3);
              }
              shouldParseAsyncArrow() {
                return this.match(p2.colon) || super.shouldParseAsyncArrow();
              }
              parseMaybeAssign(e4, t3) {
                var r3;
                let n2, s3 = null;
                if (this.hasPlugin("jsx") && (this.match(p2.jsxTagStart) || this.isRelational("<"))) {
                  if (s3 = this.state.clone(), n2 = this.tryParse(() => super.parseMaybeAssign(e4, t3), s3), !n2.error)
                    return n2.node;
                  const { context: r4 } = this.state, i3 = r4[r4.length - 1];
                  i3 === P.j_oTag ? r4.length -= 2 : i3 === P.j_expr && (r4.length -= 1);
                }
                if ((r3 = n2) != null && r3.error || this.isRelational("<")) {
                  var i2, o2;
                  let r4;
                  s3 = s3 || this.state.clone();
                  const a2 = this.tryParse((n3) => {
                    var s4;
                    r4 = this.flowParseTypeParameterDeclaration();
                    const i3 = this.forwardNoArrowParamsConversionAt(r4, () => {
                      const n4 = super.parseMaybeAssign(e4, t3);
                      return this.resetStartLocationFromNode(n4, r4), n4;
                    });
                    i3.type !== "ArrowFunctionExpression" && (s4 = i3.extra) != null && s4.parenthesized && n3();
                    const o3 = this.maybeUnwrapTypeCastExpression(i3);
                    return o3.typeParameters = r4, this.resetStartLocationFromNode(o3, r4), i3;
                  }, s3);
                  let l2 = null;
                  if (a2.node && this.maybeUnwrapTypeCastExpression(a2.node).type === "ArrowFunctionExpression") {
                    if (!a2.error && !a2.aborted)
                      return a2.node.async && this.raise(r4.start, Y.UnexpectedTypeParameterBeforeAsyncArrowFunction), a2.node;
                    l2 = a2.node;
                  }
                  if ((i2 = n2) != null && i2.node)
                    return this.state = n2.failState, n2.node;
                  if (l2)
                    return this.state = a2.failState, l2;
                  if ((o2 = n2) != null && o2.thrown)
                    throw n2.error;
                  if (a2.thrown)
                    throw a2.error;
                  throw this.raise(r4.start, Y.UnexpectedTokenAfterTypeParameter);
                }
                return super.parseMaybeAssign(e4, t3);
              }
              parseArrow(e4) {
                if (this.match(p2.colon)) {
                  const t3 = this.tryParse(() => {
                    const t4 = this.state.noAnonFunctionType;
                    this.state.noAnonFunctionType = true;
                    const r3 = this.startNode();
                    return [r3.typeAnnotation, e4.predicate] = this.flowParseTypeAndPredicateInitialiser(), this.state.noAnonFunctionType = t4, this.canInsertSemicolon() && this.unexpected(), this.match(p2.arrow) || this.unexpected(), r3;
                  });
                  if (t3.thrown)
                    return null;
                  t3.error && (this.state = t3.failState), e4.returnType = t3.node.typeAnnotation ? this.finishNode(t3.node, "TypeAnnotation") : null;
                }
                return super.parseArrow(e4);
              }
              shouldParseArrow() {
                return this.match(p2.colon) || super.shouldParseArrow();
              }
              setArrowFunctionParameters(e4, t3) {
                this.state.noArrowParamsConversionAt.indexOf(e4.start) !== -1 ? e4.params = t3 : super.setArrowFunctionParameters(e4, t3);
              }
              checkParams(e4, t3, r3) {
                if (!r3 || this.state.noArrowParamsConversionAt.indexOf(e4.start) === -1) {
                  for (let t4 = 0; t4 < e4.params.length; t4++)
                    this.isThisParam(e4.params[t4]) && t4 > 0 && this.raise(e4.params[t4].start, Y.ThisParamMustBeFirst);
                  return super.checkParams(...arguments);
                }
              }
              parseParenAndDistinguishExpression(e4) {
                return super.parseParenAndDistinguishExpression(e4 && this.state.noArrowAt.indexOf(this.state.start) === -1);
              }
              parseSubscripts(e4, t3, r3, n2) {
                if (e4.type === "Identifier" && e4.name === "async" && this.state.noArrowAt.indexOf(t3) !== -1) {
                  this.next();
                  const n3 = this.startNodeAt(t3, r3);
                  n3.callee = e4, n3.arguments = this.parseCallExpressionArguments(p2.parenR, false), e4 = this.finishNode(n3, "CallExpression");
                } else if (e4.type === "Identifier" && e4.name === "async" && this.isRelational("<")) {
                  const s3 = this.state.clone(), i2 = this.tryParse((e5) => this.parseAsyncArrowWithTypeParameters(t3, r3) || e5(), s3);
                  if (!i2.error && !i2.aborted)
                    return i2.node;
                  const o2 = this.tryParse(() => super.parseSubscripts(e4, t3, r3, n2), s3);
                  if (o2.node && !o2.error)
                    return o2.node;
                  if (i2.node)
                    return this.state = i2.failState, i2.node;
                  if (o2.node)
                    return this.state = o2.failState, o2.node;
                  throw i2.error || o2.error;
                }
                return super.parseSubscripts(e4, t3, r3, n2);
              }
              parseSubscript(e4, t3, r3, n2, s3) {
                if (this.match(p2.questionDot) && this.isLookaheadToken_lt()) {
                  if (s3.optionalChainMember = true, n2)
                    return s3.stop = true, e4;
                  this.next();
                  const i2 = this.startNodeAt(t3, r3);
                  return i2.callee = e4, i2.typeArguments = this.flowParseTypeParameterInstantiation(), this.expect(p2.parenL), i2.arguments = this.parseCallExpressionArguments(p2.parenR, false), i2.optional = true, this.finishCallExpression(i2, true);
                }
                if (!n2 && this.shouldParseTypes() && this.isRelational("<")) {
                  const n3 = this.startNodeAt(t3, r3);
                  n3.callee = e4;
                  const i2 = this.tryParse(() => (n3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew(), this.expect(p2.parenL), n3.arguments = this.parseCallExpressionArguments(p2.parenR, false), s3.optionalChainMember && (n3.optional = false), this.finishCallExpression(n3, s3.optionalChainMember)));
                  if (i2.node)
                    return i2.error && (this.state = i2.failState), i2.node;
                }
                return super.parseSubscript(e4, t3, r3, n2, s3);
              }
              parseNewArguments(e4) {
                let t3 = null;
                this.shouldParseTypes() && this.isRelational("<") && (t3 = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node), e4.typeArguments = t3, super.parseNewArguments(e4);
              }
              parseAsyncArrowWithTypeParameters(e4, t3) {
                const r3 = this.startNodeAt(e4, t3);
                if (this.parseFunctionParams(r3), this.parseArrow(r3))
                  return this.parseArrowExpression(r3, void 0, true);
              }
              readToken_mult_modulo(e4) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                if (e4 === 42 && t3 === 47 && this.state.hasFlowComment)
                  return this.state.hasFlowComment = false, this.state.pos += 2, void this.nextToken();
                super.readToken_mult_modulo(e4);
              }
              readToken_pipe_amp(e4) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                e4 !== 124 || t3 !== 125 ? super.readToken_pipe_amp(e4) : this.finishOp(p2.braceBarR, 2);
              }
              parseTopLevel(e4, t3) {
                const r3 = super.parseTopLevel(e4, t3);
                return this.state.hasFlowComment && this.raise(this.state.pos, Y.UnterminatedFlowComment), r3;
              }
              skipBlockComment() {
                if (this.hasPlugin("flowComments") && this.skipFlowComment())
                  return this.state.hasFlowComment && this.unexpected(null, Y.NestedFlowComment), this.hasFlowCommentCompletion(), this.state.pos += this.skipFlowComment(), void (this.state.hasFlowComment = true);
                if (this.state.hasFlowComment) {
                  const e4 = this.input.indexOf("*-/", this.state.pos += 2);
                  if (e4 === -1)
                    throw this.raise(this.state.pos - 2, x.UnterminatedComment);
                  this.state.pos = e4 + 3;
                } else
                  super.skipBlockComment();
              }
              skipFlowComment() {
                const { pos: e4 } = this.state;
                let t3 = 2;
                for (; [32, 9].includes(this.input.charCodeAt(e4 + t3)); )
                  t3++;
                const r3 = this.input.charCodeAt(t3 + e4), n2 = this.input.charCodeAt(t3 + e4 + 1);
                return r3 === 58 && n2 === 58 ? t3 + 2 : this.input.slice(t3 + e4, t3 + e4 + 12) === "flow-include" ? t3 + 12 : r3 === 58 && n2 !== 58 && t3;
              }
              hasFlowCommentCompletion() {
                if (this.input.indexOf("*/", this.state.pos) === -1)
                  throw this.raise(this.state.pos, x.UnterminatedComment);
              }
              flowEnumErrorBooleanMemberNotInitialized(e4, { enumName: t3, memberName: r3 }) {
                this.raise(e4, Y.EnumBooleanMemberNotInitialized, r3, t3);
              }
              flowEnumErrorInvalidMemberName(e4, { enumName: t3, memberName: r3 }) {
                const n2 = r3[0].toUpperCase() + r3.slice(1);
                this.raise(e4, Y.EnumInvalidMemberName, r3, n2, t3);
              }
              flowEnumErrorDuplicateMemberName(e4, { enumName: t3, memberName: r3 }) {
                this.raise(e4, Y.EnumDuplicateMemberName, r3, t3);
              }
              flowEnumErrorInconsistentMemberValues(e4, { enumName: t3 }) {
                this.raise(e4, Y.EnumInconsistentMemberValues, t3);
              }
              flowEnumErrorInvalidExplicitType(e4, { enumName: t3, suppliedType: r3 }) {
                return this.raise(e4, r3 === null ? Y.EnumInvalidExplicitTypeUnknownSupplied : Y.EnumInvalidExplicitType, t3, r3);
              }
              flowEnumErrorInvalidMemberInitializer(e4, { enumName: t3, explicitType: r3, memberName: n2 }) {
                let s3 = null;
                switch (r3) {
                  case "boolean":
                  case "number":
                  case "string":
                    s3 = Y.EnumInvalidMemberInitializerPrimaryType;
                    break;
                  case "symbol":
                    s3 = Y.EnumInvalidMemberInitializerSymbolType;
                    break;
                  default:
                    s3 = Y.EnumInvalidMemberInitializerUnknownType;
                }
                return this.raise(e4, s3, t3, n2, r3);
              }
              flowEnumErrorNumberMemberNotInitialized(e4, { enumName: t3, memberName: r3 }) {
                this.raise(e4, Y.EnumNumberMemberNotInitialized, t3, r3);
              }
              flowEnumErrorStringMemberInconsistentlyInitailized(e4, { enumName: t3 }) {
                this.raise(e4, Y.EnumStringMemberInconsistentlyInitailized, t3);
              }
              flowEnumMemberInit() {
                const e4 = this.state.start, t3 = () => this.match(p2.comma) || this.match(p2.braceR);
                switch (this.state.type) {
                  case p2.num: {
                    const r3 = this.parseNumericLiteral(this.state.value);
                    return t3() ? { type: "number", pos: r3.start, value: r3 } : { type: "invalid", pos: e4 };
                  }
                  case p2.string: {
                    const r3 = this.parseStringLiteral(this.state.value);
                    return t3() ? { type: "string", pos: r3.start, value: r3 } : { type: "invalid", pos: e4 };
                  }
                  case p2._true:
                  case p2._false: {
                    const r3 = this.parseBooleanLiteral(this.match(p2._true));
                    return t3() ? { type: "boolean", pos: r3.start, value: r3 } : { type: "invalid", pos: e4 };
                  }
                  default:
                    return { type: "invalid", pos: e4 };
                }
              }
              flowEnumMemberRaw() {
                const e4 = this.state.start;
                return { id: this.parseIdentifier(true), init: this.eat(p2.eq) ? this.flowEnumMemberInit() : { type: "none", pos: e4 } };
              }
              flowEnumCheckExplicitTypeMismatch(e4, t3, r3) {
                const { explicitType: n2 } = t3;
                n2 !== null && n2 !== r3 && this.flowEnumErrorInvalidMemberInitializer(e4, t3);
              }
              flowEnumMembers({ enumName: e4, explicitType: t3 }) {
                const r3 = new Set(), n2 = { booleanMembers: [], numberMembers: [], stringMembers: [], defaultedMembers: [] };
                let s3 = false;
                for (; !this.match(p2.braceR); ) {
                  if (this.eat(p2.ellipsis)) {
                    s3 = true;
                    break;
                  }
                  const i2 = this.startNode(), { id: o2, init: a2 } = this.flowEnumMemberRaw(), l2 = o2.name;
                  if (l2 === "")
                    continue;
                  /^[a-z]/.test(l2) && this.flowEnumErrorInvalidMemberName(o2.start, { enumName: e4, memberName: l2 }), r3.has(l2) && this.flowEnumErrorDuplicateMemberName(o2.start, { enumName: e4, memberName: l2 }), r3.add(l2);
                  const c4 = { enumName: e4, explicitType: t3, memberName: l2 };
                  switch (i2.id = o2, a2.type) {
                    case "boolean":
                      this.flowEnumCheckExplicitTypeMismatch(a2.pos, c4, "boolean"), i2.init = a2.value, n2.booleanMembers.push(this.finishNode(i2, "EnumBooleanMember"));
                      break;
                    case "number":
                      this.flowEnumCheckExplicitTypeMismatch(a2.pos, c4, "number"), i2.init = a2.value, n2.numberMembers.push(this.finishNode(i2, "EnumNumberMember"));
                      break;
                    case "string":
                      this.flowEnumCheckExplicitTypeMismatch(a2.pos, c4, "string"), i2.init = a2.value, n2.stringMembers.push(this.finishNode(i2, "EnumStringMember"));
                      break;
                    case "invalid":
                      throw this.flowEnumErrorInvalidMemberInitializer(a2.pos, c4);
                    case "none":
                      switch (t3) {
                        case "boolean":
                          this.flowEnumErrorBooleanMemberNotInitialized(a2.pos, c4);
                          break;
                        case "number":
                          this.flowEnumErrorNumberMemberNotInitialized(a2.pos, c4);
                          break;
                        default:
                          n2.defaultedMembers.push(this.finishNode(i2, "EnumDefaultedMember"));
                      }
                  }
                  this.match(p2.braceR) || this.expect(p2.comma);
                }
                return { members: n2, hasUnknownMembers: s3 };
              }
              flowEnumStringMembers(e4, t3, { enumName: r3 }) {
                if (e4.length === 0)
                  return t3;
                if (t3.length === 0)
                  return e4;
                if (t3.length > e4.length) {
                  for (const t4 of e4)
                    this.flowEnumErrorStringMemberInconsistentlyInitailized(t4.start, { enumName: r3 });
                  return t3;
                }
                for (const e5 of t3)
                  this.flowEnumErrorStringMemberInconsistentlyInitailized(e5.start, { enumName: r3 });
                return e4;
              }
              flowEnumParseExplicitType({ enumName: e4 }) {
                if (this.eatContextual("of")) {
                  if (!this.match(p2.name))
                    throw this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e4, suppliedType: null });
                  const { value: t3 } = this.state;
                  return this.next(), t3 !== "boolean" && t3 !== "number" && t3 !== "string" && t3 !== "symbol" && this.flowEnumErrorInvalidExplicitType(this.state.start, { enumName: e4, suppliedType: t3 }), t3;
                }
                return null;
              }
              flowEnumBody(e4, { enumName: t3, nameLoc: r3 }) {
                const n2 = this.flowEnumParseExplicitType({ enumName: t3 });
                this.expect(p2.braceL);
                const { members: s3, hasUnknownMembers: i2 } = this.flowEnumMembers({ enumName: t3, explicitType: n2 });
                switch (e4.hasUnknownMembers = i2, n2) {
                  case "boolean":
                    return e4.explicitType = true, e4.members = s3.booleanMembers, this.expect(p2.braceR), this.finishNode(e4, "EnumBooleanBody");
                  case "number":
                    return e4.explicitType = true, e4.members = s3.numberMembers, this.expect(p2.braceR), this.finishNode(e4, "EnumNumberBody");
                  case "string":
                    return e4.explicitType = true, e4.members = this.flowEnumStringMembers(s3.stringMembers, s3.defaultedMembers, { enumName: t3 }), this.expect(p2.braceR), this.finishNode(e4, "EnumStringBody");
                  case "symbol":
                    return e4.members = s3.defaultedMembers, this.expect(p2.braceR), this.finishNode(e4, "EnumSymbolBody");
                  default: {
                    const n3 = () => (e4.members = [], this.expect(p2.braceR), this.finishNode(e4, "EnumStringBody"));
                    e4.explicitType = false;
                    const i3 = s3.booleanMembers.length, o2 = s3.numberMembers.length, a2 = s3.stringMembers.length, l2 = s3.defaultedMembers.length;
                    if (i3 || o2 || a2 || l2) {
                      if (i3 || o2) {
                        if (!o2 && !a2 && i3 >= l2) {
                          for (const e5 of s3.defaultedMembers)
                            this.flowEnumErrorBooleanMemberNotInitialized(e5.start, { enumName: t3, memberName: e5.id.name });
                          return e4.members = s3.booleanMembers, this.expect(p2.braceR), this.finishNode(e4, "EnumBooleanBody");
                        }
                        if (!i3 && !a2 && o2 >= l2) {
                          for (const e5 of s3.defaultedMembers)
                            this.flowEnumErrorNumberMemberNotInitialized(e5.start, { enumName: t3, memberName: e5.id.name });
                          return e4.members = s3.numberMembers, this.expect(p2.braceR), this.finishNode(e4, "EnumNumberBody");
                        }
                        return this.flowEnumErrorInconsistentMemberValues(r3, { enumName: t3 }), n3();
                      }
                      return e4.members = this.flowEnumStringMembers(s3.stringMembers, s3.defaultedMembers, { enumName: t3 }), this.expect(p2.braceR), this.finishNode(e4, "EnumStringBody");
                    }
                    return n3();
                  }
                }
              }
              flowParseEnumDeclaration(e4) {
                const t3 = this.parseIdentifier();
                return e4.id = t3, e4.body = this.flowEnumBody(this.startNode(), { enumName: t3.name, nameLoc: t3.start }), this.finishNode(e4, "EnumDeclaration");
              }
              isLookaheadToken_lt() {
                const e4 = this.nextTokenStart();
                if (this.input.charCodeAt(e4) === 60) {
                  const t3 = this.input.charCodeAt(e4 + 1);
                  return t3 !== 60 && t3 !== 61;
                }
                return false;
              }
              maybeUnwrapTypeCastExpression(e4) {
                return e4.type === "TypeCastExpression" ? e4.expression : e4;
              }
            }, typescript: (e3) => class extends e3 {
              getScopeHandler() {
                return le;
              }
              tsIsIdentifier() {
                return this.match(p2.name);
              }
              tsTokenCanFollowModifier() {
                return (this.match(p2.bracketL) || this.match(p2.braceL) || this.match(p2.star) || this.match(p2.ellipsis) || this.match(p2.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
              }
              tsNextTokenCanFollowModifier() {
                return this.next(), this.tsTokenCanFollowModifier();
              }
              tsParseModifier(e4) {
                if (!this.match(p2.name))
                  return;
                const t3 = this.state.value;
                return e4.indexOf(t3) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this)) ? t3 : void 0;
              }
              tsParseModifiers(e4, t3, r3, n2) {
                const s3 = (t4, r4, n3, s4) => {
                  r4 === n3 && e4[s4] && this.raise(t4, de.InvalidModifiersOrder, n3, s4);
                }, i2 = (t4, r4, n3, s4) => {
                  (e4[n3] && r4 === s4 || e4[s4] && r4 === n3) && this.raise(t4, de.IncompatibleModifiers, n3, s4);
                };
                for (; ; ) {
                  const o2 = this.state.start, a2 = this.tsParseModifier(t3.concat(r3 != null ? r3 : []));
                  if (!a2)
                    break;
                  he(a2) ? e4.accessibility ? this.raise(o2, de.DuplicateAccessibilityModifier) : (s3(o2, a2, a2, "override"), s3(o2, a2, a2, "static"), s3(o2, a2, a2, "readonly"), e4.accessibility = a2) : (Object.hasOwnProperty.call(e4, a2) ? this.raise(o2, de.DuplicateModifier, a2) : (s3(o2, a2, "static", "readonly"), s3(o2, a2, "static", "override"), s3(o2, a2, "override", "readonly"), s3(o2, a2, "abstract", "override"), i2(o2, a2, "declare", "override"), i2(o2, a2, "static", "abstract")), e4[a2] = true), r3 != null && r3.includes(a2) && this.raise(o2, n2, a2);
                }
              }
              tsIsListTerminator(e4) {
                switch (e4) {
                  case "EnumMembers":
                  case "TypeMembers":
                    return this.match(p2.braceR);
                  case "HeritageClauseElement":
                    return this.match(p2.braceL);
                  case "TupleElementTypes":
                    return this.match(p2.bracketR);
                  case "TypeParametersOrArguments":
                    return this.isRelational(">");
                }
                throw new Error("Unreachable");
              }
              tsParseList(e4, t3) {
                const r3 = [];
                for (; !this.tsIsListTerminator(e4); )
                  r3.push(t3());
                return r3;
              }
              tsParseDelimitedList(e4, t3) {
                return pe(this.tsParseDelimitedListWorker(e4, t3, true));
              }
              tsParseDelimitedListWorker(e4, t3, r3) {
                const n2 = [];
                for (; !this.tsIsListTerminator(e4); ) {
                  const s3 = t3();
                  if (s3 == null)
                    return;
                  if (n2.push(s3), !this.eat(p2.comma)) {
                    if (this.tsIsListTerminator(e4))
                      break;
                    return void (r3 && this.expect(p2.comma));
                  }
                }
                return n2;
              }
              tsParseBracketedList(e4, t3, r3, n2) {
                n2 || (r3 ? this.expect(p2.bracketL) : this.expectRelational("<"));
                const s3 = this.tsParseDelimitedList(e4, t3);
                return r3 ? this.expect(p2.bracketR) : this.expectRelational(">"), s3;
              }
              tsParseImportType() {
                const e4 = this.startNode();
                return this.expect(p2._import), this.expect(p2.parenL), this.match(p2.string) || this.raise(this.state.start, de.UnsupportedImportTypeArgument), e4.argument = this.parseExprAtom(), this.expect(p2.parenR), this.eat(p2.dot) && (e4.qualifier = this.tsParseEntityName(true)), this.isRelational("<") && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSImportType");
              }
              tsParseEntityName(e4) {
                let t3 = this.parseIdentifier();
                for (; this.eat(p2.dot); ) {
                  const r3 = this.startNodeAtNode(t3);
                  r3.left = t3, r3.right = this.parseIdentifier(e4), t3 = this.finishNode(r3, "TSQualifiedName");
                }
                return t3;
              }
              tsParseTypeReference() {
                const e4 = this.startNode();
                return e4.typeName = this.tsParseEntityName(false), !this.hasPrecedingLineBreak() && this.isRelational("<") && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSTypeReference");
              }
              tsParseThisTypePredicate(e4) {
                this.next();
                const t3 = this.startNodeAtNode(e4);
                return t3.parameterName = e4, t3.typeAnnotation = this.tsParseTypeAnnotation(false), t3.asserts = false, this.finishNode(t3, "TSTypePredicate");
              }
              tsParseThisTypeNode() {
                const e4 = this.startNode();
                return this.next(), this.finishNode(e4, "TSThisType");
              }
              tsParseTypeQuery() {
                const e4 = this.startNode();
                return this.expect(p2._typeof), this.match(p2._import) ? e4.exprName = this.tsParseImportType() : e4.exprName = this.tsParseEntityName(true), this.finishNode(e4, "TSTypeQuery");
              }
              tsParseTypeParameter() {
                const e4 = this.startNode();
                return e4.name = this.parseIdentifierName(e4.start), e4.constraint = this.tsEatThenParseType(p2._extends), e4.default = this.tsEatThenParseType(p2.eq), this.finishNode(e4, "TSTypeParameter");
              }
              tsTryParseTypeParameters() {
                if (this.isRelational("<"))
                  return this.tsParseTypeParameters();
              }
              tsParseTypeParameters() {
                const e4 = this.startNode();
                return this.isRelational("<") || this.match(p2.jsxTagStart) ? this.next() : this.unexpected(), e4.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true), e4.params.length === 0 && this.raise(e4.start, de.EmptyTypeParameters), this.finishNode(e4, "TSTypeParameterDeclaration");
              }
              tsTryNextParseConstantContext() {
                return this.lookahead().type === p2._const ? (this.next(), this.tsParseTypeReference()) : null;
              }
              tsFillSignature(e4, t3) {
                const r3 = e4 === p2.arrow;
                t3.typeParameters = this.tsTryParseTypeParameters(), this.expect(p2.parenL), t3.parameters = this.tsParseBindingListForSignature(), (r3 || this.match(e4)) && (t3.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(e4));
              }
              tsParseBindingListForSignature() {
                return this.parseBindingList(p2.parenR, 41).map((e4) => (e4.type !== "Identifier" && e4.type !== "RestElement" && e4.type !== "ObjectPattern" && e4.type !== "ArrayPattern" && this.raise(e4.start, de.UnsupportedSignatureParameterKind, e4.type), e4));
              }
              tsParseTypeMemberSemicolon() {
                this.eat(p2.comma) || this.isLineTerminator() || this.expect(p2.semi);
              }
              tsParseSignatureMember(e4, t3) {
                return this.tsFillSignature(p2.colon, t3), this.tsParseTypeMemberSemicolon(), this.finishNode(t3, e4);
              }
              tsIsUnambiguouslyIndexSignature() {
                return this.next(), this.eat(p2.name) && this.match(p2.colon);
              }
              tsTryParseIndexSignature(e4) {
                if (!this.match(p2.bracketL) || !this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))
                  return;
                this.expect(p2.bracketL);
                const t3 = this.parseIdentifier();
                t3.typeAnnotation = this.tsParseTypeAnnotation(), this.resetEndLocation(t3), this.expect(p2.bracketR), e4.parameters = [t3];
                const r3 = this.tsTryParseTypeAnnotation();
                return r3 && (e4.typeAnnotation = r3), this.tsParseTypeMemberSemicolon(), this.finishNode(e4, "TSIndexSignature");
              }
              tsParsePropertyOrMethodSignature(e4, t3) {
                this.eat(p2.question) && (e4.optional = true);
                const r3 = e4;
                if (this.match(p2.parenL) || this.isRelational("<")) {
                  t3 && this.raise(e4.start, de.ReadonlyForMethodSignature);
                  const n2 = r3;
                  if (n2.kind && this.isRelational("<") && this.raise(this.state.pos, de.AccesorCannotHaveTypeParameters), this.tsFillSignature(p2.colon, n2), this.tsParseTypeMemberSemicolon(), n2.kind === "get")
                    n2.parameters.length > 0 && (this.raise(this.state.pos, x.BadGetterArity), this.isThisParam(n2.parameters[0]) && this.raise(this.state.pos, de.AccesorCannotDeclareThisParameter));
                  else if (n2.kind === "set") {
                    if (n2.parameters.length !== 1)
                      this.raise(this.state.pos, x.BadSetterArity);
                    else {
                      const e5 = n2.parameters[0];
                      this.isThisParam(e5) && this.raise(this.state.pos, de.AccesorCannotDeclareThisParameter), e5.type === "Identifier" && e5.optional && this.raise(this.state.pos, de.SetAccesorCannotHaveOptionalParameter), e5.type === "RestElement" && this.raise(this.state.pos, de.SetAccesorCannotHaveRestParameter);
                    }
                    n2.typeAnnotation && this.raise(n2.typeAnnotation.start, de.SetAccesorCannotHaveReturnType);
                  } else
                    n2.kind = "method";
                  return this.finishNode(n2, "TSMethodSignature");
                }
                {
                  const e5 = r3;
                  t3 && (e5.readonly = true);
                  const n2 = this.tsTryParseTypeAnnotation();
                  return n2 && (e5.typeAnnotation = n2), this.tsParseTypeMemberSemicolon(), this.finishNode(e5, "TSPropertySignature");
                }
              }
              tsParseTypeMember() {
                const e4 = this.startNode();
                if (this.match(p2.parenL) || this.isRelational("<"))
                  return this.tsParseSignatureMember("TSCallSignatureDeclaration", e4);
                if (this.match(p2._new)) {
                  const t3 = this.startNode();
                  return this.next(), this.match(p2.parenL) || this.isRelational("<") ? this.tsParseSignatureMember("TSConstructSignatureDeclaration", e4) : (e4.key = this.createIdentifier(t3, "new"), this.tsParsePropertyOrMethodSignature(e4, false));
                }
                this.tsParseModifiers(e4, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], de.InvalidModifierOnTypeMember);
                return this.tsTryParseIndexSignature(e4) || (this.parsePropertyName(e4, false), e4.computed || e4.key.type !== "Identifier" || e4.key.name !== "get" && e4.key.name !== "set" || !this.tsTokenCanFollowModifier() || (e4.kind = e4.key.name, this.parsePropertyName(e4, false)), this.tsParsePropertyOrMethodSignature(e4, !!e4.readonly));
              }
              tsParseTypeLiteral() {
                const e4 = this.startNode();
                return e4.members = this.tsParseObjectTypeMembers(), this.finishNode(e4, "TSTypeLiteral");
              }
              tsParseObjectTypeMembers() {
                this.expect(p2.braceL);
                const e4 = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
                return this.expect(p2.braceR), e4;
              }
              tsIsStartOfMappedType() {
                return this.next(), this.eat(p2.plusMin) ? this.isContextual("readonly") : (this.isContextual("readonly") && this.next(), !!this.match(p2.bracketL) && (this.next(), !!this.tsIsIdentifier() && (this.next(), this.match(p2._in))));
              }
              tsParseMappedTypeParameter() {
                const e4 = this.startNode();
                return e4.name = this.parseIdentifierName(e4.start), e4.constraint = this.tsExpectThenParseType(p2._in), this.finishNode(e4, "TSTypeParameter");
              }
              tsParseMappedType() {
                const e4 = this.startNode();
                return this.expect(p2.braceL), this.match(p2.plusMin) ? (e4.readonly = this.state.value, this.next(), this.expectContextual("readonly")) : this.eatContextual("readonly") && (e4.readonly = true), this.expect(p2.bracketL), e4.typeParameter = this.tsParseMappedTypeParameter(), e4.nameType = this.eatContextual("as") ? this.tsParseType() : null, this.expect(p2.bracketR), this.match(p2.plusMin) ? (e4.optional = this.state.value, this.next(), this.expect(p2.question)) : this.eat(p2.question) && (e4.optional = true), e4.typeAnnotation = this.tsTryParseType(), this.semicolon(), this.expect(p2.braceR), this.finishNode(e4, "TSMappedType");
              }
              tsParseTupleType() {
                const e4 = this.startNode();
                e4.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
                let t3 = false, r3 = null;
                return e4.elementTypes.forEach((e5) => {
                  var n2;
                  let { type: s3 } = e5;
                  !t3 || s3 === "TSRestType" || s3 === "TSOptionalType" || s3 === "TSNamedTupleMember" && e5.optional || this.raise(e5.start, de.OptionalTypeBeforeRequired), t3 = t3 || s3 === "TSNamedTupleMember" && e5.optional || s3 === "TSOptionalType", s3 === "TSRestType" && (s3 = (e5 = e5.typeAnnotation).type);
                  const i2 = s3 === "TSNamedTupleMember";
                  r3 = (n2 = r3) != null ? n2 : i2, r3 !== i2 && this.raise(e5.start, de.MixedLabeledAndUnlabeledElements);
                }), this.finishNode(e4, "TSTupleType");
              }
              tsParseTupleElementType() {
                const { start: e4, startLoc: t3 } = this.state, r3 = this.eat(p2.ellipsis);
                let n2 = this.tsParseType();
                const s3 = this.eat(p2.question);
                if (this.eat(p2.colon)) {
                  const e5 = this.startNodeAtNode(n2);
                  e5.optional = s3, n2.type !== "TSTypeReference" || n2.typeParameters || n2.typeName.type !== "Identifier" ? (this.raise(n2.start, de.InvalidTupleMemberLabel), e5.label = n2) : e5.label = n2.typeName, e5.elementType = this.tsParseType(), n2 = this.finishNode(e5, "TSNamedTupleMember");
                } else if (s3) {
                  const e5 = this.startNodeAtNode(n2);
                  e5.typeAnnotation = n2, n2 = this.finishNode(e5, "TSOptionalType");
                }
                if (r3) {
                  const r4 = this.startNodeAt(e4, t3);
                  r4.typeAnnotation = n2, n2 = this.finishNode(r4, "TSRestType");
                }
                return n2;
              }
              tsParseParenthesizedType() {
                const e4 = this.startNode();
                return this.expect(p2.parenL), e4.typeAnnotation = this.tsParseType(), this.expect(p2.parenR), this.finishNode(e4, "TSParenthesizedType");
              }
              tsParseFunctionOrConstructorType(e4, t3) {
                const r3 = this.startNode();
                return e4 === "TSConstructorType" && (r3.abstract = !!t3, t3 && this.next(), this.next()), this.tsFillSignature(p2.arrow, r3), this.finishNode(r3, e4);
              }
              tsParseLiteralTypeNode() {
                const e4 = this.startNode();
                return e4.literal = (() => {
                  switch (this.state.type) {
                    case p2.num:
                    case p2.bigint:
                    case p2.string:
                    case p2._true:
                    case p2._false:
                      return this.parseExprAtom();
                    default:
                      throw this.unexpected();
                  }
                })(), this.finishNode(e4, "TSLiteralType");
              }
              tsParseTemplateLiteralType() {
                const e4 = this.startNode();
                return e4.literal = this.parseTemplate(false), this.finishNode(e4, "TSLiteralType");
              }
              parseTemplateSubstitution() {
                return this.state.inType ? this.tsParseType() : super.parseTemplateSubstitution();
              }
              tsParseThisTypeOrThisTypePredicate() {
                const e4 = this.tsParseThisTypeNode();
                return this.isContextual("is") && !this.hasPrecedingLineBreak() ? this.tsParseThisTypePredicate(e4) : e4;
              }
              tsParseNonArrayType() {
                switch (this.state.type) {
                  case p2.name:
                  case p2._void:
                  case p2._null: {
                    const e4 = this.match(p2._void) ? "TSVoidKeyword" : this.match(p2._null) ? "TSNullKeyword" : function(e5) {
                      switch (e5) {
                        case "any":
                          return "TSAnyKeyword";
                        case "boolean":
                          return "TSBooleanKeyword";
                        case "bigint":
                          return "TSBigIntKeyword";
                        case "never":
                          return "TSNeverKeyword";
                        case "number":
                          return "TSNumberKeyword";
                        case "object":
                          return "TSObjectKeyword";
                        case "string":
                          return "TSStringKeyword";
                        case "symbol":
                          return "TSSymbolKeyword";
                        case "undefined":
                          return "TSUndefinedKeyword";
                        case "unknown":
                          return "TSUnknownKeyword";
                        default:
                          return;
                      }
                    }(this.state.value);
                    if (e4 !== void 0 && this.lookaheadCharCode() !== 46) {
                      const t3 = this.startNode();
                      return this.next(), this.finishNode(t3, e4);
                    }
                    return this.tsParseTypeReference();
                  }
                  case p2.string:
                  case p2.num:
                  case p2.bigint:
                  case p2._true:
                  case p2._false:
                    return this.tsParseLiteralTypeNode();
                  case p2.plusMin:
                    if (this.state.value === "-") {
                      const e4 = this.startNode(), t3 = this.lookahead();
                      if (t3.type !== p2.num && t3.type !== p2.bigint)
                        throw this.unexpected();
                      return e4.literal = this.parseMaybeUnary(), this.finishNode(e4, "TSLiteralType");
                    }
                    break;
                  case p2._this:
                    return this.tsParseThisTypeOrThisTypePredicate();
                  case p2._typeof:
                    return this.tsParseTypeQuery();
                  case p2._import:
                    return this.tsParseImportType();
                  case p2.braceL:
                    return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
                  case p2.bracketL:
                    return this.tsParseTupleType();
                  case p2.parenL:
                    return this.tsParseParenthesizedType();
                  case p2.backQuote:
                    return this.tsParseTemplateLiteralType();
                }
                throw this.unexpected();
              }
              tsParseArrayTypeOrHigher() {
                let e4 = this.tsParseNonArrayType();
                for (; !this.hasPrecedingLineBreak() && this.eat(p2.bracketL); )
                  if (this.match(p2.bracketR)) {
                    const t3 = this.startNodeAtNode(e4);
                    t3.elementType = e4, this.expect(p2.bracketR), e4 = this.finishNode(t3, "TSArrayType");
                  } else {
                    const t3 = this.startNodeAtNode(e4);
                    t3.objectType = e4, t3.indexType = this.tsParseType(), this.expect(p2.bracketR), e4 = this.finishNode(t3, "TSIndexedAccessType");
                  }
                return e4;
              }
              tsParseTypeOperator(e4) {
                const t3 = this.startNode();
                return this.expectContextual(e4), t3.operator = e4, t3.typeAnnotation = this.tsParseTypeOperatorOrHigher(), e4 === "readonly" && this.tsCheckTypeAnnotationForReadOnly(t3), this.finishNode(t3, "TSTypeOperator");
              }
              tsCheckTypeAnnotationForReadOnly(e4) {
                switch (e4.typeAnnotation.type) {
                  case "TSTupleType":
                  case "TSArrayType":
                    return;
                  default:
                    this.raise(e4.start, de.UnexpectedReadonly);
                }
              }
              tsParseInferType() {
                const e4 = this.startNode();
                this.expectContextual("infer");
                const t3 = this.startNode();
                return t3.name = this.parseIdentifierName(t3.start), e4.typeParameter = this.finishNode(t3, "TSTypeParameter"), this.finishNode(e4, "TSInferType");
              }
              tsParseTypeOperatorOrHigher() {
                const e4 = ["keyof", "unique", "readonly"].find((e5) => this.isContextual(e5));
                return e4 ? this.tsParseTypeOperator(e4) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
              }
              tsParseUnionOrIntersectionType(e4, t3, r3) {
                const n2 = this.startNode(), s3 = this.eat(r3), i2 = [];
                do {
                  i2.push(t3());
                } while (this.eat(r3));
                return i2.length !== 1 || s3 ? (n2.types = i2, this.finishNode(n2, e4)) : i2[0];
              }
              tsParseIntersectionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), p2.bitwiseAND);
              }
              tsParseUnionTypeOrHigher() {
                return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), p2.bitwiseOR);
              }
              tsIsStartOfFunctionType() {
                return !!this.isRelational("<") || this.match(p2.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
              }
              tsSkipParameterStart() {
                if (this.match(p2.name) || this.match(p2._this))
                  return this.next(), true;
                if (this.match(p2.braceL)) {
                  let e4 = 1;
                  for (this.next(); e4 > 0; )
                    this.match(p2.braceL) ? ++e4 : this.match(p2.braceR) && --e4, this.next();
                  return true;
                }
                if (this.match(p2.bracketL)) {
                  let e4 = 1;
                  for (this.next(); e4 > 0; )
                    this.match(p2.bracketL) ? ++e4 : this.match(p2.bracketR) && --e4, this.next();
                  return true;
                }
                return false;
              }
              tsIsUnambiguouslyStartOfFunctionType() {
                if (this.next(), this.match(p2.parenR) || this.match(p2.ellipsis))
                  return true;
                if (this.tsSkipParameterStart()) {
                  if (this.match(p2.colon) || this.match(p2.comma) || this.match(p2.question) || this.match(p2.eq))
                    return true;
                  if (this.match(p2.parenR) && (this.next(), this.match(p2.arrow)))
                    return true;
                }
                return false;
              }
              tsParseTypeOrTypePredicateAnnotation(e4) {
                return this.tsInType(() => {
                  const t3 = this.startNode();
                  this.expect(e4);
                  const r3 = this.startNode(), n2 = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
                  if (n2 && this.match(p2._this)) {
                    let e5 = this.tsParseThisTypeOrThisTypePredicate();
                    return e5.type === "TSThisType" ? (r3.parameterName = e5, r3.asserts = true, r3.typeAnnotation = null, e5 = this.finishNode(r3, "TSTypePredicate")) : (this.resetStartLocationFromNode(e5, r3), e5.asserts = true), t3.typeAnnotation = e5, this.finishNode(t3, "TSTypeAnnotation");
                  }
                  const s3 = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
                  if (!s3)
                    return n2 ? (r3.parameterName = this.parseIdentifier(), r3.asserts = n2, r3.typeAnnotation = null, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation")) : this.tsParseTypeAnnotation(false, t3);
                  const i2 = this.tsParseTypeAnnotation(false);
                  return r3.parameterName = s3, r3.typeAnnotation = i2, r3.asserts = n2, t3.typeAnnotation = this.finishNode(r3, "TSTypePredicate"), this.finishNode(t3, "TSTypeAnnotation");
                });
              }
              tsTryParseTypeOrTypePredicateAnnotation() {
                return this.match(p2.colon) ? this.tsParseTypeOrTypePredicateAnnotation(p2.colon) : void 0;
              }
              tsTryParseTypeAnnotation() {
                return this.match(p2.colon) ? this.tsParseTypeAnnotation() : void 0;
              }
              tsTryParseType() {
                return this.tsEatThenParseType(p2.colon);
              }
              tsParseTypePredicatePrefix() {
                const e4 = this.parseIdentifier();
                if (this.isContextual("is") && !this.hasPrecedingLineBreak())
                  return this.next(), e4;
              }
              tsParseTypePredicateAsserts() {
                if (!this.match(p2.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak())
                  return false;
                const e4 = this.state.containsEsc;
                return this.next(), !(!this.match(p2.name) && !this.match(p2._this) || (e4 && this.raise(this.state.lastTokStart, x.InvalidEscapedReservedWord, "asserts"), 0));
              }
              tsParseTypeAnnotation(e4 = true, t3 = this.startNode()) {
                return this.tsInType(() => {
                  e4 && this.expect(p2.colon), t3.typeAnnotation = this.tsParseType();
                }), this.finishNode(t3, "TSTypeAnnotation");
              }
              tsParseType() {
                fe(this.state.inType);
                const e4 = this.tsParseNonConditionalType();
                if (this.hasPrecedingLineBreak() || !this.eat(p2._extends))
                  return e4;
                const t3 = this.startNodeAtNode(e4);
                return t3.checkType = e4, t3.extendsType = this.tsParseNonConditionalType(), this.expect(p2.question), t3.trueType = this.tsParseType(), this.expect(p2.colon), t3.falseType = this.tsParseType(), this.finishNode(t3, "TSConditionalType");
              }
              isAbstractConstructorSignature() {
                return this.isContextual("abstract") && this.lookahead().type === p2._new;
              }
              tsParseNonConditionalType() {
                return this.tsIsStartOfFunctionType() ? this.tsParseFunctionOrConstructorType("TSFunctionType") : this.match(p2._new) ? this.tsParseFunctionOrConstructorType("TSConstructorType") : this.isAbstractConstructorSignature() ? this.tsParseFunctionOrConstructorType("TSConstructorType", true) : this.tsParseUnionTypeOrHigher();
              }
              tsParseTypeAssertion() {
                const e4 = this.startNode(), t3 = this.tsTryNextParseConstantContext();
                return e4.typeAnnotation = t3 || this.tsNextThenParseType(), this.expectRelational(">"), e4.expression = this.parseMaybeUnary(), this.finishNode(e4, "TSTypeAssertion");
              }
              tsParseHeritageClause(e4) {
                const t3 = this.state.start, r3 = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));
                return r3.length || this.raise(t3, de.EmptyHeritageClauseType, e4), r3;
              }
              tsParseExpressionWithTypeArguments() {
                const e4 = this.startNode();
                return e4.expression = this.tsParseEntityName(false), this.isRelational("<") && (e4.typeParameters = this.tsParseTypeArguments()), this.finishNode(e4, "TSExpressionWithTypeArguments");
              }
              tsParseInterfaceDeclaration(e4) {
                e4.id = this.parseIdentifier(), this.checkLVal(e4.id, "typescript interface declaration", 130), e4.typeParameters = this.tsTryParseTypeParameters(), this.eat(p2._extends) && (e4.extends = this.tsParseHeritageClause("extends"));
                const t3 = this.startNode();
                return t3.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this)), e4.body = this.finishNode(t3, "TSInterfaceBody"), this.finishNode(e4, "TSInterfaceDeclaration");
              }
              tsParseTypeAliasDeclaration(e4) {
                return e4.id = this.parseIdentifier(), this.checkLVal(e4.id, "typescript type alias", 2), e4.typeParameters = this.tsTryParseTypeParameters(), e4.typeAnnotation = this.tsInType(() => {
                  if (this.expect(p2.eq), this.isContextual("intrinsic") && this.lookahead().type !== p2.dot) {
                    const e5 = this.startNode();
                    return this.next(), this.finishNode(e5, "TSIntrinsicKeyword");
                  }
                  return this.tsParseType();
                }), this.semicolon(), this.finishNode(e4, "TSTypeAliasDeclaration");
              }
              tsInNoContext(e4) {
                const t3 = this.state.context;
                this.state.context = [t3[0]];
                try {
                  return e4();
                } finally {
                  this.state.context = t3;
                }
              }
              tsInType(e4) {
                const t3 = this.state.inType;
                this.state.inType = true;
                try {
                  return e4();
                } finally {
                  this.state.inType = t3;
                }
              }
              tsEatThenParseType(e4) {
                return this.match(e4) ? this.tsNextThenParseType() : void 0;
              }
              tsExpectThenParseType(e4) {
                return this.tsDoThenParseType(() => this.expect(e4));
              }
              tsNextThenParseType() {
                return this.tsDoThenParseType(() => this.next());
              }
              tsDoThenParseType(e4) {
                return this.tsInType(() => (e4(), this.tsParseType()));
              }
              tsParseEnumMember() {
                const e4 = this.startNode();
                return e4.id = this.match(p2.string) ? this.parseExprAtom() : this.parseIdentifier(true), this.eat(p2.eq) && (e4.initializer = this.parseMaybeAssignAllowIn()), this.finishNode(e4, "TSEnumMember");
              }
              tsParseEnumDeclaration(e4, t3) {
                return t3 && (e4.const = true), e4.id = this.parseIdentifier(), this.checkLVal(e4.id, "typescript enum declaration", t3 ? 779 : 267), this.expect(p2.braceL), e4.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this)), this.expect(p2.braceR), this.finishNode(e4, "TSEnumDeclaration");
              }
              tsParseModuleBlock() {
                const e4 = this.startNode();
                return this.scope.enter(0), this.expect(p2.braceL), this.parseBlockOrModuleBlockBody(e4.body = [], void 0, true, p2.braceR), this.scope.exit(), this.finishNode(e4, "TSModuleBlock");
              }
              tsParseModuleOrNamespaceDeclaration(e4, t3 = false) {
                if (e4.id = this.parseIdentifier(), t3 || this.checkLVal(e4.id, "module or namespace declaration", 1024), this.eat(p2.dot)) {
                  const t4 = this.startNode();
                  this.tsParseModuleOrNamespaceDeclaration(t4, true), e4.body = t4;
                } else
                  this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit();
                return this.finishNode(e4, "TSModuleDeclaration");
              }
              tsParseAmbientExternalModuleDeclaration(e4) {
                return this.isContextual("global") ? (e4.global = true, e4.id = this.parseIdentifier()) : this.match(p2.string) ? e4.id = this.parseExprAtom() : this.unexpected(), this.match(p2.braceL) ? (this.scope.enter(256), this.prodParam.enter(0), e4.body = this.tsParseModuleBlock(), this.prodParam.exit(), this.scope.exit()) : this.semicolon(), this.finishNode(e4, "TSModuleDeclaration");
              }
              tsParseImportEqualsDeclaration(e4, t3) {
                e4.isExport = t3 || false, e4.id = this.parseIdentifier(), this.checkLVal(e4.id, "import equals declaration", 9), this.expect(p2.eq);
                const r3 = this.tsParseModuleReference();
                return e4.importKind === "type" && r3.type !== "TSExternalModuleReference" && this.raise(r3.start, de.ImportAliasHasImportType), e4.moduleReference = r3, this.semicolon(), this.finishNode(e4, "TSImportEqualsDeclaration");
              }
              tsIsExternalModuleReference() {
                return this.isContextual("require") && this.lookaheadCharCode() === 40;
              }
              tsParseModuleReference() {
                return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
              }
              tsParseExternalModuleReference() {
                const e4 = this.startNode();
                if (this.expectContextual("require"), this.expect(p2.parenL), !this.match(p2.string))
                  throw this.unexpected();
                return e4.expression = this.parseExprAtom(), this.expect(p2.parenR), this.finishNode(e4, "TSExternalModuleReference");
              }
              tsLookAhead(e4) {
                const t3 = this.state.clone(), r3 = e4();
                return this.state = t3, r3;
              }
              tsTryParseAndCatch(e4) {
                const t3 = this.tryParse((t4) => e4() || t4());
                if (!t3.aborted && t3.node)
                  return t3.error && (this.state = t3.failState), t3.node;
              }
              tsTryParse(e4) {
                const t3 = this.state.clone(), r3 = e4();
                return r3 !== void 0 && r3 !== false ? r3 : void (this.state = t3);
              }
              tsTryParseDeclare(e4) {
                if (this.isLineTerminator())
                  return;
                let t3, r3 = this.state.type;
                return this.isContextual("let") && (r3 = p2._var, t3 = "let"), this.tsInAmbientContext(() => {
                  switch (r3) {
                    case p2._function:
                      return e4.declare = true, this.parseFunctionStatement(e4, false, true);
                    case p2._class:
                      return e4.declare = true, this.parseClass(e4, true, false);
                    case p2._const:
                      if (this.match(p2._const) && this.isLookaheadContextual("enum"))
                        return this.expect(p2._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e4, true);
                    case p2._var:
                      return t3 = t3 || this.state.value, this.parseVarStatement(e4, t3);
                    case p2.name: {
                      const t4 = this.state.value;
                      return t4 === "global" ? this.tsParseAmbientExternalModuleDeclaration(e4) : this.tsParseDeclaration(e4, t4, true);
                    }
                  }
                });
              }
              tsTryParseExportDeclaration() {
                return this.tsParseDeclaration(this.startNode(), this.state.value, true);
              }
              tsParseExpressionStatement(e4, t3) {
                switch (t3.name) {
                  case "declare": {
                    const t4 = this.tsTryParseDeclare(e4);
                    if (t4)
                      return t4.declare = true, t4;
                    break;
                  }
                  case "global":
                    if (this.match(p2.braceL)) {
                      this.scope.enter(256), this.prodParam.enter(0);
                      const r3 = e4;
                      return r3.global = true, r3.id = t3, r3.body = this.tsParseModuleBlock(), this.scope.exit(), this.prodParam.exit(), this.finishNode(r3, "TSModuleDeclaration");
                    }
                    break;
                  default:
                    return this.tsParseDeclaration(e4, t3.name, false);
                }
              }
              tsParseDeclaration(e4, t3, r3) {
                switch (t3) {
                  case "abstract":
                    if (this.tsCheckLineTerminator(r3) && (this.match(p2._class) || this.match(p2.name)))
                      return this.tsParseAbstractDeclaration(e4);
                    break;
                  case "enum":
                    if (r3 || this.match(p2.name))
                      return r3 && this.next(), this.tsParseEnumDeclaration(e4, false);
                    break;
                  case "interface":
                    if (this.tsCheckLineTerminator(r3) && this.match(p2.name))
                      return this.tsParseInterfaceDeclaration(e4);
                    break;
                  case "module":
                    if (this.tsCheckLineTerminator(r3)) {
                      if (this.match(p2.string))
                        return this.tsParseAmbientExternalModuleDeclaration(e4);
                      if (this.match(p2.name))
                        return this.tsParseModuleOrNamespaceDeclaration(e4);
                    }
                    break;
                  case "namespace":
                    if (this.tsCheckLineTerminator(r3) && this.match(p2.name))
                      return this.tsParseModuleOrNamespaceDeclaration(e4);
                    break;
                  case "type":
                    if (this.tsCheckLineTerminator(r3) && this.match(p2.name))
                      return this.tsParseTypeAliasDeclaration(e4);
                }
              }
              tsCheckLineTerminator(e4) {
                return e4 ? !this.hasFollowingLineBreak() && (this.next(), true) : !this.isLineTerminator();
              }
              tsTryParseGenericAsyncArrowFunction(e4, t3) {
                if (!this.isRelational("<"))
                  return;
                const r3 = this.state.maybeInArrowParameters;
                this.state.maybeInArrowParameters = true;
                const n2 = this.tsTryParseAndCatch(() => {
                  const r4 = this.startNodeAt(e4, t3);
                  return r4.typeParameters = this.tsParseTypeParameters(), super.parseFunctionParams(r4), r4.returnType = this.tsTryParseTypeOrTypePredicateAnnotation(), this.expect(p2.arrow), r4;
                });
                return this.state.maybeInArrowParameters = r3, n2 ? this.parseArrowExpression(n2, null, true) : void 0;
              }
              tsParseTypeArguments() {
                const e4 = this.startNode();
                return e4.params = this.tsInType(() => this.tsInNoContext(() => (this.expectRelational("<"), this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this))))), e4.params.length === 0 && this.raise(e4.start, de.EmptyTypeArguments), this.expectRelational(">"), this.finishNode(e4, "TSTypeParameterInstantiation");
              }
              tsIsDeclarationStart() {
                if (this.match(p2.name))
                  switch (this.state.value) {
                    case "abstract":
                    case "declare":
                    case "enum":
                    case "interface":
                    case "module":
                    case "namespace":
                    case "type":
                      return true;
                  }
                return false;
              }
              isExportDefaultSpecifier() {
                return !this.tsIsDeclarationStart() && super.isExportDefaultSpecifier();
              }
              parseAssignableListItem(e4, t3) {
                const r3 = this.state.start, n2 = this.state.startLoc;
                let s3, i2 = false, o2 = false;
                if (e4 !== void 0) {
                  const t4 = {};
                  this.tsParseModifiers(t4, ["public", "private", "protected", "override", "readonly"]), s3 = t4.accessibility, o2 = t4.override, i2 = t4.readonly, e4 === false && (s3 || i2 || o2) && this.raise(r3, de.UnexpectedParameterModifier);
                }
                const a2 = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(a2);
                const l2 = this.parseMaybeDefault(a2.start, a2.loc.start, a2);
                if (s3 || i2 || o2) {
                  const e5 = this.startNodeAt(r3, n2);
                  return t3.length && (e5.decorators = t3), s3 && (e5.accessibility = s3), i2 && (e5.readonly = i2), o2 && (e5.override = o2), l2.type !== "Identifier" && l2.type !== "AssignmentPattern" && this.raise(e5.start, de.UnsupportedParameterPropertyKind), e5.parameter = l2, this.finishNode(e5, "TSParameterProperty");
                }
                return t3.length && (a2.decorators = t3), l2;
              }
              parseFunctionBodyAndFinish(e4, t3, r3 = false) {
                this.match(p2.colon) && (e4.returnType = this.tsParseTypeOrTypePredicateAnnotation(p2.colon));
                const n2 = t3 === "FunctionDeclaration" ? "TSDeclareFunction" : t3 === "ClassMethod" ? "TSDeclareMethod" : void 0;
                n2 && !this.match(p2.braceL) && this.isLineTerminator() ? this.finishNode(e4, n2) : n2 === "TSDeclareFunction" && this.state.isAmbientContext && (this.raise(e4.start, de.DeclareFunctionHasImplementation), e4.declare) ? super.parseFunctionBodyAndFinish(e4, n2, r3) : super.parseFunctionBodyAndFinish(e4, t3, r3);
              }
              registerFunctionStatementId(e4) {
                !e4.body && e4.id ? this.checkLVal(e4.id, "function name", 1024) : super.registerFunctionStatementId(...arguments);
              }
              tsCheckForInvalidTypeCasts(e4) {
                e4.forEach((e5) => {
                  (e5 == null ? void 0 : e5.type) === "TSTypeCastExpression" && this.raise(e5.typeAnnotation.start, de.UnexpectedTypeAnnotation);
                });
              }
              toReferencedList(e4, t3) {
                return this.tsCheckForInvalidTypeCasts(e4), e4;
              }
              parseArrayLike(...e4) {
                const t3 = super.parseArrayLike(...e4);
                return t3.type === "ArrayExpression" && this.tsCheckForInvalidTypeCasts(t3.elements), t3;
              }
              parseSubscript(e4, t3, r3, n2, s3) {
                if (!this.hasPrecedingLineBreak() && this.match(p2.bang)) {
                  this.state.exprAllowed = false, this.next();
                  const n3 = this.startNodeAt(t3, r3);
                  return n3.expression = e4, this.finishNode(n3, "TSNonNullExpression");
                }
                if (this.isRelational("<")) {
                  const i2 = this.tsTryParseAndCatch(() => {
                    if (!n2 && this.atPossibleAsyncArrow(e4)) {
                      const e5 = this.tsTryParseGenericAsyncArrowFunction(t3, r3);
                      if (e5)
                        return e5;
                    }
                    const i3 = this.startNodeAt(t3, r3);
                    i3.callee = e4;
                    const o2 = this.tsParseTypeArguments();
                    if (o2) {
                      if (!n2 && this.eat(p2.parenL))
                        return i3.arguments = this.parseCallExpressionArguments(p2.parenR, false), this.tsCheckForInvalidTypeCasts(i3.arguments), i3.typeParameters = o2, s3.optionalChainMember && (i3.optional = false), this.finishCallExpression(i3, s3.optionalChainMember);
                      if (this.match(p2.backQuote)) {
                        const n3 = this.parseTaggedTemplateExpression(e4, t3, r3, s3);
                        return n3.typeParameters = o2, n3;
                      }
                    }
                    this.unexpected();
                  });
                  if (i2)
                    return i2;
                }
                return super.parseSubscript(e4, t3, r3, n2, s3);
              }
              parseNewArguments(e4) {
                if (this.isRelational("<")) {
                  const t3 = this.tsTryParseAndCatch(() => {
                    const e5 = this.tsParseTypeArguments();
                    return this.match(p2.parenL) || this.unexpected(), e5;
                  });
                  t3 && (e4.typeParameters = t3);
                }
                super.parseNewArguments(e4);
              }
              parseExprOp(e4, t3, r3, n2) {
                if (pe(p2._in.binop) > n2 && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
                  const s3 = this.startNodeAt(t3, r3);
                  s3.expression = e4;
                  const i2 = this.tsTryNextParseConstantContext();
                  return s3.typeAnnotation = i2 || this.tsNextThenParseType(), this.finishNode(s3, "TSAsExpression"), this.reScan_lt_gt(), this.parseExprOp(s3, t3, r3, n2);
                }
                return super.parseExprOp(e4, t3, r3, n2);
              }
              checkReservedWord(e4, t3, r3, n2) {
              }
              checkDuplicateExports() {
              }
              parseImport(e4) {
                if (e4.importKind = "value", this.match(p2.name) || this.match(p2.star) || this.match(p2.braceL)) {
                  let t4 = this.lookahead();
                  if (!this.isContextual("type") || t4.type === p2.comma || t4.type === p2.name && t4.value === "from" || t4.type === p2.eq || (e4.importKind = "type", this.next(), t4 = this.lookahead()), this.match(p2.name) && t4.type === p2.eq)
                    return this.tsParseImportEqualsDeclaration(e4);
                }
                const t3 = super.parseImport(e4);
                return t3.importKind === "type" && t3.specifiers.length > 1 && t3.specifiers[0].type === "ImportDefaultSpecifier" && this.raise(t3.start, de.TypeImportCannotSpecifyDefaultAndNamed), t3;
              }
              parseExport(e4) {
                if (this.match(p2._import))
                  return this.next(), this.isContextual("type") && this.lookaheadCharCode() !== 61 ? (e4.importKind = "type", this.next()) : e4.importKind = "value", this.tsParseImportEqualsDeclaration(e4, true);
                if (this.eat(p2.eq)) {
                  const t3 = e4;
                  return t3.expression = this.parseExpression(), this.semicolon(), this.finishNode(t3, "TSExportAssignment");
                }
                if (this.eatContextual("as")) {
                  const t3 = e4;
                  return this.expectContextual("namespace"), t3.id = this.parseIdentifier(), this.semicolon(), this.finishNode(t3, "TSNamespaceExportDeclaration");
                }
                return this.isContextual("type") && this.lookahead().type === p2.braceL ? (this.next(), e4.exportKind = "type") : e4.exportKind = "value", super.parseExport(e4);
              }
              isAbstractClass() {
                return this.isContextual("abstract") && this.lookahead().type === p2._class;
              }
              parseExportDefaultExpression() {
                if (this.isAbstractClass()) {
                  const e4 = this.startNode();
                  return this.next(), e4.abstract = true, this.parseClass(e4, true, true), e4;
                }
                if (this.state.value === "interface") {
                  const e4 = this.tsParseDeclaration(this.startNode(), this.state.value, true);
                  if (e4)
                    return e4;
                }
                return super.parseExportDefaultExpression();
              }
              parseStatementContent(e4, t3) {
                if (this.state.type === p2._const) {
                  const e5 = this.lookahead();
                  if (e5.type === p2.name && e5.value === "enum") {
                    const e6 = this.startNode();
                    return this.expect(p2._const), this.expectContextual("enum"), this.tsParseEnumDeclaration(e6, true);
                  }
                }
                return super.parseStatementContent(e4, t3);
              }
              parseAccessModifier() {
                return this.tsParseModifier(["public", "protected", "private"]);
              }
              tsHasSomeModifiers(e4, t3) {
                return t3.some((t4) => he(t4) ? e4.accessibility === t4 : !!e4[t4]);
              }
              parseClassMember(e4, t3, r3) {
                const n2 = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
                this.tsParseModifiers(t3, n2.concat(["static"]));
                const s3 = () => {
                  const s4 = !!t3.static;
                  s4 && this.eat(p2.braceL) ? (this.tsHasSomeModifiers(t3, n2) && this.raise(this.state.pos, de.StaticBlockCannotHaveModifier), this.parseClassStaticBlock(e4, t3)) : this.parseClassMemberWithIsStatic(e4, t3, r3, s4);
                };
                t3.declare ? this.tsInAmbientContext(s3) : s3();
              }
              parseClassMemberWithIsStatic(e4, t3, r3, n2) {
                const s3 = this.tsTryParseIndexSignature(t3);
                if (s3)
                  return e4.body.push(s3), t3.abstract && this.raise(t3.start, de.IndexSignatureHasAbstract), t3.accessibility && this.raise(t3.start, de.IndexSignatureHasAccessibility, t3.accessibility), t3.declare && this.raise(t3.start, de.IndexSignatureHasDeclare), void (t3.override && this.raise(t3.start, de.IndexSignatureHasOverride));
                !this.state.inAbstractClass && t3.abstract && this.raise(t3.start, de.NonAbstractClassHasAbstractMethod), t3.override && (r3.hadSuperClass || this.raise(t3.start, de.OverrideNotInSubClass)), super.parseClassMemberWithIsStatic(e4, t3, r3, n2);
              }
              parsePostMemberNameModifiers(e4) {
                this.eat(p2.question) && (e4.optional = true), e4.readonly && this.match(p2.parenL) && this.raise(e4.start, de.ClassMethodHasReadonly), e4.declare && this.match(p2.parenL) && this.raise(e4.start, de.ClassMethodHasDeclare);
              }
              parseExpressionStatement(e4, t3) {
                return (t3.type === "Identifier" ? this.tsParseExpressionStatement(e4, t3) : void 0) || super.parseExpressionStatement(e4, t3);
              }
              shouldParseExportDeclaration() {
                return !!this.tsIsDeclarationStart() || super.shouldParseExportDeclaration();
              }
              parseConditional(e4, t3, r3, n2) {
                if (!this.state.maybeInArrowParameters || !this.match(p2.question))
                  return super.parseConditional(e4, t3, r3, n2);
                const s3 = this.tryParse(() => super.parseConditional(e4, t3, r3));
                return s3.node ? (s3.error && (this.state = s3.failState), s3.node) : (s3.error && super.setOptionalParametersError(n2, s3.error), e4);
              }
              parseParenItem(e4, t3, r3) {
                if (e4 = super.parseParenItem(e4, t3, r3), this.eat(p2.question) && (e4.optional = true, this.resetEndLocation(e4)), this.match(p2.colon)) {
                  const n2 = this.startNodeAt(t3, r3);
                  return n2.expression = e4, n2.typeAnnotation = this.tsParseTypeAnnotation(), this.finishNode(n2, "TSTypeCastExpression");
                }
                return e4;
              }
              parseExportDeclaration(e4) {
                const t3 = this.state.start, r3 = this.state.startLoc, n2 = this.eatContextual("declare");
                if (n2 && (this.isContextual("declare") || !this.shouldParseExportDeclaration()))
                  throw this.raise(this.state.start, de.ExpectedAmbientAfterExportDeclare);
                let s3;
                return this.match(p2.name) && (s3 = this.tsTryParseExportDeclaration()), s3 || (s3 = super.parseExportDeclaration(e4)), s3 && (s3.type === "TSInterfaceDeclaration" || s3.type === "TSTypeAliasDeclaration" || n2) && (e4.exportKind = "type"), s3 && n2 && (this.resetStartLocation(s3, t3, r3), s3.declare = true), s3;
              }
              parseClassId(e4, t3, r3) {
                if ((!t3 || r3) && this.isContextual("implements"))
                  return;
                super.parseClassId(e4, t3, r3, e4.declare ? 1024 : 139);
                const n2 = this.tsTryParseTypeParameters();
                n2 && (e4.typeParameters = n2);
              }
              parseClassPropertyAnnotation(e4) {
                !e4.optional && this.eat(p2.bang) && (e4.definite = true);
                const t3 = this.tsTryParseTypeAnnotation();
                t3 && (e4.typeAnnotation = t3);
              }
              parseClassProperty(e4) {
                return this.parseClassPropertyAnnotation(e4), this.state.isAmbientContext && this.match(p2.eq) && this.raise(this.state.start, de.DeclareClassFieldHasInitializer), super.parseClassProperty(e4);
              }
              parseClassPrivateProperty(e4) {
                return e4.abstract && this.raise(e4.start, de.PrivateElementHasAbstract), e4.accessibility && this.raise(e4.start, de.PrivateElementHasAccessibility, e4.accessibility), this.parseClassPropertyAnnotation(e4), super.parseClassPrivateProperty(e4);
              }
              pushClassMethod(e4, t3, r3, n2, s3, i2) {
                const o2 = this.tsTryParseTypeParameters();
                o2 && s3 && this.raise(o2.start, de.ConstructorHasTypeParameters), !t3.declare || t3.kind !== "get" && t3.kind !== "set" || this.raise(t3.start, de.DeclareAccessor, t3.kind), o2 && (t3.typeParameters = o2), super.pushClassMethod(e4, t3, r3, n2, s3, i2);
              }
              pushClassPrivateMethod(e4, t3, r3, n2) {
                const s3 = this.tsTryParseTypeParameters();
                s3 && (t3.typeParameters = s3), super.pushClassPrivateMethod(e4, t3, r3, n2);
              }
              parseClassSuper(e4) {
                super.parseClassSuper(e4), e4.superClass && this.isRelational("<") && (e4.superTypeParameters = this.tsParseTypeArguments()), this.eatContextual("implements") && (e4.implements = this.tsParseHeritageClause("implements"));
              }
              parseObjPropValue(e4, ...t3) {
                const r3 = this.tsTryParseTypeParameters();
                r3 && (e4.typeParameters = r3), super.parseObjPropValue(e4, ...t3);
              }
              parseFunctionParams(e4, t3) {
                const r3 = this.tsTryParseTypeParameters();
                r3 && (e4.typeParameters = r3), super.parseFunctionParams(e4, t3);
              }
              parseVarId(e4, t3) {
                super.parseVarId(e4, t3), e4.id.type === "Identifier" && this.eat(p2.bang) && (e4.definite = true);
                const r3 = this.tsTryParseTypeAnnotation();
                r3 && (e4.id.typeAnnotation = r3, this.resetEndLocation(e4.id));
              }
              parseAsyncArrowFromCallExpression(e4, t3) {
                return this.match(p2.colon) && (e4.returnType = this.tsParseTypeAnnotation()), super.parseAsyncArrowFromCallExpression(e4, t3);
              }
              parseMaybeAssign(...e4) {
                var t3, r3, n2, s3, i2, o2, a2;
                let l2, c4, u2, f2;
                if (this.hasPlugin("jsx") && (this.match(p2.jsxTagStart) || this.isRelational("<"))) {
                  if (l2 = this.state.clone(), c4 = this.tryParse(() => super.parseMaybeAssign(...e4), l2), !c4.error)
                    return c4.node;
                  const { context: t4 } = this.state;
                  t4[t4.length - 1] === P.j_oTag ? t4.length -= 2 : t4[t4.length - 1] === P.j_expr && (t4.length -= 1);
                }
                if (!((t3 = c4) != null && t3.error || this.isRelational("<")))
                  return super.parseMaybeAssign(...e4);
                l2 = l2 || this.state.clone();
                const d2 = this.tryParse((t4) => {
                  var r4, n3;
                  f2 = this.tsParseTypeParameters();
                  const s4 = super.parseMaybeAssign(...e4);
                  return (s4.type !== "ArrowFunctionExpression" || (r4 = s4.extra) != null && r4.parenthesized) && t4(), ((n3 = f2) == null ? void 0 : n3.params.length) !== 0 && this.resetStartLocationFromNode(s4, f2), s4.typeParameters = f2, s4;
                }, l2);
                if (!d2.error && !d2.aborted)
                  return d2.node;
                if (!c4 && (fe(!this.hasPlugin("jsx")), u2 = this.tryParse(() => super.parseMaybeAssign(...e4), l2), !u2.error))
                  return u2.node;
                if ((r3 = c4) != null && r3.node)
                  return this.state = c4.failState, c4.node;
                if (d2.node)
                  return this.state = d2.failState, d2.node;
                if ((n2 = u2) != null && n2.node)
                  return this.state = u2.failState, u2.node;
                if ((s3 = c4) != null && s3.thrown)
                  throw c4.error;
                if (d2.thrown)
                  throw d2.error;
                if ((i2 = u2) != null && i2.thrown)
                  throw u2.error;
                throw ((o2 = c4) == null ? void 0 : o2.error) || d2.error || ((a2 = u2) == null ? void 0 : a2.error);
              }
              parseMaybeUnary(e4) {
                return !this.hasPlugin("jsx") && this.isRelational("<") ? this.tsParseTypeAssertion() : super.parseMaybeUnary(e4);
              }
              parseArrow(e4) {
                if (this.match(p2.colon)) {
                  const t3 = this.tryParse((e5) => {
                    const t4 = this.tsParseTypeOrTypePredicateAnnotation(p2.colon);
                    return !this.canInsertSemicolon() && this.match(p2.arrow) || e5(), t4;
                  });
                  if (t3.aborted)
                    return;
                  t3.thrown || (t3.error && (this.state = t3.failState), e4.returnType = t3.node);
                }
                return super.parseArrow(e4);
              }
              parseAssignableListItemTypes(e4) {
                this.eat(p2.question) && (e4.type === "Identifier" || this.state.isAmbientContext || this.state.inType || this.raise(e4.start, de.PatternIsOptional), e4.optional = true);
                const t3 = this.tsTryParseTypeAnnotation();
                return t3 && (e4.typeAnnotation = t3), this.resetEndLocation(e4), e4;
              }
              toAssignable(e4, t3 = false) {
                switch (e4.type) {
                  case "TSTypeCastExpression":
                    return super.toAssignable(this.typeCastToParameter(e4), t3);
                  case "TSParameterProperty":
                    return super.toAssignable(e4, t3);
                  case "ParenthesizedExpression":
                    return this.toAssignableParenthesizedExpression(e4, t3);
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                    return e4.expression = this.toAssignable(e4.expression, t3), e4;
                  default:
                    return super.toAssignable(e4, t3);
                }
              }
              toAssignableParenthesizedExpression(e4, t3) {
                switch (e4.expression.type) {
                  case "TSAsExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                  case "ParenthesizedExpression":
                    return e4.expression = this.toAssignable(e4.expression, t3), e4;
                  default:
                    return super.toAssignable(e4, t3);
                }
              }
              checkLVal(e4, t3, ...r3) {
                var n2;
                switch (e4.type) {
                  case "TSTypeCastExpression":
                    return;
                  case "TSParameterProperty":
                    return void this.checkLVal(e4.parameter, "parameter property", ...r3);
                  case "TSAsExpression":
                  case "TSTypeAssertion":
                    if (!(r3[0] || t3 === "parenthesized expression" || (n2 = e4.extra) != null && n2.parenthesized)) {
                      this.raise(e4.start, x.InvalidLhs, t3);
                      break;
                    }
                    return void this.checkLVal(e4.expression, "parenthesized expression", ...r3);
                  case "TSNonNullExpression":
                    return void this.checkLVal(e4.expression, t3, ...r3);
                  default:
                    return void super.checkLVal(e4, t3, ...r3);
                }
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case p2._this:
                    return this.parseIdentifier(true);
                  default:
                    return super.parseBindingAtom();
                }
              }
              parseMaybeDecoratorArguments(e4) {
                if (this.isRelational("<")) {
                  const t3 = this.tsParseTypeArguments();
                  if (this.match(p2.parenL)) {
                    const r3 = super.parseMaybeDecoratorArguments(e4);
                    return r3.typeParameters = t3, r3;
                  }
                  this.unexpected(this.state.start, p2.parenL);
                }
                return super.parseMaybeDecoratorArguments(e4);
              }
              checkCommaAfterRest(e4) {
                this.state.isAmbientContext && this.match(p2.comma) && this.lookaheadCharCode() === e4 ? this.next() : super.checkCommaAfterRest(e4);
              }
              isClassMethod() {
                return this.isRelational("<") || super.isClassMethod();
              }
              isClassProperty() {
                return this.match(p2.bang) || this.match(p2.colon) || super.isClassProperty();
              }
              parseMaybeDefault(...e4) {
                const t3 = super.parseMaybeDefault(...e4);
                return t3.type === "AssignmentPattern" && t3.typeAnnotation && t3.right.start < t3.typeAnnotation.start && this.raise(t3.typeAnnotation.start, de.TypeAnnotationAfterAssign), t3;
              }
              getTokenFromCode(e4) {
                return !this.state.inType || e4 !== 62 && e4 !== 60 ? super.getTokenFromCode(e4) : this.finishOp(p2.relational, 1);
              }
              reScan_lt_gt() {
                if (this.match(p2.relational)) {
                  const e4 = this.input.charCodeAt(this.state.start);
                  e4 !== 60 && e4 !== 62 || (this.state.pos -= 1, this.readToken_lt_gt(e4));
                }
              }
              toAssignableList(e4) {
                for (let t3 = 0; t3 < e4.length; t3++) {
                  const r3 = e4[t3];
                  if (r3)
                    switch (r3.type) {
                      case "TSTypeCastExpression":
                        e4[t3] = this.typeCastToParameter(r3);
                        break;
                      case "TSAsExpression":
                      case "TSTypeAssertion":
                        this.state.maybeInArrowParameters ? this.raise(r3.start, de.UnexpectedTypeCastInParameter) : e4[t3] = this.typeCastToParameter(r3);
                    }
                }
                return super.toAssignableList(...arguments);
              }
              typeCastToParameter(e4) {
                return e4.expression.typeAnnotation = e4.typeAnnotation, this.resetEndLocation(e4.expression, e4.typeAnnotation.end, e4.typeAnnotation.loc.end), e4.expression;
              }
              shouldParseArrow() {
                return this.match(p2.colon) || super.shouldParseArrow();
              }
              shouldParseAsyncArrow() {
                return this.match(p2.colon) || super.shouldParseAsyncArrow();
              }
              canHaveLeadingDecorator() {
                return super.canHaveLeadingDecorator() || this.isAbstractClass();
              }
              jsxParseOpeningElementAfterName(e4) {
                if (this.isRelational("<")) {
                  const t3 = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());
                  t3 && (e4.typeParameters = t3);
                }
                return super.jsxParseOpeningElementAfterName(e4);
              }
              getGetterSetterExpectedParamCount(e4) {
                const t3 = super.getGetterSetterExpectedParamCount(e4), r3 = this.getObjectOrClassMethodParams(e4)[0];
                return r3 && this.isThisParam(r3) ? t3 + 1 : t3;
              }
              parseCatchClauseParam() {
                const e4 = super.parseCatchClauseParam(), t3 = this.tsTryParseTypeAnnotation();
                return t3 && (e4.typeAnnotation = t3, this.resetEndLocation(e4)), e4;
              }
              tsInAmbientContext(e4) {
                const t3 = this.state.isAmbientContext;
                this.state.isAmbientContext = true;
                try {
                  return e4();
                } finally {
                  this.state.isAmbientContext = t3;
                }
              }
              parseClass(e4, ...t3) {
                const r3 = this.state.inAbstractClass;
                this.state.inAbstractClass = !!e4.abstract;
                try {
                  return super.parseClass(e4, ...t3);
                } finally {
                  this.state.inAbstractClass = r3;
                }
              }
              tsParseAbstractDeclaration(e4) {
                if (this.match(p2._class))
                  return e4.abstract = true, this.parseClass(e4, true, false);
                if (this.isContextual("interface")) {
                  if (!this.hasFollowingLineBreak())
                    return e4.abstract = true, this.raise(e4.start, de.NonClassMethodPropertyHasAbstractModifer), this.next(), this.tsParseInterfaceDeclaration(e4);
                } else
                  this.unexpected(null, p2._class);
              }
              parseMethod(...e4) {
                const t3 = super.parseMethod(...e4);
                if (t3.abstract && (this.hasPlugin("estree") ? t3.value.body : t3.body)) {
                  const { key: e5 } = t3;
                  this.raise(t3.start, de.AbstractMethodHasImplementation, e5.type === "Identifier" ? e5.name : `[${this.input.slice(e5.start, e5.end)}]`);
                }
                return t3;
              }
              shouldParseAsAmbientContext() {
                return !!this.getPluginOption("typescript", "dts");
              }
              parse() {
                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.parse();
              }
              getExpression() {
                return this.shouldParseAsAmbientContext() && (this.state.isAmbientContext = true), super.getExpression();
              }
            }, v8intrinsic: (e3) => class extends e3 {
              parseV8Intrinsic() {
                if (this.match(p2.modulo)) {
                  const e4 = this.state.start, t3 = this.startNode();
                  if (this.eat(p2.modulo), this.match(p2.name)) {
                    const e5 = this.parseIdentifierName(this.state.start), r3 = this.createIdentifier(t3, e5);
                    if (r3.type = "V8IntrinsicIdentifier", this.match(p2.parenL))
                      return r3;
                  }
                  this.unexpected(e4);
                }
              }
              parseExprAtom() {
                return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);
              }
            }, placeholders: (e3) => class extends e3 {
              parsePlaceholder(e4) {
                if (this.match(p2.placeholder)) {
                  const t3 = this.startNode();
                  return this.next(), this.assertNoSpace("Unexpected space in placeholder."), t3.name = super.parseIdentifier(true), this.assertNoSpace("Unexpected space in placeholder."), this.expect(p2.placeholder), this.finishPlaceholder(t3, e4);
                }
              }
              finishPlaceholder(e4, t3) {
                const r3 = !(!e4.expectedNode || e4.type !== "Placeholder");
                return e4.expectedNode = t3, r3 ? e4 : this.finishNode(e4, "Placeholder");
              }
              getTokenFromCode(e4) {
                return e4 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37 ? this.finishOp(p2.placeholder, 2) : super.getTokenFromCode(...arguments);
              }
              parseExprAtom() {
                return this.parsePlaceholder("Expression") || super.parseExprAtom(...arguments);
              }
              parseIdentifier() {
                return this.parsePlaceholder("Identifier") || super.parseIdentifier(...arguments);
              }
              checkReservedWord(e4) {
                e4 !== void 0 && super.checkReservedWord(...arguments);
              }
              parseBindingAtom() {
                return this.parsePlaceholder("Pattern") || super.parseBindingAtom(...arguments);
              }
              checkLVal(e4) {
                e4.type !== "Placeholder" && super.checkLVal(...arguments);
              }
              toAssignable(e4) {
                return e4 && e4.type === "Placeholder" && e4.expectedNode === "Expression" ? (e4.expectedNode = "Pattern", e4) : super.toAssignable(...arguments);
              }
              isLet(e4) {
                return !!super.isLet(e4) || !!this.isContextual("let") && (!e4 && this.lookahead().type === p2.placeholder);
              }
              verifyBreakContinue(e4) {
                e4.label && e4.label.type === "Placeholder" || super.verifyBreakContinue(...arguments);
              }
              parseExpressionStatement(e4, t3) {
                if (t3.type !== "Placeholder" || t3.extra && t3.extra.parenthesized)
                  return super.parseExpressionStatement(...arguments);
                if (this.match(p2.colon)) {
                  const r3 = e4;
                  return r3.label = this.finishPlaceholder(t3, "Identifier"), this.next(), r3.body = this.parseStatement("label"), this.finishNode(r3, "LabeledStatement");
                }
                return this.semicolon(), e4.name = t3.name, this.finishPlaceholder(e4, "Statement");
              }
              parseBlock() {
                return this.parsePlaceholder("BlockStatement") || super.parseBlock(...arguments);
              }
              parseFunctionId() {
                return this.parsePlaceholder("Identifier") || super.parseFunctionId(...arguments);
              }
              parseClass(e4, t3, r3) {
                const n2 = t3 ? "ClassDeclaration" : "ClassExpression";
                this.next(), this.takeDecorators(e4);
                const s3 = this.state.strict, i2 = this.parsePlaceholder("Identifier");
                if (i2)
                  if (this.match(p2._extends) || this.match(p2.placeholder) || this.match(p2.braceL))
                    e4.id = i2;
                  else {
                    if (r3 || !t3)
                      return e4.id = null, e4.body = this.finishPlaceholder(i2, "ClassBody"), this.finishNode(e4, n2);
                    this.unexpected(null, me.ClassNameIsRequired);
                  }
                else
                  this.parseClassId(e4, t3, r3);
                return this.parseClassSuper(e4), e4.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!e4.superClass, s3), this.finishNode(e4, n2);
              }
              parseExport(e4) {
                const t3 = this.parsePlaceholder("Identifier");
                if (!t3)
                  return super.parseExport(...arguments);
                if (!this.isContextual("from") && !this.match(p2.comma))
                  return e4.specifiers = [], e4.source = null, e4.declaration = this.finishPlaceholder(t3, "Declaration"), this.finishNode(e4, "ExportNamedDeclaration");
                this.expectPlugin("exportDefaultFrom");
                const r3 = this.startNode();
                return r3.exported = t3, e4.specifiers = [this.finishNode(r3, "ExportDefaultSpecifier")], super.parseExport(e4);
              }
              isExportDefaultSpecifier() {
                if (this.match(p2._default)) {
                  const e4 = this.nextTokenStart();
                  if (this.isUnparsedContextual(e4, "from") && this.input.startsWith(p2.placeholder.label, this.nextTokenStartSince(e4 + 4)))
                    return true;
                }
                return super.isExportDefaultSpecifier();
              }
              maybeParseExportDefaultSpecifier(e4) {
                return !!(e4.specifiers && e4.specifiers.length > 0) || super.maybeParseExportDefaultSpecifier(...arguments);
              }
              checkExport(e4) {
                const { specifiers: t3 } = e4;
                t3 != null && t3.length && (e4.specifiers = t3.filter((e5) => e5.exported.type === "Placeholder")), super.checkExport(e4), e4.specifiers = t3;
              }
              parseImport(e4) {
                const t3 = this.parsePlaceholder("Identifier");
                if (!t3)
                  return super.parseImport(...arguments);
                if (e4.specifiers = [], !this.isContextual("from") && !this.match(p2.comma))
                  return e4.source = this.finishPlaceholder(t3, "StringLiteral"), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
                const r3 = this.startNodeAtNode(t3);
                return r3.local = t3, this.finishNode(r3, "ImportDefaultSpecifier"), e4.specifiers.push(r3), this.eat(p2.comma) && (this.maybeParseStarImportSpecifier(e4) || this.parseNamedImportSpecifiers(e4)), this.expectContextual("from"), e4.source = this.parseImportSource(), this.semicolon(), this.finishNode(e4, "ImportDeclaration");
              }
              parseImportSource() {
                return this.parsePlaceholder("StringLiteral") || super.parseImportSource(...arguments);
              }
            } }, xe = Object.keys(Ee), Se = { sourceType: "script", sourceFilename: void 0, startLine: 1, allowAwaitOutsideFunction: false, allowReturnOutsideFunction: false, allowImportExportEverywhere: false, allowSuperOutsideMethod: false, allowUndeclaredExports: false, plugins: [], strictMode: null, ranges: false, tokens: false, createParenthesizedExpressions: false, errorRecovery: false };
            var Te = function(e3) {
              return e3 >= 48 && e3 <= 57;
            };
            const we = new Set([103, 109, 115, 105, 121, 117, 100]), Pe = { decBinOct: [46, 66, 69, 79, 95, 98, 101, 111], hex: [46, 88, 95, 120] }, Ae = { bin: [48, 49] };
            Ae.oct = [...Ae.bin, 50, 51, 52, 53, 54, 55], Ae.dec = [...Ae.oct, 56, 57], Ae.hex = [...Ae.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];
            class Oe {
              constructor(e3) {
                this.type = e3.type, this.value = e3.value, this.start = e3.start, this.end = e3.end, this.loc = new b(e3.startLoc, e3.endLoc);
              }
            }
            class Ce {
              constructor() {
                this.privateNames = new Set(), this.loneAccessors = new Map(), this.undefinedPrivateNames = new Map();
              }
            }
            class Ie {
              constructor(e3) {
                this.stack = [], this.undefinedPrivateNames = new Map(), this.raise = e3;
              }
              current() {
                return this.stack[this.stack.length - 1];
              }
              enter() {
                this.stack.push(new Ce());
              }
              exit() {
                const e3 = this.stack.pop(), t3 = this.current();
                for (const [r3, n2] of Array.from(e3.undefinedPrivateNames))
                  t3 ? t3.undefinedPrivateNames.has(r3) || t3.undefinedPrivateNames.set(r3, n2) : this.raise(n2, x.InvalidPrivateFieldResolution, r3);
              }
              declarePrivateName(e3, t3, r3) {
                const n2 = this.current();
                let s3 = n2.privateNames.has(e3);
                if (3 & t3) {
                  const r4 = s3 && n2.loneAccessors.get(e3);
                  if (r4) {
                    const i2 = 4 & r4, o2 = 4 & t3;
                    s3 = (3 & r4) == (3 & t3) || i2 !== o2, s3 || n2.loneAccessors.delete(e3);
                  } else
                    s3 || n2.loneAccessors.set(e3, t3);
                }
                s3 && this.raise(r3, x.PrivateNameRedeclaration, e3), n2.privateNames.add(e3), n2.undefinedPrivateNames.delete(e3);
              }
              usePrivateName(e3, t3) {
                let r3;
                for (r3 of this.stack)
                  if (r3.privateNames.has(e3))
                    return;
                r3 ? r3.undefinedPrivateNames.set(e3, t3) : this.raise(t3, x.InvalidPrivateFieldResolution, e3);
              }
            }
            class ke {
              constructor(e3 = 0) {
                this.type = void 0, this.type = e3;
              }
              canBeArrowParameterDeclaration() {
                return this.type === 2 || this.type === 1;
              }
              isCertainlyParameterDeclaration() {
                return this.type === 3;
              }
            }
            class Ne extends ke {
              constructor(e3) {
                super(e3), this.errors = new Map();
              }
              recordDeclarationError(e3, t3) {
                this.errors.set(e3, t3);
              }
              clearDeclarationError(e3) {
                this.errors.delete(e3);
              }
              iterateErrors(e3) {
                this.errors.forEach(e3);
              }
            }
            class _e {
              constructor(e3) {
                this.stack = [new ke()], this.raise = e3;
              }
              enter(e3) {
                this.stack.push(e3);
              }
              exit() {
                this.stack.pop();
              }
              recordParameterInitializerError(e3, t3) {
                const { stack: r3 } = this;
                let n2 = r3.length - 1, s3 = r3[n2];
                for (; !s3.isCertainlyParameterDeclaration(); ) {
                  if (!s3.canBeArrowParameterDeclaration())
                    return;
                  s3.recordDeclarationError(e3, t3), s3 = r3[--n2];
                }
                this.raise(e3, t3);
              }
              recordParenthesizedIdentifierError(e3, t3) {
                const { stack: r3 } = this, n2 = r3[r3.length - 1];
                if (n2.isCertainlyParameterDeclaration())
                  this.raise(e3, t3);
                else {
                  if (!n2.canBeArrowParameterDeclaration())
                    return;
                  n2.recordDeclarationError(e3, t3);
                }
              }
              recordAsyncArrowParametersError(e3, t3) {
                const { stack: r3 } = this;
                let n2 = r3.length - 1, s3 = r3[n2];
                for (; s3.canBeArrowParameterDeclaration(); )
                  s3.type === 2 && s3.recordDeclarationError(e3, t3), s3 = r3[--n2];
              }
              validateAsPattern() {
                const { stack: e3 } = this, t3 = e3[e3.length - 1];
                t3.canBeArrowParameterDeclaration() && t3.iterateErrors((t4, r3) => {
                  this.raise(r3, t4);
                  let n2 = e3.length - 2, s3 = e3[n2];
                  for (; s3.canBeArrowParameterDeclaration(); )
                    s3.clearDeclarationError(r3), s3 = e3[--n2];
                });
              }
            }
            function je() {
              return new ke();
            }
            class De {
              constructor() {
                this.shorthandAssign = -1, this.doubleProto = -1, this.optionalParameters = -1;
              }
            }
            class Le {
              constructor(e3, t3, r3) {
                this.type = void 0, this.start = void 0, this.end = void 0, this.loc = void 0, this.range = void 0, this.leadingComments = void 0, this.trailingComments = void 0, this.innerComments = void 0, this.extra = void 0, this.type = "", this.start = t3, this.end = 0, this.loc = new b(r3), e3 != null && e3.options.ranges && (this.range = [t3, 0]), e3 != null && e3.filename && (this.loc.filename = e3.filename);
              }
              __clone() {
                const e3 = new Le(), t3 = Object.keys(this);
                for (let r3 = 0, n2 = t3.length; r3 < n2; r3++) {
                  const n3 = t3[r3];
                  n3 !== "leadingComments" && n3 !== "trailingComments" && n3 !== "innerComments" && (e3[n3] = this[n3]);
                }
                return e3;
              }
            }
            const Me = (e3) => e3.type === "ParenthesizedExpression" ? Me(e3.expression) : e3, Be = { kind: "loop" }, Re = { kind: "switch" }, Fe = /[\uD800-\uDFFF]/u, Ue = /in(?:stanceof)?/y;
            class $e extends class extends class extends class extends class extends class extends class extends class extends class extends class {
              constructor() {
                this.sawUnambiguousESM = false, this.ambiguousScriptDifferentAst = false;
              }
              hasPlugin(e3) {
                return this.plugins.has(e3);
              }
              getPluginOption(e3, t3) {
                if (this.hasPlugin(e3))
                  return this.plugins.get(e3)[t3];
              }
            } {
              addComment(e3) {
                this.filename && (e3.loc.filename = this.filename), this.state.trailingComments.push(e3), this.state.leadingComments.push(e3);
              }
              adjustCommentsAfterTrailingComma(e3, t3, r3) {
                if (this.state.leadingComments.length === 0)
                  return;
                let n2 = null, s3 = t3.length;
                for (; n2 === null && s3 > 0; )
                  n2 = t3[--s3];
                if (n2 === null)
                  return;
                for (let e4 = 0; e4 < this.state.leadingComments.length; e4++)
                  this.state.leadingComments[e4].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(e4, 1), e4--);
                const i2 = [];
                for (let t4 = 0; t4 < this.state.leadingComments.length; t4++) {
                  const n3 = this.state.leadingComments[t4];
                  n3.end < e3.end ? (i2.push(n3), r3 || (this.state.leadingComments.splice(t4, 1), t4--)) : (e3.trailingComments === void 0 && (e3.trailingComments = []), e3.trailingComments.push(n3));
                }
                r3 && (this.state.leadingComments = []), i2.length > 0 ? n2.trailingComments = i2 : n2.trailingComments !== void 0 && (n2.trailingComments = []);
              }
              processComment(e3) {
                if (e3.type === "Program" && e3.body.length > 0)
                  return;
                const t3 = this.state.commentStack;
                let r3, n2, s3, i2, o2;
                if (this.state.trailingComments.length > 0)
                  this.state.trailingComments[0].start >= e3.end ? (s3 = this.state.trailingComments, this.state.trailingComments = []) : this.state.trailingComments.length = 0;
                else if (t3.length > 0) {
                  const r4 = v(t3);
                  r4.trailingComments && r4.trailingComments[0].start >= e3.end && (s3 = r4.trailingComments, delete r4.trailingComments);
                }
                for (t3.length > 0 && v(t3).start >= e3.start && (r3 = t3.pop()); t3.length > 0 && v(t3).start >= e3.start; )
                  n2 = t3.pop();
                if (!n2 && r3 && (n2 = r3), r3)
                  switch (e3.type) {
                    case "ObjectExpression":
                      this.adjustCommentsAfterTrailingComma(e3, e3.properties);
                      break;
                    case "ObjectPattern":
                      this.adjustCommentsAfterTrailingComma(e3, e3.properties, true);
                      break;
                    case "CallExpression":
                      this.adjustCommentsAfterTrailingComma(e3, e3.arguments);
                      break;
                    case "ArrayExpression":
                      this.adjustCommentsAfterTrailingComma(e3, e3.elements);
                      break;
                    case "ArrayPattern":
                      this.adjustCommentsAfterTrailingComma(e3, e3.elements, true);
                  }
                else
                  this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && e3.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && e3.type !== "ExportSpecifier") && this.adjustCommentsAfterTrailingComma(e3, [this.state.commentPreviousNode]);
                if (n2) {
                  if (n2.leadingComments) {
                    if (n2 !== e3 && n2.leadingComments.length > 0 && v(n2.leadingComments).end <= e3.start)
                      e3.leadingComments = n2.leadingComments, delete n2.leadingComments;
                    else
                      for (i2 = n2.leadingComments.length - 2; i2 >= 0; --i2)
                        if (n2.leadingComments[i2].end <= e3.start) {
                          e3.leadingComments = n2.leadingComments.splice(0, i2 + 1);
                          break;
                        }
                  }
                } else if (this.state.leadingComments.length > 0)
                  if (v(this.state.leadingComments).end <= e3.start) {
                    if (this.state.commentPreviousNode)
                      for (o2 = 0; o2 < this.state.leadingComments.length; o2++)
                        this.state.leadingComments[o2].end < this.state.commentPreviousNode.end && (this.state.leadingComments.splice(o2, 1), o2--);
                    this.state.leadingComments.length > 0 && (e3.leadingComments = this.state.leadingComments, this.state.leadingComments = []);
                  } else {
                    for (i2 = 0; i2 < this.state.leadingComments.length && !(this.state.leadingComments[i2].end > e3.start); i2++)
                      ;
                    const t4 = this.state.leadingComments.slice(0, i2);
                    t4.length && (e3.leadingComments = t4), s3 = this.state.leadingComments.slice(i2), s3.length === 0 && (s3 = null);
                  }
                if (this.state.commentPreviousNode = e3, s3)
                  if (s3.length && s3[0].start >= e3.start && v(s3).end <= e3.end)
                    e3.innerComments = s3;
                  else {
                    const t4 = s3.findIndex((t5) => t5.end >= e3.end);
                    t4 > 0 ? (e3.innerComments = s3.slice(0, t4), e3.trailingComments = s3.slice(t4)) : e3.trailingComments = s3;
                  }
                t3.push(e3);
              }
            } {
              getLocationForPosition(e3) {
                let t3;
                return t3 = e3 === this.state.start ? this.state.startLoc : e3 === this.state.lastTokStart ? this.state.lastTokStartLoc : e3 === this.state.end ? this.state.endLoc : e3 === this.state.lastTokEnd ? this.state.lastTokEndLoc : function(e4, t4) {
                  let r3, n2 = 1, s3 = 0;
                  for (d.lastIndex = 0; (r3 = d.exec(e4)) && r3.index < t4; )
                    n2++, s3 = d.lastIndex;
                  return new g(n2, t4 - s3);
                }(this.input, e3), t3;
              }
              raise(e3, { code: t3, reasonCode: r3, template: n2 }, ...s3) {
                return this.raiseWithData(e3, { code: t3, reasonCode: r3 }, n2, ...s3);
              }
              raiseOverwrite(e3, { code: t3, template: r3 }, ...n2) {
                const s3 = this.getLocationForPosition(e3), i2 = r3.replace(/%(\d+)/g, (e4, t4) => n2[t4]) + ` (${s3.line}:${s3.column})`;
                if (this.options.errorRecovery) {
                  const t4 = this.state.errors;
                  for (let r4 = t4.length - 1; r4 >= 0; r4--) {
                    const n3 = t4[r4];
                    if (n3.pos === e3)
                      return Object.assign(n3, { message: i2 });
                    if (n3.pos < e3)
                      break;
                  }
                }
                return this._raise({ code: t3, loc: s3, pos: e3 }, i2);
              }
              raiseWithData(e3, t3, r3, ...n2) {
                const s3 = this.getLocationForPosition(e3), i2 = r3.replace(/%(\d+)/g, (e4, t4) => n2[t4]) + ` (${s3.line}:${s3.column})`;
                return this._raise(Object.assign({ loc: s3, pos: e3 }, t3), i2);
              }
              _raise(e3, t3) {
                const r3 = new SyntaxError(t3);
                if (Object.assign(r3, e3), this.options.errorRecovery)
                  return this.isLookahead || this.state.errors.push(r3), r3;
                throw r3;
              }
            } {
              constructor(e3, t3) {
                super(), this.isLookahead = void 0, this.tokens = [], this.state = new te(), this.state.init(e3), this.input = t3, this.length = t3.length, this.isLookahead = false;
              }
              pushToken(e3) {
                this.tokens.length = this.state.tokensLength, this.tokens.push(e3), ++this.state.tokensLength;
              }
              next() {
                this.checkKeywordEscapes(), this.options.tokens && this.pushToken(new Oe(this.state)), this.state.lastTokEnd = this.state.end, this.state.lastTokStart = this.state.start, this.state.lastTokEndLoc = this.state.endLoc, this.state.lastTokStartLoc = this.state.startLoc, this.nextToken();
              }
              eat(e3) {
                return !!this.match(e3) && (this.next(), true);
              }
              match(e3) {
                return this.state.type === e3;
              }
              createLookaheadState(e3) {
                return { pos: e3.pos, value: null, type: e3.type, start: e3.start, end: e3.end, lastTokEnd: e3.end, context: [this.curContext()], inType: e3.inType };
              }
              lookahead() {
                const e3 = this.state;
                this.state = this.createLookaheadState(e3), this.isLookahead = true, this.nextToken(), this.isLookahead = false;
                const t3 = this.state;
                return this.state = e3, t3;
              }
              nextTokenStart() {
                return this.nextTokenStartSince(this.state.pos);
              }
              nextTokenStartSince(e3) {
                return m.lastIndex = e3, e3 + m.exec(this.input)[0].length;
              }
              lookaheadCharCode() {
                return this.input.charCodeAt(this.nextTokenStart());
              }
              codePointAtPos(e3) {
                let t3 = this.input.charCodeAt(e3);
                if ((64512 & t3) == 55296 && ++e3 < this.input.length) {
                  const r3 = this.input.charCodeAt(e3);
                  (64512 & r3) == 56320 && (t3 = 65536 + ((1023 & t3) << 10) + (1023 & r3));
                }
                return t3;
              }
              setStrict(e3) {
                this.state.strict = e3, e3 && (this.state.strictErrors.forEach((e4, t3) => this.raise(t3, e4)), this.state.strictErrors.clear());
              }
              curContext() {
                return this.state.context[this.state.context.length - 1];
              }
              nextToken() {
                const e3 = this.curContext();
                e3.preserveSpace || this.skipSpace(), this.state.start = this.state.pos, this.isLookahead || (this.state.startLoc = this.state.curPosition()), this.state.pos >= this.length ? this.finishToken(p2.eof) : e3 === P.template ? this.readTmplToken() : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
              }
              pushComment(e3, t3, r3, n2, s3, i2) {
                const o2 = { type: e3 ? "CommentBlock" : "CommentLine", value: t3, start: r3, end: n2, loc: new b(s3, i2) };
                this.options.tokens && this.pushToken(o2), this.state.comments.push(o2), this.addComment(o2);
              }
              skipBlockComment() {
                let e3;
                this.isLookahead || (e3 = this.state.curPosition());
                const t3 = this.state.pos, r3 = this.input.indexOf("*/", this.state.pos + 2);
                if (r3 === -1)
                  throw this.raise(t3, x.UnterminatedComment);
                let n2;
                for (this.state.pos = r3 + 2, d.lastIndex = t3; (n2 = d.exec(this.input)) && n2.index < this.state.pos; )
                  ++this.state.curLine, this.state.lineStart = n2.index + n2[0].length;
                this.isLookahead || this.pushComment(true, this.input.slice(t3 + 2, r3), t3, this.state.pos, e3, this.state.curPosition());
              }
              skipLineComment(e3) {
                const t3 = this.state.pos;
                let r3;
                this.isLookahead || (r3 = this.state.curPosition());
                let n2 = this.input.charCodeAt(this.state.pos += e3);
                if (this.state.pos < this.length)
                  for (; !h3(n2) && ++this.state.pos < this.length; )
                    n2 = this.input.charCodeAt(this.state.pos);
                this.isLookahead || this.pushComment(false, this.input.slice(t3 + e3, this.state.pos), t3, this.state.pos, r3, this.state.curPosition());
              }
              skipSpace() {
                e:
                  for (; this.state.pos < this.length; ) {
                    const e3 = this.input.charCodeAt(this.state.pos);
                    switch (e3) {
                      case 32:
                      case 160:
                      case 9:
                        ++this.state.pos;
                        break;
                      case 13:
                        this.input.charCodeAt(this.state.pos + 1) === 10 && ++this.state.pos;
                      case 10:
                      case 8232:
                      case 8233:
                        ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                        break;
                      case 47:
                        switch (this.input.charCodeAt(this.state.pos + 1)) {
                          case 42:
                            this.skipBlockComment();
                            break;
                          case 47:
                            this.skipLineComment(2);
                            break;
                          default:
                            break e;
                        }
                        break;
                      default:
                        if (!y(e3))
                          break e;
                        ++this.state.pos;
                    }
                  }
              }
              finishToken(e3, t3) {
                this.state.end = this.state.pos;
                const r3 = this.state.type;
                this.state.type = e3, this.state.value = t3, this.isLookahead || (this.state.endLoc = this.state.curPosition(), this.updateContext(r3));
              }
              readToken_numberSign() {
                if (this.state.pos === 0 && this.readToken_interpreter())
                  return;
                const e3 = this.state.pos + 1, t3 = this.codePointAtPos(e3);
                if (t3 >= 48 && t3 <= 57)
                  throw this.raise(this.state.pos, x.UnexpectedDigitAfterHash);
                if (t3 === 123 || t3 === 91 && this.hasPlugin("recordAndTuple")) {
                  if (this.expectPlugin("recordAndTuple"), this.getPluginOption("recordAndTuple", "syntaxType") !== "hash")
                    throw this.raise(this.state.pos, t3 === 123 ? x.RecordExpressionHashIncorrectStartSyntaxType : x.TupleExpressionHashIncorrectStartSyntaxType);
                  this.state.pos += 2, t3 === 123 ? this.finishToken(p2.braceHashL) : this.finishToken(p2.bracketHashL);
                } else
                  j(t3) ? (++this.state.pos, this.finishToken(p2.privateName, this.readWord1(t3))) : t3 === 92 ? (++this.state.pos, this.finishToken(p2.privateName, this.readWord1())) : this.finishOp(p2.hash, 1);
              }
              readToken_dot() {
                const e3 = this.input.charCodeAt(this.state.pos + 1);
                e3 >= 48 && e3 <= 57 ? this.readNumber(true) : e3 === 46 && this.input.charCodeAt(this.state.pos + 2) === 46 ? (this.state.pos += 3, this.finishToken(p2.ellipsis)) : (++this.state.pos, this.finishToken(p2.dot));
              }
              readToken_slash() {
                this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(p2.slashAssign, 2) : this.finishOp(p2.slash, 1);
              }
              readToken_interpreter() {
                if (this.state.pos !== 0 || this.length < 2)
                  return false;
                let e3 = this.input.charCodeAt(this.state.pos + 1);
                if (e3 !== 33)
                  return false;
                const t3 = this.state.pos;
                for (this.state.pos += 1; !h3(e3) && ++this.state.pos < this.length; )
                  e3 = this.input.charCodeAt(this.state.pos);
                const r3 = this.input.slice(t3 + 2, this.state.pos);
                return this.finishToken(p2.interpreterDirective, r3), true;
              }
              readToken_mult_modulo(e3) {
                let t3 = e3 === 42 ? p2.star : p2.modulo, r3 = 1, n2 = this.input.charCodeAt(this.state.pos + 1);
                e3 === 42 && n2 === 42 && (r3++, n2 = this.input.charCodeAt(this.state.pos + 2), t3 = p2.exponent), n2 !== 61 || this.state.inType || (r3++, t3 = p2.assign), this.finishOp(t3, r3);
              }
              readToken_pipe_amp(e3) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                if (t3 !== e3) {
                  if (e3 === 124) {
                    if (t3 === 62)
                      return void this.finishOp(p2.pipeline, 2);
                    if (this.hasPlugin("recordAndTuple") && t3 === 125) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(this.state.pos, x.RecordExpressionBarIncorrectEndSyntaxType);
                      return this.state.pos += 2, void this.finishToken(p2.braceBarR);
                    }
                    if (this.hasPlugin("recordAndTuple") && t3 === 93) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(this.state.pos, x.TupleExpressionBarIncorrectEndSyntaxType);
                      return this.state.pos += 2, void this.finishToken(p2.bracketBarR);
                    }
                  }
                  t3 !== 61 ? this.finishOp(e3 === 124 ? p2.bitwiseOR : p2.bitwiseAND, 1) : this.finishOp(p2.assign, 2);
                } else
                  this.input.charCodeAt(this.state.pos + 2) === 61 ? this.finishOp(p2.assign, 3) : this.finishOp(e3 === 124 ? p2.logicalOR : p2.logicalAND, 2);
              }
              readToken_caret() {
                this.input.charCodeAt(this.state.pos + 1) === 61 ? this.finishOp(p2.assign, 2) : this.finishOp(p2.bitwiseXOR, 1);
              }
              readToken_plus_min(e3) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                if (t3 === e3)
                  return t3 !== 45 || this.inModule || this.input.charCodeAt(this.state.pos + 2) !== 62 || this.state.lastTokEnd !== 0 && !this.hasPrecedingLineBreak() ? void this.finishOp(p2.incDec, 2) : (this.skipLineComment(3), this.skipSpace(), void this.nextToken());
                t3 === 61 ? this.finishOp(p2.assign, 2) : this.finishOp(p2.plusMin, 1);
              }
              readToken_lt_gt(e3) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                let r3 = 1;
                return t3 === e3 ? (r3 = e3 === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.state.pos + r3) === 61 ? void this.finishOp(p2.assign, r3 + 1) : void this.finishOp(p2.bitShift, r3)) : t3 !== 33 || e3 !== 60 || this.inModule || this.input.charCodeAt(this.state.pos + 2) !== 45 || this.input.charCodeAt(this.state.pos + 3) !== 45 ? (t3 === 61 && (r3 = 2), void this.finishOp(p2.relational, r3)) : (this.skipLineComment(4), this.skipSpace(), void this.nextToken());
              }
              readToken_eq_excl(e3) {
                const t3 = this.input.charCodeAt(this.state.pos + 1);
                if (t3 !== 61)
                  return e3 === 61 && t3 === 62 ? (this.state.pos += 2, void this.finishToken(p2.arrow)) : void this.finishOp(e3 === 61 ? p2.eq : p2.bang, 1);
                this.finishOp(p2.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
              }
              readToken_question() {
                const e3 = this.input.charCodeAt(this.state.pos + 1), t3 = this.input.charCodeAt(this.state.pos + 2);
                e3 === 63 ? t3 === 61 ? this.finishOp(p2.assign, 3) : this.finishOp(p2.nullishCoalescing, 2) : e3 !== 46 || t3 >= 48 && t3 <= 57 ? (++this.state.pos, this.finishToken(p2.question)) : (this.state.pos += 2, this.finishToken(p2.questionDot));
              }
              getTokenFromCode(e3) {
                switch (e3) {
                  case 46:
                    return void this.readToken_dot();
                  case 40:
                    return ++this.state.pos, void this.finishToken(p2.parenL);
                  case 41:
                    return ++this.state.pos, void this.finishToken(p2.parenR);
                  case 59:
                    return ++this.state.pos, void this.finishToken(p2.semi);
                  case 44:
                    return ++this.state.pos, void this.finishToken(p2.comma);
                  case 91:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(this.state.pos, x.TupleExpressionBarIncorrectStartSyntaxType);
                      this.state.pos += 2, this.finishToken(p2.bracketBarL);
                    } else
                      ++this.state.pos, this.finishToken(p2.bracketL);
                    return;
                  case 93:
                    return ++this.state.pos, void this.finishToken(p2.bracketR);
                  case 123:
                    if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
                      if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar")
                        throw this.raise(this.state.pos, x.RecordExpressionBarIncorrectStartSyntaxType);
                      this.state.pos += 2, this.finishToken(p2.braceBarL);
                    } else
                      ++this.state.pos, this.finishToken(p2.braceL);
                    return;
                  case 125:
                    return ++this.state.pos, void this.finishToken(p2.braceR);
                  case 58:
                    return void (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58 ? this.finishOp(p2.doubleColon, 2) : (++this.state.pos, this.finishToken(p2.colon)));
                  case 63:
                    return void this.readToken_question();
                  case 96:
                    return ++this.state.pos, void this.finishToken(p2.backQuote);
                  case 48: {
                    const e4 = this.input.charCodeAt(this.state.pos + 1);
                    if (e4 === 120 || e4 === 88)
                      return void this.readRadixNumber(16);
                    if (e4 === 111 || e4 === 79)
                      return void this.readRadixNumber(8);
                    if (e4 === 98 || e4 === 66)
                      return void this.readRadixNumber(2);
                  }
                  case 49:
                  case 50:
                  case 51:
                  case 52:
                  case 53:
                  case 54:
                  case 55:
                  case 56:
                  case 57:
                    return void this.readNumber(false);
                  case 34:
                  case 39:
                    return void this.readString(e3);
                  case 47:
                    return void this.readToken_slash();
                  case 37:
                  case 42:
                    return void this.readToken_mult_modulo(e3);
                  case 124:
                  case 38:
                    return void this.readToken_pipe_amp(e3);
                  case 94:
                    return void this.readToken_caret();
                  case 43:
                  case 45:
                    return void this.readToken_plus_min(e3);
                  case 60:
                  case 62:
                    return void this.readToken_lt_gt(e3);
                  case 61:
                  case 33:
                    return void this.readToken_eq_excl(e3);
                  case 126:
                    return void this.finishOp(p2.tilde, 1);
                  case 64:
                    return ++this.state.pos, void this.finishToken(p2.at);
                  case 35:
                    return void this.readToken_numberSign();
                  case 92:
                    return void this.readWord();
                  default:
                    if (j(e3))
                      return void this.readWord(e3);
                }
                throw this.raise(this.state.pos, x.InvalidOrUnexpectedToken, String.fromCodePoint(e3));
              }
              finishOp(e3, t3) {
                const r3 = this.input.slice(this.state.pos, this.state.pos + t3);
                this.state.pos += t3, this.finishToken(e3, r3);
              }
              readRegexp() {
                const e3 = this.state.start + 1;
                let t3, r3, { pos: n2 } = this.state;
                for (; ; ++n2) {
                  if (n2 >= this.length)
                    throw this.raise(e3, x.UnterminatedRegExp);
                  const s4 = this.input.charCodeAt(n2);
                  if (h3(s4))
                    throw this.raise(e3, x.UnterminatedRegExp);
                  if (t3)
                    t3 = false;
                  else {
                    if (s4 === 91)
                      r3 = true;
                    else if (s4 === 93 && r3)
                      r3 = false;
                    else if (s4 === 47 && !r3)
                      break;
                    t3 = s4 === 92;
                  }
                }
                const s3 = this.input.slice(e3, n2);
                ++n2;
                let i2 = "";
                for (; n2 < this.length; ) {
                  const e4 = this.codePointAtPos(n2), t4 = String.fromCharCode(e4);
                  if (we.has(e4))
                    i2.includes(t4) && this.raise(n2 + 1, x.DuplicateRegExpFlags);
                  else {
                    if (!D(e4) && e4 !== 92)
                      break;
                    this.raise(n2 + 1, x.MalformedRegExpFlags);
                  }
                  ++n2, i2 += t4;
                }
                this.state.pos = n2, this.finishToken(p2.regexp, { pattern: s3, flags: i2 });
              }
              readInt(e3, t3, r3, n2 = true) {
                const s3 = this.state.pos, i2 = e3 === 16 ? Pe.hex : Pe.decBinOct, o2 = e3 === 16 ? Ae.hex : e3 === 10 ? Ae.dec : e3 === 8 ? Ae.oct : Ae.bin;
                let a2 = false, l2 = 0;
                for (let s4 = 0, c4 = t3 == null ? 1 / 0 : t3; s4 < c4; ++s4) {
                  const t4 = this.input.charCodeAt(this.state.pos);
                  let c5;
                  if (t4 !== 95) {
                    if (c5 = t4 >= 97 ? t4 - 97 + 10 : t4 >= 65 ? t4 - 65 + 10 : Te(t4) ? t4 - 48 : 1 / 0, c5 >= e3)
                      if (this.options.errorRecovery && c5 <= 9)
                        c5 = 0, this.raise(this.state.start + s4 + 2, x.InvalidDigit, e3);
                      else {
                        if (!r3)
                          break;
                        c5 = 0, a2 = true;
                      }
                    ++this.state.pos, l2 = l2 * e3 + c5;
                  } else {
                    const e4 = this.input.charCodeAt(this.state.pos - 1), t5 = this.input.charCodeAt(this.state.pos + 1);
                    (o2.indexOf(t5) === -1 || i2.indexOf(e4) > -1 || i2.indexOf(t5) > -1 || Number.isNaN(t5)) && this.raise(this.state.pos, x.UnexpectedNumericSeparator), n2 || this.raise(this.state.pos, x.NumericSeparatorInEscapeSequence), ++this.state.pos;
                  }
                }
                return this.state.pos === s3 || t3 != null && this.state.pos - s3 !== t3 || a2 ? null : l2;
              }
              readRadixNumber(e3) {
                const t3 = this.state.pos;
                let r3 = false;
                this.state.pos += 2;
                const n2 = this.readInt(e3);
                n2 == null && this.raise(this.state.start + 2, x.InvalidDigit, e3);
                const s3 = this.input.charCodeAt(this.state.pos);
                if (s3 === 110)
                  ++this.state.pos, r3 = true;
                else if (s3 === 109)
                  throw this.raise(t3, x.InvalidDecimal);
                if (j(this.codePointAtPos(this.state.pos)))
                  throw this.raise(this.state.pos, x.NumberIdentifier);
                if (r3) {
                  const e4 = this.input.slice(t3, this.state.pos).replace(/[_n]/g, "");
                  this.finishToken(p2.bigint, e4);
                } else
                  this.finishToken(p2.num, n2);
              }
              readNumber(e3) {
                const t3 = this.state.pos;
                let r3 = false, n2 = false, s3 = false, i2 = false, o2 = false;
                e3 || this.readInt(10) !== null || this.raise(t3, x.InvalidNumber);
                const a2 = this.state.pos - t3 >= 2 && this.input.charCodeAt(t3) === 48;
                if (a2) {
                  const e4 = this.input.slice(t3, this.state.pos);
                  if (this.recordStrictModeErrors(t3, x.StrictOctalLiteral), !this.state.strict) {
                    const r4 = e4.indexOf("_");
                    r4 > 0 && this.raise(r4 + t3, x.ZeroDigitNumericSeparator);
                  }
                  o2 = a2 && !/[89]/.test(e4);
                }
                let l2 = this.input.charCodeAt(this.state.pos);
                if (l2 !== 46 || o2 || (++this.state.pos, this.readInt(10), r3 = true, l2 = this.input.charCodeAt(this.state.pos)), l2 !== 69 && l2 !== 101 || o2 || (l2 = this.input.charCodeAt(++this.state.pos), l2 !== 43 && l2 !== 45 || ++this.state.pos, this.readInt(10) === null && this.raise(t3, x.InvalidOrMissingExponent), r3 = true, i2 = true, l2 = this.input.charCodeAt(this.state.pos)), l2 === 110 && ((r3 || a2) && this.raise(t3, x.InvalidBigIntLiteral), ++this.state.pos, n2 = true), l2 === 109 && (this.expectPlugin("decimal", this.state.pos), (i2 || a2) && this.raise(t3, x.InvalidDecimal), ++this.state.pos, s3 = true), j(this.codePointAtPos(this.state.pos)))
                  throw this.raise(this.state.pos, x.NumberIdentifier);
                const c4 = this.input.slice(t3, this.state.pos).replace(/[_mn]/g, "");
                if (n2)
                  return void this.finishToken(p2.bigint, c4);
                if (s3)
                  return void this.finishToken(p2.decimal, c4);
                const u2 = o2 ? parseInt(c4, 8) : parseFloat(c4);
                this.finishToken(p2.num, u2);
              }
              readCodePoint(e3) {
                let t3;
                if (this.input.charCodeAt(this.state.pos) === 123) {
                  const r3 = ++this.state.pos;
                  if (t3 = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, e3), ++this.state.pos, t3 !== null && t3 > 1114111) {
                    if (!e3)
                      return null;
                    this.raise(r3, x.InvalidCodePoint);
                  }
                } else
                  t3 = this.readHexChar(4, false, e3);
                return t3;
              }
              readString(e3) {
                let t3 = "", r3 = ++this.state.pos;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(this.state.start, x.UnterminatedString);
                  const n2 = this.input.charCodeAt(this.state.pos);
                  if (n2 === e3)
                    break;
                  if (n2 === 92)
                    t3 += this.input.slice(r3, this.state.pos), t3 += this.readEscapedChar(false), r3 = this.state.pos;
                  else if (n2 === 8232 || n2 === 8233)
                    ++this.state.pos, ++this.state.curLine, this.state.lineStart = this.state.pos;
                  else {
                    if (h3(n2))
                      throw this.raise(this.state.start, x.UnterminatedString);
                    ++this.state.pos;
                  }
                }
                t3 += this.input.slice(r3, this.state.pos++), this.finishToken(p2.string, t3);
              }
              readTmplToken() {
                let e3 = "", t3 = this.state.pos, r3 = false;
                for (; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(this.state.start, x.UnterminatedTemplate);
                  const n2 = this.input.charCodeAt(this.state.pos);
                  if (n2 === 96 || n2 === 36 && this.input.charCodeAt(this.state.pos + 1) === 123)
                    return this.state.pos === this.state.start && this.match(p2.template) ? n2 === 36 ? (this.state.pos += 2, void this.finishToken(p2.dollarBraceL)) : (++this.state.pos, void this.finishToken(p2.backQuote)) : (e3 += this.input.slice(t3, this.state.pos), void this.finishToken(p2.template, r3 ? null : e3));
                  if (n2 === 92) {
                    e3 += this.input.slice(t3, this.state.pos);
                    const n3 = this.readEscapedChar(true);
                    n3 === null ? r3 = true : e3 += n3, t3 = this.state.pos;
                  } else if (h3(n2)) {
                    switch (e3 += this.input.slice(t3, this.state.pos), ++this.state.pos, n2) {
                      case 13:
                        this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                      case 10:
                        e3 += "\n";
                        break;
                      default:
                        e3 += String.fromCharCode(n2);
                    }
                    ++this.state.curLine, this.state.lineStart = this.state.pos, t3 = this.state.pos;
                  } else
                    ++this.state.pos;
                }
              }
              recordStrictModeErrors(e3, t3) {
                this.state.strict && !this.state.strictErrors.has(e3) ? this.raise(e3, t3) : this.state.strictErrors.set(e3, t3);
              }
              readEscapedChar(e3) {
                const t3 = !e3, r3 = this.input.charCodeAt(++this.state.pos);
                switch (++this.state.pos, r3) {
                  case 110:
                    return "\n";
                  case 114:
                    return "\r";
                  case 120: {
                    const e4 = this.readHexChar(2, false, t3);
                    return e4 === null ? null : String.fromCharCode(e4);
                  }
                  case 117: {
                    const e4 = this.readCodePoint(t3);
                    return e4 === null ? null : String.fromCodePoint(e4);
                  }
                  case 116:
                    return "	";
                  case 98:
                    return "\b";
                  case 118:
                    return "\v";
                  case 102:
                    return "\f";
                  case 13:
                    this.input.charCodeAt(this.state.pos) === 10 && ++this.state.pos;
                  case 10:
                    this.state.lineStart = this.state.pos, ++this.state.curLine;
                  case 8232:
                  case 8233:
                    return "";
                  case 56:
                  case 57:
                    if (e3)
                      return null;
                    this.recordStrictModeErrors(this.state.pos - 1, x.StrictNumericEscape);
                  default:
                    if (r3 >= 48 && r3 <= 55) {
                      const t4 = this.state.pos - 1;
                      let r4 = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0], n2 = parseInt(r4, 8);
                      n2 > 255 && (r4 = r4.slice(0, -1), n2 = parseInt(r4, 8)), this.state.pos += r4.length - 1;
                      const s3 = this.input.charCodeAt(this.state.pos);
                      if (r4 !== "0" || s3 === 56 || s3 === 57) {
                        if (e3)
                          return null;
                        this.recordStrictModeErrors(t4, x.StrictNumericEscape);
                      }
                      return String.fromCharCode(n2);
                    }
                    return String.fromCharCode(r3);
                }
              }
              readHexChar(e3, t3, r3) {
                const n2 = this.state.pos, s3 = this.readInt(16, e3, t3, false);
                return s3 === null && (r3 ? this.raise(n2, x.InvalidEscapeSequence) : this.state.pos = n2 - 1), s3;
              }
              readWord1(e3) {
                this.state.containsEsc = false;
                let t3 = "";
                const r3 = this.state.pos;
                let n2 = this.state.pos;
                for (e3 !== void 0 && (this.state.pos += e3 <= 65535 ? 1 : 2); this.state.pos < this.length; ) {
                  const e4 = this.codePointAtPos(this.state.pos);
                  if (D(e4))
                    this.state.pos += e4 <= 65535 ? 1 : 2;
                  else {
                    if (e4 !== 92)
                      break;
                    {
                      this.state.containsEsc = true, t3 += this.input.slice(n2, this.state.pos);
                      const e5 = this.state.pos, s3 = this.state.pos === r3 ? j : D;
                      if (this.input.charCodeAt(++this.state.pos) !== 117) {
                        this.raise(this.state.pos, x.MissingUnicodeEscape), n2 = this.state.pos - 1;
                        continue;
                      }
                      ++this.state.pos;
                      const i2 = this.readCodePoint(true);
                      i2 !== null && (s3(i2) || this.raise(e5, x.EscapedCharNotAnIdentifier), t3 += String.fromCodePoint(i2)), n2 = this.state.pos;
                    }
                  }
                }
                return t3 + this.input.slice(n2, this.state.pos);
              }
              readWord(e3) {
                const t3 = this.readWord1(e3), r3 = l.get(t3) || p2.name;
                this.finishToken(r3, t3);
              }
              checkKeywordEscapes() {
                const e3 = this.state.type.keyword;
                e3 && this.state.containsEsc && this.raise(this.state.start, x.InvalidEscapedReservedWord, e3);
              }
              updateContext(e3) {
                var t3, r3;
                (t3 = (r3 = this.state.type).updateContext) == null || t3.call(r3, this.state.context);
              }
            } {
              addExtra(e3, t3, r3) {
                e3 && ((e3.extra = e3.extra || {})[t3] = r3);
              }
              isRelational(e3) {
                return this.match(p2.relational) && this.state.value === e3;
              }
              expectRelational(e3) {
                this.isRelational(e3) ? this.next() : this.unexpected(null, p2.relational);
              }
              isContextual(e3) {
                return this.match(p2.name) && this.state.value === e3 && !this.state.containsEsc;
              }
              isUnparsedContextual(e3, t3) {
                const r3 = e3 + t3.length;
                if (this.input.slice(e3, r3) === t3) {
                  const e4 = this.input.charCodeAt(r3);
                  return !(D(e4) || (64512 & e4) == 55296);
                }
                return false;
              }
              isLookaheadContextual(e3) {
                const t3 = this.nextTokenStart();
                return this.isUnparsedContextual(t3, e3);
              }
              eatContextual(e3) {
                return this.isContextual(e3) && this.eat(p2.name);
              }
              expectContextual(e3, t3) {
                this.eatContextual(e3) || this.unexpected(null, t3);
              }
              canInsertSemicolon() {
                return this.match(p2.eof) || this.match(p2.braceR) || this.hasPrecedingLineBreak();
              }
              hasPrecedingLineBreak() {
                return f.test(this.input.slice(this.state.lastTokEnd, this.state.start));
              }
              hasFollowingLineBreak() {
                return f.test(this.input.slice(this.state.end, this.nextTokenStart()));
              }
              isLineTerminator() {
                return this.eat(p2.semi) || this.canInsertSemicolon();
              }
              semicolon(e3 = true) {
                (e3 ? this.isLineTerminator() : this.eat(p2.semi)) || this.raise(this.state.lastTokEnd, x.MissingSemicolon);
              }
              expect(e3, t3) {
                this.eat(e3) || this.unexpected(t3, e3);
              }
              assertNoSpace(e3 = "Unexpected space.") {
                this.state.start > this.state.lastTokEnd && this.raise(this.state.lastTokEnd, { code: E.SyntaxError, reasonCode: "UnexpectedSpace", template: e3 });
              }
              unexpected(e3, t3 = { code: E.SyntaxError, reasonCode: "UnexpectedToken", template: "Unexpected token" }) {
                throw t3 instanceof a && (t3 = { code: E.SyntaxError, reasonCode: "UnexpectedToken", template: `Unexpected token, expected "${t3.label}"` }), this.raise(e3 != null ? e3 : this.state.start, t3);
              }
              expectPlugin(e3, t3) {
                if (!this.hasPlugin(e3))
                  throw this.raiseWithData(t3 != null ? t3 : this.state.start, { missingPlugin: [e3] }, `This experimental syntax requires enabling the parser plugin: '${e3}'`);
                return true;
              }
              expectOnePlugin(e3, t3) {
                if (!e3.some((e4) => this.hasPlugin(e4)))
                  throw this.raiseWithData(t3 != null ? t3 : this.state.start, { missingPlugin: e3 }, `This experimental syntax requires enabling one of the following parser plugin(s): '${e3.join(", ")}'`);
              }
              tryParse(e3, t3 = this.state.clone()) {
                const r3 = { node: null };
                try {
                  const n2 = e3((e4 = null) => {
                    throw r3.node = e4, r3;
                  });
                  if (this.state.errors.length > t3.errors.length) {
                    const e4 = this.state;
                    return this.state = t3, this.state.tokensLength = e4.tokensLength, { node: n2, error: e4.errors[t3.errors.length], thrown: false, aborted: false, failState: e4 };
                  }
                  return { node: n2, error: null, thrown: false, aborted: false, failState: null };
                } catch (e4) {
                  const n2 = this.state;
                  if (this.state = t3, e4 instanceof SyntaxError)
                    return { node: null, error: e4, thrown: true, aborted: false, failState: n2 };
                  if (e4 === r3)
                    return { node: r3.node, error: null, thrown: false, aborted: true, failState: n2 };
                  throw e4;
                }
              }
              checkExpressionErrors(e3, t3) {
                if (!e3)
                  return false;
                const { shorthandAssign: r3, doubleProto: n2, optionalParameters: s3 } = e3;
                if (!t3)
                  return r3 >= 0 || n2 >= 0 || s3 >= 0;
                r3 >= 0 && this.unexpected(r3), n2 >= 0 && this.raise(n2, x.DuplicateProto), s3 >= 0 && this.unexpected(s3);
              }
              isLiteralPropertyName() {
                return this.match(p2.name) || !!this.state.type.keyword || this.match(p2.string) || this.match(p2.num) || this.match(p2.bigint) || this.match(p2.decimal);
              }
              isPrivateName(e3) {
                return e3.type === "PrivateName";
              }
              getPrivateNameSV(e3) {
                return e3.id.name;
              }
              hasPropertyAsPrivateName(e3) {
                return (e3.type === "MemberExpression" || e3.type === "OptionalMemberExpression") && this.isPrivateName(e3.property);
              }
              isOptionalChain(e3) {
                return e3.type === "OptionalMemberExpression" || e3.type === "OptionalCallExpression";
              }
              isObjectProperty(e3) {
                return e3.type === "ObjectProperty";
              }
              isObjectMethod(e3) {
                return e3.type === "ObjectMethod";
              }
              initializeScopes(e3 = this.options.sourceType === "module") {
                const t3 = this.state.labels;
                this.state.labels = [];
                const r3 = this.exportedIdentifiers;
                this.exportedIdentifiers = new Set();
                const n2 = this.inModule;
                this.inModule = e3;
                const s3 = this.scope, i2 = this.getScopeHandler();
                this.scope = new i2(this.raise.bind(this), this.inModule);
                const o2 = this.prodParam;
                this.prodParam = new ce();
                const a2 = this.classScope;
                this.classScope = new Ie(this.raise.bind(this));
                const l2 = this.expressionScope;
                return this.expressionScope = new _e(this.raise.bind(this)), () => {
                  this.state.labels = t3, this.exportedIdentifiers = r3, this.inModule = n2, this.scope = s3, this.prodParam = o2, this.classScope = a2, this.expressionScope = l2;
                };
              }
              enterInitialScopes() {
                let e3 = 0;
                this.hasPlugin("topLevelAwait") && this.inModule && (e3 |= 2), this.scope.enter(1), this.prodParam.enter(e3);
              }
            } {
              startNode() {
                return new Le(this, this.state.start, this.state.startLoc);
              }
              startNodeAt(e3, t3) {
                return new Le(this, e3, t3);
              }
              startNodeAtNode(e3) {
                return this.startNodeAt(e3.start, e3.loc.start);
              }
              finishNode(e3, t3) {
                return this.finishNodeAt(e3, t3, this.state.lastTokEnd, this.state.lastTokEndLoc);
              }
              finishNodeAt(e3, t3, r3, n2) {
                return e3.type = t3, e3.end = r3, e3.loc.end = n2, this.options.ranges && (e3.range[1] = r3), this.processComment(e3), e3;
              }
              resetStartLocation(e3, t3, r3) {
                e3.start = t3, e3.loc.start = r3, this.options.ranges && (e3.range[0] = t3);
              }
              resetEndLocation(e3, t3 = this.state.lastTokEnd, r3 = this.state.lastTokEndLoc) {
                e3.end = t3, e3.loc.end = r3, this.options.ranges && (e3.range[1] = t3);
              }
              resetStartLocationFromNode(e3, t3) {
                this.resetStartLocation(e3, t3.start, t3.loc.start);
              }
            } {
              toAssignable(e3, t3 = false) {
                var r3, n2;
                let s3;
                switch ((e3.type === "ParenthesizedExpression" || (r3 = e3.extra) != null && r3.parenthesized) && (s3 = Me(e3), t3 ? s3.type === "Identifier" ? this.expressionScope.recordParenthesizedIdentifierError(e3.start, x.InvalidParenthesizedAssignment) : s3.type !== "MemberExpression" && this.raise(e3.start, x.InvalidParenthesizedAssignment) : this.raise(e3.start, x.InvalidParenthesizedAssignment)), e3.type) {
                  case "Identifier":
                  case "ObjectPattern":
                  case "ArrayPattern":
                  case "AssignmentPattern":
                    break;
                  case "ObjectExpression":
                    e3.type = "ObjectPattern";
                    for (let r4 = 0, n3 = e3.properties.length, s4 = n3 - 1; r4 < n3; r4++) {
                      var i2;
                      const n4 = e3.properties[r4], o2 = r4 === s4;
                      this.toAssignableObjectExpressionProp(n4, o2, t3), o2 && n4.type === "RestElement" && (i2 = e3.extra) != null && i2.trailingComma && this.raiseRestNotLast(e3.extra.trailingComma);
                    }
                    break;
                  case "ObjectProperty":
                    this.toAssignable(e3.value, t3);
                    break;
                  case "SpreadElement": {
                    this.checkToRestConversion(e3), e3.type = "RestElement";
                    const r4 = e3.argument;
                    this.toAssignable(r4, t3);
                    break;
                  }
                  case "ArrayExpression":
                    e3.type = "ArrayPattern", this.toAssignableList(e3.elements, (n2 = e3.extra) == null ? void 0 : n2.trailingComma, t3);
                    break;
                  case "AssignmentExpression":
                    e3.operator !== "=" && this.raise(e3.left.end, x.MissingEqInAssignment), e3.type = "AssignmentPattern", delete e3.operator, this.toAssignable(e3.left, t3);
                    break;
                  case "ParenthesizedExpression":
                    this.toAssignable(s3, t3);
                }
                return e3;
              }
              toAssignableObjectExpressionProp(e3, t3, r3) {
                if (e3.type === "ObjectMethod") {
                  const t4 = e3.kind === "get" || e3.kind === "set" ? x.PatternHasAccessor : x.PatternHasMethod;
                  this.raise(e3.key.start, t4);
                } else
                  e3.type !== "SpreadElement" || t3 ? this.toAssignable(e3, r3) : this.raiseRestNotLast(e3.start);
              }
              toAssignableList(e3, t3, r3) {
                let n2 = e3.length;
                if (n2) {
                  const s3 = e3[n2 - 1];
                  if ((s3 == null ? void 0 : s3.type) === "RestElement")
                    --n2;
                  else if ((s3 == null ? void 0 : s3.type) === "SpreadElement") {
                    s3.type = "RestElement";
                    let e4 = s3.argument;
                    this.toAssignable(e4, r3), e4 = Me(e4), e4.type !== "Identifier" && e4.type !== "MemberExpression" && e4.type !== "ArrayPattern" && e4.type !== "ObjectPattern" && this.unexpected(e4.start), t3 && this.raiseTrailingCommaAfterRest(t3), --n2;
                  }
                }
                for (let t4 = 0; t4 < n2; t4++) {
                  const n3 = e3[t4];
                  n3 && (this.toAssignable(n3, r3), n3.type === "RestElement" && this.raiseRestNotLast(n3.start));
                }
                return e3;
              }
              toReferencedList(e3, t3) {
                return e3;
              }
              toReferencedListDeep(e3, t3) {
                this.toReferencedList(e3, t3);
                for (const t4 of e3)
                  (t4 == null ? void 0 : t4.type) === "ArrayExpression" && this.toReferencedListDeep(t4.elements);
              }
              parseSpread(e3, t3) {
                const r3 = this.startNode();
                return this.next(), r3.argument = this.parseMaybeAssignAllowIn(e3, void 0, t3), this.finishNode(r3, "SpreadElement");
              }
              parseRestBinding() {
                const e3 = this.startNode();
                return this.next(), e3.argument = this.parseBindingAtom(), this.finishNode(e3, "RestElement");
              }
              parseBindingAtom() {
                switch (this.state.type) {
                  case p2.bracketL: {
                    const e3 = this.startNode();
                    return this.next(), e3.elements = this.parseBindingList(p2.bracketR, 93, true), this.finishNode(e3, "ArrayPattern");
                  }
                  case p2.braceL:
                    return this.parseObjectLike(p2.braceR, true);
                }
                return this.parseIdentifier();
              }
              parseBindingList(e3, t3, r3, n2) {
                const s3 = [];
                let i2 = true;
                for (; !this.eat(e3); )
                  if (i2 ? i2 = false : this.expect(p2.comma), r3 && this.match(p2.comma))
                    s3.push(null);
                  else {
                    if (this.eat(e3))
                      break;
                    if (this.match(p2.ellipsis)) {
                      s3.push(this.parseAssignableListItemTypes(this.parseRestBinding())), this.checkCommaAfterRest(t3), this.expect(e3);
                      break;
                    }
                    {
                      const e4 = [];
                      for (this.match(p2.at) && this.hasPlugin("decorators") && this.raise(this.state.start, x.UnsupportedParameterDecorator); this.match(p2.at); )
                        e4.push(this.parseDecorator());
                      s3.push(this.parseAssignableListItem(n2, e4));
                    }
                  }
                return s3;
              }
              parseAssignableListItem(e3, t3) {
                const r3 = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(r3);
                const n2 = this.parseMaybeDefault(r3.start, r3.loc.start, r3);
                return t3.length && (r3.decorators = t3), n2;
              }
              parseAssignableListItemTypes(e3) {
                return e3;
              }
              parseMaybeDefault(e3, t3, r3) {
                var n2, s3, i2;
                if (t3 = (n2 = t3) != null ? n2 : this.state.startLoc, e3 = (s3 = e3) != null ? s3 : this.state.start, r3 = (i2 = r3) != null ? i2 : this.parseBindingAtom(), !this.eat(p2.eq))
                  return r3;
                const o2 = this.startNodeAt(e3, t3);
                return o2.left = r3, o2.right = this.parseMaybeAssignAllowIn(), this.finishNode(o2, "AssignmentPattern");
              }
              checkLVal(e3, t3, r3 = 64, n2, s3, i2 = false) {
                switch (e3.type) {
                  case "Identifier": {
                    const { name: t4 } = e3;
                    this.state.strict && (i2 ? $(t4, this.inModule) : U(t4)) && this.raise(e3.start, r3 === 64 ? x.StrictEvalArguments : x.StrictEvalArgumentsBinding, t4), n2 && (n2.has(t4) ? this.raise(e3.start, x.ParamDupe) : n2.add(t4)), s3 && t4 === "let" && this.raise(e3.start, x.LetInLexicalBinding), 64 & r3 || this.scope.declareName(t4, r3, e3.start);
                    break;
                  }
                  case "MemberExpression":
                    r3 !== 64 && this.raise(e3.start, x.InvalidPropertyBindingPattern);
                    break;
                  case "ObjectPattern":
                    for (let t4 of e3.properties) {
                      if (this.isObjectProperty(t4))
                        t4 = t4.value;
                      else if (this.isObjectMethod(t4))
                        continue;
                      this.checkLVal(t4, "object destructuring pattern", r3, n2, s3);
                    }
                    break;
                  case "ArrayPattern":
                    for (const t4 of e3.elements)
                      t4 && this.checkLVal(t4, "array destructuring pattern", r3, n2, s3);
                    break;
                  case "AssignmentPattern":
                    this.checkLVal(e3.left, "assignment pattern", r3, n2);
                    break;
                  case "RestElement":
                    this.checkLVal(e3.argument, "rest element", r3, n2);
                    break;
                  case "ParenthesizedExpression":
                    this.checkLVal(e3.expression, "parenthesized expression", r3, n2);
                    break;
                  default:
                    this.raise(e3.start, r3 === 64 ? x.InvalidLhs : x.InvalidLhsBinding, t3);
                }
              }
              checkToRestConversion(e3) {
                e3.argument.type !== "Identifier" && e3.argument.type !== "MemberExpression" && this.raise(e3.argument.start, x.InvalidRestAssignmentPattern);
              }
              checkCommaAfterRest(e3) {
                this.match(p2.comma) && (this.lookaheadCharCode() === e3 ? this.raiseTrailingCommaAfterRest(this.state.start) : this.raiseRestNotLast(this.state.start));
              }
              raiseRestNotLast(e3) {
                throw this.raise(e3, x.ElementAfterRest);
              }
              raiseTrailingCommaAfterRest(e3) {
                this.raise(e3, x.RestTrailingComma);
              }
            } {
              checkProto(e3, t3, r3, n2) {
                if (e3.type === "SpreadElement" || this.isObjectMethod(e3) || e3.computed || e3.shorthand)
                  return;
                const s3 = e3.key;
                if ((s3.type === "Identifier" ? s3.name : s3.value) === "__proto__") {
                  if (t3)
                    return void this.raise(s3.start, x.RecordNoProto);
                  r3.used && (n2 ? n2.doubleProto === -1 && (n2.doubleProto = s3.start) : this.raise(s3.start, x.DuplicateProto)), r3.used = true;
                }
              }
              shouldExitDescending(e3, t3) {
                return e3.type === "ArrowFunctionExpression" && e3.start === t3;
              }
              getExpression() {
                let e3 = 0;
                this.hasPlugin("topLevelAwait") && this.inModule && (e3 |= 2), this.scope.enter(1), this.prodParam.enter(e3), this.nextToken();
                const t3 = this.parseExpression();
                return this.match(p2.eof) || this.unexpected(), t3.comments = this.state.comments, t3.errors = this.state.errors, this.options.tokens && (t3.tokens = this.tokens), t3;
              }
              parseExpression(e3, t3) {
                return e3 ? this.disallowInAnd(() => this.parseExpressionBase(t3)) : this.allowInAnd(() => this.parseExpressionBase(t3));
              }
              parseExpressionBase(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc, n2 = this.parseMaybeAssign(e3);
                if (this.match(p2.comma)) {
                  const s3 = this.startNodeAt(t3, r3);
                  for (s3.expressions = [n2]; this.eat(p2.comma); )
                    s3.expressions.push(this.parseMaybeAssign(e3));
                  return this.toReferencedList(s3.expressions), this.finishNode(s3, "SequenceExpression");
                }
                return n2;
              }
              parseMaybeAssignDisallowIn(e3, t3) {
                return this.disallowInAnd(() => this.parseMaybeAssign(e3, t3));
              }
              parseMaybeAssignAllowIn(e3, t3) {
                return this.allowInAnd(() => this.parseMaybeAssign(e3, t3));
              }
              setOptionalParametersError(e3, t3) {
                var r3;
                e3.optionalParameters = (r3 = t3 == null ? void 0 : t3.pos) != null ? r3 : this.state.start;
              }
              parseMaybeAssign(e3, t3) {
                const r3 = this.state.start, n2 = this.state.startLoc;
                if (this.isContextual("yield") && this.prodParam.hasYield) {
                  let e4 = this.parseYield();
                  return t3 && (e4 = t3.call(this, e4, r3, n2)), e4;
                }
                let s3;
                e3 ? s3 = false : (e3 = new De(), s3 = true), (this.match(p2.parenL) || this.match(p2.name)) && (this.state.potentialArrowAt = this.state.start);
                let i2 = this.parseMaybeConditional(e3);
                if (t3 && (i2 = t3.call(this, i2, r3, n2)), this.state.type.isAssign) {
                  const t4 = this.startNodeAt(r3, n2), s4 = this.state.value;
                  return t4.operator = s4, this.match(p2.eq) ? (t4.left = this.toAssignable(i2, true), e3.doubleProto = -1) : t4.left = i2, e3.shorthandAssign >= t4.left.start && (e3.shorthandAssign = -1), this.checkLVal(i2, "assignment expression"), this.next(), t4.right = this.parseMaybeAssign(), this.finishNode(t4, "AssignmentExpression");
                }
                return s3 && this.checkExpressionErrors(e3, true), i2;
              }
              parseMaybeConditional(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc, n2 = this.state.potentialArrowAt, s3 = this.parseExprOps(e3);
                return this.shouldExitDescending(s3, n2) ? s3 : this.parseConditional(s3, t3, r3, e3);
              }
              parseConditional(e3, t3, r3, n2) {
                if (this.eat(p2.question)) {
                  const n3 = this.startNodeAt(t3, r3);
                  return n3.test = e3, n3.consequent = this.parseMaybeAssignAllowIn(), this.expect(p2.colon), n3.alternate = this.parseMaybeAssign(), this.finishNode(n3, "ConditionalExpression");
                }
                return e3;
              }
              parseExprOps(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc, n2 = this.state.potentialArrowAt, s3 = this.parseMaybeUnary(e3);
                return this.shouldExitDescending(s3, n2) ? s3 : this.parseExprOp(s3, t3, r3, -1);
              }
              parseExprOp(e3, t3, r3, n2) {
                let s3 = this.state.type.binop;
                if (s3 != null && (this.prodParam.hasIn || !this.match(p2._in)) && s3 > n2) {
                  const i2 = this.state.type;
                  if (i2 === p2.pipeline) {
                    if (this.expectPlugin("pipelineOperator"), this.state.inFSharpPipelineDirectBody)
                      return e3;
                    this.state.inPipeline = true, this.checkPipelineAtInfixOperator(e3, t3);
                  }
                  const o2 = this.startNodeAt(t3, r3);
                  o2.left = e3, o2.operator = this.state.value;
                  const a2 = i2 === p2.logicalOR || i2 === p2.logicalAND, l2 = i2 === p2.nullishCoalescing;
                  if (l2 && (s3 = p2.logicalAND.binop), this.next(), i2 === p2.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal" && this.match(p2.name) && this.state.value === "await" && this.prodParam.hasAwait)
                    throw this.raise(this.state.start, x.UnexpectedAwaitAfterPipelineBody);
                  o2.right = this.parseExprOpRightExpr(i2, s3), this.finishNode(o2, a2 || l2 ? "LogicalExpression" : "BinaryExpression");
                  const c4 = this.state.type;
                  if (l2 && (c4 === p2.logicalOR || c4 === p2.logicalAND) || a2 && c4 === p2.nullishCoalescing)
                    throw this.raise(this.state.start, x.MixingCoalesceWithLogical);
                  return this.parseExprOp(o2, t3, r3, n2);
                }
                return e3;
              }
              parseExprOpRightExpr(e3, t3) {
                const r3 = this.state.start, n2 = this.state.startLoc;
                switch (e3) {
                  case p2.pipeline:
                    switch (this.getPluginOption("pipelineOperator", "proposal")) {
                      case "smart":
                        return this.withTopicPermittingContext(() => this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(e3, t3), r3, n2));
                      case "fsharp":
                        return this.withSoloAwaitPermittingContext(() => this.parseFSharpPipelineBody(t3));
                    }
                  default:
                    return this.parseExprOpBaseRightExpr(e3, t3);
                }
              }
              parseExprOpBaseRightExpr(e3, t3) {
                const r3 = this.state.start, n2 = this.state.startLoc;
                return this.parseExprOp(this.parseMaybeUnary(), r3, n2, e3.rightAssociative ? t3 - 1 : t3);
              }
              checkExponentialAfterUnary(e3) {
                this.match(p2.exponent) && this.raise(e3.argument.start, x.UnexpectedTokenUnaryExponentiation);
              }
              parseMaybeUnary(e3, t3) {
                const r3 = this.state.start, n2 = this.state.startLoc, s3 = this.isContextual("await");
                if (s3 && this.isAwaitAllowed()) {
                  this.next();
                  const e4 = this.parseAwait(r3, n2);
                  return t3 || this.checkExponentialAfterUnary(e4), e4;
                }
                if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak())
                  return this.parseModuleExpression();
                const i2 = this.match(p2.incDec), o2 = this.startNode();
                if (this.state.type.prefix) {
                  o2.operator = this.state.value, o2.prefix = true, this.match(p2._throw) && this.expectPlugin("throwExpressions");
                  const r4 = this.match(p2._delete);
                  if (this.next(), o2.argument = this.parseMaybeUnary(null, true), this.checkExpressionErrors(e3, true), this.state.strict && r4) {
                    const e4 = o2.argument;
                    e4.type === "Identifier" ? this.raise(o2.start, x.StrictDelete) : this.hasPropertyAsPrivateName(e4) && this.raise(o2.start, x.DeletePrivateField);
                  }
                  if (!i2)
                    return t3 || this.checkExponentialAfterUnary(o2), this.finishNode(o2, "UnaryExpression");
                }
                const a2 = this.parseUpdate(o2, i2, e3);
                return s3 && (this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(p2.modulo)) && !this.isAmbiguousAwait() ? (this.raiseOverwrite(r3, this.hasPlugin("topLevelAwait") ? x.AwaitNotInAsyncContext : x.AwaitNotInAsyncFunction), this.parseAwait(r3, n2)) : a2;
              }
              parseUpdate(e3, t3, r3) {
                if (t3)
                  return this.checkLVal(e3.argument, "prefix operation"), this.finishNode(e3, "UpdateExpression");
                const n2 = this.state.start, s3 = this.state.startLoc;
                let i2 = this.parseExprSubscripts(r3);
                if (this.checkExpressionErrors(r3, false))
                  return i2;
                for (; this.state.type.postfix && !this.canInsertSemicolon(); ) {
                  const e4 = this.startNodeAt(n2, s3);
                  e4.operator = this.state.value, e4.prefix = false, e4.argument = i2, this.checkLVal(i2, "postfix operation"), this.next(), i2 = this.finishNode(e4, "UpdateExpression");
                }
                return i2;
              }
              parseExprSubscripts(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc, n2 = this.state.potentialArrowAt, s3 = this.parseExprAtom(e3);
                return this.shouldExitDescending(s3, n2) ? s3 : this.parseSubscripts(s3, t3, r3);
              }
              parseSubscripts(e3, t3, r3, n2) {
                const s3 = { optionalChainMember: false, maybeAsyncArrow: this.atPossibleAsyncArrow(e3), stop: false };
                do {
                  e3 = this.parseSubscript(e3, t3, r3, n2, s3), s3.maybeAsyncArrow = false;
                } while (!s3.stop);
                return e3;
              }
              parseSubscript(e3, t3, r3, n2, s3) {
                if (!n2 && this.eat(p2.doubleColon))
                  return this.parseBind(e3, t3, r3, n2, s3);
                if (this.match(p2.backQuote))
                  return this.parseTaggedTemplateExpression(e3, t3, r3, s3);
                let i2 = false;
                if (this.match(p2.questionDot)) {
                  if (n2 && this.lookaheadCharCode() === 40)
                    return s3.stop = true, e3;
                  s3.optionalChainMember = i2 = true, this.next();
                }
                return !n2 && this.match(p2.parenL) ? this.parseCoverCallAndAsyncArrowHead(e3, t3, r3, s3, i2) : i2 || this.match(p2.bracketL) || this.eat(p2.dot) ? this.parseMember(e3, t3, r3, s3, i2) : (s3.stop = true, e3);
              }
              parseMember(e3, t3, r3, n2, s3) {
                const i2 = this.startNodeAt(t3, r3), o2 = this.eat(p2.bracketL);
                i2.object = e3, i2.computed = o2;
                const a2 = !o2 && this.match(p2.privateName) && this.state.value, l2 = o2 ? this.parseExpression() : a2 ? this.parsePrivateName() : this.parseIdentifier(true);
                return a2 !== false && (i2.object.type === "Super" && this.raise(t3, x.SuperPrivateField), this.classScope.usePrivateName(a2, l2.start)), i2.property = l2, o2 && this.expect(p2.bracketR), n2.optionalChainMember ? (i2.optional = s3, this.finishNode(i2, "OptionalMemberExpression")) : this.finishNode(i2, "MemberExpression");
              }
              parseBind(e3, t3, r3, n2, s3) {
                const i2 = this.startNodeAt(t3, r3);
                return i2.object = e3, i2.callee = this.parseNoCallExpr(), s3.stop = true, this.parseSubscripts(this.finishNode(i2, "BindExpression"), t3, r3, n2);
              }
              parseCoverCallAndAsyncArrowHead(e3, t3, r3, n2, s3) {
                const i2 = this.state.maybeInArrowParameters;
                let o2 = null;
                this.state.maybeInArrowParameters = true, this.next();
                let a2 = this.startNodeAt(t3, r3);
                return a2.callee = e3, n2.maybeAsyncArrow && (this.expressionScope.enter(new Ne(2)), o2 = new De()), n2.optionalChainMember && (a2.optional = s3), a2.arguments = s3 ? this.parseCallExpressionArguments(p2.parenR) : this.parseCallExpressionArguments(p2.parenR, e3.type === "Import", e3.type !== "Super", a2, o2), this.finishCallExpression(a2, n2.optionalChainMember), n2.maybeAsyncArrow && this.shouldParseAsyncArrow() && !s3 ? (n2.stop = true, this.expressionScope.validateAsPattern(), this.expressionScope.exit(), a2 = this.parseAsyncArrowFromCallExpression(this.startNodeAt(t3, r3), a2)) : (n2.maybeAsyncArrow && (this.checkExpressionErrors(o2, true), this.expressionScope.exit()), this.toReferencedArguments(a2)), this.state.maybeInArrowParameters = i2, a2;
              }
              toReferencedArguments(e3, t3) {
                this.toReferencedListDeep(e3.arguments, t3);
              }
              parseTaggedTemplateExpression(e3, t3, r3, n2) {
                const s3 = this.startNodeAt(t3, r3);
                return s3.tag = e3, s3.quasi = this.parseTemplate(true), n2.optionalChainMember && this.raise(t3, x.OptionalChainingNoTemplate), this.finishNode(s3, "TaggedTemplateExpression");
              }
              atPossibleAsyncArrow(e3) {
                return e3.type === "Identifier" && e3.name === "async" && this.state.lastTokEnd === e3.end && !this.canInsertSemicolon() && e3.end - e3.start == 5 && e3.start === this.state.potentialArrowAt;
              }
              finishCallExpression(e3, t3) {
                if (e3.callee.type === "Import")
                  if (e3.arguments.length === 2 && (this.hasPlugin("moduleAttributes") || this.expectPlugin("importAssertions")), e3.arguments.length === 0 || e3.arguments.length > 2)
                    this.raise(e3.start, x.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
                  else
                    for (const t4 of e3.arguments)
                      t4.type === "SpreadElement" && this.raise(t4.start, x.ImportCallSpreadArgument);
                return this.finishNode(e3, t3 ? "OptionalCallExpression" : "CallExpression");
              }
              parseCallExpressionArguments(e3, t3, r3, n2, s3) {
                const i2 = [];
                let o2 = true;
                const a2 = this.state.inFSharpPipelineDirectBody;
                for (this.state.inFSharpPipelineDirectBody = false; !this.eat(e3); ) {
                  if (o2)
                    o2 = false;
                  else if (this.expect(p2.comma), this.match(e3)) {
                    !t3 || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") || this.raise(this.state.lastTokStart, x.ImportCallArgumentTrailingComma), n2 && this.addExtra(n2, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                  }
                  i2.push(this.parseExprListItem(false, s3, r3));
                }
                return this.state.inFSharpPipelineDirectBody = a2, i2;
              }
              shouldParseAsyncArrow() {
                return this.match(p2.arrow) && !this.canInsertSemicolon();
              }
              parseAsyncArrowFromCallExpression(e3, t3) {
                var r3;
                return this.expect(p2.arrow), this.parseArrowExpression(e3, t3.arguments, true, (r3 = t3.extra) == null ? void 0 : r3.trailingComma), e3;
              }
              parseNoCallExpr() {
                const e3 = this.state.start, t3 = this.state.startLoc;
                return this.parseSubscripts(this.parseExprAtom(), e3, t3, true);
              }
              parseExprAtom(e3) {
                let t3;
                switch (this.state.type) {
                  case p2._super:
                    return this.parseSuper();
                  case p2._import:
                    return t3 = this.startNode(), this.next(), this.match(p2.dot) ? this.parseImportMetaProperty(t3) : (this.match(p2.parenL) || this.raise(this.state.lastTokStart, x.UnsupportedImport), this.finishNode(t3, "Import"));
                  case p2._this:
                    return t3 = this.startNode(), this.next(), this.finishNode(t3, "ThisExpression");
                  case p2.name: {
                    const e4 = this.state.potentialArrowAt === this.state.start, t4 = this.state.containsEsc, r3 = this.parseIdentifier();
                    if (!t4 && r3.name === "async" && !this.canInsertSemicolon()) {
                      if (this.match(p2._function))
                        return this.next(), this.parseFunction(this.startNodeAtNode(r3), void 0, true);
                      if (this.match(p2.name))
                        return this.lookaheadCharCode() === 61 ? this.parseAsyncArrowUnaryFunction(r3) : r3;
                      if (this.match(p2._do))
                        return this.parseDo(true);
                    }
                    return e4 && this.match(p2.arrow) && !this.canInsertSemicolon() ? (this.next(), this.parseArrowExpression(this.startNodeAtNode(r3), [r3], false)) : r3;
                  }
                  case p2._do:
                    return this.parseDo(false);
                  case p2.slash:
                  case p2.slashAssign:
                    return this.readRegexp(), this.parseRegExpLiteral(this.state.value);
                  case p2.num:
                    return this.parseNumericLiteral(this.state.value);
                  case p2.bigint:
                    return this.parseBigIntLiteral(this.state.value);
                  case p2.decimal:
                    return this.parseDecimalLiteral(this.state.value);
                  case p2.string:
                    return this.parseStringLiteral(this.state.value);
                  case p2._null:
                    return this.parseNullLiteral();
                  case p2._true:
                    return this.parseBooleanLiteral(true);
                  case p2._false:
                    return this.parseBooleanLiteral(false);
                  case p2.parenL: {
                    const e4 = this.state.potentialArrowAt === this.state.start;
                    return this.parseParenAndDistinguishExpression(e4);
                  }
                  case p2.bracketBarL:
                  case p2.bracketHashL:
                    return this.parseArrayLike(this.state.type === p2.bracketBarL ? p2.bracketBarR : p2.bracketR, false, true, e3);
                  case p2.bracketL:
                    return this.parseArrayLike(p2.bracketR, true, false, e3);
                  case p2.braceBarL:
                  case p2.braceHashL:
                    return this.parseObjectLike(this.state.type === p2.braceBarL ? p2.braceBarR : p2.braceR, false, true, e3);
                  case p2.braceL:
                    return this.parseObjectLike(p2.braceR, false, false, e3);
                  case p2._function:
                    return this.parseFunctionOrFunctionSent();
                  case p2.at:
                    this.parseDecorators();
                  case p2._class:
                    return t3 = this.startNode(), this.takeDecorators(t3), this.parseClass(t3, false);
                  case p2._new:
                    return this.parseNewOrNewTarget();
                  case p2.backQuote:
                    return this.parseTemplate(false);
                  case p2.doubleColon: {
                    t3 = this.startNode(), this.next(), t3.object = null;
                    const e4 = t3.callee = this.parseNoCallExpr();
                    if (e4.type === "MemberExpression")
                      return this.finishNode(t3, "BindExpression");
                    throw this.raise(e4.start, x.UnsupportedBind);
                  }
                  case p2.privateName: {
                    const e4 = this.state.start, r3 = this.state.value;
                    if (t3 = this.parsePrivateName(), this.match(p2._in))
                      this.expectPlugin("privateIn"), this.classScope.usePrivateName(r3, t3.start);
                    else {
                      if (!this.hasPlugin("privateIn"))
                        throw this.unexpected(e4);
                      this.raise(this.state.start, x.PrivateInExpectedIn, r3);
                    }
                    return t3;
                  }
                  case p2.hash:
                    if (this.state.inPipeline)
                      return t3 = this.startNode(), this.getPluginOption("pipelineOperator", "proposal") !== "smart" && this.raise(t3.start, x.PrimaryTopicRequiresSmartPipeline), this.next(), this.primaryTopicReferenceIsAllowedInCurrentTopicContext() || this.raise(t3.start, x.PrimaryTopicNotAllowed), this.registerTopicReference(), this.finishNode(t3, "PipelinePrimaryTopicReference");
                  case p2.relational:
                    if (this.state.value === "<") {
                      const e4 = this.input.codePointAt(this.nextTokenStart());
                      (j(e4) || e4 === 62) && this.expectOnePlugin(["jsx", "flow", "typescript"]);
                    }
                  default:
                    throw this.unexpected();
                }
              }
              parseAsyncArrowUnaryFunction(e3) {
                const t3 = this.startNodeAtNode(e3);
                this.prodParam.enter(ue(true, this.prodParam.hasYield));
                const r3 = [this.parseIdentifier()];
                return this.prodParam.exit(), this.hasPrecedingLineBreak() && this.raise(this.state.pos, x.LineTerminatorBeforeArrow), this.expect(p2.arrow), this.parseArrowExpression(t3, r3, true), t3;
              }
              parseDo(e3) {
                this.expectPlugin("doExpressions"), e3 && this.expectPlugin("asyncDoExpressions");
                const t3 = this.startNode();
                t3.async = e3, this.next();
                const r3 = this.state.labels;
                return this.state.labels = [], e3 ? (this.prodParam.enter(2), t3.body = this.parseBlock(), this.prodParam.exit()) : t3.body = this.parseBlock(), this.state.labels = r3, this.finishNode(t3, "DoExpression");
              }
              parseSuper() {
                const e3 = this.startNode();
                return this.next(), !this.match(p2.parenL) || this.scope.allowDirectSuper || this.options.allowSuperOutsideMethod ? this.scope.allowSuper || this.options.allowSuperOutsideMethod || this.raise(e3.start, x.UnexpectedSuper) : this.raise(e3.start, x.SuperNotAllowed), this.match(p2.parenL) || this.match(p2.bracketL) || this.match(p2.dot) || this.raise(e3.start, x.UnsupportedSuper), this.finishNode(e3, "Super");
              }
              parseMaybePrivateName(e3) {
                return this.match(p2.privateName) ? (e3 || this.raise(this.state.start + 1, x.UnexpectedPrivateField), this.parsePrivateName()) : this.parseIdentifier(true);
              }
              parsePrivateName() {
                const e3 = this.startNode(), t3 = this.startNodeAt(this.state.start + 1, new g(this.state.curLine, this.state.start + 1 - this.state.lineStart)), r3 = this.state.value;
                return this.next(), e3.id = this.createIdentifier(t3, r3), this.finishNode(e3, "PrivateName");
              }
              parseFunctionOrFunctionSent() {
                const e3 = this.startNode();
                if (this.next(), this.prodParam.hasYield && this.match(p2.dot)) {
                  const t3 = this.createIdentifier(this.startNodeAtNode(e3), "function");
                  return this.next(), this.parseMetaProperty(e3, t3, "sent");
                }
                return this.parseFunction(e3);
              }
              parseMetaProperty(e3, t3, r3) {
                e3.meta = t3, t3.name === "function" && r3 === "sent" && (this.isContextual(r3) ? this.expectPlugin("functionSent") : this.hasPlugin("functionSent") || this.unexpected());
                const n2 = this.state.containsEsc;
                return e3.property = this.parseIdentifier(true), (e3.property.name !== r3 || n2) && this.raise(e3.property.start, x.UnsupportedMetaProperty, t3.name, r3), this.finishNode(e3, "MetaProperty");
              }
              parseImportMetaProperty(e3) {
                const t3 = this.createIdentifier(this.startNodeAtNode(e3), "import");
                return this.next(), this.isContextual("meta") && (this.inModule || this.raise(t3.start, S.ImportMetaOutsideModule), this.sawUnambiguousESM = true), this.parseMetaProperty(e3, t3, "meta");
              }
              parseLiteralAtNode(e3, t3, r3) {
                return this.addExtra(r3, "rawValue", e3), this.addExtra(r3, "raw", this.input.slice(r3.start, this.state.end)), r3.value = e3, this.next(), this.finishNode(r3, t3);
              }
              parseLiteral(e3, t3) {
                const r3 = this.startNode();
                return this.parseLiteralAtNode(e3, t3, r3);
              }
              parseStringLiteral(e3) {
                return this.parseLiteral(e3, "StringLiteral");
              }
              parseNumericLiteral(e3) {
                return this.parseLiteral(e3, "NumericLiteral");
              }
              parseBigIntLiteral(e3) {
                return this.parseLiteral(e3, "BigIntLiteral");
              }
              parseDecimalLiteral(e3) {
                return this.parseLiteral(e3, "DecimalLiteral");
              }
              parseRegExpLiteral(e3) {
                const t3 = this.parseLiteral(e3.value, "RegExpLiteral");
                return t3.pattern = e3.pattern, t3.flags = e3.flags, t3;
              }
              parseBooleanLiteral(e3) {
                const t3 = this.startNode();
                return t3.value = e3, this.next(), this.finishNode(t3, "BooleanLiteral");
              }
              parseNullLiteral() {
                const e3 = this.startNode();
                return this.next(), this.finishNode(e3, "NullLiteral");
              }
              parseParenAndDistinguishExpression(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc;
                let n2;
                this.next(), this.expressionScope.enter(new Ne(1));
                const s3 = this.state.maybeInArrowParameters, i2 = this.state.inFSharpPipelineDirectBody;
                this.state.maybeInArrowParameters = true, this.state.inFSharpPipelineDirectBody = false;
                const o2 = this.state.start, a2 = this.state.startLoc, l2 = [], c4 = new De();
                let u2, f2, d2 = true;
                for (; !this.match(p2.parenR); ) {
                  if (d2)
                    d2 = false;
                  else if (this.expect(p2.comma, c4.optionalParameters === -1 ? null : c4.optionalParameters), this.match(p2.parenR)) {
                    f2 = this.state.start;
                    break;
                  }
                  if (this.match(p2.ellipsis)) {
                    const e4 = this.state.start, t4 = this.state.startLoc;
                    u2 = this.state.start, l2.push(this.parseParenItem(this.parseRestBinding(), e4, t4)), this.checkCommaAfterRest(41);
                    break;
                  }
                  l2.push(this.parseMaybeAssignAllowIn(c4, this.parseParenItem));
                }
                const h4 = this.state.lastTokEnd, m2 = this.state.lastTokEndLoc;
                this.expect(p2.parenR), this.state.maybeInArrowParameters = s3, this.state.inFSharpPipelineDirectBody = i2;
                let y2 = this.startNodeAt(t3, r3);
                if (e3 && this.shouldParseArrow() && (y2 = this.parseArrow(y2)))
                  return this.expressionScope.validateAsPattern(), this.expressionScope.exit(), this.parseArrowExpression(y2, l2, false), y2;
                if (this.expressionScope.exit(), l2.length || this.unexpected(this.state.lastTokStart), f2 && this.unexpected(f2), u2 && this.unexpected(u2), this.checkExpressionErrors(c4, true), this.toReferencedListDeep(l2, true), l2.length > 1 ? (n2 = this.startNodeAt(o2, a2), n2.expressions = l2, this.finishNodeAt(n2, "SequenceExpression", h4, m2)) : n2 = l2[0], !this.options.createParenthesizedExpressions)
                  return this.addExtra(n2, "parenthesized", true), this.addExtra(n2, "parenStart", t3), n2;
                const g2 = this.startNodeAt(t3, r3);
                return g2.expression = n2, this.finishNode(g2, "ParenthesizedExpression"), g2;
              }
              shouldParseArrow() {
                return !this.canInsertSemicolon();
              }
              parseArrow(e3) {
                if (this.eat(p2.arrow))
                  return e3;
              }
              parseParenItem(e3, t3, r3) {
                return e3;
              }
              parseNewOrNewTarget() {
                const e3 = this.startNode();
                if (this.next(), this.match(p2.dot)) {
                  const t3 = this.createIdentifier(this.startNodeAtNode(e3), "new");
                  this.next();
                  const r3 = this.parseMetaProperty(e3, t3, "target");
                  return this.scope.inNonArrowFunction || this.scope.inClass || this.raise(r3.start, x.UnexpectedNewTarget), r3;
                }
                return this.parseNew(e3);
              }
              parseNew(e3) {
                return e3.callee = this.parseNoCallExpr(), e3.callee.type === "Import" ? this.raise(e3.callee.start, x.ImportCallNotNewExpression) : this.isOptionalChain(e3.callee) ? this.raise(this.state.lastTokEnd, x.OptionalChainingNoNew) : this.eat(p2.questionDot) && this.raise(this.state.start, x.OptionalChainingNoNew), this.parseNewArguments(e3), this.finishNode(e3, "NewExpression");
              }
              parseNewArguments(e3) {
                if (this.eat(p2.parenL)) {
                  const t3 = this.parseExprList(p2.parenR);
                  this.toReferencedList(t3), e3.arguments = t3;
                } else
                  e3.arguments = [];
              }
              parseTemplateElement(e3) {
                const t3 = this.startNode();
                return this.state.value === null && (e3 || this.raise(this.state.start + 1, x.InvalidEscapeSequenceTemplate)), t3.value = { raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"), cooked: this.state.value }, this.next(), t3.tail = this.match(p2.backQuote), this.finishNode(t3, "TemplateElement");
              }
              parseTemplate(e3) {
                const t3 = this.startNode();
                this.next(), t3.expressions = [];
                let r3 = this.parseTemplateElement(e3);
                for (t3.quasis = [r3]; !r3.tail; )
                  this.expect(p2.dollarBraceL), t3.expressions.push(this.parseTemplateSubstitution()), this.expect(p2.braceR), t3.quasis.push(r3 = this.parseTemplateElement(e3));
                return this.next(), this.finishNode(t3, "TemplateLiteral");
              }
              parseTemplateSubstitution() {
                return this.parseExpression();
              }
              parseObjectLike(e3, t3, r3, n2) {
                r3 && this.expectPlugin("recordAndTuple");
                const s3 = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = false;
                const i2 = Object.create(null);
                let o2 = true;
                const a2 = this.startNode();
                for (a2.properties = [], this.next(); !this.match(e3); ) {
                  if (o2)
                    o2 = false;
                  else if (this.expect(p2.comma), this.match(e3)) {
                    this.addExtra(a2, "trailingComma", this.state.lastTokStart);
                    break;
                  }
                  const s4 = this.parsePropertyDefinition(t3, n2);
                  t3 || this.checkProto(s4, r3, i2, n2), r3 && !this.isObjectProperty(s4) && s4.type !== "SpreadElement" && this.raise(s4.start, x.InvalidRecordProperty), s4.shorthand && this.addExtra(s4, "shorthand", true), a2.properties.push(s4);
                }
                this.next(), this.state.inFSharpPipelineDirectBody = s3;
                let l2 = "ObjectExpression";
                return t3 ? l2 = "ObjectPattern" : r3 && (l2 = "RecordExpression"), this.finishNode(a2, l2);
              }
              maybeAsyncOrAccessorProp(e3) {
                return !e3.computed && e3.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(p2.bracketL) || this.match(p2.star));
              }
              parsePropertyDefinition(e3, t3) {
                let r3 = [];
                if (this.match(p2.at))
                  for (this.hasPlugin("decorators") && this.raise(this.state.start, x.UnsupportedPropertyDecorator); this.match(p2.at); )
                    r3.push(this.parseDecorator());
                const n2 = this.startNode();
                let s3, i2, o2 = false, a2 = false, l2 = false;
                if (this.match(p2.ellipsis))
                  return r3.length && this.unexpected(), e3 ? (this.next(), n2.argument = this.parseIdentifier(), this.checkCommaAfterRest(125), this.finishNode(n2, "RestElement")) : this.parseSpread();
                r3.length && (n2.decorators = r3, r3 = []), n2.method = false, (e3 || t3) && (s3 = this.state.start, i2 = this.state.startLoc), e3 || (o2 = this.eat(p2.star));
                const c4 = this.state.containsEsc, u2 = this.parsePropertyName(n2, false);
                if (!e3 && !o2 && !c4 && this.maybeAsyncOrAccessorProp(n2)) {
                  const e4 = u2.name;
                  e4 !== "async" || this.hasPrecedingLineBreak() || (a2 = true, o2 = this.eat(p2.star), this.parsePropertyName(n2, false)), e4 !== "get" && e4 !== "set" || (l2 = true, n2.kind = e4, this.match(p2.star) && (o2 = true, this.raise(this.state.pos, x.AccessorIsGenerator, e4), this.next()), this.parsePropertyName(n2, false));
                }
                return this.parseObjPropValue(n2, s3, i2, o2, a2, e3, l2, t3), n2;
              }
              getGetterSetterExpectedParamCount(e3) {
                return e3.kind === "get" ? 0 : 1;
              }
              getObjectOrClassMethodParams(e3) {
                return e3.params;
              }
              checkGetterSetterParams(e3) {
                var t3;
                const r3 = this.getGetterSetterExpectedParamCount(e3), n2 = this.getObjectOrClassMethodParams(e3), s3 = e3.start;
                n2.length !== r3 && (e3.kind === "get" ? this.raise(s3, x.BadGetterArity) : this.raise(s3, x.BadSetterArity)), e3.kind === "set" && ((t3 = n2[n2.length - 1]) == null ? void 0 : t3.type) === "RestElement" && this.raise(s3, x.BadSetterRestParameter);
              }
              parseObjectMethod(e3, t3, r3, n2, s3) {
                return s3 ? (this.parseMethod(e3, t3, false, false, false, "ObjectMethod"), this.checkGetterSetterParams(e3), e3) : r3 || t3 || this.match(p2.parenL) ? (n2 && this.unexpected(), e3.kind = "method", e3.method = true, this.parseMethod(e3, t3, r3, false, false, "ObjectMethod")) : void 0;
              }
              parseObjectProperty(e3, t3, r3, n2, s3) {
                return e3.shorthand = false, this.eat(p2.colon) ? (e3.value = n2 ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(s3), this.finishNode(e3, "ObjectProperty")) : e3.computed || e3.key.type !== "Identifier" ? void 0 : (this.checkReservedWord(e3.key.name, e3.key.start, true, false), n2 ? e3.value = this.parseMaybeDefault(t3, r3, e3.key.__clone()) : this.match(p2.eq) && s3 ? (s3.shorthandAssign === -1 && (s3.shorthandAssign = this.state.start), e3.value = this.parseMaybeDefault(t3, r3, e3.key.__clone())) : e3.value = e3.key.__clone(), e3.shorthand = true, this.finishNode(e3, "ObjectProperty"));
              }
              parseObjPropValue(e3, t3, r3, n2, s3, i2, o2, a2) {
                const l2 = this.parseObjectMethod(e3, n2, s3, i2, o2) || this.parseObjectProperty(e3, t3, r3, i2, a2);
                return l2 || this.unexpected(), l2;
              }
              parsePropertyName(e3, t3) {
                if (this.eat(p2.bracketL))
                  e3.computed = true, e3.key = this.parseMaybeAssignAllowIn(), this.expect(p2.bracketR);
                else {
                  const r3 = this.state.inPropertyName;
                  this.state.inPropertyName = true;
                  const n2 = this.state.type;
                  e3.key = n2 === p2.num || n2 === p2.string || n2 === p2.bigint || n2 === p2.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(t3), n2 !== p2.privateName && (e3.computed = false), this.state.inPropertyName = r3;
                }
                return e3.key;
              }
              initFunction(e3, t3) {
                e3.id = null, e3.generator = false, e3.async = !!t3;
              }
              parseMethod(e3, t3, r3, n2, s3, i2, o2 = false) {
                this.initFunction(e3, r3), e3.generator = !!t3;
                const a2 = n2;
                return this.scope.enter(18 | (o2 ? 64 : 0) | (s3 ? 32 : 0)), this.prodParam.enter(ue(r3, e3.generator)), this.parseFunctionParams(e3, a2), this.parseFunctionBodyAndFinish(e3, i2, true), this.prodParam.exit(), this.scope.exit(), e3;
              }
              parseArrayLike(e3, t3, r3, n2) {
                r3 && this.expectPlugin("recordAndTuple");
                const s3 = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = false;
                const i2 = this.startNode();
                return this.next(), i2.elements = this.parseExprList(e3, !r3, n2, i2), this.state.inFSharpPipelineDirectBody = s3, this.finishNode(i2, r3 ? "TupleExpression" : "ArrayExpression");
              }
              parseArrowExpression(e3, t3, r3, n2) {
                this.scope.enter(6);
                let s3 = ue(r3, false);
                !this.match(p2.bracketL) && this.prodParam.hasIn && (s3 |= 8), this.prodParam.enter(s3), this.initFunction(e3, r3);
                const i2 = this.state.maybeInArrowParameters;
                return t3 && (this.state.maybeInArrowParameters = true, this.setArrowFunctionParameters(e3, t3, n2)), this.state.maybeInArrowParameters = false, this.parseFunctionBody(e3, true), this.prodParam.exit(), this.scope.exit(), this.state.maybeInArrowParameters = i2, this.finishNode(e3, "ArrowFunctionExpression");
              }
              setArrowFunctionParameters(e3, t3, r3) {
                e3.params = this.toAssignableList(t3, r3, false);
              }
              parseFunctionBodyAndFinish(e3, t3, r3 = false) {
                this.parseFunctionBody(e3, false, r3), this.finishNode(e3, t3);
              }
              parseFunctionBody(e3, t3, r3 = false) {
                const n2 = t3 && !this.match(p2.braceL);
                if (this.expressionScope.enter(je()), n2)
                  e3.body = this.parseMaybeAssign(), this.checkParams(e3, false, t3, false);
                else {
                  const n3 = this.state.strict, s3 = this.state.labels;
                  this.state.labels = [], this.prodParam.enter(4 | this.prodParam.currentFlags()), e3.body = this.parseBlock(true, false, (s4) => {
                    const i2 = !this.isSimpleParamList(e3.params);
                    if (s4 && i2) {
                      const t4 = e3.kind !== "method" && e3.kind !== "constructor" || !e3.key ? e3.start : e3.key.end;
                      this.raise(t4, x.IllegalLanguageModeDirective);
                    }
                    const o2 = !n3 && this.state.strict;
                    this.checkParams(e3, !(this.state.strict || t3 || r3 || i2), t3, o2), this.state.strict && e3.id && this.checkLVal(e3.id, "function name", 65, void 0, void 0, o2);
                  }), this.prodParam.exit(), this.expressionScope.exit(), this.state.labels = s3;
                }
              }
              isSimpleParamList(e3) {
                for (let t3 = 0, r3 = e3.length; t3 < r3; t3++)
                  if (e3[t3].type !== "Identifier")
                    return false;
                return true;
              }
              checkParams(e3, t3, r3, n2 = true) {
                const s3 = new Set();
                for (const r4 of e3.params)
                  this.checkLVal(r4, "function parameter list", 5, t3 ? null : s3, void 0, n2);
              }
              parseExprList(e3, t3, r3, n2) {
                const s3 = [];
                let i2 = true;
                for (; !this.eat(e3); ) {
                  if (i2)
                    i2 = false;
                  else if (this.expect(p2.comma), this.match(e3)) {
                    n2 && this.addExtra(n2, "trailingComma", this.state.lastTokStart), this.next();
                    break;
                  }
                  s3.push(this.parseExprListItem(t3, r3));
                }
                return s3;
              }
              parseExprListItem(e3, t3, r3) {
                let n2;
                if (this.match(p2.comma))
                  e3 || this.raise(this.state.pos, x.UnexpectedToken, ","), n2 = null;
                else if (this.match(p2.ellipsis)) {
                  const e4 = this.state.start, r4 = this.state.startLoc;
                  n2 = this.parseParenItem(this.parseSpread(t3), e4, r4);
                } else if (this.match(p2.question)) {
                  this.expectPlugin("partialApplication"), r3 || this.raise(this.state.start, x.UnexpectedArgumentPlaceholder);
                  const e4 = this.startNode();
                  this.next(), n2 = this.finishNode(e4, "ArgumentPlaceholder");
                } else
                  n2 = this.parseMaybeAssignAllowIn(t3, this.parseParenItem);
                return n2;
              }
              parseIdentifier(e3) {
                const t3 = this.startNode(), r3 = this.parseIdentifierName(t3.start, e3);
                return this.createIdentifier(t3, r3);
              }
              createIdentifier(e3, t3) {
                return e3.name = t3, e3.loc.identifierName = t3, this.finishNode(e3, "Identifier");
              }
              parseIdentifierName(e3, t3) {
                let r3;
                const { start: n2, type: s3 } = this.state;
                if (s3 === p2.name)
                  r3 = this.state.value;
                else {
                  if (!s3.keyword)
                    throw this.unexpected();
                  r3 = s3.keyword;
                }
                return t3 ? this.state.type = p2.name : this.checkReservedWord(r3, n2, !!s3.keyword, false), this.next(), r3;
              }
              checkReservedWord(e3, t3, r3, n2) {
                if (!(e3.length > 10) && function(e4) {
                  return V.has(e4);
                }(e3)) {
                  if (e3 === "yield") {
                    if (this.prodParam.hasYield)
                      return void this.raise(t3, x.YieldBindingIdentifier);
                  } else if (e3 === "await") {
                    if (this.prodParam.hasAwait)
                      return void this.raise(t3, x.AwaitBindingIdentifier);
                    if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction)
                      return void this.raise(t3, x.AwaitBindingIdentifierInStaticBlock);
                    this.expressionScope.recordAsyncArrowParametersError(t3, x.AwaitBindingIdentifier);
                  } else if (e3 === "arguments" && this.scope.inClassAndNotInNonArrowFunction)
                    return void this.raise(t3, x.ArgumentsInClass);
                  r3 && q(e3) ? this.raise(t3, x.UnexpectedKeyword, e3) : (this.state.strict ? n2 ? $ : F : R)(e3, this.inModule) && this.raise(t3, x.UnexpectedReservedWord, e3);
                }
              }
              isAwaitAllowed() {
                return !!this.prodParam.hasAwait || !(!this.options.allowAwaitOutsideFunction || this.scope.inFunction);
              }
              parseAwait(e3, t3) {
                const r3 = this.startNodeAt(e3, t3);
                return this.expressionScope.recordParameterInitializerError(r3.start, x.AwaitExpressionFormalParameter), this.eat(p2.star) && this.raise(r3.start, x.ObsoleteAwaitStar), this.scope.inFunction || this.options.allowAwaitOutsideFunction || (this.isAmbiguousAwait() ? this.ambiguousScriptDifferentAst = true : this.sawUnambiguousESM = true), this.state.soloAwait || (r3.argument = this.parseMaybeUnary(null, true)), this.finishNode(r3, "AwaitExpression");
              }
              isAmbiguousAwait() {
                return this.hasPrecedingLineBreak() || this.match(p2.plusMin) || this.match(p2.parenL) || this.match(p2.bracketL) || this.match(p2.backQuote) || this.match(p2.regexp) || this.match(p2.slash) || this.hasPlugin("v8intrinsic") && this.match(p2.modulo);
              }
              parseYield() {
                const e3 = this.startNode();
                this.expressionScope.recordParameterInitializerError(e3.start, x.YieldInParameter), this.next();
                let t3 = false, r3 = null;
                if (!this.hasPrecedingLineBreak())
                  switch (t3 = this.eat(p2.star), this.state.type) {
                    case p2.semi:
                    case p2.eof:
                    case p2.braceR:
                    case p2.parenR:
                    case p2.bracketR:
                    case p2.braceBarR:
                    case p2.colon:
                    case p2.comma:
                      if (!t3)
                        break;
                    default:
                      r3 = this.parseMaybeAssign();
                  }
                return e3.delegate = t3, e3.argument = r3, this.finishNode(e3, "YieldExpression");
              }
              checkPipelineAtInfixOperator(e3, t3) {
                this.getPluginOption("pipelineOperator", "proposal") === "smart" && e3.type === "SequenceExpression" && this.raise(t3, x.PipelineHeadSequenceExpression);
              }
              parseSmartPipelineBody(e3, t3, r3) {
                return this.checkSmartPipelineBodyEarlyErrors(e3, t3), this.parseSmartPipelineBodyInStyle(e3, t3, r3);
              }
              checkSmartPipelineBodyEarlyErrors(e3, t3) {
                if (this.match(p2.arrow))
                  throw this.raise(this.state.start, x.PipelineBodyNoArrow);
                e3.type === "SequenceExpression" && this.raise(t3, x.PipelineBodySequenceExpression);
              }
              parseSmartPipelineBodyInStyle(e3, t3, r3) {
                const n2 = this.startNodeAt(t3, r3), s3 = this.isSimpleReference(e3);
                return s3 ? n2.callee = e3 : (this.topicReferenceWasUsedInCurrentTopicContext() || this.raise(t3, x.PipelineTopicUnused), n2.expression = e3), this.finishNode(n2, s3 ? "PipelineBareFunction" : "PipelineTopicExpression");
              }
              isSimpleReference(e3) {
                switch (e3.type) {
                  case "MemberExpression":
                    return !e3.computed && this.isSimpleReference(e3.object);
                  case "Identifier":
                    return true;
                  default:
                    return false;
                }
              }
              withTopicPermittingContext(e3) {
                const t3 = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 1, maxTopicIndex: null };
                try {
                  return e3();
                } finally {
                  this.state.topicContext = t3;
                }
              }
              withTopicForbiddingContext(e3) {
                const t3 = this.state.topicContext;
                this.state.topicContext = { maxNumOfResolvableTopics: 0, maxTopicIndex: null };
                try {
                  return e3();
                } finally {
                  this.state.topicContext = t3;
                }
              }
              withSoloAwaitPermittingContext(e3) {
                const t3 = this.state.soloAwait;
                this.state.soloAwait = true;
                try {
                  return e3();
                } finally {
                  this.state.soloAwait = t3;
                }
              }
              allowInAnd(e3) {
                const t3 = this.prodParam.currentFlags();
                if (8 & ~t3) {
                  this.prodParam.enter(8 | t3);
                  try {
                    return e3();
                  } finally {
                    this.prodParam.exit();
                  }
                }
                return e3();
              }
              disallowInAnd(e3) {
                const t3 = this.prodParam.currentFlags();
                if (8 & t3) {
                  this.prodParam.enter(-9 & t3);
                  try {
                    return e3();
                  } finally {
                    this.prodParam.exit();
                  }
                }
                return e3();
              }
              registerTopicReference() {
                this.state.topicContext.maxTopicIndex = 0;
              }
              primaryTopicReferenceIsAllowedInCurrentTopicContext() {
                return this.state.topicContext.maxNumOfResolvableTopics >= 1;
              }
              topicReferenceWasUsedInCurrentTopicContext() {
                return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
              }
              parseFSharpPipelineBody(e3) {
                const t3 = this.state.start, r3 = this.state.startLoc;
                this.state.potentialArrowAt = this.state.start;
                const n2 = this.state.inFSharpPipelineDirectBody;
                this.state.inFSharpPipelineDirectBody = true;
                const s3 = this.parseExprOp(this.parseMaybeUnary(), t3, r3, e3);
                return this.state.inFSharpPipelineDirectBody = n2, s3;
              }
              parseModuleExpression() {
                this.expectPlugin("moduleBlocks");
                const e3 = this.startNode();
                this.next(), this.eat(p2.braceL);
                const t3 = this.initializeScopes(true);
                this.enterInitialScopes();
                const r3 = this.startNode();
                try {
                  e3.body = this.parseProgram(r3, p2.braceR, "module");
                } finally {
                  t3();
                }
                return this.eat(p2.braceR), this.finishNode(e3, "ModuleExpression");
              }
            } {
              parseTopLevel(e3, t3) {
                return e3.program = this.parseProgram(t3), e3.comments = this.state.comments, this.options.tokens && (e3.tokens = function(e4) {
                  for (let t4 = 0; t4 < e4.length; t4++) {
                    const r3 = e4[t4];
                    if (r3.type === p2.privateName) {
                      const { loc: n2, start: s3, value: i2, end: o2 } = r3, a2 = s3 + 1, l2 = new g(n2.start.line, n2.start.column + 1);
                      e4.splice(t4, 1, new Oe({ type: p2.hash, value: "#", start: s3, end: a2, startLoc: n2.start, endLoc: l2 }), new Oe({ type: p2.name, value: i2, start: a2, end: o2, startLoc: l2, endLoc: n2.end }));
                    }
                  }
                  return e4;
                }(this.tokens)), this.finishNode(e3, "File");
              }
              parseProgram(e3, t3 = p2.eof, r3 = this.options.sourceType) {
                if (e3.sourceType = r3, e3.interpreter = this.parseInterpreterDirective(), this.parseBlockBody(e3, true, true, t3), this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0)
                  for (const [e4] of Array.from(this.scope.undefinedExports)) {
                    const t4 = this.scope.undefinedExports.get(e4);
                    this.raise(t4, x.ModuleExportUndefined, e4);
                  }
                return this.finishNode(e3, "Program");
              }
              stmtToDirective(e3) {
                const t3 = e3.expression, r3 = this.startNodeAt(t3.start, t3.loc.start), n2 = this.startNodeAt(e3.start, e3.loc.start), s3 = this.input.slice(t3.start, t3.end), i2 = r3.value = s3.slice(1, -1);
                return this.addExtra(r3, "raw", s3), this.addExtra(r3, "rawValue", i2), n2.value = this.finishNodeAt(r3, "DirectiveLiteral", t3.end, t3.loc.end), this.finishNodeAt(n2, "Directive", e3.end, e3.loc.end);
              }
              parseInterpreterDirective() {
                if (!this.match(p2.interpreterDirective))
                  return null;
                const e3 = this.startNode();
                return e3.value = this.state.value, this.next(), this.finishNode(e3, "InterpreterDirective");
              }
              isLet(e3) {
                return !!this.isContextual("let") && this.isLetKeyword(e3);
              }
              isLetKeyword(e3) {
                const t3 = this.nextTokenStart(), r3 = this.codePointAtPos(t3);
                if (r3 === 92 || r3 === 91)
                  return true;
                if (e3)
                  return false;
                if (r3 === 123)
                  return true;
                if (j(r3)) {
                  Ue.lastIndex = t3;
                  const e4 = Ue.exec(this.input);
                  if (e4 !== null) {
                    const r4 = this.codePointAtPos(t3 + e4[0].length);
                    if (!D(r4) && r4 !== 92)
                      return false;
                  }
                  return true;
                }
                return false;
              }
              parseStatement(e3, t3) {
                return this.match(p2.at) && this.parseDecorators(true), this.parseStatementContent(e3, t3);
              }
              parseStatementContent(e3, t3) {
                let r3 = this.state.type;
                const n2 = this.startNode();
                let s3;
                switch (this.isLet(e3) && (r3 = p2._var, s3 = "let"), r3) {
                  case p2._break:
                  case p2._continue:
                    return this.parseBreakContinueStatement(n2, r3.keyword);
                  case p2._debugger:
                    return this.parseDebuggerStatement(n2);
                  case p2._do:
                    return this.parseDoStatement(n2);
                  case p2._for:
                    return this.parseForStatement(n2);
                  case p2._function:
                    if (this.lookaheadCharCode() === 46)
                      break;
                    return e3 && (this.state.strict ? this.raise(this.state.start, x.StrictFunction) : e3 !== "if" && e3 !== "label" && this.raise(this.state.start, x.SloppyFunction)), this.parseFunctionStatement(n2, false, !e3);
                  case p2._class:
                    return e3 && this.unexpected(), this.parseClass(n2, true);
                  case p2._if:
                    return this.parseIfStatement(n2);
                  case p2._return:
                    return this.parseReturnStatement(n2);
                  case p2._switch:
                    return this.parseSwitchStatement(n2);
                  case p2._throw:
                    return this.parseThrowStatement(n2);
                  case p2._try:
                    return this.parseTryStatement(n2);
                  case p2._const:
                  case p2._var:
                    return s3 = s3 || this.state.value, e3 && s3 !== "var" && this.raise(this.state.start, x.UnexpectedLexicalDeclaration), this.parseVarStatement(n2, s3);
                  case p2._while:
                    return this.parseWhileStatement(n2);
                  case p2._with:
                    return this.parseWithStatement(n2);
                  case p2.braceL:
                    return this.parseBlock();
                  case p2.semi:
                    return this.parseEmptyStatement(n2);
                  case p2._import: {
                    const e4 = this.lookaheadCharCode();
                    if (e4 === 40 || e4 === 46)
                      break;
                  }
                  case p2._export: {
                    let e4;
                    return this.options.allowImportExportEverywhere || t3 || this.raise(this.state.start, x.UnexpectedImportExport), this.next(), r3 === p2._import ? (e4 = this.parseImport(n2), e4.type !== "ImportDeclaration" || e4.importKind && e4.importKind !== "value" || (this.sawUnambiguousESM = true)) : (e4 = this.parseExport(n2), (e4.type !== "ExportNamedDeclaration" || e4.exportKind && e4.exportKind !== "value") && (e4.type !== "ExportAllDeclaration" || e4.exportKind && e4.exportKind !== "value") && e4.type !== "ExportDefaultDeclaration" || (this.sawUnambiguousESM = true)), this.assertModuleNodeAllowed(n2), e4;
                  }
                  default:
                    if (this.isAsyncFunction())
                      return e3 && this.raise(this.state.start, x.AsyncFunctionInSingleStatementContext), this.next(), this.parseFunctionStatement(n2, true, !e3);
                }
                const i2 = this.state.value, o2 = this.parseExpression();
                return r3 === p2.name && o2.type === "Identifier" && this.eat(p2.colon) ? this.parseLabeledStatement(n2, i2, o2, e3) : this.parseExpressionStatement(n2, o2);
              }
              assertModuleNodeAllowed(e3) {
                this.options.allowImportExportEverywhere || this.inModule || this.raise(e3.start, S.ImportOutsideModule);
              }
              takeDecorators(e3) {
                const t3 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                t3.length && (e3.decorators = t3, this.resetStartLocationFromNode(e3, t3[0]), this.state.decoratorStack[this.state.decoratorStack.length - 1] = []);
              }
              canHaveLeadingDecorator() {
                return this.match(p2._class);
              }
              parseDecorators(e3) {
                const t3 = this.state.decoratorStack[this.state.decoratorStack.length - 1];
                for (; this.match(p2.at); ) {
                  const e4 = this.parseDecorator();
                  t3.push(e4);
                }
                if (this.match(p2._export))
                  e3 || this.unexpected(), this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, x.DecoratorExportClass);
                else if (!this.canHaveLeadingDecorator())
                  throw this.raise(this.state.start, x.UnexpectedLeadingDecorator);
              }
              parseDecorator() {
                this.expectOnePlugin(["decorators-legacy", "decorators"]);
                const e3 = this.startNode();
                if (this.next(), this.hasPlugin("decorators")) {
                  this.state.decoratorStack.push([]);
                  const t3 = this.state.start, r3 = this.state.startLoc;
                  let n2;
                  if (this.eat(p2.parenL))
                    n2 = this.parseExpression(), this.expect(p2.parenR);
                  else
                    for (n2 = this.parseIdentifier(false); this.eat(p2.dot); ) {
                      const e4 = this.startNodeAt(t3, r3);
                      e4.object = n2, e4.property = this.parseIdentifier(true), e4.computed = false, n2 = this.finishNode(e4, "MemberExpression");
                    }
                  e3.expression = this.parseMaybeDecoratorArguments(n2), this.state.decoratorStack.pop();
                } else
                  e3.expression = this.parseExprSubscripts();
                return this.finishNode(e3, "Decorator");
              }
              parseMaybeDecoratorArguments(e3) {
                if (this.eat(p2.parenL)) {
                  const t3 = this.startNodeAtNode(e3);
                  return t3.callee = e3, t3.arguments = this.parseCallExpressionArguments(p2.parenR, false), this.toReferencedList(t3.arguments), this.finishNode(t3, "CallExpression");
                }
                return e3;
              }
              parseBreakContinueStatement(e3, t3) {
                const r3 = t3 === "break";
                return this.next(), this.isLineTerminator() ? e3.label = null : (e3.label = this.parseIdentifier(), this.semicolon()), this.verifyBreakContinue(e3, t3), this.finishNode(e3, r3 ? "BreakStatement" : "ContinueStatement");
              }
              verifyBreakContinue(e3, t3) {
                const r3 = t3 === "break";
                let n2;
                for (n2 = 0; n2 < this.state.labels.length; ++n2) {
                  const t4 = this.state.labels[n2];
                  if (e3.label == null || t4.name === e3.label.name) {
                    if (t4.kind != null && (r3 || t4.kind === "loop"))
                      break;
                    if (e3.label && r3)
                      break;
                  }
                }
                n2 === this.state.labels.length && this.raise(e3.start, x.IllegalBreakContinue, t3);
              }
              parseDebuggerStatement(e3) {
                return this.next(), this.semicolon(), this.finishNode(e3, "DebuggerStatement");
              }
              parseHeaderExpression() {
                this.expect(p2.parenL);
                const e3 = this.parseExpression();
                return this.expect(p2.parenR), e3;
              }
              parseDoStatement(e3) {
                return this.next(), this.state.labels.push(Be), e3.body = this.withTopicForbiddingContext(() => this.parseStatement("do")), this.state.labels.pop(), this.expect(p2._while), e3.test = this.parseHeaderExpression(), this.eat(p2.semi), this.finishNode(e3, "DoWhileStatement");
              }
              parseForStatement(e3) {
                this.next(), this.state.labels.push(Be);
                let t3 = -1;
                if (this.isAwaitAllowed() && this.eatContextual("await") && (t3 = this.state.lastTokStart), this.scope.enter(0), this.expect(p2.parenL), this.match(p2.semi))
                  return t3 > -1 && this.unexpected(t3), this.parseFor(e3, null);
                const r3 = this.isContextual("let"), n2 = r3 && this.isLetKeyword();
                if (this.match(p2._var) || this.match(p2._const) || n2) {
                  const r4 = this.startNode(), s4 = n2 ? "let" : this.state.value;
                  return this.next(), this.parseVar(r4, true, s4), this.finishNode(r4, "VariableDeclaration"), (this.match(p2._in) || this.isContextual("of")) && r4.declarations.length === 1 ? this.parseForIn(e3, r4, t3) : (t3 > -1 && this.unexpected(t3), this.parseFor(e3, r4));
                }
                const s3 = this.match(p2.name) && !this.state.containsEsc, i2 = new De(), o2 = this.parseExpression(true, i2), a2 = this.isContextual("of");
                if (a2 && (r3 ? this.raise(o2.start, x.ForOfLet) : t3 === -1 && s3 && o2.type === "Identifier" && o2.name === "async" && this.raise(o2.start, x.ForOfAsync)), a2 || this.match(p2._in)) {
                  this.toAssignable(o2, true);
                  const r4 = a2 ? "for-of statement" : "for-in statement";
                  return this.checkLVal(o2, r4), this.parseForIn(e3, o2, t3);
                }
                return this.checkExpressionErrors(i2, true), t3 > -1 && this.unexpected(t3), this.parseFor(e3, o2);
              }
              parseFunctionStatement(e3, t3, r3) {
                return this.next(), this.parseFunction(e3, 1 | (r3 ? 0 : 2), t3);
              }
              parseIfStatement(e3) {
                return this.next(), e3.test = this.parseHeaderExpression(), e3.consequent = this.parseStatement("if"), e3.alternate = this.eat(p2._else) ? this.parseStatement("if") : null, this.finishNode(e3, "IfStatement");
              }
              parseReturnStatement(e3) {
                return this.prodParam.hasReturn || this.options.allowReturnOutsideFunction || this.raise(this.state.start, x.IllegalReturn), this.next(), this.isLineTerminator() ? e3.argument = null : (e3.argument = this.parseExpression(), this.semicolon()), this.finishNode(e3, "ReturnStatement");
              }
              parseSwitchStatement(e3) {
                this.next(), e3.discriminant = this.parseHeaderExpression();
                const t3 = e3.cases = [];
                let r3, n2;
                for (this.expect(p2.braceL), this.state.labels.push(Re), this.scope.enter(0); !this.match(p2.braceR); )
                  if (this.match(p2._case) || this.match(p2._default)) {
                    const e4 = this.match(p2._case);
                    r3 && this.finishNode(r3, "SwitchCase"), t3.push(r3 = this.startNode()), r3.consequent = [], this.next(), e4 ? r3.test = this.parseExpression() : (n2 && this.raise(this.state.lastTokStart, x.MultipleDefaultsInSwitch), n2 = true, r3.test = null), this.expect(p2.colon);
                  } else
                    r3 ? r3.consequent.push(this.parseStatement(null)) : this.unexpected();
                return this.scope.exit(), r3 && this.finishNode(r3, "SwitchCase"), this.next(), this.state.labels.pop(), this.finishNode(e3, "SwitchStatement");
              }
              parseThrowStatement(e3) {
                return this.next(), this.hasPrecedingLineBreak() && this.raise(this.state.lastTokEnd, x.NewlineAfterThrow), e3.argument = this.parseExpression(), this.semicolon(), this.finishNode(e3, "ThrowStatement");
              }
              parseCatchClauseParam() {
                const e3 = this.parseBindingAtom(), t3 = e3.type === "Identifier";
                return this.scope.enter(t3 ? 8 : 0), this.checkLVal(e3, "catch clause", 9), e3;
              }
              parseTryStatement(e3) {
                if (this.next(), e3.block = this.parseBlock(), e3.handler = null, this.match(p2._catch)) {
                  const t3 = this.startNode();
                  this.next(), this.match(p2.parenL) ? (this.expect(p2.parenL), t3.param = this.parseCatchClauseParam(), this.expect(p2.parenR)) : (t3.param = null, this.scope.enter(0)), t3.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false)), this.scope.exit(), e3.handler = this.finishNode(t3, "CatchClause");
                }
                return e3.finalizer = this.eat(p2._finally) ? this.parseBlock() : null, e3.handler || e3.finalizer || this.raise(e3.start, x.NoCatchOrFinally), this.finishNode(e3, "TryStatement");
              }
              parseVarStatement(e3, t3) {
                return this.next(), this.parseVar(e3, false, t3), this.semicolon(), this.finishNode(e3, "VariableDeclaration");
              }
              parseWhileStatement(e3) {
                return this.next(), e3.test = this.parseHeaderExpression(), this.state.labels.push(Be), e3.body = this.withTopicForbiddingContext(() => this.parseStatement("while")), this.state.labels.pop(), this.finishNode(e3, "WhileStatement");
              }
              parseWithStatement(e3) {
                return this.state.strict && this.raise(this.state.start, x.StrictWith), this.next(), e3.object = this.parseHeaderExpression(), e3.body = this.withTopicForbiddingContext(() => this.parseStatement("with")), this.finishNode(e3, "WithStatement");
              }
              parseEmptyStatement(e3) {
                return this.next(), this.finishNode(e3, "EmptyStatement");
              }
              parseLabeledStatement(e3, t3, r3, n2) {
                for (const e4 of this.state.labels)
                  e4.name === t3 && this.raise(r3.start, x.LabelRedeclaration, t3);
                const s3 = this.state.type.isLoop ? "loop" : this.match(p2._switch) ? "switch" : null;
                for (let t4 = this.state.labels.length - 1; t4 >= 0; t4--) {
                  const r4 = this.state.labels[t4];
                  if (r4.statementStart !== e3.start)
                    break;
                  r4.statementStart = this.state.start, r4.kind = s3;
                }
                return this.state.labels.push({ name: t3, kind: s3, statementStart: this.state.start }), e3.body = this.parseStatement(n2 ? n2.indexOf("label") === -1 ? n2 + "label" : n2 : "label"), this.state.labels.pop(), e3.label = r3, this.finishNode(e3, "LabeledStatement");
              }
              parseExpressionStatement(e3, t3) {
                return e3.expression = t3, this.semicolon(), this.finishNode(e3, "ExpressionStatement");
              }
              parseBlock(e3 = false, t3 = true, r3) {
                const n2 = this.startNode();
                return e3 && this.state.strictErrors.clear(), this.expect(p2.braceL), t3 && this.scope.enter(0), this.parseBlockBody(n2, e3, false, p2.braceR, r3), t3 && this.scope.exit(), this.finishNode(n2, "BlockStatement");
              }
              isValidDirective(e3) {
                return e3.type === "ExpressionStatement" && e3.expression.type === "StringLiteral" && !e3.expression.extra.parenthesized;
              }
              parseBlockBody(e3, t3, r3, n2, s3) {
                const i2 = e3.body = [], o2 = e3.directives = [];
                this.parseBlockOrModuleBlockBody(i2, t3 ? o2 : void 0, r3, n2, s3);
              }
              parseBlockOrModuleBlockBody(e3, t3, r3, n2, s3) {
                const i2 = this.state.strict;
                let o2 = false, a2 = false;
                for (; !this.match(n2); ) {
                  const n3 = this.parseStatement(null, r3);
                  if (t3 && !a2) {
                    if (this.isValidDirective(n3)) {
                      const e4 = this.stmtToDirective(n3);
                      t3.push(e4), o2 || e4.value.value !== "use strict" || (o2 = true, this.setStrict(true));
                      continue;
                    }
                    a2 = true, this.state.strictErrors.clear();
                  }
                  e3.push(n3);
                }
                s3 && s3.call(this, o2), i2 || this.setStrict(false), this.next();
              }
              parseFor(e3, t3) {
                return e3.init = t3, this.semicolon(false), e3.test = this.match(p2.semi) ? null : this.parseExpression(), this.semicolon(false), e3.update = this.match(p2.parenR) ? null : this.parseExpression(), this.expect(p2.parenR), e3.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, "ForStatement");
              }
              parseForIn(e3, t3, r3) {
                const n2 = this.match(p2._in);
                return this.next(), n2 ? r3 > -1 && this.unexpected(r3) : e3.await = r3 > -1, t3.type !== "VariableDeclaration" || t3.declarations[0].init == null || n2 && !this.state.strict && t3.kind === "var" && t3.declarations[0].id.type === "Identifier" ? t3.type === "AssignmentPattern" && this.raise(t3.start, x.InvalidLhs, "for-loop") : this.raise(t3.start, x.ForInOfLoopInitializer, n2 ? "for-in" : "for-of"), e3.left = t3, e3.right = n2 ? this.parseExpression() : this.parseMaybeAssignAllowIn(), this.expect(p2.parenR), e3.body = this.withTopicForbiddingContext(() => this.parseStatement("for")), this.scope.exit(), this.state.labels.pop(), this.finishNode(e3, n2 ? "ForInStatement" : "ForOfStatement");
              }
              parseVar(e3, t3, r3) {
                const n2 = e3.declarations = [], s3 = this.hasPlugin("typescript");
                for (e3.kind = r3; ; ) {
                  const e4 = this.startNode();
                  if (this.parseVarId(e4, r3), this.eat(p2.eq) ? e4.init = t3 ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn() : (r3 !== "const" || this.match(p2._in) || this.isContextual("of") ? e4.id.type === "Identifier" || t3 && (this.match(p2._in) || this.isContextual("of")) || this.raise(this.state.lastTokEnd, x.DeclarationMissingInitializer, "Complex binding patterns") : s3 || this.raise(this.state.lastTokEnd, x.DeclarationMissingInitializer, "Const declarations"), e4.init = null), n2.push(this.finishNode(e4, "VariableDeclarator")), !this.eat(p2.comma))
                    break;
                }
                return e3;
              }
              parseVarId(e3, t3) {
                e3.id = this.parseBindingAtom(), this.checkLVal(e3.id, "variable declaration", t3 === "var" ? 5 : 9, void 0, t3 !== "var");
              }
              parseFunction(e3, t3 = 0, r3 = false) {
                const n2 = 1 & t3, s3 = 2 & t3, i2 = !(!n2 || 4 & t3);
                this.initFunction(e3, r3), this.match(p2.star) && s3 && this.raise(this.state.start, x.GeneratorInSingleStatementContext), e3.generator = this.eat(p2.star), n2 && (e3.id = this.parseFunctionId(i2));
                const o2 = this.state.maybeInArrowParameters;
                return this.state.maybeInArrowParameters = false, this.scope.enter(2), this.prodParam.enter(ue(r3, e3.generator)), n2 || (e3.id = this.parseFunctionId()), this.parseFunctionParams(e3, false), this.withTopicForbiddingContext(() => {
                  this.parseFunctionBodyAndFinish(e3, n2 ? "FunctionDeclaration" : "FunctionExpression");
                }), this.prodParam.exit(), this.scope.exit(), n2 && !s3 && this.registerFunctionStatementId(e3), this.state.maybeInArrowParameters = o2, e3;
              }
              parseFunctionId(e3) {
                return e3 || this.match(p2.name) ? this.parseIdentifier() : null;
              }
              parseFunctionParams(e3, t3) {
                this.expect(p2.parenL), this.expressionScope.enter(new ke(3)), e3.params = this.parseBindingList(p2.parenR, 41, false, t3), this.expressionScope.exit();
              }
              registerFunctionStatementId(e3) {
                e3.id && this.scope.declareName(e3.id.name, this.state.strict || e3.generator || e3.async ? this.scope.treatFunctionsAsVar ? 5 : 9 : 17, e3.id.start);
              }
              parseClass(e3, t3, r3) {
                this.next(), this.takeDecorators(e3);
                const n2 = this.state.strict;
                return this.state.strict = true, this.parseClassId(e3, t3, r3), this.parseClassSuper(e3), e3.body = this.parseClassBody(!!e3.superClass, n2), this.finishNode(e3, t3 ? "ClassDeclaration" : "ClassExpression");
              }
              isClassProperty() {
                return this.match(p2.eq) || this.match(p2.semi) || this.match(p2.braceR);
              }
              isClassMethod() {
                return this.match(p2.parenL);
              }
              isNonstaticConstructor(e3) {
                return !(e3.computed || e3.static || e3.key.name !== "constructor" && e3.key.value !== "constructor");
              }
              parseClassBody(e3, t3) {
                this.classScope.enter();
                const r3 = { hadConstructor: false, hadSuperClass: e3 };
                let n2 = [];
                const s3 = this.startNode();
                if (s3.body = [], this.expect(p2.braceL), this.withTopicForbiddingContext(() => {
                  for (; !this.match(p2.braceR); ) {
                    if (this.eat(p2.semi)) {
                      if (n2.length > 0)
                        throw this.raise(this.state.lastTokEnd, x.DecoratorSemicolon);
                      continue;
                    }
                    if (this.match(p2.at)) {
                      n2.push(this.parseDecorator());
                      continue;
                    }
                    const e4 = this.startNode();
                    n2.length && (e4.decorators = n2, this.resetStartLocationFromNode(e4, n2[0]), n2 = []), this.parseClassMember(s3, e4, r3), e4.kind === "constructor" && e4.decorators && e4.decorators.length > 0 && this.raise(e4.start, x.DecoratorConstructor);
                  }
                }), this.state.strict = t3, this.next(), n2.length)
                  throw this.raise(this.state.start, x.TrailingDecorator);
                return this.classScope.exit(), this.finishNode(s3, "ClassBody");
              }
              parseClassMemberFromModifier(e3, t3) {
                const r3 = this.parseIdentifier(true);
                if (this.isClassMethod()) {
                  const n2 = t3;
                  return n2.kind = "method", n2.computed = false, n2.key = r3, n2.static = false, this.pushClassMethod(e3, n2, false, false, false, false), true;
                }
                if (this.isClassProperty()) {
                  const n2 = t3;
                  return n2.computed = false, n2.key = r3, n2.static = false, e3.body.push(this.parseClassProperty(n2)), true;
                }
                return false;
              }
              parseClassMember(e3, t3, r3) {
                const n2 = this.isContextual("static");
                if (n2) {
                  if (this.parseClassMemberFromModifier(e3, t3))
                    return;
                  if (this.eat(p2.braceL))
                    return void this.parseClassStaticBlock(e3, t3);
                }
                this.parseClassMemberWithIsStatic(e3, t3, r3, n2);
              }
              parseClassMemberWithIsStatic(e3, t3, r3, n2) {
                const s3 = t3, i2 = t3, o2 = t3, a2 = t3, l2 = s3, c4 = s3;
                if (t3.static = n2, this.eat(p2.star)) {
                  l2.kind = "method";
                  const t4 = this.match(p2.privateName);
                  return this.parseClassElementName(l2), t4 ? void this.pushClassPrivateMethod(e3, i2, true, false) : (this.isNonstaticConstructor(s3) && this.raise(s3.key.start, x.ConstructorIsGenerator), void this.pushClassMethod(e3, s3, true, false, false, false));
                }
                const u2 = this.state.containsEsc, f2 = this.match(p2.privateName), d2 = this.parseClassElementName(t3), h4 = d2.type === "Identifier", m2 = this.state.start;
                if (this.parsePostMemberNameModifiers(c4), this.isClassMethod()) {
                  if (l2.kind = "method", f2)
                    return void this.pushClassPrivateMethod(e3, i2, false, false);
                  const n3 = this.isNonstaticConstructor(s3);
                  let o3 = false;
                  n3 && (s3.kind = "constructor", r3.hadConstructor && !this.hasPlugin("typescript") && this.raise(d2.start, x.DuplicateConstructor), n3 && this.hasPlugin("typescript") && t3.override && this.raise(d2.start, x.OverrideOnConstructor), r3.hadConstructor = true, o3 = r3.hadSuperClass), this.pushClassMethod(e3, s3, false, false, n3, o3);
                } else if (this.isClassProperty())
                  f2 ? this.pushClassPrivateProperty(e3, a2) : this.pushClassProperty(e3, o2);
                else if (!h4 || d2.name !== "async" || u2 || this.isLineTerminator())
                  if (!h4 || d2.name !== "get" && d2.name !== "set" || u2 || this.match(p2.star) && this.isLineTerminator())
                    this.isLineTerminator() ? f2 ? this.pushClassPrivateProperty(e3, a2) : this.pushClassProperty(e3, o2) : this.unexpected();
                  else {
                    l2.kind = d2.name;
                    const t4 = this.match(p2.privateName);
                    this.parseClassElementName(s3), t4 ? this.pushClassPrivateMethod(e3, i2, false, false) : (this.isNonstaticConstructor(s3) && this.raise(s3.key.start, x.ConstructorIsAccessor), this.pushClassMethod(e3, s3, false, false, false, false)), this.checkGetterSetterParams(s3);
                  }
                else {
                  const t4 = this.eat(p2.star);
                  c4.optional && this.unexpected(m2), l2.kind = "method";
                  const r4 = this.match(p2.privateName);
                  this.parseClassElementName(l2), this.parsePostMemberNameModifiers(c4), r4 ? this.pushClassPrivateMethod(e3, i2, t4, true) : (this.isNonstaticConstructor(s3) && this.raise(s3.key.start, x.ConstructorIsAsync), this.pushClassMethod(e3, s3, t4, true, false, false));
                }
              }
              parseClassElementName(e3) {
                const { type: t3, value: r3, start: n2 } = this.state;
                return t3 !== p2.name && t3 !== p2.string || !e3.static || r3 !== "prototype" || this.raise(n2, x.StaticPrototype), t3 === p2.privateName && r3 === "constructor" && this.raise(n2, x.ConstructorClassPrivateField), this.parsePropertyName(e3, true);
              }
              parseClassStaticBlock(e3, t3) {
                var r3;
                this.expectPlugin("classStaticBlock", t3.start), this.scope.enter(208);
                const n2 = this.state.labels;
                this.state.labels = [], this.prodParam.enter(0);
                const s3 = t3.body = [];
                this.parseBlockOrModuleBlockBody(s3, void 0, false, p2.braceR), this.prodParam.exit(), this.scope.exit(), this.state.labels = n2, e3.body.push(this.finishNode(t3, "StaticBlock")), (r3 = t3.decorators) != null && r3.length && this.raise(t3.start, x.DecoratorStaticBlock);
              }
              pushClassProperty(e3, t3) {
                t3.computed || t3.key.name !== "constructor" && t3.key.value !== "constructor" || this.raise(t3.key.start, x.ConstructorClassField), e3.body.push(this.parseClassProperty(t3));
              }
              pushClassPrivateProperty(e3, t3) {
                const r3 = this.parseClassPrivateProperty(t3);
                e3.body.push(r3), this.classScope.declarePrivateName(this.getPrivateNameSV(r3.key), 0, r3.key.start);
              }
              pushClassMethod(e3, t3, r3, n2, s3, i2) {
                e3.body.push(this.parseMethod(t3, r3, n2, s3, i2, "ClassMethod", true));
              }
              pushClassPrivateMethod(e3, t3, r3, n2) {
                const s3 = this.parseMethod(t3, r3, n2, false, false, "ClassPrivateMethod", true);
                e3.body.push(s3);
                const i2 = s3.kind === "get" ? s3.static ? 6 : 2 : s3.kind === "set" ? s3.static ? 5 : 1 : 0;
                this.classScope.declarePrivateName(this.getPrivateNameSV(s3.key), i2, s3.key.start);
              }
              parsePostMemberNameModifiers(e3) {
              }
              parseClassPrivateProperty(e3) {
                return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassPrivateProperty");
              }
              parseClassProperty(e3) {
                return this.parseInitializer(e3), this.semicolon(), this.finishNode(e3, "ClassProperty");
              }
              parseInitializer(e3) {
                this.scope.enter(80), this.expressionScope.enter(je()), this.prodParam.enter(0), e3.value = this.eat(p2.eq) ? this.parseMaybeAssignAllowIn() : null, this.expressionScope.exit(), this.prodParam.exit(), this.scope.exit();
              }
              parseClassId(e3, t3, r3, n2 = 139) {
                this.match(p2.name) ? (e3.id = this.parseIdentifier(), t3 && this.checkLVal(e3.id, "class name", n2)) : r3 || !t3 ? e3.id = null : this.unexpected(null, x.MissingClassName);
              }
              parseClassSuper(e3) {
                e3.superClass = this.eat(p2._extends) ? this.parseExprSubscripts() : null;
              }
              parseExport(e3) {
                const t3 = this.maybeParseExportDefaultSpecifier(e3), r3 = !t3 || this.eat(p2.comma), n2 = r3 && this.eatExportStar(e3), s3 = n2 && this.maybeParseExportNamespaceSpecifier(e3), i2 = r3 && (!s3 || this.eat(p2.comma)), o2 = t3 || n2;
                if (n2 && !s3)
                  return t3 && this.unexpected(), this.parseExportFrom(e3, true), this.finishNode(e3, "ExportAllDeclaration");
                const a2 = this.maybeParseExportNamedSpecifiers(e3);
                if (t3 && r3 && !n2 && !a2 || s3 && i2 && !a2)
                  throw this.unexpected(null, p2.braceL);
                let l2;
                if (o2 || a2 ? (l2 = false, this.parseExportFrom(e3, o2)) : l2 = this.maybeParseExportDeclaration(e3), o2 || a2 || l2)
                  return this.checkExport(e3, true, false, !!e3.source), this.finishNode(e3, "ExportNamedDeclaration");
                if (this.eat(p2._default))
                  return e3.declaration = this.parseExportDefaultExpression(), this.checkExport(e3, true, true), this.finishNode(e3, "ExportDefaultDeclaration");
                throw this.unexpected(null, p2.braceL);
              }
              eatExportStar(e3) {
                return this.eat(p2.star);
              }
              maybeParseExportDefaultSpecifier(e3) {
                if (this.isExportDefaultSpecifier()) {
                  this.expectPlugin("exportDefaultFrom");
                  const t3 = this.startNode();
                  return t3.exported = this.parseIdentifier(true), e3.specifiers = [this.finishNode(t3, "ExportDefaultSpecifier")], true;
                }
                return false;
              }
              maybeParseExportNamespaceSpecifier(e3) {
                if (this.isContextual("as")) {
                  e3.specifiers || (e3.specifiers = []);
                  const t3 = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
                  return this.next(), t3.exported = this.parseModuleExportName(), e3.specifiers.push(this.finishNode(t3, "ExportNamespaceSpecifier")), true;
                }
                return false;
              }
              maybeParseExportNamedSpecifiers(e3) {
                return !!this.match(p2.braceL) && (e3.specifiers || (e3.specifiers = []), e3.specifiers.push(...this.parseExportSpecifiers()), e3.source = null, e3.declaration = null, true);
              }
              maybeParseExportDeclaration(e3) {
                return !!this.shouldParseExportDeclaration() && (e3.specifiers = [], e3.source = null, e3.declaration = this.parseExportDeclaration(e3), true);
              }
              isAsyncFunction() {
                if (!this.isContextual("async"))
                  return false;
                const e3 = this.nextTokenStart();
                return !f.test(this.input.slice(this.state.pos, e3)) && this.isUnparsedContextual(e3, "function");
              }
              parseExportDefaultExpression() {
                const e3 = this.startNode(), t3 = this.isAsyncFunction();
                if (this.match(p2._function) || t3)
                  return this.next(), t3 && this.next(), this.parseFunction(e3, 5, t3);
                if (this.match(p2._class))
                  return this.parseClass(e3, true, true);
                if (this.match(p2.at))
                  return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") && this.raise(this.state.start, x.DecoratorBeforeExport), this.parseDecorators(false), this.parseClass(e3, true, true);
                if (this.match(p2._const) || this.match(p2._var) || this.isLet())
                  throw this.raise(this.state.start, x.UnsupportedDefaultExport);
                {
                  const e4 = this.parseMaybeAssignAllowIn();
                  return this.semicolon(), e4;
                }
              }
              parseExportDeclaration(e3) {
                return this.parseStatement(null);
              }
              isExportDefaultSpecifier() {
                if (this.match(p2.name)) {
                  const e4 = this.state.value;
                  if (e4 === "async" && !this.state.containsEsc || e4 === "let")
                    return false;
                  if ((e4 === "type" || e4 === "interface") && !this.state.containsEsc) {
                    const e5 = this.lookahead();
                    if (e5.type === p2.name && e5.value !== "from" || e5.type === p2.braceL)
                      return this.expectOnePlugin(["flow", "typescript"]), false;
                  }
                } else if (!this.match(p2._default))
                  return false;
                const e3 = this.nextTokenStart(), t3 = this.isUnparsedContextual(e3, "from");
                if (this.input.charCodeAt(e3) === 44 || this.match(p2.name) && t3)
                  return true;
                if (this.match(p2._default) && t3) {
                  const t4 = this.input.charCodeAt(this.nextTokenStartSince(e3 + 4));
                  return t4 === 34 || t4 === 39;
                }
                return false;
              }
              parseExportFrom(e3, t3) {
                if (this.eatContextual("from")) {
                  e3.source = this.parseImportSource(), this.checkExport(e3);
                  const t4 = this.maybeParseImportAssertions();
                  t4 && (e3.assertions = t4);
                } else
                  t3 ? this.unexpected() : e3.source = null;
                this.semicolon();
              }
              shouldParseExportDeclaration() {
                if (this.match(p2.at) && (this.expectOnePlugin(["decorators", "decorators-legacy"]), this.hasPlugin("decorators"))) {
                  if (!this.getPluginOption("decorators", "decoratorsBeforeExport"))
                    return true;
                  this.unexpected(this.state.start, x.DecoratorBeforeExport);
                }
                return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
              }
              checkExport(e3, t3, r3, n2) {
                if (t3) {
                  if (r3) {
                    if (this.checkDuplicateExports(e3, "default"), this.hasPlugin("exportDefaultFrom")) {
                      var s3;
                      const t4 = e3.declaration;
                      t4.type !== "Identifier" || t4.name !== "from" || t4.end - t4.start != 4 || (s3 = t4.extra) != null && s3.parenthesized || this.raise(t4.start, x.ExportDefaultFromAsIdentifier);
                    }
                  } else if (e3.specifiers && e3.specifiers.length)
                    for (const t4 of e3.specifiers) {
                      const { exported: e4 } = t4, r4 = e4.type === "Identifier" ? e4.name : e4.value;
                      if (this.checkDuplicateExports(t4, r4), !n2 && t4.local) {
                        const { local: e5 } = t4;
                        e5.type !== "Identifier" ? this.raise(t4.start, x.ExportBindingIsString, e5.value, r4) : (this.checkReservedWord(e5.name, e5.start, true, false), this.scope.checkLocalExport(e5));
                      }
                    }
                  else if (e3.declaration) {
                    if (e3.declaration.type === "FunctionDeclaration" || e3.declaration.type === "ClassDeclaration") {
                      const t4 = e3.declaration.id;
                      if (!t4)
                        throw new Error("Assertion failure");
                      this.checkDuplicateExports(e3, t4.name);
                    } else if (e3.declaration.type === "VariableDeclaration")
                      for (const t4 of e3.declaration.declarations)
                        this.checkDeclaration(t4.id);
                  }
                }
                if (this.state.decoratorStack[this.state.decoratorStack.length - 1].length)
                  throw this.raise(e3.start, x.UnsupportedDecoratorExport);
              }
              checkDeclaration(e3) {
                if (e3.type === "Identifier")
                  this.checkDuplicateExports(e3, e3.name);
                else if (e3.type === "ObjectPattern")
                  for (const t3 of e3.properties)
                    this.checkDeclaration(t3);
                else if (e3.type === "ArrayPattern")
                  for (const t3 of e3.elements)
                    t3 && this.checkDeclaration(t3);
                else
                  e3.type === "ObjectProperty" ? this.checkDeclaration(e3.value) : e3.type === "RestElement" ? this.checkDeclaration(e3.argument) : e3.type === "AssignmentPattern" && this.checkDeclaration(e3.left);
              }
              checkDuplicateExports(e3, t3) {
                this.exportedIdentifiers.has(t3) && this.raise(e3.start, t3 === "default" ? x.DuplicateDefaultExport : x.DuplicateExport, t3), this.exportedIdentifiers.add(t3);
              }
              parseExportSpecifiers() {
                const e3 = [];
                let t3 = true;
                for (this.expect(p2.braceL); !this.eat(p2.braceR); ) {
                  if (t3)
                    t3 = false;
                  else if (this.expect(p2.comma), this.eat(p2.braceR))
                    break;
                  const r3 = this.startNode();
                  r3.local = this.parseModuleExportName(), r3.exported = this.eatContextual("as") ? this.parseModuleExportName() : r3.local.__clone(), e3.push(this.finishNode(r3, "ExportSpecifier"));
                }
                return e3;
              }
              parseModuleExportName() {
                if (this.match(p2.string)) {
                  const e3 = this.parseStringLiteral(this.state.value), t3 = e3.value.match(Fe);
                  return t3 && this.raise(e3.start, x.ModuleExportNameHasLoneSurrogate, t3[0].charCodeAt(0).toString(16)), e3;
                }
                return this.parseIdentifier(true);
              }
              parseImport(e3) {
                if (e3.specifiers = [], !this.match(p2.string)) {
                  const t4 = !this.maybeParseDefaultImportSpecifier(e3) || this.eat(p2.comma), r3 = t4 && this.maybeParseStarImportSpecifier(e3);
                  t4 && !r3 && this.parseNamedImportSpecifiers(e3), this.expectContextual("from");
                }
                e3.source = this.parseImportSource();
                const t3 = this.maybeParseImportAssertions();
                if (t3)
                  e3.assertions = t3;
                else {
                  const t4 = this.maybeParseModuleAttributes();
                  t4 && (e3.attributes = t4);
                }
                return this.semicolon(), this.finishNode(e3, "ImportDeclaration");
              }
              parseImportSource() {
                return this.match(p2.string) || this.unexpected(), this.parseExprAtom();
              }
              shouldParseDefaultImport(e3) {
                return this.match(p2.name);
              }
              parseImportSpecifierLocal(e3, t3, r3, n2) {
                t3.local = this.parseIdentifier(), this.checkLVal(t3.local, n2, 9), e3.specifiers.push(this.finishNode(t3, r3));
              }
              parseAssertEntries() {
                const e3 = [], t3 = new Set();
                do {
                  if (this.match(p2.braceR))
                    break;
                  const r3 = this.startNode(), n2 = this.state.value;
                  if (t3.has(n2) && this.raise(this.state.start, x.ModuleAttributesWithDuplicateKeys, n2), t3.add(n2), this.match(p2.string) ? r3.key = this.parseStringLiteral(n2) : r3.key = this.parseIdentifier(true), this.expect(p2.colon), !this.match(p2.string))
                    throw this.unexpected(this.state.start, x.ModuleAttributeInvalidValue);
                  r3.value = this.parseStringLiteral(this.state.value), this.finishNode(r3, "ImportAttribute"), e3.push(r3);
                } while (this.eat(p2.comma));
                return e3;
              }
              maybeParseModuleAttributes() {
                if (!this.match(p2._with) || this.hasPrecedingLineBreak())
                  return this.hasPlugin("moduleAttributes") ? [] : null;
                this.expectPlugin("moduleAttributes"), this.next();
                const e3 = [], t3 = new Set();
                do {
                  const r3 = this.startNode();
                  if (r3.key = this.parseIdentifier(true), r3.key.name !== "type" && this.raise(r3.key.start, x.ModuleAttributeDifferentFromType, r3.key.name), t3.has(r3.key.name) && this.raise(r3.key.start, x.ModuleAttributesWithDuplicateKeys, r3.key.name), t3.add(r3.key.name), this.expect(p2.colon), !this.match(p2.string))
                    throw this.unexpected(this.state.start, x.ModuleAttributeInvalidValue);
                  r3.value = this.parseStringLiteral(this.state.value), this.finishNode(r3, "ImportAttribute"), e3.push(r3);
                } while (this.eat(p2.comma));
                return e3;
              }
              maybeParseImportAssertions() {
                if (!this.isContextual("assert") || this.hasPrecedingLineBreak())
                  return this.hasPlugin("importAssertions") ? [] : null;
                this.expectPlugin("importAssertions"), this.next(), this.eat(p2.braceL);
                const e3 = this.parseAssertEntries();
                return this.eat(p2.braceR), e3;
              }
              maybeParseDefaultImportSpecifier(e3) {
                return !!this.shouldParseDefaultImport(e3) && (this.parseImportSpecifierLocal(e3, this.startNode(), "ImportDefaultSpecifier", "default import specifier"), true);
              }
              maybeParseStarImportSpecifier(e3) {
                if (this.match(p2.star)) {
                  const t3 = this.startNode();
                  return this.next(), this.expectContextual("as"), this.parseImportSpecifierLocal(e3, t3, "ImportNamespaceSpecifier", "import namespace specifier"), true;
                }
                return false;
              }
              parseNamedImportSpecifiers(e3) {
                let t3 = true;
                for (this.expect(p2.braceL); !this.eat(p2.braceR); ) {
                  if (t3)
                    t3 = false;
                  else {
                    if (this.eat(p2.colon))
                      throw this.raise(this.state.start, x.DestructureNamedImport);
                    if (this.expect(p2.comma), this.eat(p2.braceR))
                      break;
                  }
                  this.parseImportSpecifier(e3);
                }
              }
              parseImportSpecifier(e3) {
                const t3 = this.startNode(), r3 = this.match(p2.string);
                if (t3.imported = this.parseModuleExportName(), this.eatContextual("as"))
                  t3.local = this.parseIdentifier();
                else {
                  const { imported: e4 } = t3;
                  if (r3)
                    throw this.raise(t3.start, x.ImportBindingIsString, e4.value);
                  this.checkReservedWord(e4.name, t3.start, true, true), t3.local = e4.__clone();
                }
                this.checkLVal(t3.local, "import specifier", 9), e3.specifiers.push(this.finishNode(t3, "ImportSpecifier"));
              }
              isThisParam(e3) {
                return e3.type === "Identifier" && e3.name === "this";
              }
            } {
              constructor(e3, t3) {
                super(e3 = function(e4) {
                  const t4 = {};
                  for (const r3 of Object.keys(Se))
                    t4[r3] = e4 && e4[r3] != null ? e4[r3] : Se[r3];
                  return t4;
                }(e3), t3), this.options = e3, this.initializeScopes(), this.plugins = function(e4) {
                  const t4 = new Map();
                  for (const r3 of e4) {
                    const [e5, n2] = Array.isArray(r3) ? r3 : [r3, {}];
                    t4.has(e5) || t4.set(e5, n2 || {});
                  }
                  return t4;
                }(this.options.plugins), this.filename = e3.sourceFilename;
              }
              getScopeHandler() {
                return K;
              }
              parse() {
                this.enterInitialScopes();
                const e3 = this.startNode(), t3 = this.startNode();
                return this.nextToken(), e3.errors = null, this.parseTopLevel(e3, t3), e3.errors = this.state.errors, e3;
              }
            }
            function qe(e3, t3) {
              let r3 = $e;
              return e3 != null && e3.plugins && (function(e4) {
                if (ye(e4, "decorators")) {
                  if (ye(e4, "decorators-legacy"))
                    throw new Error("Cannot use the decorators and decorators-legacy plugin together");
                  const t4 = ge(e4, "decorators", "decoratorsBeforeExport");
                  if (t4 == null)
                    throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option, whose value must be a boolean. If you are migrating from Babylon/Babel 6 or want to use the old decorators proposal, you should use the 'decorators-legacy' plugin instead of 'decorators'.");
                  if (typeof t4 != "boolean")
                    throw new Error("'decoratorsBeforeExport' must be a boolean.");
                }
                if (ye(e4, "flow") && ye(e4, "typescript"))
                  throw new Error("Cannot combine flow and typescript plugins.");
                if (ye(e4, "placeholders") && ye(e4, "v8intrinsic"))
                  throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
                if (ye(e4, "pipelineOperator") && !be.includes(ge(e4, "pipelineOperator", "proposal")))
                  throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + be.map((e5) => `'${e5}'`).join(", "));
                if (ye(e4, "moduleAttributes")) {
                  if (ye(e4, "importAssertions"))
                    throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
                  if (ge(e4, "moduleAttributes", "version") !== "may-2020")
                    throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
                }
                if (ye(e4, "recordAndTuple") && !ve.includes(ge(e4, "recordAndTuple", "syntaxType")))
                  throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + ve.map((e5) => `'${e5}'`).join(", "));
                if (ye(e4, "asyncDoExpressions") && !ye(e4, "doExpressions")) {
                  const e5 = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
                  throw e5.missingPlugins = "doExpressions", e5;
                }
              }(e3.plugins), r3 = function(e4) {
                const t4 = xe.filter((t5) => ye(e4, t5)), r4 = t4.join("/");
                let n2 = Ve[r4];
                if (!n2) {
                  n2 = $e;
                  for (const e5 of t4)
                    n2 = Ee[e5](n2);
                  Ve[r4] = n2;
                }
                return n2;
              }(e3.plugins)), new r3(e3, t3);
            }
            const Ve = {};
            t2.parse = function(e3, t3) {
              var r3;
              if (((r3 = t3) == null ? void 0 : r3.sourceType) !== "unambiguous")
                return qe(t3, e3).parse();
              t3 = Object.assign({}, t3);
              try {
                t3.sourceType = "module";
                const r4 = qe(t3, e3), n2 = r4.parse();
                if (r4.sawUnambiguousESM)
                  return n2;
                if (r4.ambiguousScriptDifferentAst)
                  try {
                    return t3.sourceType = "script", qe(t3, e3).parse();
                  } catch (e4) {
                  }
                else
                  n2.program.sourceType = "script";
                return n2;
              } catch (r4) {
                try {
                  return t3.sourceType = "script", qe(t3, e3).parse();
                } catch (e4) {
                }
                throw r4;
              }
            }, t2.parseExpression = function(e3, t3) {
              const r3 = qe(t3, e3);
              return r3.options.strictMode && (r3.state.strict = true), r3.getExpression();
            }, t2.tokTypes = p2;
          }, (e2, t2, r2) => {
            const n = r2(23);
            e2.exports = { re: n.re, src: n.src, tokens: n.t, SEMVER_SPEC_VERSION: r2(41).SEMVER_SPEC_VERSION, SemVer: r2(3), compareIdentifiers: r2(94).compareIdentifiers, rcompareIdentifiers: r2(94).rcompareIdentifiers, parse: r2(29), valid: r2(261), clean: r2(262), inc: r2(263), diff: r2(264), major: r2(265), minor: r2(266), patch: r2(267), prerelease: r2(268), compare: r2(12), rcompare: r2(269), compareLoose: r2(270), compareBuild: r2(72), sort: r2(271), rsort: r2(272), gt: r2(44), lt: r2(73), eq: r2(71), neq: r2(147), gte: r2(74), lte: r2(75), cmp: r2(148), coerce: r2(273), Comparator: r2(45), Range: r2(13), satisfies: r2(46), toComparators: r2(276), maxSatisfying: r2(277), minSatisfying: r2(278), minVersion: r2(279), validRange: r2(280), outside: r2(76), gtr: r2(281), ltr: r2(282), intersects: r2(283), simplifyRange: r2(284), subset: r2(285) };
          }, (e2, t2, r2) => {
            const { MAX_LENGTH: n } = r2(41), { re: s2, t: i } = r2(23), o = r2(3), a = r2(43);
            e2.exports = (e3, t3) => {
              if (t3 = a(t3), e3 instanceof o)
                return e3;
              if (typeof e3 != "string")
                return null;
              if (e3.length > n)
                return null;
              if (!(t3.loose ? s2[i.LOOSE] : s2[i.FULL]).test(e3))
                return null;
              try {
                return new o(e3, t3);
              } catch (e4) {
                return null;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7);
            function s2(e3) {
              return (s2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
                return typeof e4;
              } : function(e4) {
                return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
              })(e3);
            }
            var i, o, a = r2(240).codes, l = a.ERR_AMBIGUOUS_ARGUMENT, c = a.ERR_INVALID_ARG_TYPE, u = a.ERR_INVALID_ARG_VALUE, p2 = a.ERR_INVALID_RETURN_VALUE, f = a.ERR_MISSING_ARGS, d = r2(249), h3 = r2(36).inspect, m = r2(36).types, y = m.isPromise, g = m.isRegExp, b = Object.assign ? Object.assign : r2(250).assign, v = Object.is ? Object.is : r2(140);
            function E() {
              var e3 = r2(254);
              i = e3.isDeepEqual, o = e3.isDeepStrictEqual;
            }
            new Map();
            var x = false, S = e2.exports = A, T = {};
            function w(e3) {
              if (e3.message instanceof Error)
                throw e3.message;
              throw new d(e3);
            }
            function P(e3, t3, r3, n2) {
              if (!r3) {
                var s3 = false;
                if (t3 === 0)
                  s3 = true, n2 = "No value argument passed to `assert.ok()`";
                else if (n2 instanceof Error)
                  throw n2;
                var i2 = new d({ actual: r3, expected: true, message: n2, operator: "==", stackStartFn: e3 });
                throw i2.generatedMessage = s3, i2;
              }
            }
            function A() {
              for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
                t3[r3] = arguments[r3];
              P.apply(void 0, [A, t3.length].concat(t3));
            }
            S.fail = function e3(t3, r3, s3, i2, o2) {
              var a2, l2 = arguments.length;
              if (l2 === 0)
                a2 = "Failed";
              else if (l2 === 1)
                s3 = t3, t3 = void 0;
              else {
                if (x === false) {
                  x = true;
                  var c4 = n.emitWarning ? n.emitWarning : void 0;
                  c4("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
                }
                l2 === 2 && (i2 = "!=");
              }
              if (s3 instanceof Error)
                throw s3;
              var u2 = { actual: t3, expected: r3, operator: i2 === void 0 ? "fail" : i2, stackStartFn: o2 || e3 };
              s3 !== void 0 && (u2.message = s3);
              var p3 = new d(u2);
              throw a2 && (p3.message = a2, p3.generatedMessage = true), p3;
            }, S.AssertionError = d, S.ok = A, S.equal = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              t3 != r3 && w({ actual: t3, expected: r3, message: n2, operator: "==", stackStartFn: e3 });
            }, S.notEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              t3 == r3 && w({ actual: t3, expected: r3, message: n2, operator: "!=", stackStartFn: e3 });
            }, S.deepEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              i === void 0 && E(), i(t3, r3) || w({ actual: t3, expected: r3, message: n2, operator: "deepEqual", stackStartFn: e3 });
            }, S.notDeepEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              i === void 0 && E(), i(t3, r3) && w({ actual: t3, expected: r3, message: n2, operator: "notDeepEqual", stackStartFn: e3 });
            }, S.deepStrictEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              i === void 0 && E(), o(t3, r3) || w({ actual: t3, expected: r3, message: n2, operator: "deepStrictEqual", stackStartFn: e3 });
            }, S.notDeepStrictEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              i === void 0 && E(), o(t3, r3) && w({ actual: t3, expected: r3, message: n2, operator: "notDeepStrictEqual", stackStartFn: e3 });
            }, S.strictEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              v(t3, r3) || w({ actual: t3, expected: r3, message: n2, operator: "strictEqual", stackStartFn: e3 });
            }, S.notStrictEqual = function e3(t3, r3, n2) {
              if (arguments.length < 2)
                throw new f("actual", "expected");
              v(t3, r3) && w({ actual: t3, expected: r3, message: n2, operator: "notStrictEqual", stackStartFn: e3 });
            };
            var O = function e3(t3, r3, n2) {
              var s3 = this;
              !function(e4, t4) {
                if (!(e4 instanceof t4))
                  throw new TypeError("Cannot call a class as a function");
              }(this, e3), r3.forEach(function(e4) {
                e4 in t3 && (n2 !== void 0 && typeof n2[e4] == "string" && g(t3[e4]) && t3[e4].test(n2[e4]) ? s3[e4] = n2[e4] : s3[e4] = t3[e4]);
              });
            };
            function C(e3, t3, r3, n2, s3, i2) {
              if (!(r3 in e3) || !o(e3[r3], t3[r3])) {
                if (!n2) {
                  var a2 = new O(e3, s3), l2 = new O(t3, s3, e3), c4 = new d({ actual: a2, expected: l2, operator: "deepStrictEqual", stackStartFn: i2 });
                  throw c4.actual = e3, c4.expected = t3, c4.operator = i2.name, c4;
                }
                w({ actual: e3, expected: t3, message: n2, operator: i2.name, stackStartFn: i2 });
              }
            }
            function I(e3, t3, r3, n2) {
              if (typeof t3 != "function") {
                if (g(t3))
                  return t3.test(e3);
                if (arguments.length === 2)
                  throw new c("expected", ["Function", "RegExp"], t3);
                if (s2(e3) !== "object" || e3 === null) {
                  var o2 = new d({ actual: e3, expected: t3, message: r3, operator: "deepStrictEqual", stackStartFn: n2 });
                  throw o2.operator = n2.name, o2;
                }
                var a2 = Object.keys(t3);
                if (t3 instanceof Error)
                  a2.push("name", "message");
                else if (a2.length === 0)
                  throw new u("error", t3, "may not be an empty object");
                return i === void 0 && E(), a2.forEach(function(s3) {
                  typeof e3[s3] == "string" && g(t3[s3]) && t3[s3].test(e3[s3]) || C(e3, t3, s3, r3, a2, n2);
                }), true;
              }
              return t3.prototype !== void 0 && e3 instanceof t3 || !Error.isPrototypeOf(t3) && t3.call({}, e3) === true;
            }
            function k2(e3) {
              if (typeof e3 != "function")
                throw new c("fn", "Function", e3);
              try {
                e3();
              } catch (e4) {
                return e4;
              }
              return T;
            }
            function N(e3) {
              return y(e3) || e3 !== null && s2(e3) === "object" && typeof e3.then == "function" && typeof e3.catch == "function";
            }
            function _(e3) {
              return Promise.resolve().then(function() {
                var t3;
                if (typeof e3 == "function") {
                  if (!N(t3 = e3()))
                    throw new p2("instance of Promise", "promiseFn", t3);
                } else {
                  if (!N(e3))
                    throw new c("promiseFn", ["Function", "Promise"], e3);
                  t3 = e3;
                }
                return Promise.resolve().then(function() {
                  return t3;
                }).then(function() {
                  return T;
                }).catch(function(e4) {
                  return e4;
                });
              });
            }
            function j(e3, t3, r3, n2) {
              if (typeof r3 == "string") {
                if (arguments.length === 4)
                  throw new c("error", ["Object", "Error", "Function", "RegExp"], r3);
                if (s2(t3) === "object" && t3 !== null) {
                  if (t3.message === r3)
                    throw new l("error/message", 'The error message "'.concat(t3.message, '" is identical to the message.'));
                } else if (t3 === r3)
                  throw new l("error/message", 'The error "'.concat(t3, '" is identical to the message.'));
                n2 = r3, r3 = void 0;
              } else if (r3 != null && s2(r3) !== "object" && typeof r3 != "function")
                throw new c("error", ["Object", "Error", "Function", "RegExp"], r3);
              if (t3 === T) {
                var i2 = "";
                r3 && r3.name && (i2 += " (".concat(r3.name, ")")), i2 += n2 ? ": ".concat(n2) : ".";
                var o2 = e3.name === "rejects" ? "rejection" : "exception";
                w({ actual: void 0, expected: r3, operator: e3.name, message: "Missing expected ".concat(o2).concat(i2), stackStartFn: e3 });
              }
              if (r3 && !I(t3, r3, n2, e3))
                throw t3;
            }
            function D(e3, t3, r3, n2) {
              if (t3 !== T) {
                if (typeof r3 == "string" && (n2 = r3, r3 = void 0), !r3 || I(t3, r3)) {
                  var s3 = n2 ? ": ".concat(n2) : ".", i2 = e3.name === "doesNotReject" ? "rejection" : "exception";
                  w({ actual: t3, expected: r3, operator: e3.name, message: "Got unwanted ".concat(i2).concat(s3, "\n") + 'Actual message: "'.concat(t3 && t3.message, '"'), stackStartFn: e3 });
                }
                throw t3;
              }
            }
            function L() {
              for (var e3 = arguments.length, t3 = new Array(e3), r3 = 0; r3 < e3; r3++)
                t3[r3] = arguments[r3];
              P.apply(void 0, [L, t3.length].concat(t3));
            }
            S.throws = function e3(t3) {
              for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++)
                n2[s3 - 1] = arguments[s3];
              j.apply(void 0, [e3, k2(t3)].concat(n2));
            }, S.rejects = function e3(t3) {
              for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++)
                n2[s3 - 1] = arguments[s3];
              return _(t3).then(function(t4) {
                return j.apply(void 0, [e3, t4].concat(n2));
              });
            }, S.doesNotThrow = function e3(t3) {
              for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++)
                n2[s3 - 1] = arguments[s3];
              D.apply(void 0, [e3, k2(t3)].concat(n2));
            }, S.doesNotReject = function e3(t3) {
              for (var r3 = arguments.length, n2 = new Array(r3 > 1 ? r3 - 1 : 0), s3 = 1; s3 < r3; s3++)
                n2[s3 - 1] = arguments[s3];
              return _(t3).then(function(t4) {
                return D.apply(void 0, [e3, t4].concat(n2));
              });
            }, S.ifError = function e3(t3) {
              if (t3 != null) {
                var r3 = "ifError got unwanted exception: ";
                s2(t3) === "object" && typeof t3.message == "string" ? t3.message.length === 0 && t3.constructor ? r3 += t3.constructor.name : r3 += t3.message : r3 += h3(t3);
                var n2 = new d({ actual: t3, expected: null, operator: "ifError", message: r3, stackStartFn: e3 }), i2 = t3.stack;
                if (typeof i2 == "string") {
                  var o2 = i2.split("\n");
                  o2.shift();
                  for (var a2 = n2.stack.split("\n"), l2 = 0; l2 < o2.length; l2++) {
                    var c4 = a2.indexOf(o2[l2]);
                    if (c4 !== -1) {
                      a2 = a2.slice(0, c4);
                      break;
                    }
                  }
                  n2.stack = "".concat(a2.join("\n"), "\n").concat(o2.join("\n"));
                }
                throw n2;
              }
            }, S.strict = b(L, S, { equal: S.strictEqual, deepEqual: S.deepStrictEqual, notEqual: S.notStrictEqual, notDeepEqual: S.notDeepStrictEqual }), S.strict.strict = S.strict;
          }, (e2, t2, r2) => {
            var n = r2(16);
            e2.exports = !n(function() {
              return Object.defineProperty({}, 1, { get: function() {
                return 7;
              } })[1] != 7;
            });
          }, (e2, t2, r2) => {
            var n = r2(31), s2 = r2(112), i = r2(116);
            e2.exports = n ? function(e3, t3, r3) {
              return s2.f(e3, t3, i(1, r3));
            } : function(e3, t3, r3) {
              return e3[t3] = r3, e3;
            };
          }, (e2, t2, r2) => {
            var n = r2(59);
            e2.exports = n("navigator", "userAgent") || "";
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.clear = function() {
              s2(), i();
            }, t2.clearPath = s2, t2.clearScope = i, t2.scope = t2.path = void 0;
            let r2 = new WeakMap();
            t2.path = r2;
            let n = new WeakMap();
            function s2() {
              t2.path = r2 = new WeakMap();
            }
            function i() {
              t2.scope = n = new WeakMap();
            }
            t2.scope = n;
          }, (e2, t2, r2) => {
            "use strict";
            let n, s2, i = r2(22);
            class o extends i {
              constructor(e3) {
                super(e3), this.type = "root", this.nodes || (this.nodes = []);
              }
              removeChild(e3, t3) {
                let r3 = this.index(e3);
                return !t3 && r3 === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[r3].raws.before), super.removeChild(e3);
              }
              normalize(e3, t3, r3) {
                let n2 = super.normalize(e3);
                if (t3) {
                  if (r3 === "prepend")
                    this.nodes.length > 1 ? t3.raws.before = this.nodes[1].raws.before : delete t3.raws.before;
                  else if (this.first !== t3)
                    for (let e4 of n2)
                      e4.raws.before = t3.raws.before;
                }
                return n2;
              }
              toResult(e3 = {}) {
                return new n(new s2(), this, e3).stringify();
              }
            }
            o.registerLazyResult = (e3) => {
              n = e3;
            }, o.registerProcessor = (e3) => {
              s2 = e3;
            }, e2.exports = o, o.default = o;
          }, (e2, t2, r2) => {
            var n = r2(7), s2 = Object.getOwnPropertyDescriptors || function(e3) {
              for (var t3 = Object.keys(e3), r3 = {}, n2 = 0; n2 < t3.length; n2++)
                r3[t3[n2]] = Object.getOwnPropertyDescriptor(e3, t3[n2]);
              return r3;
            }, i = /%[sdj%]/g;
            t2.format = function(e3) {
              if (!b(e3)) {
                for (var t3 = [], r3 = 0; r3 < arguments.length; r3++)
                  t3.push(l(arguments[r3]));
                return t3.join(" ");
              }
              r3 = 1;
              for (var n2 = arguments, s3 = n2.length, o2 = String(e3).replace(i, function(e4) {
                if (e4 === "%%")
                  return "%";
                if (r3 >= s3)
                  return e4;
                switch (e4) {
                  case "%s":
                    return String(n2[r3++]);
                  case "%d":
                    return Number(n2[r3++]);
                  case "%j":
                    try {
                      return JSON.stringify(n2[r3++]);
                    } catch (e5) {
                      return "[Circular]";
                    }
                  default:
                    return e4;
                }
              }), a2 = n2[r3]; r3 < s3; a2 = n2[++r3])
                y(a2) || !x(a2) ? o2 += " " + a2 : o2 += " " + l(a2);
              return o2;
            }, t2.deprecate = function(e3, r3) {
              if (n !== void 0 && n.noDeprecation === true)
                return e3;
              if (n === void 0)
                return function() {
                  return t2.deprecate(e3, r3).apply(this, arguments);
                };
              var s3 = false;
              return function() {
                if (!s3) {
                  if (n.throwDeprecation)
                    throw new Error(r3);
                  n.traceDeprecation, s3 = true;
                }
                return e3.apply(this, arguments);
              };
            };
            var o = {}, a = /^$/;
            function l(e3, r3) {
              var n2 = { seen: [], stylize: u };
              return arguments.length >= 3 && (n2.depth = arguments[2]), arguments.length >= 4 && (n2.colors = arguments[3]), m(r3) ? n2.showHidden = r3 : r3 && t2._extend(n2, r3), v(n2.showHidden) && (n2.showHidden = false), v(n2.depth) && (n2.depth = 2), v(n2.colors) && (n2.colors = false), v(n2.customInspect) && (n2.customInspect = true), n2.colors && (n2.stylize = c), p2(n2, e3, n2.depth);
            }
            function c(e3, t3) {
              var r3 = l.styles[t3];
              return r3 ? "[" + l.colors[r3][0] + "m" + e3 + "[" + l.colors[r3][1] + "m" : e3;
            }
            function u(e3, t3) {
              return e3;
            }
            function p2(e3, r3, n2) {
              if (e3.customInspect && r3 && w(r3.inspect) && r3.inspect !== t2.inspect && (!r3.constructor || r3.constructor.prototype !== r3)) {
                var s3 = r3.inspect(n2, e3);
                return b(s3) || (s3 = p2(e3, s3, n2)), s3;
              }
              var i2 = function(e4, t3) {
                if (v(t3))
                  return e4.stylize("undefined", "undefined");
                if (b(t3)) {
                  var r4 = "'" + JSON.stringify(t3).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return e4.stylize(r4, "string");
                }
                return g(t3) ? e4.stylize("" + t3, "number") : m(t3) ? e4.stylize("" + t3, "boolean") : y(t3) ? e4.stylize("null", "null") : void 0;
              }(e3, r3);
              if (i2)
                return i2;
              var o2 = Object.keys(r3), a2 = function(e4) {
                var t3 = {};
                return e4.forEach(function(e5, r4) {
                  t3[e5] = true;
                }), t3;
              }(o2);
              if (e3.showHidden && (o2 = Object.getOwnPropertyNames(r3)), T(r3) && (o2.indexOf("message") >= 0 || o2.indexOf("description") >= 0))
                return f(r3);
              if (o2.length === 0) {
                if (w(r3)) {
                  var l2 = r3.name ? ": " + r3.name : "";
                  return e3.stylize("[Function" + l2 + "]", "special");
                }
                if (E(r3))
                  return e3.stylize(RegExp.prototype.toString.call(r3), "regexp");
                if (S(r3))
                  return e3.stylize(Date.prototype.toString.call(r3), "date");
                if (T(r3))
                  return f(r3);
              }
              var c4, u2 = "", x2 = false, P2 = ["{", "}"];
              return h3(r3) && (x2 = true, P2 = ["[", "]"]), w(r3) && (u2 = " [Function" + (r3.name ? ": " + r3.name : "") + "]"), E(r3) && (u2 = " " + RegExp.prototype.toString.call(r3)), S(r3) && (u2 = " " + Date.prototype.toUTCString.call(r3)), T(r3) && (u2 = " " + f(r3)), o2.length !== 0 || x2 && r3.length != 0 ? n2 < 0 ? E(r3) ? e3.stylize(RegExp.prototype.toString.call(r3), "regexp") : e3.stylize("[Object]", "special") : (e3.seen.push(r3), c4 = x2 ? function(e4, t3, r4, n3, s4) {
                for (var i3 = [], o3 = 0, a3 = t3.length; o3 < a3; ++o3)
                  A(t3, String(o3)) ? i3.push(d(e4, t3, r4, n3, String(o3), true)) : i3.push("");
                return s4.forEach(function(s5) {
                  s5.match(/^\d+$/) || i3.push(d(e4, t3, r4, n3, s5, true));
                }), i3;
              }(e3, r3, n2, a2, o2) : o2.map(function(t3) {
                return d(e3, r3, n2, a2, t3, x2);
              }), e3.seen.pop(), function(e4, t3, r4) {
                return e4.reduce(function(e5, t4) {
                  return t4.indexOf("\n"), e5 + t4.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0) > 60 ? r4[0] + (t3 === "" ? "" : t3 + "\n ") + " " + e4.join(",\n  ") + " " + r4[1] : r4[0] + t3 + " " + e4.join(", ") + " " + r4[1];
              }(c4, u2, P2)) : P2[0] + u2 + P2[1];
            }
            function f(e3) {
              return "[" + Error.prototype.toString.call(e3) + "]";
            }
            function d(e3, t3, r3, n2, s3, i2) {
              var o2, a2, l2;
              if ((l2 = Object.getOwnPropertyDescriptor(t3, s3) || { value: t3[s3] }).get ? a2 = l2.set ? e3.stylize("[Getter/Setter]", "special") : e3.stylize("[Getter]", "special") : l2.set && (a2 = e3.stylize("[Setter]", "special")), A(n2, s3) || (o2 = "[" + s3 + "]"), a2 || (e3.seen.indexOf(l2.value) < 0 ? (a2 = y(r3) ? p2(e3, l2.value, null) : p2(e3, l2.value, r3 - 1)).indexOf("\n") > -1 && (a2 = i2 ? a2.split("\n").map(function(e4) {
                return "  " + e4;
              }).join("\n").substr(2) : "\n" + a2.split("\n").map(function(e4) {
                return "   " + e4;
              }).join("\n")) : a2 = e3.stylize("[Circular]", "special")), v(o2)) {
                if (i2 && s3.match(/^\d+$/))
                  return a2;
                (o2 = JSON.stringify("" + s3)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (o2 = o2.substr(1, o2.length - 2), o2 = e3.stylize(o2, "name")) : (o2 = o2.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), o2 = e3.stylize(o2, "string"));
              }
              return o2 + ": " + a2;
            }
            function h3(e3) {
              return Array.isArray(e3);
            }
            function m(e3) {
              return typeof e3 == "boolean";
            }
            function y(e3) {
              return e3 === null;
            }
            function g(e3) {
              return typeof e3 == "number";
            }
            function b(e3) {
              return typeof e3 == "string";
            }
            function v(e3) {
              return e3 === void 0;
            }
            function E(e3) {
              return x(e3) && P(e3) === "[object RegExp]";
            }
            function x(e3) {
              return typeof e3 == "object" && e3 !== null;
            }
            function S(e3) {
              return x(e3) && P(e3) === "[object Date]";
            }
            function T(e3) {
              return x(e3) && (P(e3) === "[object Error]" || e3 instanceof Error);
            }
            function w(e3) {
              return typeof e3 == "function";
            }
            function P(e3) {
              return Object.prototype.toString.call(e3);
            }
            function A(e3, t3) {
              return Object.prototype.hasOwnProperty.call(e3, t3);
            }
            t2.debuglog = function(e3) {
              return e3 = e3.toUpperCase(), o[e3] || (a.test(e3) ? (n.pid, o[e3] = function() {
                t2.format.apply(t2, arguments);
              }) : o[e3] = function() {
              }), o[e3];
            }, t2.inspect = l, l.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, l.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, t2.types = r2(241), t2.isArray = h3, t2.isBoolean = m, t2.isNull = y, t2.isNullOrUndefined = function(e3) {
              return e3 == null;
            }, t2.isNumber = g, t2.isString = b, t2.isSymbol = function(e3) {
              return typeof e3 == "symbol";
            }, t2.isUndefined = v, t2.isRegExp = E, t2.types.isRegExp = E, t2.isObject = x, t2.isDate = S, t2.types.isDate = S, t2.isError = T, t2.types.isNativeError = T, t2.isFunction = w, t2.isPrimitive = function(e3) {
              return e3 === null || typeof e3 == "boolean" || typeof e3 == "number" || typeof e3 == "string" || typeof e3 == "symbol" || e3 === void 0;
            }, t2.isBuffer = r2(248), t2.log = function() {
            }, t2.inherits = r2(171), t2._extend = function(e3, t3) {
              if (!t3 || !x(t3))
                return e3;
              for (var r3 = Object.keys(t3), n2 = r3.length; n2--; )
                e3[r3[n2]] = t3[r3[n2]];
              return e3;
            };
            var O = typeof Symbol != "undefined" ? Symbol("util.promisify.custom") : void 0;
            function C(e3, t3) {
              if (!e3) {
                var r3 = new Error("Promise was rejected with a falsy value");
                r3.reason = e3, e3 = r3;
              }
              return t3(e3);
            }
            t2.promisify = function(e3) {
              if (typeof e3 != "function")
                throw new TypeError('The "original" argument must be of type Function');
              if (O && e3[O]) {
                var t3;
                if (typeof (t3 = e3[O]) != "function")
                  throw new TypeError('The "util.promisify.custom" argument must be of type Function');
                return Object.defineProperty(t3, O, { value: t3, enumerable: false, writable: false, configurable: true }), t3;
              }
              function t3() {
                for (var t4, r3, n2 = new Promise(function(e4, n3) {
                  t4 = e4, r3 = n3;
                }), s3 = [], i2 = 0; i2 < arguments.length; i2++)
                  s3.push(arguments[i2]);
                s3.push(function(e4, n3) {
                  e4 ? r3(e4) : t4(n3);
                });
                try {
                  e3.apply(this, s3);
                } catch (e4) {
                  r3(e4);
                }
                return n2;
              }
              return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), O && Object.defineProperty(t3, O, { value: t3, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t3, s2(e3));
            }, t2.promisify.custom = O, t2.callbackify = function(e3) {
              if (typeof e3 != "function")
                throw new TypeError('The "original" argument must be of type Function');
              function t3() {
                for (var t4 = [], r3 = 0; r3 < arguments.length; r3++)
                  t4.push(arguments[r3]);
                var s3 = t4.pop();
                if (typeof s3 != "function")
                  throw new TypeError("The last argument must be of type Function");
                var i2 = this, o2 = function() {
                  return s3.apply(i2, arguments);
                };
                e3.apply(this, t4).then(function(e4) {
                  n.nextTick(o2.bind(null, null, e4));
                }, function(e4) {
                  n.nextTick(C.bind(null, e4, o2));
                });
              }
              return Object.setPrototypeOf(t3, Object.getPrototypeOf(e3)), Object.defineProperties(t3, s2(e3)), t3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            const n = r2(427), s2 = r2(428), i = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            t2.Buffer = l, t2.SlowBuffer = function(e3) {
              return +e3 != e3 && (e3 = 0), l.alloc(+e3);
            }, t2.INSPECT_MAX_BYTES = 50;
            const o = 2147483647;
            function a(e3) {
              if (e3 > o)
                throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
              const t3 = new Uint8Array(e3);
              return Object.setPrototypeOf(t3, l.prototype), t3;
            }
            function l(e3, t3, r3) {
              if (typeof e3 == "number") {
                if (typeof t3 == "string")
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return p2(e3);
              }
              return c(e3, t3, r3);
            }
            function c(e3, t3, r3) {
              if (typeof e3 == "string")
                return function(e4, t4) {
                  if (typeof t4 == "string" && t4 !== "" || (t4 = "utf8"), !l.isEncoding(t4))
                    throw new TypeError("Unknown encoding: " + t4);
                  const r4 = 0 | m(e4, t4);
                  let n3 = a(r4);
                  const s4 = n3.write(e4, t4);
                  return s4 !== r4 && (n3 = n3.slice(0, s4)), n3;
                }(e3, t3);
              if (ArrayBuffer.isView(e3))
                return function(e4) {
                  if (Y(e4, Uint8Array)) {
                    const t4 = new Uint8Array(e4);
                    return d(t4.buffer, t4.byteOffset, t4.byteLength);
                  }
                  return f(e4);
                }(e3);
              if (e3 == null)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
              if (Y(e3, ArrayBuffer) || e3 && Y(e3.buffer, ArrayBuffer))
                return d(e3, t3, r3);
              if (typeof SharedArrayBuffer != "undefined" && (Y(e3, SharedArrayBuffer) || e3 && Y(e3.buffer, SharedArrayBuffer)))
                return d(e3, t3, r3);
              if (typeof e3 == "number")
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              const n2 = e3.valueOf && e3.valueOf();
              if (n2 != null && n2 !== e3)
                return l.from(n2, t3, r3);
              const s3 = function(e4) {
                if (l.isBuffer(e4)) {
                  const t4 = 0 | h3(e4.length), r4 = a(t4);
                  return r4.length === 0 || e4.copy(r4, 0, 0, t4), r4;
                }
                return e4.length !== void 0 ? typeof e4.length != "number" || X(e4.length) ? a(0) : f(e4) : e4.type === "Buffer" && Array.isArray(e4.data) ? f(e4.data) : void 0;
              }(e3);
              if (s3)
                return s3;
              if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof e3[Symbol.toPrimitive] == "function")
                return l.from(e3[Symbol.toPrimitive]("string"), t3, r3);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e3);
            }
            function u(e3) {
              if (typeof e3 != "number")
                throw new TypeError('"size" argument must be of type number');
              if (e3 < 0)
                throw new RangeError('The value "' + e3 + '" is invalid for option "size"');
            }
            function p2(e3) {
              return u(e3), a(e3 < 0 ? 0 : 0 | h3(e3));
            }
            function f(e3) {
              const t3 = e3.length < 0 ? 0 : 0 | h3(e3.length), r3 = a(t3);
              for (let n2 = 0; n2 < t3; n2 += 1)
                r3[n2] = 255 & e3[n2];
              return r3;
            }
            function d(e3, t3, r3) {
              if (t3 < 0 || e3.byteLength < t3)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (e3.byteLength < t3 + (r3 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              let n2;
              return n2 = t3 === void 0 && r3 === void 0 ? new Uint8Array(e3) : r3 === void 0 ? new Uint8Array(e3, t3) : new Uint8Array(e3, t3, r3), Object.setPrototypeOf(n2, l.prototype), n2;
            }
            function h3(e3) {
              if (e3 >= o)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
              return 0 | e3;
            }
            function m(e3, t3) {
              if (l.isBuffer(e3))
                return e3.length;
              if (ArrayBuffer.isView(e3) || Y(e3, ArrayBuffer))
                return e3.byteLength;
              if (typeof e3 != "string")
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e3);
              const r3 = e3.length, n2 = arguments.length > 2 && arguments[2] === true;
              if (!n2 && r3 === 0)
                return 0;
              let s3 = false;
              for (; ; )
                switch (t3) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return r3;
                  case "utf8":
                  case "utf-8":
                    return G(e3).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * r3;
                  case "hex":
                    return r3 >>> 1;
                  case "base64":
                    return H(e3).length;
                  default:
                    if (s3)
                      return n2 ? -1 : G(e3).length;
                    t3 = ("" + t3).toLowerCase(), s3 = true;
                }
            }
            function y(e3, t3, r3) {
              let n2 = false;
              if ((t3 === void 0 || t3 < 0) && (t3 = 0), t3 > this.length)
                return "";
              if ((r3 === void 0 || r3 > this.length) && (r3 = this.length), r3 <= 0)
                return "";
              if ((r3 >>>= 0) <= (t3 >>>= 0))
                return "";
              for (e3 || (e3 = "utf8"); ; )
                switch (e3) {
                  case "hex":
                    return k2(this, t3, r3);
                  case "utf8":
                  case "utf-8":
                    return A(this, t3, r3);
                  case "ascii":
                    return C(this, t3, r3);
                  case "latin1":
                  case "binary":
                    return I(this, t3, r3);
                  case "base64":
                    return P(this, t3, r3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return N(this, t3, r3);
                  default:
                    if (n2)
                      throw new TypeError("Unknown encoding: " + e3);
                    e3 = (e3 + "").toLowerCase(), n2 = true;
                }
            }
            function g(e3, t3, r3) {
              const n2 = e3[t3];
              e3[t3] = e3[r3], e3[r3] = n2;
            }
            function b(e3, t3, r3, n2, s3) {
              if (e3.length === 0)
                return -1;
              if (typeof r3 == "string" ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), X(r3 = +r3) && (r3 = s3 ? 0 : e3.length - 1), r3 < 0 && (r3 = e3.length + r3), r3 >= e3.length) {
                if (s3)
                  return -1;
                r3 = e3.length - 1;
              } else if (r3 < 0) {
                if (!s3)
                  return -1;
                r3 = 0;
              }
              if (typeof t3 == "string" && (t3 = l.from(t3, n2)), l.isBuffer(t3))
                return t3.length === 0 ? -1 : v(e3, t3, r3, n2, s3);
              if (typeof t3 == "number")
                return t3 &= 255, typeof Uint8Array.prototype.indexOf == "function" ? s3 ? Uint8Array.prototype.indexOf.call(e3, t3, r3) : Uint8Array.prototype.lastIndexOf.call(e3, t3, r3) : v(e3, [t3], r3, n2, s3);
              throw new TypeError("val must be string, number or Buffer");
            }
            function v(e3, t3, r3, n2, s3) {
              let i2, o2 = 1, a2 = e3.length, l2 = t3.length;
              if (n2 !== void 0 && ((n2 = String(n2).toLowerCase()) === "ucs2" || n2 === "ucs-2" || n2 === "utf16le" || n2 === "utf-16le")) {
                if (e3.length < 2 || t3.length < 2)
                  return -1;
                o2 = 2, a2 /= 2, l2 /= 2, r3 /= 2;
              }
              function c4(e4, t4) {
                return o2 === 1 ? e4[t4] : e4.readUInt16BE(t4 * o2);
              }
              if (s3) {
                let n3 = -1;
                for (i2 = r3; i2 < a2; i2++)
                  if (c4(e3, i2) === c4(t3, n3 === -1 ? 0 : i2 - n3)) {
                    if (n3 === -1 && (n3 = i2), i2 - n3 + 1 === l2)
                      return n3 * o2;
                  } else
                    n3 !== -1 && (i2 -= i2 - n3), n3 = -1;
              } else
                for (r3 + l2 > a2 && (r3 = a2 - l2), i2 = r3; i2 >= 0; i2--) {
                  let r4 = true;
                  for (let n3 = 0; n3 < l2; n3++)
                    if (c4(e3, i2 + n3) !== c4(t3, n3)) {
                      r4 = false;
                      break;
                    }
                  if (r4)
                    return i2;
                }
              return -1;
            }
            function E(e3, t3, r3, n2) {
              r3 = Number(r3) || 0;
              const s3 = e3.length - r3;
              n2 ? (n2 = Number(n2)) > s3 && (n2 = s3) : n2 = s3;
              const i2 = t3.length;
              let o2;
              for (n2 > i2 / 2 && (n2 = i2 / 2), o2 = 0; o2 < n2; ++o2) {
                const n3 = parseInt(t3.substr(2 * o2, 2), 16);
                if (X(n3))
                  return o2;
                e3[r3 + o2] = n3;
              }
              return o2;
            }
            function x(e3, t3, r3, n2) {
              return J(G(t3, e3.length - r3), e3, r3, n2);
            }
            function S(e3, t3, r3, n2) {
              return J(function(e4) {
                const t4 = [];
                for (let r4 = 0; r4 < e4.length; ++r4)
                  t4.push(255 & e4.charCodeAt(r4));
                return t4;
              }(t3), e3, r3, n2);
            }
            function T(e3, t3, r3, n2) {
              return J(H(t3), e3, r3, n2);
            }
            function w(e3, t3, r3, n2) {
              return J(function(e4, t4) {
                let r4, n3, s3;
                const i2 = [];
                for (let o2 = 0; o2 < e4.length && !((t4 -= 2) < 0); ++o2)
                  r4 = e4.charCodeAt(o2), n3 = r4 >> 8, s3 = r4 % 256, i2.push(s3), i2.push(n3);
                return i2;
              }(t3, e3.length - r3), e3, r3, n2);
            }
            function P(e3, t3, r3) {
              return t3 === 0 && r3 === e3.length ? n.fromByteArray(e3) : n.fromByteArray(e3.slice(t3, r3));
            }
            function A(e3, t3, r3) {
              r3 = Math.min(e3.length, r3);
              const n2 = [];
              let s3 = t3;
              for (; s3 < r3; ) {
                const t4 = e3[s3];
                let i2 = null, o2 = t4 > 239 ? 4 : t4 > 223 ? 3 : t4 > 191 ? 2 : 1;
                if (s3 + o2 <= r3) {
                  let r4, n3, a2, l2;
                  switch (o2) {
                    case 1:
                      t4 < 128 && (i2 = t4);
                      break;
                    case 2:
                      r4 = e3[s3 + 1], (192 & r4) == 128 && (l2 = (31 & t4) << 6 | 63 & r4, l2 > 127 && (i2 = l2));
                      break;
                    case 3:
                      r4 = e3[s3 + 1], n3 = e3[s3 + 2], (192 & r4) == 128 && (192 & n3) == 128 && (l2 = (15 & t4) << 12 | (63 & r4) << 6 | 63 & n3, l2 > 2047 && (l2 < 55296 || l2 > 57343) && (i2 = l2));
                      break;
                    case 4:
                      r4 = e3[s3 + 1], n3 = e3[s3 + 2], a2 = e3[s3 + 3], (192 & r4) == 128 && (192 & n3) == 128 && (192 & a2) == 128 && (l2 = (15 & t4) << 18 | (63 & r4) << 12 | (63 & n3) << 6 | 63 & a2, l2 > 65535 && l2 < 1114112 && (i2 = l2));
                  }
                }
                i2 === null ? (i2 = 65533, o2 = 1) : i2 > 65535 && (i2 -= 65536, n2.push(i2 >>> 10 & 1023 | 55296), i2 = 56320 | 1023 & i2), n2.push(i2), s3 += o2;
              }
              return function(e4) {
                const t4 = e4.length;
                if (t4 <= O)
                  return String.fromCharCode.apply(String, e4);
                let r4 = "", n3 = 0;
                for (; n3 < t4; )
                  r4 += String.fromCharCode.apply(String, e4.slice(n3, n3 += O));
                return r4;
              }(n2);
            }
            t2.kMaxLength = o, l.TYPED_ARRAY_SUPPORT = function() {
              try {
                const e3 = new Uint8Array(1), t3 = { foo: function() {
                  return 42;
                } };
                return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e3, t3), e3.foo() === 42;
              } catch (e3) {
                return false;
              }
            }(), !l.TYPED_ARRAY_SUPPORT && typeof console != "undefined" && console.error, Object.defineProperty(l.prototype, "parent", { enumerable: true, get: function() {
              if (l.isBuffer(this))
                return this.buffer;
            } }), Object.defineProperty(l.prototype, "offset", { enumerable: true, get: function() {
              if (l.isBuffer(this))
                return this.byteOffset;
            } }), l.poolSize = 8192, l.from = function(e3, t3, r3) {
              return c(e3, t3, r3);
            }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array), l.alloc = function(e3, t3, r3) {
              return function(e4, t4, r4) {
                return u(e4), e4 <= 0 ? a(e4) : t4 !== void 0 ? typeof r4 == "string" ? a(e4).fill(t4, r4) : a(e4).fill(t4) : a(e4);
              }(e3, t3, r3);
            }, l.allocUnsafe = function(e3) {
              return p2(e3);
            }, l.allocUnsafeSlow = function(e3) {
              return p2(e3);
            }, l.isBuffer = function(e3) {
              return e3 != null && e3._isBuffer === true && e3 !== l.prototype;
            }, l.compare = function(e3, t3) {
              if (Y(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), Y(t3, Uint8Array) && (t3 = l.from(t3, t3.offset, t3.byteLength)), !l.isBuffer(e3) || !l.isBuffer(t3))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e3 === t3)
                return 0;
              let r3 = e3.length, n2 = t3.length;
              for (let s3 = 0, i2 = Math.min(r3, n2); s3 < i2; ++s3)
                if (e3[s3] !== t3[s3]) {
                  r3 = e3[s3], n2 = t3[s3];
                  break;
                }
              return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
            }, l.isEncoding = function(e3) {
              switch (String(e3).toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, l.concat = function(e3, t3) {
              if (!Array.isArray(e3))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (e3.length === 0)
                return l.alloc(0);
              let r3;
              if (t3 === void 0)
                for (t3 = 0, r3 = 0; r3 < e3.length; ++r3)
                  t3 += e3[r3].length;
              const n2 = l.allocUnsafe(t3);
              let s3 = 0;
              for (r3 = 0; r3 < e3.length; ++r3) {
                let t4 = e3[r3];
                if (Y(t4, Uint8Array))
                  s3 + t4.length > n2.length ? (l.isBuffer(t4) || (t4 = l.from(t4)), t4.copy(n2, s3)) : Uint8Array.prototype.set.call(n2, t4, s3);
                else {
                  if (!l.isBuffer(t4))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  t4.copy(n2, s3);
                }
                s3 += t4.length;
              }
              return n2;
            }, l.byteLength = m, l.prototype._isBuffer = true, l.prototype.swap16 = function() {
              const e3 = this.length;
              if (e3 % 2 != 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (let t3 = 0; t3 < e3; t3 += 2)
                g(this, t3, t3 + 1);
              return this;
            }, l.prototype.swap32 = function() {
              const e3 = this.length;
              if (e3 % 4 != 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (let t3 = 0; t3 < e3; t3 += 4)
                g(this, t3, t3 + 3), g(this, t3 + 1, t3 + 2);
              return this;
            }, l.prototype.swap64 = function() {
              const e3 = this.length;
              if (e3 % 8 != 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (let t3 = 0; t3 < e3; t3 += 8)
                g(this, t3, t3 + 7), g(this, t3 + 1, t3 + 6), g(this, t3 + 2, t3 + 5), g(this, t3 + 3, t3 + 4);
              return this;
            }, l.prototype.toString = function() {
              const e3 = this.length;
              return e3 === 0 ? "" : arguments.length === 0 ? A(this, 0, e3) : y.apply(this, arguments);
            }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function(e3) {
              if (!l.isBuffer(e3))
                throw new TypeError("Argument must be a Buffer");
              return this === e3 || l.compare(this, e3) === 0;
            }, l.prototype.inspect = function() {
              let e3 = "";
              const r3 = t2.INSPECT_MAX_BYTES;
              return e3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (e3 += " ... "), "<Buffer " + e3 + ">";
            }, i && (l.prototype[i] = l.prototype.inspect), l.prototype.compare = function(e3, t3, r3, n2, s3) {
              if (Y(e3, Uint8Array) && (e3 = l.from(e3, e3.offset, e3.byteLength)), !l.isBuffer(e3))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e3);
              if (t3 === void 0 && (t3 = 0), r3 === void 0 && (r3 = e3 ? e3.length : 0), n2 === void 0 && (n2 = 0), s3 === void 0 && (s3 = this.length), t3 < 0 || r3 > e3.length || n2 < 0 || s3 > this.length)
                throw new RangeError("out of range index");
              if (n2 >= s3 && t3 >= r3)
                return 0;
              if (n2 >= s3)
                return -1;
              if (t3 >= r3)
                return 1;
              if (this === e3)
                return 0;
              let i2 = (s3 >>>= 0) - (n2 >>>= 0), o2 = (r3 >>>= 0) - (t3 >>>= 0);
              const a2 = Math.min(i2, o2), c4 = this.slice(n2, s3), u2 = e3.slice(t3, r3);
              for (let e4 = 0; e4 < a2; ++e4)
                if (c4[e4] !== u2[e4]) {
                  i2 = c4[e4], o2 = u2[e4];
                  break;
                }
              return i2 < o2 ? -1 : o2 < i2 ? 1 : 0;
            }, l.prototype.includes = function(e3, t3, r3) {
              return this.indexOf(e3, t3, r3) !== -1;
            }, l.prototype.indexOf = function(e3, t3, r3) {
              return b(this, e3, t3, r3, true);
            }, l.prototype.lastIndexOf = function(e3, t3, r3) {
              return b(this, e3, t3, r3, false);
            }, l.prototype.write = function(e3, t3, r3, n2) {
              if (t3 === void 0)
                n2 = "utf8", r3 = this.length, t3 = 0;
              else if (r3 === void 0 && typeof t3 == "string")
                n2 = t3, r3 = this.length, t3 = 0;
              else {
                if (!isFinite(t3))
                  throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                t3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, n2 === void 0 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
              }
              const s3 = this.length - t3;
              if ((r3 === void 0 || r3 > s3) && (r3 = s3), e3.length > 0 && (r3 < 0 || t3 < 0) || t3 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              n2 || (n2 = "utf8");
              let i2 = false;
              for (; ; )
                switch (n2) {
                  case "hex":
                    return E(this, e3, t3, r3);
                  case "utf8":
                  case "utf-8":
                    return x(this, e3, t3, r3);
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return S(this, e3, t3, r3);
                  case "base64":
                    return T(this, e3, t3, r3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return w(this, e3, t3, r3);
                  default:
                    if (i2)
                      throw new TypeError("Unknown encoding: " + n2);
                    n2 = ("" + n2).toLowerCase(), i2 = true;
                }
            }, l.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            const O = 4096;
            function C(e3, t3, r3) {
              let n2 = "";
              r3 = Math.min(e3.length, r3);
              for (let s3 = t3; s3 < r3; ++s3)
                n2 += String.fromCharCode(127 & e3[s3]);
              return n2;
            }
            function I(e3, t3, r3) {
              let n2 = "";
              r3 = Math.min(e3.length, r3);
              for (let s3 = t3; s3 < r3; ++s3)
                n2 += String.fromCharCode(e3[s3]);
              return n2;
            }
            function k2(e3, t3, r3) {
              const n2 = e3.length;
              (!t3 || t3 < 0) && (t3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
              let s3 = "";
              for (let n3 = t3; n3 < r3; ++n3)
                s3 += z[e3[n3]];
              return s3;
            }
            function N(e3, t3, r3) {
              const n2 = e3.slice(t3, r3);
              let s3 = "";
              for (let e4 = 0; e4 < n2.length - 1; e4 += 2)
                s3 += String.fromCharCode(n2[e4] + 256 * n2[e4 + 1]);
              return s3;
            }
            function _(e3, t3, r3) {
              if (e3 % 1 != 0 || e3 < 0)
                throw new RangeError("offset is not uint");
              if (e3 + t3 > r3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function j(e3, t3, r3, n2, s3, i2) {
              if (!l.isBuffer(e3))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t3 > s3 || t3 < i2)
                throw new RangeError('"value" argument is out of bounds');
              if (r3 + n2 > e3.length)
                throw new RangeError("Index out of range");
            }
            function D(e3, t3, r3, n2, s3) {
              q(t3, n2, s3, e3, r3, 7);
              let i2 = Number(t3 & BigInt(4294967295));
              e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2, i2 >>= 8, e3[r3++] = i2;
              let o2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
              return e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, o2 >>= 8, e3[r3++] = o2, r3;
            }
            function L(e3, t3, r3, n2, s3) {
              q(t3, n2, s3, e3, r3, 7);
              let i2 = Number(t3 & BigInt(4294967295));
              e3[r3 + 7] = i2, i2 >>= 8, e3[r3 + 6] = i2, i2 >>= 8, e3[r3 + 5] = i2, i2 >>= 8, e3[r3 + 4] = i2;
              let o2 = Number(t3 >> BigInt(32) & BigInt(4294967295));
              return e3[r3 + 3] = o2, o2 >>= 8, e3[r3 + 2] = o2, o2 >>= 8, e3[r3 + 1] = o2, o2 >>= 8, e3[r3] = o2, r3 + 8;
            }
            function M(e3, t3, r3, n2, s3, i2) {
              if (r3 + n2 > e3.length)
                throw new RangeError("Index out of range");
              if (r3 < 0)
                throw new RangeError("Index out of range");
            }
            function B(e3, t3, r3, n2, i2) {
              return t3 = +t3, r3 >>>= 0, i2 || M(e3, 0, r3, 4), s2.write(e3, t3, r3, n2, 23, 4), r3 + 4;
            }
            function R(e3, t3, r3, n2, i2) {
              return t3 = +t3, r3 >>>= 0, i2 || M(e3, 0, r3, 8), s2.write(e3, t3, r3, n2, 52, 8), r3 + 8;
            }
            l.prototype.slice = function(e3, t3) {
              const r3 = this.length;
              (e3 = ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), (t3 = t3 === void 0 ? r3 : ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), t3 < e3 && (t3 = e3);
              const n2 = this.subarray(e3, t3);
              return Object.setPrototypeOf(n2, l.prototype), n2;
            }, l.prototype.readUintLE = l.prototype.readUIntLE = function(e3, t3, r3) {
              e3 >>>= 0, t3 >>>= 0, r3 || _(e3, t3, this.length);
              let n2 = this[e3], s3 = 1, i2 = 0;
              for (; ++i2 < t3 && (s3 *= 256); )
                n2 += this[e3 + i2] * s3;
              return n2;
            }, l.prototype.readUintBE = l.prototype.readUIntBE = function(e3, t3, r3) {
              e3 >>>= 0, t3 >>>= 0, r3 || _(e3, t3, this.length);
              let n2 = this[e3 + --t3], s3 = 1;
              for (; t3 > 0 && (s3 *= 256); )
                n2 += this[e3 + --t3] * s3;
              return n2;
            }, l.prototype.readUint8 = l.prototype.readUInt8 = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 1, this.length), this[e3];
            }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 2, this.length), this[e3] | this[e3 + 1] << 8;
            }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 2, this.length), this[e3] << 8 | this[e3 + 1];
            }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), (this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16) + 16777216 * this[e3 + 3];
            }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), 16777216 * this[e3] + (this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3]);
            }, l.prototype.readBigUInt64LE = Q(function(e3) {
              V(e3 >>>= 0, "offset");
              const t3 = this[e3], r3 = this[e3 + 7];
              t3 !== void 0 && r3 !== void 0 || W(e3, this.length - 8);
              const n2 = t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24, s3 = this[++e3] + 256 * this[++e3] + 65536 * this[++e3] + r3 * 2 ** 24;
              return BigInt(n2) + (BigInt(s3) << BigInt(32));
            }), l.prototype.readBigUInt64BE = Q(function(e3) {
              V(e3 >>>= 0, "offset");
              const t3 = this[e3], r3 = this[e3 + 7];
              t3 !== void 0 && r3 !== void 0 || W(e3, this.length - 8);
              const n2 = t3 * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + this[++e3], s3 = this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3;
              return (BigInt(n2) << BigInt(32)) + BigInt(s3);
            }), l.prototype.readIntLE = function(e3, t3, r3) {
              e3 >>>= 0, t3 >>>= 0, r3 || _(e3, t3, this.length);
              let n2 = this[e3], s3 = 1, i2 = 0;
              for (; ++i2 < t3 && (s3 *= 256); )
                n2 += this[e3 + i2] * s3;
              return s3 *= 128, n2 >= s3 && (n2 -= Math.pow(2, 8 * t3)), n2;
            }, l.prototype.readIntBE = function(e3, t3, r3) {
              e3 >>>= 0, t3 >>>= 0, r3 || _(e3, t3, this.length);
              let n2 = t3, s3 = 1, i2 = this[e3 + --n2];
              for (; n2 > 0 && (s3 *= 256); )
                i2 += this[e3 + --n2] * s3;
              return s3 *= 128, i2 >= s3 && (i2 -= Math.pow(2, 8 * t3)), i2;
            }, l.prototype.readInt8 = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 1, this.length), 128 & this[e3] ? -1 * (255 - this[e3] + 1) : this[e3];
            }, l.prototype.readInt16LE = function(e3, t3) {
              e3 >>>= 0, t3 || _(e3, 2, this.length);
              const r3 = this[e3] | this[e3 + 1] << 8;
              return 32768 & r3 ? 4294901760 | r3 : r3;
            }, l.prototype.readInt16BE = function(e3, t3) {
              e3 >>>= 0, t3 || _(e3, 2, this.length);
              const r3 = this[e3 + 1] | this[e3] << 8;
              return 32768 & r3 ? 4294901760 | r3 : r3;
            }, l.prototype.readInt32LE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), this[e3] | this[e3 + 1] << 8 | this[e3 + 2] << 16 | this[e3 + 3] << 24;
            }, l.prototype.readInt32BE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), this[e3] << 24 | this[e3 + 1] << 16 | this[e3 + 2] << 8 | this[e3 + 3];
            }, l.prototype.readBigInt64LE = Q(function(e3) {
              V(e3 >>>= 0, "offset");
              const t3 = this[e3], r3 = this[e3 + 7];
              t3 !== void 0 && r3 !== void 0 || W(e3, this.length - 8);
              const n2 = this[e3 + 4] + 256 * this[e3 + 5] + 65536 * this[e3 + 6] + (r3 << 24);
              return (BigInt(n2) << BigInt(32)) + BigInt(t3 + 256 * this[++e3] + 65536 * this[++e3] + this[++e3] * 2 ** 24);
            }), l.prototype.readBigInt64BE = Q(function(e3) {
              V(e3 >>>= 0, "offset");
              const t3 = this[e3], r3 = this[e3 + 7];
              t3 !== void 0 && r3 !== void 0 || W(e3, this.length - 8);
              const n2 = (t3 << 24) + 65536 * this[++e3] + 256 * this[++e3] + this[++e3];
              return (BigInt(n2) << BigInt(32)) + BigInt(this[++e3] * 2 ** 24 + 65536 * this[++e3] + 256 * this[++e3] + r3);
            }), l.prototype.readFloatLE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), s2.read(this, e3, true, 23, 4);
            }, l.prototype.readFloatBE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 4, this.length), s2.read(this, e3, false, 23, 4);
            }, l.prototype.readDoubleLE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 8, this.length), s2.read(this, e3, true, 52, 8);
            }, l.prototype.readDoubleBE = function(e3, t3) {
              return e3 >>>= 0, t3 || _(e3, 8, this.length), s2.read(this, e3, false, 52, 8);
            }, l.prototype.writeUintLE = l.prototype.writeUIntLE = function(e3, t3, r3, n2) {
              e3 = +e3, t3 >>>= 0, r3 >>>= 0, n2 || j(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
              let s3 = 1, i2 = 0;
              for (this[t3] = 255 & e3; ++i2 < r3 && (s3 *= 256); )
                this[t3 + i2] = e3 / s3 & 255;
              return t3 + r3;
            }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function(e3, t3, r3, n2) {
              e3 = +e3, t3 >>>= 0, r3 >>>= 0, n2 || j(this, e3, t3, r3, Math.pow(2, 8 * r3) - 1, 0);
              let s3 = r3 - 1, i2 = 1;
              for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i2 *= 256); )
                this[t3 + s3] = e3 / i2 & 255;
              return t3 + r3;
            }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 1, 255, 0), this[t3] = 255 & e3, t3 + 1;
            }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 65535, 0), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
            }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 65535, 0), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
            }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 4294967295, 0), this[t3 + 3] = e3 >>> 24, this[t3 + 2] = e3 >>> 16, this[t3 + 1] = e3 >>> 8, this[t3] = 255 & e3, t3 + 4;
            }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 4294967295, 0), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
            }, l.prototype.writeBigUInt64LE = Q(function(e3, t3 = 0) {
              return D(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
            }), l.prototype.writeBigUInt64BE = Q(function(e3, t3 = 0) {
              return L(this, e3, t3, BigInt(0), BigInt("0xffffffffffffffff"));
            }), l.prototype.writeIntLE = function(e3, t3, r3, n2) {
              if (e3 = +e3, t3 >>>= 0, !n2) {
                const n3 = Math.pow(2, 8 * r3 - 1);
                j(this, e3, t3, r3, n3 - 1, -n3);
              }
              let s3 = 0, i2 = 1, o2 = 0;
              for (this[t3] = 255 & e3; ++s3 < r3 && (i2 *= 256); )
                e3 < 0 && o2 === 0 && this[t3 + s3 - 1] !== 0 && (o2 = 1), this[t3 + s3] = (e3 / i2 >> 0) - o2 & 255;
              return t3 + r3;
            }, l.prototype.writeIntBE = function(e3, t3, r3, n2) {
              if (e3 = +e3, t3 >>>= 0, !n2) {
                const n3 = Math.pow(2, 8 * r3 - 1);
                j(this, e3, t3, r3, n3 - 1, -n3);
              }
              let s3 = r3 - 1, i2 = 1, o2 = 0;
              for (this[t3 + s3] = 255 & e3; --s3 >= 0 && (i2 *= 256); )
                e3 < 0 && o2 === 0 && this[t3 + s3 + 1] !== 0 && (o2 = 1), this[t3 + s3] = (e3 / i2 >> 0) - o2 & 255;
              return t3 + r3;
            }, l.prototype.writeInt8 = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 1, 127, -128), e3 < 0 && (e3 = 255 + e3 + 1), this[t3] = 255 & e3, t3 + 1;
            }, l.prototype.writeInt16LE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 32767, -32768), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, t3 + 2;
            }, l.prototype.writeInt16BE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 2, 32767, -32768), this[t3] = e3 >>> 8, this[t3 + 1] = 255 & e3, t3 + 2;
            }, l.prototype.writeInt32LE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 2147483647, -2147483648), this[t3] = 255 & e3, this[t3 + 1] = e3 >>> 8, this[t3 + 2] = e3 >>> 16, this[t3 + 3] = e3 >>> 24, t3 + 4;
            }, l.prototype.writeInt32BE = function(e3, t3, r3) {
              return e3 = +e3, t3 >>>= 0, r3 || j(this, e3, t3, 4, 2147483647, -2147483648), e3 < 0 && (e3 = 4294967295 + e3 + 1), this[t3] = e3 >>> 24, this[t3 + 1] = e3 >>> 16, this[t3 + 2] = e3 >>> 8, this[t3 + 3] = 255 & e3, t3 + 4;
            }, l.prototype.writeBigInt64LE = Q(function(e3, t3 = 0) {
              return D(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), l.prototype.writeBigInt64BE = Q(function(e3, t3 = 0) {
              return L(this, e3, t3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
            }), l.prototype.writeFloatLE = function(e3, t3, r3) {
              return B(this, e3, t3, true, r3);
            }, l.prototype.writeFloatBE = function(e3, t3, r3) {
              return B(this, e3, t3, false, r3);
            }, l.prototype.writeDoubleLE = function(e3, t3, r3) {
              return R(this, e3, t3, true, r3);
            }, l.prototype.writeDoubleBE = function(e3, t3, r3) {
              return R(this, e3, t3, false, r3);
            }, l.prototype.copy = function(e3, t3, r3, n2) {
              if (!l.isBuffer(e3))
                throw new TypeError("argument should be a Buffer");
              if (r3 || (r3 = 0), n2 || n2 === 0 || (n2 = this.length), t3 >= e3.length && (t3 = e3.length), t3 || (t3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3)
                return 0;
              if (e3.length === 0 || this.length === 0)
                return 0;
              if (t3 < 0)
                throw new RangeError("targetStart out of bounds");
              if (r3 < 0 || r3 >= this.length)
                throw new RangeError("Index out of range");
              if (n2 < 0)
                throw new RangeError("sourceEnd out of bounds");
              n2 > this.length && (n2 = this.length), e3.length - t3 < n2 - r3 && (n2 = e3.length - t3 + r3);
              const s3 = n2 - r3;
              return this === e3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t3, r3, n2) : Uint8Array.prototype.set.call(e3, this.subarray(r3, n2), t3), s3;
            }, l.prototype.fill = function(e3, t3, r3, n2) {
              if (typeof e3 == "string") {
                if (typeof t3 == "string" ? (n2 = t3, t3 = 0, r3 = this.length) : typeof r3 == "string" && (n2 = r3, r3 = this.length), n2 !== void 0 && typeof n2 != "string")
                  throw new TypeError("encoding must be a string");
                if (typeof n2 == "string" && !l.isEncoding(n2))
                  throw new TypeError("Unknown encoding: " + n2);
                if (e3.length === 1) {
                  const t4 = e3.charCodeAt(0);
                  (n2 === "utf8" && t4 < 128 || n2 === "latin1") && (e3 = t4);
                }
              } else
                typeof e3 == "number" ? e3 &= 255 : typeof e3 == "boolean" && (e3 = Number(e3));
              if (t3 < 0 || this.length < t3 || this.length < r3)
                throw new RangeError("Out of range index");
              if (r3 <= t3)
                return this;
              let s3;
              if (t3 >>>= 0, r3 = r3 === void 0 ? this.length : r3 >>> 0, e3 || (e3 = 0), typeof e3 == "number")
                for (s3 = t3; s3 < r3; ++s3)
                  this[s3] = e3;
              else {
                const i2 = l.isBuffer(e3) ? e3 : l.from(e3, n2), o2 = i2.length;
                if (o2 === 0)
                  throw new TypeError('The value "' + e3 + '" is invalid for argument "value"');
                for (s3 = 0; s3 < r3 - t3; ++s3)
                  this[s3 + t3] = i2[s3 % o2];
              }
              return this;
            };
            const F = {};
            function U(e3, t3, r3) {
              F[e3] = class extends r3 {
                constructor() {
                  super(), Object.defineProperty(this, "message", { value: t3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${e3}]`, this.stack, delete this.name;
                }
                get code() {
                  return e3;
                }
                set code(e4) {
                  Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: e4, writable: true });
                }
                toString() {
                  return `${this.name} [${e3}]: ${this.message}`;
                }
              };
            }
            function $(e3) {
              let t3 = "", r3 = e3.length;
              const n2 = e3[0] === "-" ? 1 : 0;
              for (; r3 >= n2 + 4; r3 -= 3)
                t3 = `_${e3.slice(r3 - 3, r3)}${t3}`;
              return `${e3.slice(0, r3)}${t3}`;
            }
            function q(e3, t3, r3, n2, s3, i2) {
              if (e3 > r3 || e3 < t3) {
                const n3 = typeof t3 == "bigint" ? "n" : "";
                let s4;
                throw s4 = i2 > 3 ? t3 === 0 || t3 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (i2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (i2 + 1) - 1}${n3}) and < 2 ** ${8 * (i2 + 1) - 1}${n3}` : `>= ${t3}${n3} and <= ${r3}${n3}`, new F.ERR_OUT_OF_RANGE("value", s4, e3);
              }
              !function(e4, t4, r4) {
                V(t4, "offset"), e4[t4] !== void 0 && e4[t4 + r4] !== void 0 || W(t4, e4.length - (r4 + 1));
              }(n2, s3, i2);
            }
            function V(e3, t3) {
              if (typeof e3 != "number")
                throw new F.ERR_INVALID_ARG_TYPE(t3, "number", e3);
            }
            function W(e3, t3, r3) {
              if (Math.floor(e3) !== e3)
                throw V(e3, r3), new F.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", e3);
              if (t3 < 0)
                throw new F.ERR_BUFFER_OUT_OF_BOUNDS();
              throw new F.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${t3}`, e3);
            }
            U("ERR_BUFFER_OUT_OF_BOUNDS", function(e3) {
              return e3 ? `${e3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
            }, RangeError), U("ERR_INVALID_ARG_TYPE", function(e3, t3) {
              return `The "${e3}" argument must be of type number. Received type ${typeof t3}`;
            }, TypeError), U("ERR_OUT_OF_RANGE", function(e3, t3, r3) {
              let n2 = `The value of "${e3}" is out of range.`, s3 = r3;
              return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? s3 = $(String(r3)) : typeof r3 == "bigint" && (s3 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (s3 = $(s3)), s3 += "n"), n2 += ` It must be ${t3}. Received ${s3}`, n2;
            }, RangeError);
            const K = /[^+/0-9A-Za-z-_]/g;
            function G(e3, t3) {
              let r3;
              t3 = t3 || 1 / 0;
              const n2 = e3.length;
              let s3 = null;
              const i2 = [];
              for (let o2 = 0; o2 < n2; ++o2) {
                if (r3 = e3.charCodeAt(o2), r3 > 55295 && r3 < 57344) {
                  if (!s3) {
                    if (r3 > 56319) {
                      (t3 -= 3) > -1 && i2.push(239, 191, 189);
                      continue;
                    }
                    if (o2 + 1 === n2) {
                      (t3 -= 3) > -1 && i2.push(239, 191, 189);
                      continue;
                    }
                    s3 = r3;
                    continue;
                  }
                  if (r3 < 56320) {
                    (t3 -= 3) > -1 && i2.push(239, 191, 189), s3 = r3;
                    continue;
                  }
                  r3 = 65536 + (s3 - 55296 << 10 | r3 - 56320);
                } else
                  s3 && (t3 -= 3) > -1 && i2.push(239, 191, 189);
                if (s3 = null, r3 < 128) {
                  if ((t3 -= 1) < 0)
                    break;
                  i2.push(r3);
                } else if (r3 < 2048) {
                  if ((t3 -= 2) < 0)
                    break;
                  i2.push(r3 >> 6 | 192, 63 & r3 | 128);
                } else if (r3 < 65536) {
                  if ((t3 -= 3) < 0)
                    break;
                  i2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
                } else {
                  if (!(r3 < 1114112))
                    throw new Error("Invalid code point");
                  if ((t3 -= 4) < 0)
                    break;
                  i2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
                }
              }
              return i2;
            }
            function H(e3) {
              return n.toByteArray(function(e4) {
                if ((e4 = (e4 = e4.split("=")[0]).trim().replace(K, "")).length < 2)
                  return "";
                for (; e4.length % 4 != 0; )
                  e4 += "=";
                return e4;
              }(e3));
            }
            function J(e3, t3, r3, n2) {
              let s3;
              for (s3 = 0; s3 < n2 && !(s3 + r3 >= t3.length || s3 >= e3.length); ++s3)
                t3[s3 + r3] = e3[s3];
              return s3;
            }
            function Y(e3, t3) {
              return e3 instanceof t3 || e3 != null && e3.constructor != null && e3.constructor.name != null && e3.constructor.name === t3.name;
            }
            function X(e3) {
              return e3 != e3;
            }
            const z = function() {
              const e3 = "0123456789abcdef", t3 = new Array(256);
              for (let r3 = 0; r3 < 16; ++r3) {
                const n2 = 16 * r3;
                for (let s3 = 0; s3 < 16; ++s3)
                  t3[n2 + s3] = e3[r3] + e3[s3];
              }
              return t3;
            }();
            function Q(e3) {
              return typeof BigInt == "undefined" ? Z : e3;
            }
            function Z() {
              throw new Error("BigInt not supported");
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = true) {
              return typeof e3 == "string" && ((!t3 || !(0, n.isKeyword)(e3) && !(0, n.isStrictReservedWord)(e3, true)) && (0, n.isIdentifierName)(e3));
            };
            var n = r2(63);
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7);
            Object.defineProperty(t2, "__esModule", { value: true }), t2.codeFrameColumns = a, t2.default = function(e3, t3, r3, s3 = {}) {
              if (!i) {
                i = true;
                const e4 = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
                n.emitWarning ? n.emitWarning(e4, "DeprecationWarning") : new Error(e4).name = "DeprecationWarning";
              }
              return a(e3, { start: { column: r3 = Math.max(r3, 0), line: t3 } }, s3);
            };
            var s2 = r2(438);
            let i = false;
            const o = /\r\n|[\n\r\u2028\u2029]/;
            function a(e3, t3, r3 = {}) {
              const n2 = (r3.highlightCode || r3.forceColor) && (0, s2.shouldHighlight)(r3), i2 = (0, s2.getChalk)(r3), a2 = function(e4) {
                return { gutter: e4.grey, marker: e4.red.bold, message: e4.red.bold };
              }(i2), l = (e4, t4) => n2 ? e4(t4) : t4, c = e3.split(o), { start: u, end: p2, markerLines: f } = function(e4, t4, r4) {
                const n3 = Object.assign({ column: 0, line: -1 }, e4.start), s3 = Object.assign({}, n3, e4.end), { linesAbove: i3 = 2, linesBelow: o2 = 3 } = r4 || {}, a3 = n3.line, l2 = n3.column, c4 = s3.line, u2 = s3.column;
                let p3 = Math.max(a3 - (i3 + 1), 0), f2 = Math.min(t4.length, c4 + o2);
                a3 === -1 && (p3 = 0), c4 === -1 && (f2 = t4.length);
                const d2 = c4 - a3, h4 = {};
                if (d2)
                  for (let e5 = 0; e5 <= d2; e5++) {
                    const r5 = e5 + a3;
                    if (l2)
                      if (e5 === 0) {
                        const e6 = t4[r5 - 1].length;
                        h4[r5] = [l2, e6 - l2 + 1];
                      } else if (e5 === d2)
                        h4[r5] = [0, u2];
                      else {
                        const n4 = t4[r5 - e5].length;
                        h4[r5] = [0, n4];
                      }
                    else
                      h4[r5] = true;
                  }
                else
                  h4[a3] = l2 === u2 ? !l2 || [l2, 0] : [l2, u2 - l2];
                return { start: p3, end: f2, markerLines: h4 };
              }(t3, c, r3), d = t3.start && typeof t3.start.column == "number", h3 = String(p2).length;
              let m = (n2 ? (0, s2.default)(e3, r3) : e3).split(o).slice(u, p2).map((e4, t4) => {
                const n3 = u + 1 + t4, s3 = ` ${` ${n3}`.slice(-h3)} |`, i3 = f[n3], o2 = !f[n3 + 1];
                if (i3) {
                  let t5 = "";
                  if (Array.isArray(i3)) {
                    const n4 = e4.slice(0, Math.max(i3[0] - 1, 0)).replace(/[^\t]/g, " "), c4 = i3[1] || 1;
                    t5 = ["\n ", l(a2.gutter, s3.replace(/\d/g, " ")), " ", n4, l(a2.marker, "^").repeat(c4)].join(""), o2 && r3.message && (t5 += " " + l(a2.message, r3.message));
                  }
                  return [l(a2.marker, ">"), l(a2.gutter, s3), e4.length > 0 ? ` ${e4}` : "", t5].join("");
                }
                return ` ${l(a2.gutter, s3)}${e4.length > 0 ? ` ${e4}` : ""}`;
              }).join("\n");
              return r3.message && !d && (m = `${" ".repeat(h3 + 1)}${r3.message}
${m}`), n2 ? i2.reset(m) : m;
            }
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(251), s2 = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", i = Object.prototype.toString, o = Array.prototype.concat, a = Object.defineProperty, l = a && function() {
              var e3 = {};
              try {
                for (var t3 in a(e3, "x", { enumerable: false, value: e3 }), e3)
                  return false;
                return e3.x === e3;
              } catch (e4) {
                return false;
              }
            }(), c = function(e3, t3, r3, n2) {
              var s3;
              (!(t3 in e3) || typeof (s3 = n2) == "function" && i.call(s3) === "[object Function]" && n2()) && (l ? a(e3, t3, { configurable: true, enumerable: false, value: r3, writable: true }) : e3[t3] = r3);
            }, u = function(e3, t3) {
              var r3 = arguments.length > 2 ? arguments[2] : {}, i2 = n(t3);
              s2 && (i2 = o.call(i2, Object.getOwnPropertySymbols(t3)));
              for (var a2 = 0; a2 < i2.length; a2 += 1)
                c(e3, i2[a2], t3[i2[a2]], r3[i2[a2]]);
            };
            u.supportsDescriptors = !!l, e2.exports = u;
          }, (e2) => {
            const t2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
            e2.exports = { SEMVER_SPEC_VERSION: "2.0.0", MAX_LENGTH: 256, MAX_SAFE_INTEGER: t2, MAX_SAFE_COMPONENT_LENGTH: 16 };
          }, (e2, t2, r2) => {
            var n = r2(7);
            const s2 = (typeof n == "object" && n.env, () => {
            });
            e2.exports = s2;
          }, (e2) => {
            const t2 = ["includePrerelease", "loose", "rtl"];
            e2.exports = (e3) => e3 ? typeof e3 != "object" ? { loose: true } : t2.filter((t3) => e3[t3]).reduce((e4, t3) => (e4[t3] = true, e4), {}) : {};
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) > 0;
          }, (e2, t2, r2) => {
            const n = Symbol("SemVer ANY");
            class s2 {
              static get ANY() {
                return n;
              }
              constructor(e3, t3) {
                if (t3 = i(t3), e3 instanceof s2) {
                  if (e3.loose === !!t3.loose)
                    return e3;
                  e3 = e3.value;
                }
                c("comparator", e3, t3), this.options = t3, this.loose = !!t3.loose, this.parse(e3), this.semver === n ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
              }
              parse(e3) {
                const t3 = this.options.loose ? o[a.COMPARATORLOOSE] : o[a.COMPARATOR], r3 = e3.match(t3);
                if (!r3)
                  throw new TypeError(`Invalid comparator: ${e3}`);
                this.operator = r3[1] !== void 0 ? r3[1] : "", this.operator === "=" && (this.operator = ""), r3[2] ? this.semver = new u(r3[2], this.options.loose) : this.semver = n;
              }
              toString() {
                return this.value;
              }
              test(e3) {
                if (c("Comparator.test", e3, this.options.loose), this.semver === n || e3 === n)
                  return true;
                if (typeof e3 == "string")
                  try {
                    e3 = new u(e3, this.options);
                  } catch (e4) {
                    return false;
                  }
                return l(e3, this.operator, this.semver, this.options);
              }
              intersects(e3, t3) {
                if (!(e3 instanceof s2))
                  throw new TypeError("a Comparator is required");
                if (t3 && typeof t3 == "object" || (t3 = { loose: !!t3, includePrerelease: false }), this.operator === "")
                  return this.value === "" || new p2(e3.value, t3).test(this.value);
                if (e3.operator === "")
                  return e3.value === "" || new p2(this.value, t3).test(e3.semver);
                const r3 = !(this.operator !== ">=" && this.operator !== ">" || e3.operator !== ">=" && e3.operator !== ">"), n2 = !(this.operator !== "<=" && this.operator !== "<" || e3.operator !== "<=" && e3.operator !== "<"), i2 = this.semver.version === e3.semver.version, o2 = !(this.operator !== ">=" && this.operator !== "<=" || e3.operator !== ">=" && e3.operator !== "<="), a2 = l(this.semver, "<", e3.semver, t3) && (this.operator === ">=" || this.operator === ">") && (e3.operator === "<=" || e3.operator === "<"), c4 = l(this.semver, ">", e3.semver, t3) && (this.operator === "<=" || this.operator === "<") && (e3.operator === ">=" || e3.operator === ">");
                return r3 || n2 || i2 && o2 || a2 || c4;
              }
            }
            e2.exports = s2;
            const i = r2(43), { re: o, t: a } = r2(23), l = r2(148), c = r2(42), u = r2(3), p2 = r2(13);
          }, (e2, t2, r2) => {
            const n = r2(13);
            e2.exports = (e3, t3, r3) => {
              try {
                t3 = new n(t3, r3);
              } catch (e4) {
                return false;
              }
              return t3.test(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(48);
            class s2 extends n {
              constructor(e3) {
                e3 && e3.value !== void 0 && typeof e3.value != "string" && (e3 = { ...e3, value: String(e3.value) }), super(e3), this.type = "decl";
              }
              get variable() {
                return this.prop.startsWith("--") || this.prop[0] === "$";
              }
            }
            e2.exports = s2, s2.default = s2;
          }, (e2, t2, r2) => {
            "use strict";
            let { isClean: n, my: s2 } = r2(154), i = r2(85), o = r2(155), a = r2(86);
            function l(e3, t3) {
              let r3 = new e3.constructor();
              for (let n2 in e3) {
                if (!Object.prototype.hasOwnProperty.call(e3, n2))
                  continue;
                if (n2 === "proxyCache")
                  continue;
                let s3 = e3[n2], i2 = typeof s3;
                n2 === "parent" && i2 === "object" ? t3 && (r3[n2] = t3) : n2 === "source" ? r3[n2] = s3 : Array.isArray(s3) ? r3[n2] = s3.map((e4) => l(e4, r3)) : (i2 === "object" && s3 !== null && (s3 = l(s3)), r3[n2] = s3);
              }
              return r3;
            }
            class c {
              constructor(e3 = {}) {
                this.raws = {}, this[n] = false, this[s2] = true;
                for (let t3 in e3)
                  if (t3 === "nodes") {
                    this.nodes = [];
                    for (let r3 of e3[t3])
                      typeof r3.clone == "function" ? this.append(r3.clone()) : this.append(r3);
                  } else
                    this[t3] = e3[t3];
              }
              error(e3, t3 = {}) {
                if (this.source) {
                  let r3 = this.positionBy(t3);
                  return this.source.input.error(e3, r3.line, r3.column, t3);
                }
                return new i(e3);
              }
              warn(e3, t3, r3) {
                let n2 = { node: this };
                for (let e4 in r3)
                  n2[e4] = r3[e4];
                return e3.warn(t3, n2);
              }
              remove() {
                return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
              }
              toString(e3 = a) {
                e3.stringify && (e3 = e3.stringify);
                let t3 = "";
                return e3(this, (e4) => {
                  t3 += e4;
                }), t3;
              }
              assign(e3 = {}) {
                for (let t3 in e3)
                  this[t3] = e3[t3];
                return this;
              }
              clone(e3 = {}) {
                let t3 = l(this);
                for (let r3 in e3)
                  t3[r3] = e3[r3];
                return t3;
              }
              cloneBefore(e3 = {}) {
                let t3 = this.clone(e3);
                return this.parent.insertBefore(this, t3), t3;
              }
              cloneAfter(e3 = {}) {
                let t3 = this.clone(e3);
                return this.parent.insertAfter(this, t3), t3;
              }
              replaceWith(...e3) {
                if (this.parent) {
                  let t3 = this, r3 = false;
                  for (let n2 of e3)
                    n2 === this ? r3 = true : r3 ? (this.parent.insertAfter(t3, n2), t3 = n2) : this.parent.insertBefore(t3, n2);
                  r3 || this.remove();
                }
                return this;
              }
              next() {
                if (!this.parent)
                  return;
                let e3 = this.parent.index(this);
                return this.parent.nodes[e3 + 1];
              }
              prev() {
                if (!this.parent)
                  return;
                let e3 = this.parent.index(this);
                return this.parent.nodes[e3 - 1];
              }
              before(e3) {
                return this.parent.insertBefore(this, e3), this;
              }
              after(e3) {
                return this.parent.insertAfter(this, e3), this;
              }
              root() {
                let e3 = this;
                for (; e3.parent && e3.parent.type !== "document"; )
                  e3 = e3.parent;
                return e3;
              }
              raw(e3, t3) {
                return new o().raw(this, e3, t3);
              }
              cleanRaws(e3) {
                delete this.raws.before, delete this.raws.after, e3 || delete this.raws.between;
              }
              toJSON(e3, t3) {
                let r3 = {}, n2 = t3 == null;
                t3 = t3 || new Map();
                let s3 = 0;
                for (let e4 in this) {
                  if (!Object.prototype.hasOwnProperty.call(this, e4))
                    continue;
                  if (e4 === "parent" || e4 === "proxyCache")
                    continue;
                  let n3 = this[e4];
                  if (Array.isArray(n3))
                    r3[e4] = n3.map((e5) => typeof e5 == "object" && e5.toJSON ? e5.toJSON(null, t3) : e5);
                  else if (typeof n3 == "object" && n3.toJSON)
                    r3[e4] = n3.toJSON(null, t3);
                  else if (e4 === "source") {
                    let i2 = t3.get(n3.input);
                    i2 == null && (i2 = s3, t3.set(n3.input, s3), s3++), r3[e4] = { inputId: i2, start: n3.start, end: n3.end };
                  } else
                    r3[e4] = n3;
                }
                return n2 && (r3.inputs = [...t3.keys()].map((e4) => e4.toJSON())), r3;
              }
              positionInside(e3) {
                let t3 = this.toString(), r3 = this.source.start.column, n2 = this.source.start.line;
                for (let s3 = 0; s3 < e3; s3++)
                  t3[s3] === "\n" ? (r3 = 1, n2 += 1) : r3 += 1;
                return { line: n2, column: r3 };
              }
              positionBy(e3) {
                let t3 = this.source.start;
                if (e3.index)
                  t3 = this.positionInside(e3.index);
                else if (e3.word) {
                  let r3 = this.toString().indexOf(e3.word);
                  r3 !== -1 && (t3 = this.positionInside(r3));
                }
                return t3;
              }
              getProxyProcessor() {
                return { set: (e3, t3, r3) => (e3[t3] === r3 || (e3[t3] = r3, t3 !== "prop" && t3 !== "value" && t3 !== "name" && t3 !== "params" && t3 !== "important" && t3 !== "text" || e3.markDirty()), true), get: (e3, t3) => t3 === "proxyOf" ? e3 : t3 === "root" ? () => e3.root().toProxy() : e3[t3] };
              }
              toProxy() {
                return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
              }
              addToError(e3) {
                if (e3.postcssNode = this, e3.stack && this.source && /\n\s{4}at /.test(e3.stack)) {
                  let t3 = this.source;
                  e3.stack = e3.stack.replace(/\n\s{4}at /, `$&${t3.input.from}:${t3.start.line}:${t3.start.column}$&`);
                }
                return e3;
              }
              markDirty() {
                if (this[n]) {
                  this[n] = false;
                  let e3 = this;
                  for (; e3 = e3.parent; )
                    e3[n] = false;
                }
              }
              get proxyOf() {
                return this;
              }
            }
            e2.exports = c, c.default = c;
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(48);
            class s2 extends n {
              constructor(e3) {
                super(e3), this.type = "comment";
              }
            }
            e2.exports = s2, s2.default = s2;
          }, function(e2, t2, r2) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), Object.defineProperty(e3, n2, { enumerable: true, get: function() {
                return t3[r3];
              } });
            } : function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), e3[n2] = t3[r3];
            }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
              Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
            } : function(e3, t3) {
              e3.default = t3;
            }), i = this && this.__importStar || function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = {};
              if (e3 != null)
                for (var r3 in e3)
                  r3 !== "default" && Object.prototype.hasOwnProperty.call(e3, r3) && n(t3, e3, r3);
              return s2(t3, e3), t3;
            }, o = this && this.__importDefault || function(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            };
            Object.defineProperty(t2, "__esModule", { value: true }), t2.transformJSXSpreadAttribute = t2.isConstant = t2.dedupeProperties = t2.isOn = t2.buildIIFE = t2.walksScope = t2.transformJSXSpreadChild = t2.transformJSXExpressionContainer = t2.transformJSXText = t2.getJSXAttributeName = t2.getTag = t2.transformJSXMemberExpression = t2.checkIsComponent = t2.shouldTransformedToSlots = t2.isDirective = t2.createIdentifier = t2.KEEP_ALIVE = t2.FRAGMENT = t2.JSX_HELPER_KEY = void 0;
            const a = i(r2(0)), l = o(r2(532)), c = o(r2(534));
            t2.JSX_HELPER_KEY = "JSX_HELPER_KEY", t2.FRAGMENT = "Fragment", t2.KEEP_ALIVE = "KeepAlive", t2.createIdentifier = (e3, t3) => e3.get(t3)(), t2.isDirective = (e3) => e3.startsWith("v-") || e3.startsWith("v") && e3.length >= 2 && e3[1] >= "A" && e3[1] <= "Z", t2.shouldTransformedToSlots = (e3) => !(e3.endsWith(t2.FRAGMENT) || e3 === t2.KEEP_ALIVE), t2.checkIsComponent = (e3) => {
              const r3 = e3.get("name");
              if (r3.isJSXMemberExpression())
                return t2.shouldTransformedToSlots(r3.node.property.name);
              const n2 = r3.node.name;
              return t2.shouldTransformedToSlots(n2) && !l.default.includes(n2) && !c.default.includes(n2);
            }, t2.transformJSXMemberExpression = (e3) => {
              const r3 = e3.node.object, n2 = e3.node.property, s3 = a.isJSXMemberExpression(r3) ? t2.transformJSXMemberExpression(e3.get("object")) : a.isJSXIdentifier(r3) ? a.identifier(r3.name) : a.nullLiteral(), i2 = a.identifier(n2.name);
              return a.memberExpression(s3, i2);
            }, t2.getTag = (e3, r3) => {
              var n2, s3;
              const i2 = e3.get("openingElement").get("name");
              if (i2.isJSXIdentifier()) {
                const { name: o2 } = i2.node;
                return l.default.includes(o2) || c.default.includes(o2) ? a.stringLiteral(o2) : o2 === t2.FRAGMENT ? t2.createIdentifier(r3, t2.FRAGMENT) : e3.scope.hasBinding(o2) ? a.identifier(o2) : ((s3 = (n2 = r3.opts).isCustomElement) === null || s3 === void 0 ? void 0 : s3.call(n2, o2)) ? a.stringLiteral(o2) : a.callExpression(t2.createIdentifier(r3, "resolveComponent"), [a.stringLiteral(o2)]);
              }
              if (i2.isJSXMemberExpression())
                return t2.transformJSXMemberExpression(i2);
              throw new Error(`getTag: ${i2.type} is not supported`);
            }, t2.getJSXAttributeName = (e3) => {
              const t3 = e3.node.name;
              return a.isJSXIdentifier(t3) ? t3.name : `${t3.namespace.name}:${t3.name.name}`;
            }, t2.transformJSXText = (e3) => {
              const { node: t3 } = e3, r3 = t3.value.split(/\r\n|\n|\r/);
              let n2 = 0;
              for (let e4 = 0; e4 < r3.length; e4++)
                r3[e4].match(/[^ \t]/) && (n2 = e4);
              let s3 = "";
              for (let e4 = 0; e4 < r3.length; e4++) {
                const t4 = r3[e4], i2 = e4 === 0, o2 = e4 === r3.length - 1, a2 = e4 === n2;
                let l2 = t4.replace(/\t/g, " ");
                i2 || (l2 = l2.replace(/^[ ]+/, "")), o2 || (l2 = l2.replace(/[ ]+$/, "")), l2 && (a2 || (l2 += " "), s3 += l2);
              }
              return s3 !== "" ? a.stringLiteral(s3) : null;
            }, t2.transformJSXExpressionContainer = (e3) => e3.get("expression").node, t2.transformJSXSpreadChild = (e3) => a.spreadElement(e3.get("expression").node), t2.walksScope = (e3, r3, n2) => {
              e3.scope.hasBinding(r3) && e3.parentPath && (a.isJSXElement(e3.parentPath.node) && e3.parentPath.setData("slotFlag", n2), t2.walksScope(e3.parentPath, r3, n2));
            }, t2.buildIIFE = (e3, t3) => {
              const { parentPath: r3 } = e3;
              if (a.isAssignmentExpression(r3)) {
                const { left: n2 } = r3.node;
                if (a.isIdentifier(n2))
                  return t3.map((t4) => {
                    if (a.isIdentifier(t4) && t4.name === n2.name) {
                      const n3 = e3.scope.generateUidIdentifier(t4.name);
                      return r3.insertBefore(a.variableDeclaration("const", [a.variableDeclarator(n3, a.callExpression(a.functionExpression(null, [], a.blockStatement([a.returnStatement(t4)])), []))])), n3;
                    }
                    return t4;
                  });
              }
              return t3;
            };
            const u = /^on[^a-z]/;
            t2.isOn = (e3) => u.test(e3), t2.dedupeProperties = (e3 = [], t3) => {
              if (!t3)
                return e3;
              const r3 = new Map(), n2 = [];
              return e3.forEach((e4) => {
                if (a.isStringLiteral(e4.key)) {
                  const { value: t4 } = e4.key, s3 = r3.get(t4);
                  s3 ? (t4 === "style" || t4 === "class" || t4.startsWith("on")) && ((e5, t5) => {
                    a.isArrayExpression(e5.value) ? e5.value.elements.push(t5.value) : e5.value = a.arrayExpression([e5.value, t5.value]);
                  })(s3, e4) : (r3.set(t4, e4), n2.push(e4));
                } else
                  n2.push(e4);
              }), n2;
            }, t2.isConstant = (e3) => {
              if (a.isIdentifier(e3))
                return e3.name === "undefined";
              if (a.isArrayExpression(e3)) {
                const { elements: r3 } = e3;
                return r3.every((e4) => e4 && t2.isConstant(e4));
              }
              return a.isObjectExpression(e3) ? e3.properties.every((e4) => t2.isConstant(e4.value)) : !!a.isLiteral(e3);
            }, t2.transformJSXSpreadAttribute = (e3, r3, n2, s3) => {
              const i2 = r3.get("argument"), o2 = a.isObjectExpression(i2.node) ? i2.node.properties : void 0;
              o2 ? n2 ? s3.push(a.objectExpression(o2)) : s3.push(...o2) : (i2.isIdentifier() && t2.walksScope(e3, i2.node.name, 2), s3.push(n2 ? i2.node : a.spreadElement(i2.node)));
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(69), s2 = r2(67), i = s2("%Function.prototype.apply%"), o = s2("%Function.prototype.call%"), a = s2("%Reflect.apply%", true) || n.call(o, i), l = s2("%Object.getOwnPropertyDescriptor%", true), c = s2("%Object.defineProperty%", true), u = s2("%Math.max%");
            if (c)
              try {
                c({}, "a", { value: 1 });
              } catch (e3) {
                c = null;
              }
            e2.exports = function(e3) {
              var t3 = a(n, o, arguments);
              if (l && c) {
                var r3 = l(t3, "length");
                r3.configurable && c(t3, "length", { value: 1 + u(0, e3.length - (arguments.length - 1)) });
              }
              return t3;
            };
            var p2 = function() {
              return a(n, i, arguments);
            };
            c ? c(e2.exports, "apply", { value: p2 }) : e2.exports.apply = p2;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
                return { default: e3 };
              var t3 = o();
              if (t3 && t3.has(e3))
                return t3.get(e3);
              var r3 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var s3 in e3)
                if (Object.prototype.hasOwnProperty.call(e3, s3)) {
                  var i2 = n2 ? Object.getOwnPropertyDescriptor(e3, s3) : null;
                  i2 && (i2.get || i2.set) ? Object.defineProperty(r3, s3, i2) : r3[s3] = e3[s3];
                }
              return r3.default = e3, t3 && t3.set(e3, r3), r3;
            }(r2(5));
            function o() {
              if (typeof WeakMap != "function")
                return null;
              var e3 = new WeakMap();
              return o = function() {
                return e3;
              }, e3;
            }
            function a(e3, t3) {
              (t3 == null || t3 > e3.length) && (t3 = e3.length);
              for (var r3 = 0, n2 = new Array(t3); r3 < t3; r3++)
                n2[r3] = e3[r3];
              return n2;
            }
            function l(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function c(e3, t3) {
              return (c = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var u = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).nodes || (r4.nodes = []), r4;
              }
              r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, c(t3, r3);
              var s3, o2, u2 = n2.prototype;
              return u2.append = function(e4) {
                return e4.parent = this, this.nodes.push(e4), this;
              }, u2.prepend = function(e4) {
                return e4.parent = this, this.nodes.unshift(e4), this;
              }, u2.at = function(e4) {
                return this.nodes[e4];
              }, u2.index = function(e4) {
                return typeof e4 == "number" ? e4 : this.nodes.indexOf(e4);
              }, u2.removeChild = function(e4) {
                var t4;
                for (var r4 in e4 = this.index(e4), this.at(e4).parent = void 0, this.nodes.splice(e4, 1), this.indexes)
                  (t4 = this.indexes[r4]) >= e4 && (this.indexes[r4] = t4 - 1);
                return this;
              }, u2.removeAll = function() {
                for (var e4, t4 = function(e5, t5) {
                  var r4;
                  if (typeof Symbol == "undefined" || e5[Symbol.iterator] == null) {
                    if (Array.isArray(e5) || (r4 = function(e6, t6) {
                      if (e6) {
                        if (typeof e6 == "string")
                          return a(e6, t6);
                        var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                        return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? a(e6, t6) : void 0;
                      }
                    }(e5)) || t5 && e5 && typeof e5.length == "number") {
                      r4 && (e5 = r4);
                      var n3 = 0;
                      return function() {
                        return n3 >= e5.length ? { done: true } : { done: false, value: e5[n3++] };
                      };
                    }
                    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                  }
                  return (r4 = e5[Symbol.iterator]()).next.bind(r4);
                }(this.nodes); !(e4 = t4()).done; )
                  e4.value.parent = void 0;
                return this.nodes = [], this;
              }, u2.empty = function() {
                return this.removeAll();
              }, u2.insertAfter = function(e4, t4) {
                t4.parent = this;
                var r4, n3 = this.index(e4);
                for (var s4 in this.nodes.splice(n3 + 1, 0, t4), t4.parent = this, this.indexes)
                  n3 <= (r4 = this.indexes[s4]) && (this.indexes[s4] = r4 + 1);
                return this;
              }, u2.insertBefore = function(e4, t4) {
                t4.parent = this;
                var r4, n3 = this.index(e4);
                for (var s4 in this.nodes.splice(n3, 0, t4), t4.parent = this, this.indexes)
                  (r4 = this.indexes[s4]) <= n3 && (this.indexes[s4] = r4 + 1);
                return this;
              }, u2._findChildAtPosition = function(e4, t4) {
                var r4 = void 0;
                return this.each(function(n3) {
                  if (n3.atPosition) {
                    var s4 = n3.atPosition(e4, t4);
                    if (s4)
                      return r4 = s4, false;
                  } else if (n3.isAtPosition(e4, t4))
                    return r4 = n3, false;
                }), r4;
              }, u2.atPosition = function(e4, t4) {
                return this.isAtPosition(e4, t4) ? this._findChildAtPosition(e4, t4) || this : void 0;
              }, u2._inferEndPosition = function() {
                this.last && this.last.source && this.last.source.end && (this.source = this.source || {}, this.source.end = this.source.end || {}, Object.assign(this.source.end, this.last.source.end));
              }, u2.each = function(e4) {
                this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach++;
                var t4 = this.lastEach;
                if (this.indexes[t4] = 0, this.length) {
                  for (var r4, n3; this.indexes[t4] < this.length && (r4 = this.indexes[t4], (n3 = e4(this.at(r4), r4)) !== false); )
                    this.indexes[t4] += 1;
                  return delete this.indexes[t4], n3 !== false && void 0;
                }
              }, u2.walk = function(e4) {
                return this.each(function(t4, r4) {
                  var n3 = e4(t4, r4);
                  if (n3 !== false && t4.length && (n3 = t4.walk(e4)), n3 === false)
                    return false;
                });
              }, u2.walkAttributes = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.ATTRIBUTE)
                    return e4.call(t4, r4);
                });
              }, u2.walkClasses = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.CLASS)
                    return e4.call(t4, r4);
                });
              }, u2.walkCombinators = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.COMBINATOR)
                    return e4.call(t4, r4);
                });
              }, u2.walkComments = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.COMMENT)
                    return e4.call(t4, r4);
                });
              }, u2.walkIds = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.ID)
                    return e4.call(t4, r4);
                });
              }, u2.walkNesting = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.NESTING)
                    return e4.call(t4, r4);
                });
              }, u2.walkPseudos = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.PSEUDO)
                    return e4.call(t4, r4);
                });
              }, u2.walkTags = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.TAG)
                    return e4.call(t4, r4);
                });
              }, u2.walkUniversals = function(e4) {
                var t4 = this;
                return this.walk(function(r4) {
                  if (r4.type === i.UNIVERSAL)
                    return e4.call(t4, r4);
                });
              }, u2.split = function(e4) {
                var t4 = this, r4 = [];
                return this.reduce(function(n3, s4, i2) {
                  var o3 = e4.call(t4, s4);
                  return r4.push(s4), o3 ? (n3.push(r4), r4 = []) : i2 === t4.length - 1 && n3.push(r4), n3;
                }, []);
              }, u2.map = function(e4) {
                return this.nodes.map(e4);
              }, u2.reduce = function(e4, t4) {
                return this.nodes.reduce(e4, t4);
              }, u2.every = function(e4) {
                return this.nodes.every(e4);
              }, u2.some = function(e4) {
                return this.nodes.some(e4);
              }, u2.filter = function(e4) {
                return this.nodes.filter(e4);
              }, u2.sort = function(e4) {
                return this.nodes.sort(e4);
              }, u2.toString = function() {
                return this.map(String).join("");
              }, s3 = n2, (o2 = [{ key: "first", get: function() {
                return this.at(0);
              } }, { key: "last", get: function() {
                return this.at(this.length - 1);
              } }, { key: "length", get: function() {
                return this.nodes.length;
              } }]) && l(s3.prototype, o2), n2;
            }(s2.default);
            t2.default = u, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n = i(r2(92)), s2 = r2(91);
            function i(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            function o(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function a(e3, t3) {
              return (a = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var l = function(e3) {
              var t3, r3;
              function i2() {
                return e3.apply(this, arguments) || this;
              }
              r3 = e3, (t3 = i2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, a(t3, r3);
              var l2, c, u = i2.prototype;
              return u.qualifiedName = function(e4) {
                return this.namespace ? this.namespaceString + "|" + e4 : e4;
              }, u.valueToString = function() {
                return this.qualifiedName(e3.prototype.valueToString.call(this));
              }, l2 = i2, (c = [{ key: "namespace", get: function() {
                return this._namespace;
              }, set: function(e4) {
                if (e4 === true || e4 === "*" || e4 === "&")
                  return this._namespace = e4, void (this.raws && delete this.raws.namespace);
                var t4 = (0, n.default)(e4, { isIdentifier: true });
                this._namespace = e4, t4 !== e4 ? ((0, s2.ensureObject)(this, "raws"), this.raws.namespace = t4) : this.raws && delete this.raws.namespace;
              } }, { key: "ns", get: function() {
                return this._namespace;
              }, set: function(e4) {
                this.namespace = e4;
              } }, { key: "namespaceString", get: function() {
                if (this.namespace) {
                  var e4 = this.stringifyProperty("namespace");
                  return e4 === true ? "" : e4;
                }
                return "";
              } }]) && o(l2.prototype, c), i2;
            }(i(r2(15)).default);
            t2.default = l, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(111), i = r2(17), o = r2(58), a = r2(117), l = r2(185), c = s2("wks"), u = n.Symbol, p2 = l ? u : u && u.withoutSetter || o;
            e2.exports = function(e3) {
              return i(c, e3) && (a || typeof c[e3] == "string") || (a && i(u, e3) ? c[e3] = u[e3] : c[e3] = p2("Symbol." + e3)), c[e3];
            };
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(56), i = "__core-js_shared__", o = n[i] || s2(i, {});
            e2.exports = o;
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(32);
            e2.exports = function(e3, t3) {
              try {
                s2(n, e3, t3);
              } catch (r3) {
                n[e3] = t3;
              }
              return t3;
            };
          }, (e2, t2, r2) => {
            var n = r2(24);
            e2.exports = function(e3) {
              if (!n(e3))
                throw TypeError(String(e3) + " is not an object");
              return e3;
            };
          }, (e2) => {
            var t2 = 0, r2 = Math.random();
            e2.exports = function(e3) {
              return "Symbol(" + String(e3 === void 0 ? "" : e3) + ")_" + (++t2 + r2).toString(36);
            };
          }, (e2, t2, r2) => {
            var n = r2(184), s2 = r2(2), i = function(e3) {
              return typeof e3 == "function" ? e3 : void 0;
            };
            e2.exports = function(e3, t3) {
              return arguments.length < 2 ? i(n[e3]) || i(s2[e3]) : n[e3] && n[e3][t3] || s2[e3] && s2[e3][t3];
            };
          }, (e2) => {
            var t2 = {}.toString;
            e2.exports = function(e3) {
              return t2.call(e3).slice(8, -1);
            };
          }, (e2, t2, r2) => {
            var n = r2(198), s2 = r2(110);
            e2.exports = function(e3) {
              return n(s2(e3));
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              return !!t3 && ((0, s2.default)(t3.type, e3) ? r3 === void 0 || (0, n.default)(t3, r3) : !r3 && t3.type === "Placeholder" && e3 in o.FLIPPED_ALIAS_KEYS && (0, i.default)(t3.expectedNode, e3));
            };
            var n = r2(127), s2 = r2(129), i = r2(216), o = r2(11);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "isIdentifierName", { enumerable: true, get: function() {
              return n.isIdentifierName;
            } }), Object.defineProperty(t2, "isIdentifierChar", { enumerable: true, get: function() {
              return n.isIdentifierChar;
            } }), Object.defineProperty(t2, "isIdentifierStart", { enumerable: true, get: function() {
              return n.isIdentifierStart;
            } }), Object.defineProperty(t2, "isReservedWord", { enumerable: true, get: function() {
              return s2.isReservedWord;
            } }), Object.defineProperty(t2, "isStrictBindOnlyReservedWord", { enumerable: true, get: function() {
              return s2.isStrictBindOnlyReservedWord;
            } }), Object.defineProperty(t2, "isStrictBindReservedWord", { enumerable: true, get: function() {
              return s2.isStrictBindReservedWord;
            } }), Object.defineProperty(t2, "isStrictReservedWord", { enumerable: true, get: function() {
              return s2.isStrictReservedWord;
            } }), Object.defineProperty(t2, "isKeyword", { enumerable: true, get: function() {
              return s2.isKeyword;
            } });
            var n = r2(368), s2 = r2(369);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = s2;
            var n = r2(1);
            function s2(e3, t3, r3) {
              let i = [].concat(e3);
              const o = Object.create(null);
              for (; i.length; ) {
                const e4 = i.shift();
                if (!e4)
                  continue;
                const a = s2.keys[e4.type];
                if ((0, n.isIdentifier)(e4))
                  t3 ? (o[e4.name] = o[e4.name] || []).push(e4) : o[e4.name] = e4;
                else if (!(0, n.isExportDeclaration)(e4) || (0, n.isExportAllDeclaration)(e4)) {
                  if (r3) {
                    if ((0, n.isFunctionDeclaration)(e4)) {
                      i.push(e4.id);
                      continue;
                    }
                    if ((0, n.isFunctionExpression)(e4))
                      continue;
                  }
                  if (a)
                    for (let t4 = 0; t4 < a.length; t4++) {
                      const r4 = a[t4];
                      e4[r4] && (i = i.concat(e4[r4]));
                    }
                } else
                  (0, n.isDeclaration)(e4.declaration) && i.push(e4.declaration);
              }
              return o;
            }
            s2.keys = { DeclareClass: ["id"], DeclareFunction: ["id"], DeclareModule: ["id"], DeclareVariable: ["id"], DeclareInterface: ["id"], DeclareTypeAlias: ["id"], DeclareOpaqueType: ["id"], InterfaceDeclaration: ["id"], TypeAlias: ["id"], OpaqueType: ["id"], CatchClause: ["param"], LabeledStatement: ["label"], UnaryExpression: ["argument"], AssignmentExpression: ["left"], ImportSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportDefaultSpecifier: ["local"], ImportDeclaration: ["specifiers"], ExportSpecifier: ["exported"], ExportNamespaceSpecifier: ["exported"], ExportDefaultSpecifier: ["exported"], FunctionDeclaration: ["id", "params"], FunctionExpression: ["id", "params"], ArrowFunctionExpression: ["params"], ObjectMethod: ["params"], ClassMethod: ["params"], ForInStatement: ["left"], ForOfStatement: ["left"], ClassDeclaration: ["id"], ClassExpression: ["id"], RestElement: ["argument"], UpdateExpression: ["argument"], ObjectProperty: ["value"], AssignmentPattern: ["left"], ArrayPattern: ["elements"], ObjectPattern: ["properties"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id"] };
          }, (e2) => {
            e2.exports = function() {
              return function() {
              };
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(67), s2 = r2(51), i = s2(n("String.prototype.indexOf"));
            e2.exports = function(e3, t3) {
              var r3 = n(e3, !!t3);
              return typeof r3 == "function" && i(e3, ".prototype.") > -1 ? s2(r3) : r3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n, s2 = SyntaxError, i = Function, o = TypeError, a = function(e3) {
              try {
                return i('"use strict"; return (' + e3 + ").constructor;")();
              } catch (e4) {
              }
            }, l = Object.getOwnPropertyDescriptor;
            if (l)
              try {
                l({}, "");
              } catch (e3) {
                l = null;
              }
            var c = function() {
              throw new o();
            }, u = l ? function() {
              try {
                return c;
              } catch (e3) {
                try {
                  return l(arguments, "callee").get;
                } catch (e4) {
                  return c;
                }
              }
            }() : c, p2 = r2(68)(), f = Object.getPrototypeOf || function(e3) {
              return e3.__proto__;
            }, d = {}, h3 = typeof Uint8Array == "undefined" ? n : f(Uint8Array), m = { "%AggregateError%": typeof AggregateError == "undefined" ? n : AggregateError, "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer == "undefined" ? n : ArrayBuffer, "%ArrayIteratorPrototype%": p2 ? f([][Symbol.iterator]()) : n, "%AsyncFromSyncIteratorPrototype%": n, "%AsyncFunction%": d, "%AsyncGenerator%": d, "%AsyncGeneratorFunction%": d, "%AsyncIteratorPrototype%": d, "%Atomics%": typeof Atomics == "undefined" ? n : Atomics, "%BigInt%": typeof BigInt == "undefined" ? n : BigInt, "%Boolean%": Boolean, "%DataView%": typeof DataView == "undefined" ? n : DataView, "%Date%": Date, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%eval%": eval, "%EvalError%": EvalError, "%Float32Array%": typeof Float32Array == "undefined" ? n : Float32Array, "%Float64Array%": typeof Float64Array == "undefined" ? n : Float64Array, "%FinalizationRegistry%": typeof FinalizationRegistry == "undefined" ? n : FinalizationRegistry, "%Function%": i, "%GeneratorFunction%": d, "%Int8Array%": typeof Int8Array == "undefined" ? n : Int8Array, "%Int16Array%": typeof Int16Array == "undefined" ? n : Int16Array, "%Int32Array%": typeof Int32Array == "undefined" ? n : Int32Array, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": p2 ? f(f([][Symbol.iterator]())) : n, "%JSON%": typeof JSON == "object" ? JSON : n, "%Map%": typeof Map == "undefined" ? n : Map, "%MapIteratorPrototype%": typeof Map != "undefined" && p2 ? f(new Map()[Symbol.iterator]()) : n, "%Math%": Math, "%Number%": Number, "%Object%": Object, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise == "undefined" ? n : Promise, "%Proxy%": typeof Proxy == "undefined" ? n : Proxy, "%RangeError%": RangeError, "%ReferenceError%": ReferenceError, "%Reflect%": typeof Reflect == "undefined" ? n : Reflect, "%RegExp%": RegExp, "%Set%": typeof Set == "undefined" ? n : Set, "%SetIteratorPrototype%": typeof Set != "undefined" && p2 ? f(new Set()[Symbol.iterator]()) : n, "%SharedArrayBuffer%": typeof SharedArrayBuffer == "undefined" ? n : SharedArrayBuffer, "%String%": String, "%StringIteratorPrototype%": p2 ? f(""[Symbol.iterator]()) : n, "%Symbol%": p2 ? Symbol : n, "%SyntaxError%": s2, "%ThrowTypeError%": u, "%TypedArray%": h3, "%TypeError%": o, "%Uint8Array%": typeof Uint8Array == "undefined" ? n : Uint8Array, "%Uint8ClampedArray%": typeof Uint8ClampedArray == "undefined" ? n : Uint8ClampedArray, "%Uint16Array%": typeof Uint16Array == "undefined" ? n : Uint16Array, "%Uint32Array%": typeof Uint32Array == "undefined" ? n : Uint32Array, "%URIError%": URIError, "%WeakMap%": typeof WeakMap == "undefined" ? n : WeakMap, "%WeakRef%": typeof WeakRef == "undefined" ? n : WeakRef, "%WeakSet%": typeof WeakSet == "undefined" ? n : WeakSet }, y = function e3(t3) {
              var r3;
              if (t3 === "%AsyncFunction%")
                r3 = a("async function () {}");
              else if (t3 === "%GeneratorFunction%")
                r3 = a("function* () {}");
              else if (t3 === "%AsyncGeneratorFunction%")
                r3 = a("async function* () {}");
              else if (t3 === "%AsyncGenerator%") {
                var n2 = e3("%AsyncGeneratorFunction%");
                n2 && (r3 = n2.prototype);
              } else if (t3 === "%AsyncIteratorPrototype%") {
                var s3 = e3("%AsyncGenerator%");
                s3 && (r3 = f(s3.prototype));
              }
              return m[t3] = r3, r3;
            }, g = { "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"], "%ArrayPrototype%": ["Array", "prototype"], "%ArrayProto_entries%": ["Array", "prototype", "entries"], "%ArrayProto_forEach%": ["Array", "prototype", "forEach"], "%ArrayProto_keys%": ["Array", "prototype", "keys"], "%ArrayProto_values%": ["Array", "prototype", "values"], "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"], "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"], "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"], "%BooleanPrototype%": ["Boolean", "prototype"], "%DataViewPrototype%": ["DataView", "prototype"], "%DatePrototype%": ["Date", "prototype"], "%ErrorPrototype%": ["Error", "prototype"], "%EvalErrorPrototype%": ["EvalError", "prototype"], "%Float32ArrayPrototype%": ["Float32Array", "prototype"], "%Float64ArrayPrototype%": ["Float64Array", "prototype"], "%FunctionPrototype%": ["Function", "prototype"], "%Generator%": ["GeneratorFunction", "prototype"], "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"], "%Int8ArrayPrototype%": ["Int8Array", "prototype"], "%Int16ArrayPrototype%": ["Int16Array", "prototype"], "%Int32ArrayPrototype%": ["Int32Array", "prototype"], "%JSONParse%": ["JSON", "parse"], "%JSONStringify%": ["JSON", "stringify"], "%MapPrototype%": ["Map", "prototype"], "%NumberPrototype%": ["Number", "prototype"], "%ObjectPrototype%": ["Object", "prototype"], "%ObjProto_toString%": ["Object", "prototype", "toString"], "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"], "%PromisePrototype%": ["Promise", "prototype"], "%PromiseProto_then%": ["Promise", "prototype", "then"], "%Promise_all%": ["Promise", "all"], "%Promise_reject%": ["Promise", "reject"], "%Promise_resolve%": ["Promise", "resolve"], "%RangeErrorPrototype%": ["RangeError", "prototype"], "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"], "%RegExpPrototype%": ["RegExp", "prototype"], "%SetPrototype%": ["Set", "prototype"], "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"], "%StringPrototype%": ["String", "prototype"], "%SymbolPrototype%": ["Symbol", "prototype"], "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"], "%TypedArrayPrototype%": ["TypedArray", "prototype"], "%TypeErrorPrototype%": ["TypeError", "prototype"], "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"], "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"], "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"], "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"], "%URIErrorPrototype%": ["URIError", "prototype"], "%WeakMapPrototype%": ["WeakMap", "prototype"], "%WeakSetPrototype%": ["WeakSet", "prototype"] }, b = r2(69), v = r2(245), E = b.call(Function.call, Array.prototype.concat), x = b.call(Function.apply, Array.prototype.splice), S = b.call(Function.call, String.prototype.replace), T = b.call(Function.call, String.prototype.slice), w = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, P = /\\(\\)?/g, A = function(e3) {
              var t3 = T(e3, 0, 1), r3 = T(e3, -1);
              if (t3 === "%" && r3 !== "%")
                throw new s2("invalid intrinsic syntax, expected closing `%`");
              if (r3 === "%" && t3 !== "%")
                throw new s2("invalid intrinsic syntax, expected opening `%`");
              var n2 = [];
              return S(e3, w, function(e4, t4, r4, s3) {
                n2[n2.length] = r4 ? S(s3, P, "$1") : t4 || e4;
              }), n2;
            }, O = function(e3, t3) {
              var r3, n2 = e3;
              if (v(g, n2) && (n2 = "%" + (r3 = g[n2])[0] + "%"), v(m, n2)) {
                var i2 = m[n2];
                if (i2 === d && (i2 = y(n2)), i2 === void 0 && !t3)
                  throw new o("intrinsic " + e3 + " exists, but is not available. Please file an issue!");
                return { alias: r3, name: n2, value: i2 };
              }
              throw new s2("intrinsic " + e3 + " does not exist!");
            };
            e2.exports = function(e3, t3) {
              if (typeof e3 != "string" || e3.length === 0)
                throw new o("intrinsic name must be a non-empty string");
              if (arguments.length > 1 && typeof t3 != "boolean")
                throw new o('"allowMissing" argument must be a boolean');
              var r3 = A(e3), n2 = r3.length > 0 ? r3[0] : "", i2 = O("%" + n2 + "%", t3), a2 = i2.name, c4 = i2.value, u2 = false, p3 = i2.alias;
              p3 && (n2 = p3[0], x(r3, E([0, 1], p3)));
              for (var f2 = 1, d2 = true; f2 < r3.length; f2 += 1) {
                var h4 = r3[f2], y2 = T(h4, 0, 1), g2 = T(h4, -1);
                if ((y2 === '"' || y2 === "'" || y2 === "`" || g2 === '"' || g2 === "'" || g2 === "`") && y2 !== g2)
                  throw new s2("property names with quotes must have matching quotes");
                if (h4 !== "constructor" && d2 || (u2 = true), v(m, a2 = "%" + (n2 += "." + h4) + "%"))
                  c4 = m[a2];
                else if (c4 != null) {
                  if (!(h4 in c4)) {
                    if (!t3)
                      throw new o("base intrinsic for " + e3 + " exists, but the property is not available.");
                    return;
                  }
                  if (l && f2 + 1 >= r3.length) {
                    var b2 = l(c4, h4);
                    c4 = (d2 = !!b2) && "get" in b2 && !("originalValue" in b2.get) ? b2.get : c4[h4];
                  } else
                    d2 = v(c4, h4), c4 = c4[h4];
                  d2 && !u2 && (m[a2] = c4);
                }
              }
              return c4;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = typeof Symbol != "undefined" && Symbol, s2 = r2(243);
            e2.exports = function() {
              return typeof n == "function" && typeof Symbol == "function" && typeof n("foo") == "symbol" && typeof Symbol("bar") == "symbol" && s2();
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(244);
            e2.exports = Function.prototype.bind || n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.skipAllButComputedKey = l, t2.default = t2.environmentVisitor = void 0;
            var n = r2(10), s2 = r2(258), i = r2(259), o = r2(0);
            function a(e3, t3, r3, n2) {
              e3 = o.cloneNode(e3);
              const s3 = t3 || n2 ? e3 : o.memberExpression(e3, o.identifier("prototype"));
              return o.callExpression(r3.addHelper("getPrototypeOf"), [s3]);
            }
            function l(e3) {
              if (!e3.node.computed)
                return void e3.skip();
              const t3 = o.VISITOR_KEYS[e3.type];
              for (const r3 of t3)
                r3 !== "key" && e3.skipKey(r3);
            }
            const c = { [(o.staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation"](e3) {
              e3.skip();
            }, Function(e3) {
              e3.isMethod() || e3.isArrowFunctionExpression() || e3.skip();
            }, "Method|ClassProperty"(e3) {
              l(e3);
            } };
            t2.environmentVisitor = c;
            const u = n.default.visitors.merge([c, { Super(e3, t3) {
              const { node: r3, parentPath: n2 } = e3;
              n2.isMemberExpression({ object: r3 }) && t3.handle(n2);
            } }]), p2 = n.default.visitors.merge([c, { Scopable(e3, { refName: t3 }) {
              const r3 = e3.scope.getOwnBinding(t3);
              r3 && r3.identifier.name === t3 && e3.scope.rename(t3);
            } }]), f = { memoise(e3, t3) {
              const { scope: r3, node: n2 } = e3, { computed: s3, property: i2 } = n2;
              if (!s3)
                return;
              const o2 = r3.maybeGenerateMemoised(i2);
              o2 && this.memoiser.set(i2, o2, t3);
            }, prop(e3) {
              const { computed: t3, property: r3 } = e3.node;
              return this.memoiser.has(r3) ? o.cloneNode(this.memoiser.get(r3)) : t3 ? o.cloneNode(r3) : o.stringLiteral(r3.name);
            }, get(e3) {
              return this._get(e3, this._getThisRefs());
            }, _get(e3, t3) {
              const r3 = a(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
              return o.callExpression(this.file.addHelper("get"), [t3.memo ? o.sequenceExpression([t3.memo, r3]) : r3, this.prop(e3), t3.this]);
            }, _getThisRefs() {
              if (!this.isDerivedConstructor)
                return { this: o.thisExpression() };
              const e3 = this.scope.generateDeclaredUidIdentifier("thisSuper");
              return { memo: o.assignmentExpression("=", e3, o.thisExpression()), this: o.cloneNode(e3) };
            }, set(e3, t3) {
              const r3 = this._getThisRefs(), n2 = a(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
              return o.callExpression(this.file.addHelper("set"), [r3.memo ? o.sequenceExpression([r3.memo, n2]) : n2, this.prop(e3), t3, r3.this, o.booleanLiteral(e3.isInStrictMode())]);
            }, destructureSet(e3) {
              throw e3.buildCodeFrameError("Destructuring to a super field is not supported yet.");
            }, call(e3, t3) {
              const r3 = this._getThisRefs();
              return (0, i.default)(this._get(e3, r3), o.cloneNode(r3.this), t3, false);
            }, optionalCall(e3, t3) {
              const r3 = this._getThisRefs();
              return (0, i.default)(this._get(e3, r3), o.cloneNode(r3.this), t3, true);
            } }, d = Object.assign({}, f, { prop(e3) {
              const { property: t3 } = e3.node;
              return this.memoiser.has(t3) ? o.cloneNode(this.memoiser.get(t3)) : o.cloneNode(t3);
            }, get(e3) {
              const { isStatic: t3, getSuperRef: r3 } = this, { computed: n2 } = e3.node, s3 = this.prop(e3);
              let i2;
              var a2, l2;
              return i2 = t3 ? (a2 = r3()) != null ? a2 : o.memberExpression(o.identifier("Function"), o.identifier("prototype")) : o.memberExpression((l2 = r3()) != null ? l2 : o.identifier("Object"), o.identifier("prototype")), o.memberExpression(i2, s3, n2);
            }, set(e3, t3) {
              const { computed: r3 } = e3.node, n2 = this.prop(e3);
              return o.assignmentExpression("=", o.memberExpression(o.thisExpression(), n2, r3), t3);
            }, destructureSet(e3) {
              const { computed: t3 } = e3.node, r3 = this.prop(e3);
              return o.memberExpression(o.thisExpression(), r3, t3);
            }, call(e3, t3) {
              return (0, i.default)(this.get(e3), o.thisExpression(), t3, false);
            }, optionalCall(e3, t3) {
              return (0, i.default)(this.get(e3), o.thisExpression(), t3, true);
            } });
            t2.default = class {
              constructor(e3) {
                var t3;
                const r3 = e3.methodPath;
                this.methodPath = r3, this.isDerivedConstructor = r3.isClassMethod({ kind: "constructor" }) && !!e3.superRef, this.isStatic = r3.isObjectMethod() || r3.node.static || (r3.isStaticBlock == null ? void 0 : r3.isStaticBlock()), this.isPrivateMethod = r3.isPrivate() && r3.isMethod(), this.file = e3.file, this.constantSuper = (t3 = e3.constantSuper) != null ? t3 : e3.isLoose, this.opts = e3;
              }
              getObjectRef() {
                return o.cloneNode(this.opts.objectRef || this.opts.getObjectRef());
              }
              getSuperRef() {
                return this.opts.superRef ? o.cloneNode(this.opts.superRef) : this.opts.getSuperRef ? o.cloneNode(this.opts.getSuperRef()) : void 0;
              }
              replace() {
                this.opts.refToPreserve && this.methodPath.traverse(p2, { refName: this.opts.refToPreserve.name });
                const e3 = this.constantSuper ? d : f;
                (0, s2.default)(this.methodPath, u, Object.assign({ file: this.file, scope: this.methodPath.scope, isDerivedConstructor: this.isDerivedConstructor, isStatic: this.isStatic, isPrivateMethod: this.isPrivateMethod, getObjectRef: this.getObjectRef.bind(this), getSuperRef: this.getSuperRef.bind(this) }, e3));
              }
            };
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) === 0;
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3, r3) => {
              const s2 = new n(e3, r3), i = new n(t3, r3);
              return s2.compare(i) || s2.compareBuild(i);
            };
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) < 0;
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) >= 0;
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) <= 0;
          }, (e2, t2, r2) => {
            const n = r2(3), s2 = r2(45), { ANY: i } = s2, o = r2(13), a = r2(46), l = r2(44), c = r2(73), u = r2(75), p2 = r2(74);
            e2.exports = (e3, t3, r3, f) => {
              let d, h3, m, y, g;
              switch (e3 = new n(e3, f), t3 = new o(t3, f), r3) {
                case ">":
                  d = l, h3 = u, m = c, y = ">", g = ">=";
                  break;
                case "<":
                  d = c, h3 = p2, m = l, y = "<", g = "<=";
                  break;
                default:
                  throw new TypeError('Must provide a hilo val of "<" or ">"');
              }
              if (a(e3, t3, f))
                return false;
              for (let r4 = 0; r4 < t3.set.length; ++r4) {
                const n2 = t3.set[r4];
                let o2 = null, a2 = null;
                if (n2.forEach((e4) => {
                  e4.semver === i && (e4 = new s2(">=0.0.0")), o2 = o2 || e4, a2 = a2 || e4, d(e4.semver, o2.semver, f) ? o2 = e4 : m(e4.semver, a2.semver, f) && (a2 = e4);
                }), o2.operator === y || o2.operator === g)
                  return false;
                if ((!a2.operator || a2.operator === y) && h3(e3, a2.semver))
                  return false;
                if (a2.operator === g && m(e3, a2.semver))
                  return false;
              }
              return true;
            };
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.findConfigUpwards = function(e3) {
              return null;
            }, t2.findPackageData = function* (e3) {
              return { filepath: e3, directories: [], pkg: null, isPackage: false };
            }, t2.findRelativeConfig = function* (e3, t3, r2) {
              return { config: null, ignore: null };
            }, t2.findRootConfig = function* (e3, t3, r2) {
              return null;
            }, t2.loadConfig = function* (e3, t3, r2, n) {
              throw new Error(`Cannot load ${e3} relative to ${t3} in a browser`);
            }, t2.resolveShowConfigPath = function* (e3) {
              return null;
            }, t2.resolvePlugin = function(e3, t3) {
              return null;
            }, t2.resolvePreset = function(e3, t3) {
              return null;
            }, t2.loadPlugin = function(e3, t3) {
              throw new Error(`Cannot load plugin ${e3} relative to ${t3} in a browser`);
            }, t2.loadPreset = function(e3, t3) {
              throw new Error(`Cannot load preset ${e3} relative to ${t3} in a browser`);
            }, t2.ROOT_CONFIG_FILENAMES = void 0, t2.ROOT_CONFIG_FILENAMES = [];
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.createConfigItem = function(e3, t3, r3) {
              return r3 !== void 0 ? l.errback(e3, t3, r3) : typeof t3 == "function" ? l.errback(e3, void 0, r3) : l.sync(e3, t3);
            }, Object.defineProperty(t2, "default", { enumerable: true, get: function() {
              return s2.default;
            } }), t2.createConfigItemAsync = t2.createConfigItemSync = t2.loadOptionsAsync = t2.loadOptionsSync = t2.loadOptions = t2.loadPartialConfigAsync = t2.loadPartialConfigSync = t2.loadPartialConfig = void 0;
            var s2 = r2(466), i = r2(303), o = r2(80);
            const a = n()(function* (e3) {
              var t3;
              const r3 = yield* (0, s2.default)(e3);
              return (t3 = r3 == null ? void 0 : r3.options) != null ? t3 : null;
            }), l = n()(o.createConfigItem), c = (e3) => (t3, r3) => (r3 === void 0 && typeof t3 == "function" && (r3 = t3, t3 = void 0), r3 ? e3.errback(t3, r3) : e3.sync(t3)), u = c(i.loadPartialConfig);
            t2.loadPartialConfig = u;
            const p2 = i.loadPartialConfig.sync;
            t2.loadPartialConfigSync = p2;
            const f = i.loadPartialConfig.async;
            t2.loadPartialConfigAsync = f;
            const d = c(a);
            t2.loadOptions = d;
            const h3 = a.sync;
            t2.loadOptionsSync = h3;
            const m = a.async;
            t2.loadOptionsAsync = m;
            const y = l.sync;
            t2.createConfigItemSync = y;
            const g = l.async;
            t2.createConfigItemAsync = g;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
              constructor(e3, t3, r2) {
                this.key = void 0, this.manipulateOptions = void 0, this.post = void 0, this.pre = void 0, this.visitor = void 0, this.parserOverride = void 0, this.generatorOverride = void 0, this.options = void 0, this.key = e3.name || r2, this.manipulateOptions = e3.manipulateOptions, this.post = e3.post, this.pre = e3.pre, this.visitor = e3.visitor || {}, this.parserOverride = e3.parserOverride, this.generatorOverride = e3.generatorOverride, this.options = t3;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(8);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.createItemFromDescriptor = i, t2.createConfigItem = function* (e3, { dirname: t3 = ".", type: r3 } = {}) {
              return i(yield* (0, s2.createDescriptor)(e3, n().resolve(t3), { type: r3, alias: "programmatic item" }));
            }, t2.getItemDescriptor = function(e3) {
              if (e3 != null && e3[o])
                return e3._descriptor;
            };
            var s2 = r2(288);
            function i(e3) {
              return new a(e3);
            }
            const o = Symbol.for("@babel/core@7 - ConfigItem");
            class a {
              constructor(e3) {
                this._descriptor = void 0, this[o] = true, this.value = void 0, this.options = void 0, this.dirname = void 0, this.name = void 0, this.file = void 0, this._descriptor = e3, Object.defineProperty(this, "_descriptor", { enumerable: false }), Object.defineProperty(this, o, { enumerable: false }), this.value = this._descriptor.value, this.options = this._descriptor.options, this.dirname = this._descriptor.dirname, this.name = this._descriptor.name, this.file = this._descriptor.file ? { request: this._descriptor.file.request, resolved: this._descriptor.file.resolved } : void 0, Object.freeze(this);
              }
            }
            Object.freeze(a.prototype);
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.makeWeakCache = l, t2.makeWeakCacheSync = function(e3) {
              return o(l(e3));
            }, t2.makeStrongCache = c, t2.makeStrongCacheSync = function(e3) {
              return o(c(e3));
            }, t2.assertSimpleType = h3;
            var s2 = r2(287), i = r2(150);
            const o = (e3) => n()(e3).sync;
            function* a() {
              return true;
            }
            function l(e3) {
              return u(WeakMap, e3);
            }
            function c(e3) {
              return u(Map, e3);
            }
            function u(e3, t3) {
              const r3 = new e3(), n2 = new e3(), o2 = new e3();
              return function* (e4, a2) {
                const l2 = yield* (0, s2.isAsync)(), c4 = l2 ? n2 : r3, u2 = yield* function* (e5, t4, r4, n3, i2) {
                  const o3 = yield* p2(t4, n3, i2);
                  if (o3.valid)
                    return o3;
                  if (e5) {
                    const e6 = yield* p2(r4, n3, i2);
                    if (e6.valid)
                      return { valid: true, value: yield* (0, s2.waitFor)(e6.value.promise) };
                  }
                  return { valid: false, value: null };
                }(l2, c4, o2, e4, a2);
                if (u2.valid)
                  return u2.value;
                const h4 = new d(a2), y = t3(e4, h4);
                let g, b;
                if ((0, i.isIterableIterator)(y)) {
                  const t4 = y;
                  b = yield* (0, s2.onFirstPause)(t4, () => {
                    g = function(e5, t5, r4) {
                      const n3 = new m();
                      return f(t5, e5, r4, n3), n3;
                    }(h4, o2, e4);
                  });
                } else
                  b = y;
                return f(c4, h4, e4, b), g && (o2.delete(e4), g.release(b)), b;
              };
            }
            function* p2(e3, t3, r3) {
              const n2 = e3.get(t3);
              if (n2) {
                for (const { value: e4, valid: t4 } of n2)
                  if (yield* t4(r3))
                    return { valid: true, value: e4 };
              }
              return { valid: false, value: null };
            }
            function f(e3, t3, r3, n2) {
              t3.configured() || t3.forever();
              let s3 = e3.get(r3);
              switch (t3.deactivate(), t3.mode()) {
                case "forever":
                  s3 = [{ value: n2, valid: a }], e3.set(r3, s3);
                  break;
                case "invalidate":
                  s3 = [{ value: n2, valid: t3.validator() }], e3.set(r3, s3);
                  break;
                case "valid":
                  s3 ? s3.push({ value: n2, valid: t3.validator() }) : (s3 = [{ value: n2, valid: t3.validator() }], e3.set(r3, s3));
              }
            }
            class d {
              constructor(e3) {
                this._active = true, this._never = false, this._forever = false, this._invalidate = false, this._configured = false, this._pairs = [], this._data = void 0, this._data = e3;
              }
              simple() {
                return function(e3) {
                  function t3(t4) {
                    if (typeof t4 != "boolean")
                      return e3.using(() => h3(t4()));
                    t4 ? e3.forever() : e3.never();
                  }
                  return t3.forever = () => e3.forever(), t3.never = () => e3.never(), t3.using = (t4) => e3.using(() => h3(t4())), t3.invalidate = (t4) => e3.invalidate(() => h3(t4())), t3;
                }(this);
              }
              mode() {
                return this._never ? "never" : this._forever ? "forever" : this._invalidate ? "invalidate" : "valid";
              }
              forever() {
                if (!this._active)
                  throw new Error("Cannot change caching after evaluation has completed.");
                if (this._never)
                  throw new Error("Caching has already been configured with .never()");
                this._forever = true, this._configured = true;
              }
              never() {
                if (!this._active)
                  throw new Error("Cannot change caching after evaluation has completed.");
                if (this._forever)
                  throw new Error("Caching has already been configured with .forever()");
                this._never = true, this._configured = true;
              }
              using(e3) {
                if (!this._active)
                  throw new Error("Cannot change caching after evaluation has completed.");
                if (this._never || this._forever)
                  throw new Error("Caching has already been configured with .never or .forever()");
                this._configured = true;
                const t3 = e3(this._data), r3 = (0, s2.maybeAsync)(e3, "You appear to be using an async cache handler, but Babel has been called synchronously");
                return (0, s2.isThenable)(t3) ? t3.then((e4) => (this._pairs.push([e4, r3]), e4)) : (this._pairs.push([t3, r3]), t3);
              }
              invalidate(e3) {
                return this._invalidate = true, this.using(e3);
              }
              validator() {
                const e3 = this._pairs;
                return function* (t3) {
                  for (const [r3, n2] of e3)
                    if (r3 !== (yield* n2(t3)))
                      return false;
                  return true;
                };
              }
              deactivate() {
                this._active = false;
              }
              configured() {
                return this._configured;
              }
            }
            function h3(e3) {
              if ((0, s2.isThenable)(e3))
                throw new Error("You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.");
              if (e3 != null && typeof e3 != "string" && typeof e3 != "boolean" && typeof e3 != "number")
                throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
              return e3;
            }
            class m {
              constructor() {
                this.released = false, this.promise = void 0, this._resolve = void 0, this.promise = new Promise((e3) => {
                  this._resolve = e3;
                });
              }
              release(e3) {
                this.released = true, this._resolve(e3);
              }
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.validate = function(e3, t3) {
              return p2({ type: "root", source: e3 }, t3);
            }, t2.checkNoUnwrappedItemOptionPairs = function(e3, t3, r3, n2) {
              if (t3 === 0)
                return;
              const s3 = e3[t3 - 1], i2 = e3[t3];
              s3.file && s3.options === void 0 && typeof i2.value == "object" && (n2.message += `
- Maybe you meant to use
"${r3}": [
  ["${s3.file.request}", ${JSON.stringify(i2.value, void 0, 2)}]
]
To be a valid ${r3}, its name and options should be wrapped in a pair of brackets`);
            }, t2.assumptionsNames = void 0, r2(79);
            var n = r2(481), s2 = r2(301);
            const i = { cwd: s2.assertString, root: s2.assertString, rootMode: s2.assertRootMode, configFile: s2.assertConfigFileSearch, caller: s2.assertCallerMetadata, filename: s2.assertString, filenameRelative: s2.assertString, code: s2.assertBoolean, ast: s2.assertBoolean, cloneInputAst: s2.assertBoolean, envName: s2.assertString }, o = { babelrc: s2.assertBoolean, babelrcRoots: s2.assertBabelrcSearch }, a = { extends: s2.assertString, ignore: s2.assertIgnoreList, only: s2.assertIgnoreList, targets: s2.assertTargets, browserslistConfigFile: s2.assertConfigFileSearch, browserslistEnv: s2.assertString }, l = { inputSourceMap: s2.assertInputSourceMap, presets: s2.assertPluginList, plugins: s2.assertPluginList, passPerPreset: s2.assertBoolean, assumptions: s2.assertAssumptions, env: function(e3, t3) {
              if (e3.parent.type === "env")
                throw new Error(`${(0, s2.msg)(e3)} is not allowed inside of another .env block`);
              const r3 = e3.parent, n2 = (0, s2.assertObject)(e3, t3);
              if (n2)
                for (const t4 of Object.keys(n2)) {
                  const i2 = (0, s2.assertObject)((0, s2.access)(e3, t4), n2[t4]);
                  i2 && p2({ type: "env", name: t4, parent: r3 }, i2);
                }
              return n2;
            }, overrides: function(e3, t3) {
              if (e3.parent.type === "env")
                throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .env block`);
              if (e3.parent.type === "overrides")
                throw new Error(`${(0, s2.msg)(e3)} is not allowed inside an .overrides block`);
              const r3 = e3.parent, n2 = (0, s2.assertArray)(e3, t3);
              if (n2)
                for (const [t4, i2] of n2.entries()) {
                  const n3 = (0, s2.access)(e3, t4), o2 = (0, s2.assertObject)(n3, i2);
                  if (!o2)
                    throw new Error(`${(0, s2.msg)(n3)} must be an object`);
                  p2({ type: "overrides", index: t4, parent: r3 }, o2);
                }
              return n2;
            }, test: s2.assertConfigApplicableTest, include: s2.assertConfigApplicableTest, exclude: s2.assertConfigApplicableTest, retainLines: s2.assertBoolean, comments: s2.assertBoolean, shouldPrintComment: s2.assertFunction, compact: s2.assertCompact, minified: s2.assertBoolean, auxiliaryCommentBefore: s2.assertString, auxiliaryCommentAfter: s2.assertString, sourceType: s2.assertSourceType, wrapPluginVisitorMethod: s2.assertFunction, highlightCode: s2.assertBoolean, sourceMaps: s2.assertSourceMaps, sourceMap: s2.assertSourceMaps, sourceFileName: s2.assertString, sourceRoot: s2.assertString, parserOpts: s2.assertObject, generatorOpts: s2.assertObject };
            Object.assign(l, { getModuleId: s2.assertFunction, moduleRoot: s2.assertString, moduleIds: s2.assertBoolean, moduleId: s2.assertString });
            const c = new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);
            function u(e3) {
              return e3.type === "root" ? e3.source : u(e3.parent);
            }
            function p2(e3, t3) {
              const r3 = u(e3);
              return function(e4) {
                if (d(e4, "sourceMap") && d(e4, "sourceMaps"))
                  throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
              }(t3), Object.keys(t3).forEach((n2) => {
                const c4 = { type: "option", name: n2, parent: e3 };
                if (r3 === "preset" && a[n2])
                  throw new Error(`${(0, s2.msg)(c4)} is not allowed in preset options`);
                if (r3 !== "arguments" && i[n2])
                  throw new Error(`${(0, s2.msg)(c4)} is only allowed in root programmatic options`);
                if (r3 !== "arguments" && r3 !== "configfile" && o[n2]) {
                  if (r3 === "babelrcfile" || r3 === "extendsfile")
                    throw new Error(`${(0, s2.msg)(c4)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
                  throw new Error(`${(0, s2.msg)(c4)} is only allowed in root programmatic options, or babel.config.js/config file options`);
                }
                (l[n2] || a[n2] || o[n2] || i[n2] || f)(c4, t3[n2]);
              }), t3;
            }
            function f(e3) {
              const t3 = e3.name;
              if (n.default[t3]) {
                const { message: r3, version: i2 = 5 } = n.default[t3];
                throw new Error(`Using removed Babel ${i2} option: ${(0, s2.msg)(e3)} - ${r3}`);
              }
              {
                const t4 = new Error(`Unknown option: ${(0, s2.msg)(e3)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
                throw t4.code = "BABEL_UNKNOWN_OPTION", t4;
              }
            }
            function d(e3, t3) {
              return Object.prototype.hasOwnProperty.call(e3, t3);
            }
            t2.assumptionsNames = c;
          }, (e2, t2, r2) => {
            "use strict";
            e2.exports = r2(507);
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7);
            let s2 = r2(85), i = r2(47), o = r2(156), a = r2(22), l = r2(308), c = r2(86), u = r2(309), p2 = r2(87), f = r2(160), d = r2(49), h3 = r2(88), m = r2(159), y = r2(90), g = r2(161), b = r2(162), v = r2(89), E = r2(35), x = r2(48);
            function S(...e3) {
              return e3.length === 1 && Array.isArray(e3[0]) && (e3 = e3[0]), new l(e3);
            }
            S.plugin = function(e3, t3) {
              function r3(...r4) {
                let n2 = t3(...r4);
                return n2.postcssPlugin = e3, n2.postcssVersion = new l().version, n2;
              }
              let s3;
              return console && console.warn && n.env.LANG && n.env.LANG.startsWith("cn"), Object.defineProperty(r3, "postcss", { get: () => (s3 || (s3 = r3()), s3) }), r3.process = function(e4, t4, n2) {
                return S([r3(n2)]).process(e4, t4);
              }, r3;
            }, S.stringify = c, S.parse = g, S.fromJSON = u, S.list = b, S.comment = (e3) => new d(e3), S.atRule = (e3) => new h3(e3), S.decl = (e3) => new i(e3), S.rule = (e3) => new v(e3), S.root = (e3) => new E(e3), S.document = (e3) => new p2(e3), S.CssSyntaxError = s2, S.Declaration = i, S.Container = a, S.Document = p2, S.Comment = d, S.Warning = f, S.AtRule = h3, S.Result = m, S.Input = y, S.Rule = v, S.Root = E, S.Node = x, o.registerPostcss(S), e2.exports = S, S.default = S;
          }, (e2, t2, r2) => {
            "use strict";
            let { red: n, bold: s2, gray: i, options: o } = r2(513), a = r2(319);
            class l extends Error {
              constructor(e3, t3, r3, n2, s3, i2) {
                super(e3), this.name = "CssSyntaxError", this.reason = e3, s3 && (this.file = s3), n2 && (this.source = n2), i2 && (this.plugin = i2), t3 !== void 0 && r3 !== void 0 && (this.line = t3, this.column = r3), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, l);
              }
              setMessage() {
                this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", this.line !== void 0 && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
              }
              showSourceCode(e3) {
                if (!this.source)
                  return "";
                let t3 = this.source;
                e3 == null && (e3 = o.enabled), a && e3 && (t3 = a(t3));
                let r3, l2, c = t3.split(/\r?\n/), u = Math.max(this.line - 3, 0), p2 = Math.min(this.line + 2, c.length), f = String(p2).length;
                return e3 ? (r3 = (e4) => s2(n(e4)), l2 = (e4) => i(e4)) : r3 = l2 = (e4) => e4, c.slice(u, p2).map((e4, t4) => {
                  let n2 = u + 1 + t4, s3 = " " + (" " + n2).slice(-f) + " | ";
                  if (n2 === this.line) {
                    let t5 = l2(s3.replace(/\d/g, " ")) + e4.slice(0, this.column - 1).replace(/[^\t]/g, " ");
                    return r3(">") + l2(s3) + e4 + "\n " + t5 + r3("^");
                  }
                  return " " + l2(s3) + e4;
                }).join("\n");
              }
              toString() {
                let e3 = this.showSourceCode();
                return e3 && (e3 = "\n\n" + e3 + "\n"), this.name + ": " + this.message + e3;
              }
            }
            e2.exports = l, l.default = l;
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(155);
            function s2(e3, t3) {
              new n(t3).stringify(e3);
            }
            e2.exports = s2, s2.default = s2;
          }, (e2, t2, r2) => {
            "use strict";
            let n, s2, i = r2(22);
            class o extends i {
              constructor(e3) {
                super({ type: "document", ...e3 }), this.nodes || (this.nodes = []);
              }
              toResult(e3 = {}) {
                return new n(new s2(), this, e3).stringify();
              }
            }
            o.registerLazyResult = (e3) => {
              n = e3;
            }, o.registerProcessor = (e3) => {
              s2 = e3;
            }, e2.exports = o, o.default = o;
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(22);
            class s2 extends n {
              constructor(e3) {
                super(e3), this.type = "atrule";
              }
              append(...e3) {
                return this.proxyOf.nodes || (this.nodes = []), super.append(...e3);
              }
              prepend(...e3) {
                return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e3);
              }
            }
            e2.exports = s2, s2.default = s2, n.registerAtRule(s2);
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(22), s2 = r2(162);
            class i extends n {
              constructor(e3) {
                super(e3), this.type = "rule", this.nodes || (this.nodes = []);
              }
              get selectors() {
                return s2.comma(this.selector);
              }
              set selectors(e3) {
                let t3 = this.selector ? this.selector.match(/,\s*/) : null, r3 = t3 ? t3[0] : "," + this.raw("between", "beforeOpen");
                this.selector = e3.join(r3);
              }
            }
            e2.exports = i, i.default = i, n.registerRule(i);
          }, (e2, t2, r2) => {
            "use strict";
            let { SourceMapConsumer: n, SourceMapGenerator: s2 } = r2(157), { fileURLToPath: i, pathToFileURL: o } = r2(321), { resolve: a, isAbsolute: l } = r2(158), { nanoid: c } = r2(325), u = r2(319), p2 = r2(85), f = r2(163), d = Symbol("fromOffsetCache"), h3 = Boolean(n && s2), m = Boolean(a && l);
            class y {
              constructor(e3, t3 = {}) {
                if (e3 == null || typeof e3 == "object" && !e3.toString)
                  throw new Error(`PostCSS received ${e3} instead of CSS string`);
                if (this.css = e3.toString(), this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE" ? (this.hasBOM = true, this.css = this.css.slice(1)) : this.hasBOM = false, t3.from && (!m || /^\w+:\/\//.test(t3.from) || l(t3.from) ? this.file = t3.from : this.file = a(t3.from)), m && h3) {
                  let e4 = new f(this.css, t3);
                  if (e4.text) {
                    this.map = e4;
                    let t4 = e4.consumer().file;
                    !this.file && t4 && (this.file = this.mapResolve(t4));
                  }
                }
                this.file || (this.id = "<input css " + c(6) + ">"), this.map && (this.map.file = this.from);
              }
              fromOffset(e3) {
                let t3, r3;
                if (this[d])
                  r3 = this[d];
                else {
                  let e4 = this.css.split("\n");
                  r3 = new Array(e4.length);
                  let t4 = 0;
                  for (let n3 = 0, s3 = e4.length; n3 < s3; n3++)
                    r3[n3] = t4, t4 += e4[n3].length + 1;
                  this[d] = r3;
                }
                t3 = r3[r3.length - 1];
                let n2 = 0;
                if (e3 >= t3)
                  n2 = r3.length - 1;
                else {
                  let t4, s3 = r3.length - 2;
                  for (; n2 < s3; )
                    if (t4 = n2 + (s3 - n2 >> 1), e3 < r3[t4])
                      s3 = t4 - 1;
                    else {
                      if (!(e3 >= r3[t4 + 1])) {
                        n2 = t4;
                        break;
                      }
                      n2 = t4 + 1;
                    }
                }
                return { line: n2 + 1, col: e3 - r3[n2] + 1 };
              }
              error(e3, t3, r3, n2 = {}) {
                let s3;
                if (!r3) {
                  let e4 = this.fromOffset(t3);
                  t3 = e4.line, r3 = e4.col;
                }
                let i2 = this.origin(t3, r3);
                return s3 = i2 ? new p2(e3, i2.line, i2.column, i2.source, i2.file, n2.plugin) : new p2(e3, t3, r3, this.css, this.file, n2.plugin), s3.input = { line: t3, column: r3, source: this.css }, this.file && (o && (s3.input.url = o(this.file).toString()), s3.input.file = this.file), s3;
              }
              origin(e3, t3) {
                if (!this.map)
                  return false;
                let r3, n2 = this.map.consumer(), s3 = n2.originalPositionFor({ line: e3, column: t3 });
                if (!s3.source)
                  return false;
                r3 = l(s3.source) ? o(s3.source) : new URL(s3.source, this.map.consumer().sourceRoot || o(this.map.mapFile));
                let a2 = { url: r3.toString(), line: s3.line, column: s3.column };
                if (r3.protocol === "file:") {
                  if (!i)
                    throw new Error("file: protocol is not available in this PostCSS build");
                  a2.file = i(r3);
                }
                let c4 = n2.sourceContentFor(s3.source);
                return c4 && (a2.source = c4), a2;
              }
              mapResolve(e3) {
                return /^\w+:\/\//.test(e3) ? e3 : a(this.map.consumer().sourceRoot || this.map.root || ".", e3);
              }
              get from() {
                return this.file || this.id;
              }
              toJSON() {
                let e3 = {};
                for (let t3 of ["hasBOM", "css", "file", "id"])
                  this[t3] != null && (e3[t3] = this[t3]);
                return this.map && (e3.map = { ...this.map }, e3.map.consumerCache && (e3.map.consumerCache = void 0)), e3;
              }
            }
            e2.exports = y, y.default = y, u && u.registerInput && u.registerInput(y);
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.stripComments = t2.ensureObject = t2.getProp = t2.unesc = void 0;
            var n = a(r2(98));
            t2.unesc = n.default;
            var s2 = a(r2(174));
            t2.getProp = s2.default;
            var i = a(r2(175));
            t2.ensureObject = i.default;
            var o = a(r2(176));
            function a(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            t2.stripComments = o.default;
          }, (e2) => {
            "use strict";
            var t2 = {}.hasOwnProperty, r2 = /[ -,\.\/:-@\[-\^`\{-~]/, n = /[ -,\.\/:-@\[\]\^`\{-~]/, s2 = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g, i = function e3(i2, o) {
              (o = function(e4, r3) {
                if (!e4)
                  return r3;
                var n2 = {};
                for (var s3 in r3)
                  n2[s3] = t2.call(e4, s3) ? e4[s3] : r3[s3];
                return n2;
              }(o, e3.options)).quotes != "single" && o.quotes != "double" && (o.quotes = "single");
              for (var a = o.quotes == "double" ? '"' : "'", l = o.isIdentifier, c = i2.charAt(0), u = "", p2 = 0, f = i2.length; p2 < f; ) {
                var d = i2.charAt(p2++), h3 = d.charCodeAt(), m = void 0;
                if (h3 < 32 || h3 > 126) {
                  if (h3 >= 55296 && h3 <= 56319 && p2 < f) {
                    var y = i2.charCodeAt(p2++);
                    (64512 & y) == 56320 ? h3 = ((1023 & h3) << 10) + (1023 & y) + 65536 : p2--;
                  }
                  m = "\\" + h3.toString(16).toUpperCase() + " ";
                } else
                  m = o.escapeEverything ? r2.test(d) ? "\\" + d : "\\" + h3.toString(16).toUpperCase() + " " : /[\t\n\f\r\x0B]/.test(d) ? "\\" + h3.toString(16).toUpperCase() + " " : d == "\\" || !l && (d == '"' && a == d || d == "'" && a == d) || l && n.test(d) ? "\\" + d : d;
                u += m;
              }
              return l && (/^-[-\d]/.test(u) ? u = "\\-" + u.slice(1) : /\d/.test(c) && (u = "\\3" + c + " " + u.slice(1))), u = u.replace(s2, function(e4, t3, r3) {
                return t3 && t3.length % 2 ? e4 : (t3 || "") + r3;
              }), !l && o.wrap ? a + u + a : u;
            };
            i.options = { escapeEverything: false, isIdentifier: false, quotes: "single", wrap: false }, i.version = "3.0.0", e2.exports = i;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.createClassFeaturePlugin = function({ name: e3, feature: t3, loose: r3, manipulateOptions: f, api: d = { assumption: () => {
            } } }) {
              const h3 = d.assumption("setPublicClassFields"), m = d.assumption("privateFieldsAsProperties"), y = d.assumption("constantSuper"), g = d.assumption("noDocumentAll");
              if (r3 === true) {
                const e4 = [];
                h3 !== void 0 && e4.push('"setPublicClassFields"'), m !== void 0 && e4.push('"privateFieldsAsProperties"'), e4.length;
              }
              return { name: e3, manipulateOptions: f, pre() {
                (0, c.enableFeature)(this.file, t3, r3), (!this.file.get(p2) || this.file.get(p2) < u) && this.file.set(p2, u);
              }, visitor: { Class(e4, r4) {
                if (this.file.get(p2) !== u)
                  return;
                (0, c.verifyUsedFeatures)(e4, this.file);
                const i2 = (0, c.isLoose)(this.file, t3);
                let f2, d2 = (0, a.hasOwnDecorators)(e4.node);
                const b = [], v = [], E = [], x = new Set(), S = e4.get("body");
                for (const e5 of S.get("body")) {
                  if ((0, c.verifyUsedFeatures)(e5, this.file), e5.node.computed && E.push(e5), e5.isPrivate()) {
                    const { name: t4 } = e5.node.key.id, r5 = `get ${t4}`, n2 = `set ${t4}`;
                    if (e5.node.kind === "get") {
                      if (x.has(r5) || x.has(t4) && !x.has(n2))
                        throw e5.buildCodeFrameError("Duplicate private field");
                      x.add(r5).add(t4);
                    } else if (e5.node.kind === "set") {
                      if (x.has(n2) || x.has(t4) && !x.has(r5))
                        throw e5.buildCodeFrameError("Duplicate private field");
                      x.add(n2).add(t4);
                    } else {
                      if (x.has(t4) && !x.has(r5) && !x.has(n2) || x.has(t4) && (x.has(r5) || x.has(n2)))
                        throw e5.buildCodeFrameError("Duplicate private field");
                      x.add(t4);
                    }
                  }
                  e5.isClassMethod({ kind: "constructor" }) ? f2 = e5 : (v.push(e5), (e5.isProperty() || e5.isPrivate() || e5.isStaticBlock != null && e5.isStaticBlock()) && b.push(e5)), d2 || (d2 = (0, a.hasOwnDecorators)(e5.node));
                }
                if (!b.length && !d2)
                  return;
                const T = e4.node.id;
                let w;
                !T || e4.isClassExpression() ? ((0, s2.default)(e4), w = e4.scope.generateUidIdentifier("class")) : w = n.types.cloneNode(e4.node.id);
                const P = (0, o.buildPrivateNamesMap)(b), A = (0, o.buildPrivateNamesNodes)(P, m != null ? m : i2, r4);
                let O, C, I, k2, N;
                (0, o.transformPrivateNamesUsage)(w, e4, P, { privateFieldsAsProperties: m != null ? m : i2, noDocumentAll: g }, r4), d2 ? (C = I = O = [], { instanceNodes: k2, wrapClass: N } = (0, a.buildDecoratedClass)(w, e4, v, this.file)) : (O = (0, l.extractComputedKeys)(w, e4, E, this.file), { staticNodes: C, pureStaticNodes: I, instanceNodes: k2, wrapClass: N } = (0, o.buildFieldsInitNodes)(w, e4.node.superClass, b, P, r4, h3 != null ? h3 : i2, m != null ? m : i2, y != null ? y : i2, T)), k2.length > 0 && (0, l.injectInitialization)(e4, f2, k2, (e5, t4) => {
                  if (!d2)
                    for (const r5 of b)
                      r5.node.static || r5.traverse(e5, t4);
                }), (e4 = N(e4)).insertBefore([...A, ...O]), C.length > 0 && e4.insertAfter(C), I.length > 0 && e4.find((e5) => e5.isStatement() || e5.isDeclaration()).insertAfter(I);
              }, PrivateName(e4) {
                if (this.file.get(p2) === u && !e4.parentPath.isPrivate({ key: e4.node }))
                  throw e4.buildCodeFrameError(`Unknown PrivateName "${e4}"`);
              }, ExportDefaultDeclaration(e4) {
                if (this.file.get(p2) !== u)
                  return;
                const t4 = e4.get("declaration");
                t4.isClassDeclaration() && (0, a.hasDecorators)(t4.node) && (t4.node.id ? (0, i.default)(e4) : t4.node.type = "ClassExpression");
              } } };
            }, Object.defineProperty(t2, "injectInitialization", { enumerable: true, get: function() {
              return l.injectInitialization;
            } }), Object.defineProperty(t2, "enableFeature", { enumerable: true, get: function() {
              return c.enableFeature;
            } }), Object.defineProperty(t2, "FEATURES", { enumerable: true, get: function() {
              return c.FEATURES;
            } });
            var n = r2(9), s2 = r2(134), i = r2(132), o = r2(537), a = r2(311), l = r2(539), c = r2(540);
            const u = "7.14.6".split(".").reduce((e3, t3) => 1e5 * e3 + +t3, 0), p2 = "@babel/plugin-class-features/version";
          }, (e2) => {
            const t2 = /^[0-9]+$/, r2 = (e3, r3) => {
              const n = t2.test(e3), s2 = t2.test(r3);
              return n && s2 && (e3 = +e3, r3 = +r3), e3 === r3 ? 0 : n && !s2 ? -1 : s2 && !n ? 1 : e3 < r3 ? -1 : 1;
            };
            e2.exports = { compareIdentifiers: r2, rcompareIdentifiers: (e3, t3) => r2(t3, e3) };
          }, function(e2, t2) {
            !function(e3) {
              "use strict";
              class t3 {
                constructor() {
                  this.should_skip = false, this.should_remove = false, this.replacement = null, this.context = { skip: () => this.should_skip = true, remove: () => this.should_remove = true, replace: (e4) => this.replacement = e4 };
                }
                replace(e4, t4, r3, n2) {
                  e4 && (r3 !== null ? e4[t4][r3] = n2 : e4[t4] = n2);
                }
                remove(e4, t4, r3) {
                  e4 && (r3 !== null ? e4[t4].splice(r3, 1) : delete e4[t4]);
                }
              }
              class r2 extends t3 {
                constructor(e4, t4) {
                  super(), this.enter = e4, this.leave = t4;
                }
                visit(e4, t4, r3, n2) {
                  if (e4) {
                    if (this.enter) {
                      const s2 = this.should_skip, i = this.should_remove, o = this.replacement;
                      this.should_skip = false, this.should_remove = false, this.replacement = null, this.enter.call(this.context, e4, t4, r3, n2), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n2, e4)), this.should_remove && this.remove(t4, r3, n2);
                      const a = this.should_skip, l = this.should_remove;
                      if (this.should_skip = s2, this.should_remove = i, this.replacement = o, a)
                        return e4;
                      if (l)
                        return null;
                    }
                    for (const t5 in e4) {
                      const r4 = e4[t5];
                      if (typeof r4 == "object")
                        if (Array.isArray(r4))
                          for (let n3 = 0; n3 < r4.length; n3 += 1)
                            r4[n3] !== null && typeof r4[n3].type == "string" && (this.visit(r4[n3], e4, t5, n3) || n3--);
                        else
                          r4 !== null && typeof r4.type == "string" && this.visit(r4, e4, t5, null);
                    }
                    if (this.leave) {
                      const s2 = this.replacement, i = this.should_remove;
                      this.replacement = null, this.should_remove = false, this.leave.call(this.context, e4, t4, r3, n2), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n2, e4)), this.should_remove && this.remove(t4, r3, n2);
                      const o = this.should_remove;
                      if (this.replacement = s2, this.should_remove = i, o)
                        return null;
                    }
                  }
                  return e4;
                }
              }
              class n extends t3 {
                constructor(e4, t4) {
                  super(), this.enter = e4, this.leave = t4;
                }
                async visit(e4, t4, r3, n2) {
                  if (e4) {
                    if (this.enter) {
                      const s2 = this.should_skip, i = this.should_remove, o = this.replacement;
                      this.should_skip = false, this.should_remove = false, this.replacement = null, await this.enter.call(this.context, e4, t4, r3, n2), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n2, e4)), this.should_remove && this.remove(t4, r3, n2);
                      const a = this.should_skip, l = this.should_remove;
                      if (this.should_skip = s2, this.should_remove = i, this.replacement = o, a)
                        return e4;
                      if (l)
                        return null;
                    }
                    for (const t5 in e4) {
                      const r4 = e4[t5];
                      if (typeof r4 == "object")
                        if (Array.isArray(r4))
                          for (let n3 = 0; n3 < r4.length; n3 += 1)
                            r4[n3] !== null && typeof r4[n3].type == "string" && (await this.visit(r4[n3], e4, t5, n3) || n3--);
                        else
                          r4 !== null && typeof r4.type == "string" && await this.visit(r4, e4, t5, null);
                    }
                    if (this.leave) {
                      const s2 = this.replacement, i = this.should_remove;
                      this.replacement = null, this.should_remove = false, await this.leave.call(this.context, e4, t4, r3, n2), this.replacement && (e4 = this.replacement, this.replace(t4, r3, n2, e4)), this.should_remove && this.remove(t4, r3, n2);
                      const o = this.should_remove;
                      if (this.replacement = s2, this.should_remove = i, o)
                        return null;
                    }
                  }
                  return e4;
                }
              }
              e3.asyncWalk = async function(e4, { enter: t4, leave: r3 }) {
                const s2 = new n(t4, r3);
                return await s2.visit(e4, null);
              }, e3.walk = function(e4, { enter: t4, leave: n2 }) {
                return new r2(t4, n2).visit(e4, null);
              }, Object.defineProperty(e3, "__esModule", { value: true });
            }(t2);
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(172)) && n.__esModule ? n : { default: n }, i = function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
                return { default: e3 };
              var t3 = o();
              if (t3 && t3.has(e3))
                return t3.get(e3);
              var r3 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var s3 in e3)
                if (Object.prototype.hasOwnProperty.call(e3, s3)) {
                  var i2 = n2 ? Object.getOwnPropertyDescriptor(e3, s3) : null;
                  i2 && (i2.get || i2.set) ? Object.defineProperty(r3, s3, i2) : r3[s3] = e3[s3];
                }
              return r3.default = e3, t3 && t3.set(e3, r3), r3;
            }(r2(166));
            function o() {
              if (typeof WeakMap != "function")
                return null;
              var e3 = new WeakMap();
              return o = function() {
                return e3;
              }, e3;
            }
            var a = function(e3) {
              return new s2.default(e3);
            };
            Object.assign(a, i), delete a.__esModule;
            var l = a;
            t2.default = l, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(52)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function a(e3, t3) {
              return (a = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var l = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.ROOT, r4;
              }
              r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, a(t3, r3);
              var s3, l2, c = n2.prototype;
              return c.toString = function() {
                var e4 = this.reduce(function(e5, t4) {
                  return e5.push(String(t4)), e5;
                }, []).join(",");
                return this.trailingComma ? e4 + "," : e4;
              }, c.error = function(e4, t4) {
                return this._error ? this._error(e4, t4) : new Error(e4);
              }, s3 = n2, (l2 = [{ key: "errorGenerator", set: function(e4) {
                this._error = e4;
              } }]) && o(s3.prototype, l2), n2;
            }(s2.default);
            t2.default = l, e2.exports = t2.default;
          }, (e2, t2) => {
            "use strict";
            function r2(e3) {
              for (var t3 = e3.toLowerCase(), r3 = "", n2 = false, s2 = 0; s2 < 6 && t3[s2] !== void 0; s2++) {
                var i = t3.charCodeAt(s2);
                if (n2 = i === 32, !(i >= 97 && i <= 102 || i >= 48 && i <= 57))
                  break;
                r3 += t3[s2];
              }
              if (r3.length !== 0) {
                var o = parseInt(r3, 16);
                return o >= 55296 && o <= 57343 || o === 0 || o > 1114111 ? ["\uFFFD", r3.length + (n2 ? 1 : 0)] : [String.fromCodePoint(o), r3.length + (n2 ? 1 : 0)];
              }
            }
            t2.__esModule = true, t2.default = function(e3) {
              if (!n.test(e3))
                return e3;
              for (var t3 = "", s2 = 0; s2 < e3.length; s2++)
                if (e3[s2] !== "\\")
                  t3 += e3[s2];
                else {
                  var i = r2(e3.slice(s2 + 1, s2 + 7));
                  if (i !== void 0) {
                    t3 += i[0], s2 += i[1];
                    continue;
                  }
                  if (e3[s2 + 1] === "\\") {
                    t3 += "\\", s2++;
                    continue;
                  }
                  e3.length === s2 + 1 && (t3 += e3[s2]);
                }
              return t3;
            };
            var n = /\\/;
            e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(52)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.SELECTOR, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n = a(r2(92)), s2 = r2(91), i = a(r2(15)), o = r2(5);
            function a(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            function l(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function c(e3, t3) {
              return (c = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var u = function(e3) {
              var t3, r3, i2, a2;
              function u2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = o.CLASS, r4._constructed = true, r4;
              }
              return r3 = e3, (t3 = u2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, c(t3, r3), u2.prototype.valueToString = function() {
                return "." + e3.prototype.valueToString.call(this);
              }, i2 = u2, (a2 = [{ key: "value", get: function() {
                return this._value;
              }, set: function(e4) {
                if (this._constructed) {
                  var t4 = (0, n.default)(e4, { isIdentifier: true });
                  t4 !== e4 ? ((0, s2.ensureObject)(this, "raws"), this.raws.value = t4) : this.raws && delete this.raws.value;
                }
                this._value = e4;
              } }]) && l(i2.prototype, a2), u2;
            }(i.default);
            t2.default = u, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.COMMENT, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.ID, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2.prototype.valueToString = function() {
                return "#" + e3.prototype.valueToString.call(this);
              }, n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(53)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.TAG, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.STRING, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(52)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.PSEUDO, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2.prototype.toString = function() {
                var e4 = this.length ? "(" + this.map(String).join(",") + ")" : "";
                return [this.rawSpaceBefore, this.stringifyProperty("value"), e4, this.rawSpaceAfter].join("");
              }, n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(53)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.UNIVERSAL, r4.value = "*", r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.COMBINATOR, r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(15)) && n.__esModule ? n : { default: n }, i = r2(5);
            function o(e3, t3) {
              return (o = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var a = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return (r4 = e3.call(this, t4) || this).type = i.NESTING, r4.value = "&", r4;
              }
              return r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, o(t3, r3), n2;
            }(s2.default);
            t2.default = a, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            var n = r2(110);
            e2.exports = function(e3) {
              return Object(n(e3));
            };
          }, (e2) => {
            e2.exports = function(e3) {
              if (e3 == null)
                throw TypeError("Can't call method on " + e3);
              return e3;
            };
          }, (e2, t2, r2) => {
            var n = r2(183), s2 = r2(55);
            (e2.exports = function(e3, t3) {
              return s2[e3] || (s2[e3] = t3 !== void 0 ? t3 : {});
            })("versions", []).push({ version: "3.15.2", mode: n ? "pure" : "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)" });
          }, (e2, t2, r2) => {
            var n = r2(31), s2 = r2(113), i = r2(57), o = r2(115), a = Object.defineProperty;
            t2.f = n ? a : function(e3, t3, r3) {
              if (i(e3), t3 = o(t3, true), i(r3), s2)
                try {
                  return a(e3, t3, r3);
                } catch (e4) {
                }
              if ("get" in r3 || "set" in r3)
                throw TypeError("Accessors not supported");
              return "value" in r3 && (e3[t3] = r3.value), e3;
            };
          }, (e2, t2, r2) => {
            var n = r2(31), s2 = r2(16), i = r2(114);
            e2.exports = !n && !s2(function() {
              return Object.defineProperty(i("div"), "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(24), i = n.document, o = s2(i) && s2(i.createElement);
            e2.exports = function(e3) {
              return o ? i.createElement(e3) : {};
            };
          }, (e2, t2, r2) => {
            var n = r2(24);
            e2.exports = function(e3, t3) {
              if (!n(e3))
                return e3;
              var r3, s2;
              if (t3 && typeof (r3 = e3.toString) == "function" && !n(s2 = r3.call(e3)))
                return s2;
              if (typeof (r3 = e3.valueOf) == "function" && !n(s2 = r3.call(e3)))
                return s2;
              if (!t3 && typeof (r3 = e3.toString) == "function" && !n(s2 = r3.call(e3)))
                return s2;
              throw TypeError("Can't convert object to primitive value");
            };
          }, (e2) => {
            e2.exports = function(e3, t2) {
              return { enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t2 };
            };
          }, (e2, t2, r2) => {
            var n = r2(118), s2 = r2(16);
            e2.exports = !!Object.getOwnPropertySymbols && !s2(function() {
              var e3 = Symbol();
              return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && n && n < 41;
            });
          }, (e2, t2, r2) => {
            var n, s2, i = r2(2), o = r2(33), a = i.process, l = a && a.versions, c = l && l.v8;
            c ? s2 = (n = c.split("."))[0] < 4 ? 1 : n[0] + n[1] : o && (!(n = o.match(/Edge\/(\d+)/)) || n[1] >= 74) && (n = o.match(/Chrome\/(\d+)/)) && (s2 = n[1]), e2.exports = s2 && +s2;
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(32), i = r2(17), o = r2(56), a = r2(120), l = r2(186), c = l.get, u = l.enforce, p2 = String(String).split("String");
            (e2.exports = function(e3, t3, r3, a2) {
              var l2, c4 = !!a2 && !!a2.unsafe, f = !!a2 && !!a2.enumerable, d = !!a2 && !!a2.noTargetGet;
              typeof r3 == "function" && (typeof t3 != "string" || i(r3, "name") || s2(r3, "name", t3), (l2 = u(r3)).source || (l2.source = p2.join(typeof t3 == "string" ? t3 : ""))), e3 !== n ? (c4 ? !d && e3[t3] && (f = true) : delete e3[t3], f ? e3[t3] = r3 : s2(e3, t3, r3)) : f ? e3[t3] = r3 : o(t3, r3);
            })(Function.prototype, "toString", function() {
              return typeof this == "function" && c(this).source || a(this);
            });
          }, (e2, t2, r2) => {
            var n = r2(55), s2 = Function.toString;
            typeof n.inspectSource != "function" && (n.inspectSource = function(e3) {
              return s2.call(e3);
            }), e2.exports = n.inspectSource;
          }, (e2, t2, r2) => {
            var n = r2(111), s2 = r2(58), i = n("keys");
            e2.exports = function(e3) {
              return i[e3] || (i[e3] = s2(e3));
            };
          }, (e2) => {
            e2.exports = {};
          }, (e2) => {
            e2.exports = function(e3) {
              if (typeof e3 != "function")
                throw TypeError(String(e3) + " is not a function");
              return e3;
            };
          }, (e2, t2, r2) => {
            var n = r2(125), s2 = Math.min;
            e2.exports = function(e3) {
              return e3 > 0 ? s2(n(e3), 9007199254740991) : 0;
            };
          }, (e2) => {
            var t2 = Math.ceil, r2 = Math.floor;
            e2.exports = function(e3) {
              return isNaN(e3 = +e3) ? 0 : (e3 > 0 ? r2 : t2)(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(211);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(10);
              return s2 = function() {
                return e3;
              }, e3;
            }
            function i() {
              const e3 = r2(39);
              return i = function() {
                return e3;
              }, e3;
            }
            function o() {
              const e3 = r2(0);
              return o = function() {
                return e3;
              }, e3;
            }
            function a() {
              const e3 = r2(239);
              return a = function() {
                return e3;
              }, e3;
            }
            function l() {
              const e3 = r2(28);
              return l = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            const c = { enter(e3, t3) {
              const r3 = e3.node.loc;
              r3 && (t3.loc = r3, e3.stop());
            } };
            class u {
              constructor(e3, { code: t3, ast: r3, inputMap: n2 }) {
                this._map = new Map(), this.opts = void 0, this.declarations = {}, this.path = null, this.ast = {}, this.scope = void 0, this.metadata = {}, this.code = "", this.inputMap = null, this.hub = { file: this, getCode: () => this.code, getScope: () => this.scope, addHelper: this.addHelper.bind(this), buildError: this.buildCodeFrameError.bind(this) }, this.opts = e3, this.code = t3, this.ast = r3, this.inputMap = n2, this.path = s2().NodePath.get({ hub: this.hub, parentPath: null, parent: this.ast, container: this.ast, key: "program" }).setContext(), this.scope = this.path.scope;
              }
              get shebang() {
                const { interpreter: e3 } = this.path.node;
                return e3 ? e3.value : "";
              }
              set shebang(e3) {
                e3 ? this.path.get("interpreter").replaceWith(o().interpreterDirective(e3)) : this.path.get("interpreter").remove();
              }
              set(e3, t3) {
                if (e3 === "helpersNamespace")
                  throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
                this._map.set(e3, t3);
              }
              get(e3) {
                return this._map.get(e3);
              }
              has(e3) {
                return this._map.has(e3);
              }
              getModuleName() {
                return (0, a().getModuleName)(this.opts, this.opts);
              }
              addImport() {
                throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
              }
              availableHelper(e3, t3) {
                let r3;
                try {
                  r3 = n().minVersion(e3);
                } catch (e4) {
                  if (e4.code !== "BABEL_HELPER_UNKNOWN")
                    throw e4;
                  return false;
                }
                return typeof t3 != "string" || (l().valid(t3) && (t3 = `^${t3}`), !l().intersects(`<${r3}`, t3) && !l().intersects(">=8.0.0", t3));
              }
              addHelper(e3) {
                const t3 = this.declarations[e3];
                if (t3)
                  return o().cloneNode(t3);
                const r3 = this.get("helperGenerator");
                if (r3) {
                  const t4 = r3(e3);
                  if (t4)
                    return t4;
                }
                n().ensure(e3, u);
                const s3 = this.declarations[e3] = this.scope.generateUidIdentifier(e3), i2 = {};
                for (const t4 of n().getDependencies(e3))
                  i2[t4] = this.addHelper(t4);
                const { nodes: a2, globals: l2 } = n().get(e3, (e4) => i2[e4], s3, Object.keys(this.scope.getAllBindings()));
                return l2.forEach((e4) => {
                  this.path.scope.hasBinding(e4, true) && this.path.scope.rename(e4);
                }), a2.forEach((e4) => {
                  e4._compact = true;
                }), this.path.unshiftContainer("body", a2), this.path.get("body").forEach((e4) => {
                  a2.indexOf(e4.node) !== -1 && e4.isVariableDeclaration() && this.scope.registerDeclaration(e4);
                }), s3;
              }
              addTemplateObject() {
                throw new Error("This function has been moved into the template literal transform itself.");
              }
              buildCodeFrameError(e3, t3, r3 = SyntaxError) {
                let n2 = e3 && (e3.loc || e3._loc);
                if (!n2 && e3) {
                  const r4 = { loc: null };
                  (0, s2().default)(e3, c, this.scope, r4), n2 = r4.loc;
                  let i2 = "This is an error on an internal node. Probably an internal error.";
                  n2 && (i2 += " Location has been estimated."), t3 += ` (${i2})`;
                }
                if (n2) {
                  const { highlightCode: e4 = true } = this.opts;
                  t3 += "\n" + (0, i().codeFrameColumns)(this.code, { start: { line: n2.start.line, column: n2.start.column + 1 }, end: n2.end && n2.start.line === n2.end.line ? { line: n2.end.line, column: n2.end.column + 1 } : void 0 }, { highlightCode: e4 });
                }
                return new r3(t3);
              }
            }
            t2.default = u;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r2 = Object.keys(t3);
              for (const n of r2)
                if (e3[n] !== t3[n])
                  return false;
              return true;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.classMethodOrDeclareMethodCommon = t2.classMethodOrPropertyCommon = t2.patternLikeCommon = t2.functionDeclarationCommon = t2.functionTypeAnnotationCommon = t2.functionCommon = void 0, r2(62), r2(38), r2(63);
            var n = r2(25), s2 = r2(20);
            (0, s2.default)("ArrayExpression", { fields: { elements: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeOrValueType)("null", "Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, s2.default)("AssignmentExpression", { fields: { operator: { validate: (0, s2.assertValueType)("string") }, left: { validate: (0, s2.assertNodeType)("LVal") }, right: { validate: (0, s2.assertNodeType)("Expression") } }, builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Expression"] }), (0, s2.default)("BinaryExpression", { builder: ["operator", "left", "right"], fields: { operator: { validate: (0, s2.assertOneOf)(...n.BINARY_OPERATORS) }, left: { validate: function() {
              const e3 = (0, s2.assertNodeType)("Expression"), t3 = (0, s2.assertNodeType)("Expression", "PrivateName"), r3 = function(r4, n2, s3) {
                (r4.operator === "in" ? t3 : e3)(r4, n2, s3);
              };
              return r3.oneOfNodeTypes = ["Expression", "PrivateName"], r3;
            }() }, right: { validate: (0, s2.assertNodeType)("Expression") } }, visitor: ["left", "right"], aliases: ["Binary", "Expression"] }), (0, s2.default)("InterpreterDirective", { builder: ["value"], fields: { value: { validate: (0, s2.assertValueType)("string") } } }), (0, s2.default)("Directive", { visitor: ["value"], fields: { value: { validate: (0, s2.assertNodeType)("DirectiveLiteral") } } }), (0, s2.default)("DirectiveLiteral", { builder: ["value"], fields: { value: { validate: (0, s2.assertValueType)("string") } } }), (0, s2.default)("BlockStatement", { builder: ["body", "directives"], visitor: ["directives", "body"], fields: { directives: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block", "Statement"] }), (0, s2.default)("BreakStatement", { visitor: ["label"], fields: { label: { validate: (0, s2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), (0, s2.default)("CallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments"], aliases: ["Expression"], fields: Object.assign({ callee: { validate: (0, s2.assertNodeType)("Expression", "V8IntrinsicIdentifier") }, arguments: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) } }, { optional: { validate: (0, s2.assertOneOf)(true, false), optional: true } }, { typeArguments: { validate: (0, s2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, s2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } }) }), (0, s2.default)("CatchClause", { visitor: ["param", "body"], fields: { param: { validate: (0, s2.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"), optional: true }, body: { validate: (0, s2.assertNodeType)("BlockStatement") } }, aliases: ["Scopable", "BlockParent"] }), (0, s2.default)("ConditionalExpression", { visitor: ["test", "consequent", "alternate"], fields: { test: { validate: (0, s2.assertNodeType)("Expression") }, consequent: { validate: (0, s2.assertNodeType)("Expression") }, alternate: { validate: (0, s2.assertNodeType)("Expression") } }, aliases: ["Expression", "Conditional"] }), (0, s2.default)("ContinueStatement", { visitor: ["label"], fields: { label: { validate: (0, s2.assertNodeType)("Identifier"), optional: true } }, aliases: ["Statement", "Terminatorless", "CompletionStatement"] }), (0, s2.default)("DebuggerStatement", { aliases: ["Statement"] }), (0, s2.default)("DoWhileStatement", { visitor: ["test", "body"], fields: { test: { validate: (0, s2.assertNodeType)("Expression") }, body: { validate: (0, s2.assertNodeType)("Statement") } }, aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"] }), (0, s2.default)("EmptyStatement", { aliases: ["Statement"] }), (0, s2.default)("ExpressionStatement", { visitor: ["expression"], fields: { expression: { validate: (0, s2.assertNodeType)("Expression") } }, aliases: ["Statement", "ExpressionWrapper"] }), (0, s2.default)("File", { builder: ["program", "comments", "tokens"], visitor: ["program"], fields: { program: { validate: (0, s2.assertNodeType)("Program") }, comments: { validate: Object.assign(() => {
            }, { each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] } }), optional: true }, tokens: { validate: (0, s2.assertEach)(Object.assign(() => {
            }, { type: "any" })), optional: true } } }), (0, s2.default)("ForInStatement", { visitor: ["left", "right", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, s2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, s2.assertNodeType)("Expression") }, body: { validate: (0, s2.assertNodeType)("Statement") } } }), (0, s2.default)("ForStatement", { visitor: ["init", "test", "update", "body"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"], fields: { init: { validate: (0, s2.assertNodeType)("VariableDeclaration", "Expression"), optional: true }, test: { validate: (0, s2.assertNodeType)("Expression"), optional: true }, update: { validate: (0, s2.assertNodeType)("Expression"), optional: true }, body: { validate: (0, s2.assertNodeType)("Statement") } } });
            const i = { params: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Identifier", "Pattern", "RestElement"))) }, generator: { default: false }, async: { default: false } };
            t2.functionCommon = i;
            const o = { returnType: { validate: (0, s2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, s2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true } };
            t2.functionTypeAnnotationCommon = o;
            const a = Object.assign({}, i, { declare: { validate: (0, s2.assertValueType)("boolean"), optional: true }, id: { validate: (0, s2.assertNodeType)("Identifier"), optional: true } });
            t2.functionDeclarationCommon = a, (0, s2.default)("FunctionDeclaration", { builder: ["id", "params", "body", "generator", "async"], visitor: ["id", "params", "body", "returnType", "typeParameters"], fields: Object.assign({}, a, o, { body: { validate: (0, s2.assertNodeType)("BlockStatement") } }), aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"], validate: () => {
            } }), (0, s2.default)("FunctionExpression", { inherits: "FunctionDeclaration", aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, i, o, { id: { validate: (0, s2.assertNodeType)("Identifier"), optional: true }, body: { validate: (0, s2.assertNodeType)("BlockStatement") } }) });
            const l = { typeAnnotation: { validate: (0, s2.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))) } };
            t2.patternLikeCommon = l, (0, s2.default)("Identifier", { builder: ["name"], visitor: ["typeAnnotation", "decorators"], aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"], fields: Object.assign({}, l, { name: { validate: (0, s2.chain)((0, s2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
            }, { type: "string" })) }, optional: { validate: (0, s2.assertValueType)("boolean"), optional: true } }), validate(e3, t3, r3) {
            } }), (0, s2.default)("IfStatement", { visitor: ["test", "consequent", "alternate"], aliases: ["Statement", "Conditional"], fields: { test: { validate: (0, s2.assertNodeType)("Expression") }, consequent: { validate: (0, s2.assertNodeType)("Statement") }, alternate: { optional: true, validate: (0, s2.assertNodeType)("Statement") } } }), (0, s2.default)("LabeledStatement", { visitor: ["label", "body"], aliases: ["Statement"], fields: { label: { validate: (0, s2.assertNodeType)("Identifier") }, body: { validate: (0, s2.assertNodeType)("Statement") } } }), (0, s2.default)("StringLiteral", { builder: ["value"], fields: { value: { validate: (0, s2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, s2.default)("NumericLiteral", { builder: ["value"], deprecatedAlias: "NumberLiteral", fields: { value: { validate: (0, s2.assertValueType)("number") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, s2.default)("NullLiteral", { aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, s2.default)("BooleanLiteral", { builder: ["value"], fields: { value: { validate: (0, s2.assertValueType)("boolean") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, s2.default)("RegExpLiteral", { builder: ["pattern", "flags"], deprecatedAlias: "RegexLiteral", aliases: ["Expression", "Pureish", "Literal"], fields: { pattern: { validate: (0, s2.assertValueType)("string") }, flags: { validate: (0, s2.chain)((0, s2.assertValueType)("string"), Object.assign(function(e3, t3, r3) {
            }, { type: "string" })), default: "" } } }), (0, s2.default)("LogicalExpression", { builder: ["operator", "left", "right"], visitor: ["left", "right"], aliases: ["Binary", "Expression"], fields: { operator: { validate: (0, s2.assertOneOf)(...n.LOGICAL_OPERATORS) }, left: { validate: (0, s2.assertNodeType)("Expression") }, right: { validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("MemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression", "LVal"], fields: Object.assign({ object: { validate: (0, s2.assertNodeType)("Expression") }, property: { validate: function() {
              const e3 = (0, s2.assertNodeType)("Identifier", "PrivateName"), t3 = (0, s2.assertNodeType)("Expression"), r3 = function(r4, n2, s3) {
                (r4.computed ? t3 : e3)(r4, n2, s3);
              };
              return r3.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"], r3;
            }() }, computed: { default: false } }, { optional: { validate: (0, s2.assertOneOf)(true, false), optional: true } }) }), (0, s2.default)("NewExpression", { inherits: "CallExpression" }), (0, s2.default)("Program", { visitor: ["directives", "body"], builder: ["body", "directives", "sourceType", "interpreter"], fields: { sourceFile: { validate: (0, s2.assertValueType)("string") }, sourceType: { validate: (0, s2.assertOneOf)("script", "module"), default: "script" }, interpreter: { validate: (0, s2.assertNodeType)("InterpreterDirective"), default: null, optional: true }, directives: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Directive"))), default: [] }, body: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent", "Block"] }), (0, s2.default)("ObjectExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ObjectMethod", "ObjectProperty", "SpreadElement"))) } } }), (0, s2.default)("ObjectMethod", { builder: ["kind", "key", "params", "body", "computed", "generator", "async"], fields: Object.assign({}, i, o, { kind: Object.assign({ validate: (0, s2.assertOneOf)("method", "get", "set") }, { default: "method" }), computed: { default: false }, key: { validate: function() {
              const e3 = (0, s2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), t3 = (0, s2.assertNodeType)("Expression"), r3 = function(r4, n2, s3) {
                (r4.computed ? t3 : e3)(r4, n2, s3);
              };
              return r3.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"], r3;
            }() }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true }, body: { validate: (0, s2.assertNodeType)("BlockStatement") } }), visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"] }), (0, s2.default)("ObjectProperty", { builder: ["key", "value", "computed", "shorthand", "decorators"], fields: { computed: { default: false }, key: { validate: function() {
              const e3 = (0, s2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), t3 = (0, s2.assertNodeType)("Expression"), r3 = function(r4, n2, s3) {
                (r4.computed ? t3 : e3)(r4, n2, s3);
              };
              return r3.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"], r3;
            }() }, value: { validate: (0, s2.assertNodeType)("Expression", "PatternLike") }, shorthand: { validate: (0, s2.chain)((0, s2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
            }, { type: "boolean" }), function(e3, t3, r3) {
            }), default: false }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true } }, visitor: ["key", "value", "decorators"], aliases: ["UserWhitespacable", "Property", "ObjectMember"], validate: ((0, s2.assertNodeType)("Identifier", "Pattern"), (0, s2.assertNodeType)("Expression"), function(e3, t3, r3) {
            }) }), (0, s2.default)("RestElement", { visitor: ["argument", "typeAnnotation"], builder: ["argument"], aliases: ["LVal", "PatternLike"], deprecatedAlias: "RestProperty", fields: Object.assign({}, l, { argument: { validate: (0, s2.assertNodeType)("LVal") } }), validate(e3, t3) {
            } }), (0, s2.default)("ReturnStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, s2.assertNodeType)("Expression"), optional: true } } }), (0, s2.default)("SequenceExpression", { visitor: ["expressions"], fields: { expressions: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Expression"))) } }, aliases: ["Expression"] }), (0, s2.default)("ParenthesizedExpression", { visitor: ["expression"], aliases: ["Expression", "ExpressionWrapper"], fields: { expression: { validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("SwitchCase", { visitor: ["test", "consequent"], fields: { test: { validate: (0, s2.assertNodeType)("Expression"), optional: true }, consequent: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Statement"))) } } }), (0, s2.default)("SwitchStatement", { visitor: ["discriminant", "cases"], aliases: ["Statement", "BlockParent", "Scopable"], fields: { discriminant: { validate: (0, s2.assertNodeType)("Expression") }, cases: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("SwitchCase"))) } } }), (0, s2.default)("ThisExpression", { aliases: ["Expression"] }), (0, s2.default)("ThrowStatement", { visitor: ["argument"], aliases: ["Statement", "Terminatorless", "CompletionStatement"], fields: { argument: { validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("TryStatement", { visitor: ["block", "handler", "finalizer"], aliases: ["Statement"], fields: { block: { validate: (0, s2.chain)((0, s2.assertNodeType)("BlockStatement"), Object.assign(function(e3) {
            }, { oneOfNodeTypes: ["BlockStatement"] })) }, handler: { optional: true, validate: (0, s2.assertNodeType)("CatchClause") }, finalizer: { optional: true, validate: (0, s2.assertNodeType)("BlockStatement") } } }), (0, s2.default)("UnaryExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: true }, argument: { validate: (0, s2.assertNodeType)("Expression") }, operator: { validate: (0, s2.assertOneOf)(...n.UNARY_OPERATORS) } }, visitor: ["argument"], aliases: ["UnaryLike", "Expression"] }), (0, s2.default)("UpdateExpression", { builder: ["operator", "argument", "prefix"], fields: { prefix: { default: false }, argument: { validate: (0, s2.assertNodeType)("Expression") }, operator: { validate: (0, s2.assertOneOf)(...n.UPDATE_OPERATORS) } }, visitor: ["argument"], aliases: ["Expression"] }), (0, s2.default)("VariableDeclaration", { builder: ["kind", "declarations"], visitor: ["declarations"], aliases: ["Statement", "Declaration"], fields: { declare: { validate: (0, s2.assertValueType)("boolean"), optional: true }, kind: { validate: (0, s2.assertOneOf)("var", "let", "const") }, declarations: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("VariableDeclarator"))) } }, validate(e3, t3, r3) {
            } }), (0, s2.default)("VariableDeclarator", { visitor: ["id", "init"], fields: { id: { validate: (0, s2.assertNodeType)("LVal") }, definite: { optional: true, validate: (0, s2.assertValueType)("boolean") }, init: { optional: true, validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("WhileStatement", { visitor: ["test", "body"], aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"], fields: { test: { validate: (0, s2.assertNodeType)("Expression") }, body: { validate: (0, s2.assertNodeType)("Statement") } } }), (0, s2.default)("WithStatement", { visitor: ["object", "body"], aliases: ["Statement"], fields: { object: { validate: (0, s2.assertNodeType)("Expression") }, body: { validate: (0, s2.assertNodeType)("Statement") } } }), (0, s2.default)("AssignmentPattern", { visitor: ["left", "right", "decorators"], builder: ["left", "right"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, l, { left: { validate: (0, s2.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression") }, right: { validate: (0, s2.assertNodeType)("Expression") }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true } }) }), (0, s2.default)("ArrayPattern", { visitor: ["elements", "typeAnnotation"], builder: ["elements"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, l, { elements: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeOrValueType)("null", "PatternLike"))) }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true } }) }), (0, s2.default)("ArrowFunctionExpression", { builder: ["params", "body", "async"], visitor: ["params", "body", "returnType", "typeParameters"], aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"], fields: Object.assign({}, i, o, { expression: { validate: (0, s2.assertValueType)("boolean") }, body: { validate: (0, s2.assertNodeType)("BlockStatement", "Expression") } }) }), (0, s2.default)("ClassBody", { visitor: ["body"], fields: { body: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature"))) } } }), (0, s2.default)("ClassExpression", { builder: ["id", "superClass", "body", "decorators"], visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"], aliases: ["Scopable", "Class", "Expression"], fields: { id: { validate: (0, s2.assertNodeType)("Identifier"), optional: true }, typeParameters: { validate: (0, s2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, s2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, s2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, s2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, s2.assertNodeType)("InterfaceExtends"), optional: true } } }), (0, s2.default)("ClassDeclaration", { inherits: "ClassExpression", aliases: ["Scopable", "Class", "Statement", "Declaration"], fields: { id: { validate: (0, s2.assertNodeType)("Identifier") }, typeParameters: { validate: (0, s2.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"), optional: true }, body: { validate: (0, s2.assertNodeType)("ClassBody") }, superClass: { optional: true, validate: (0, s2.assertNodeType)("Expression") }, superTypeParameters: { validate: (0, s2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true }, implements: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("TSExpressionWithTypeArguments", "ClassImplements"))), optional: true }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true }, mixins: { validate: (0, s2.assertNodeType)("InterfaceExtends"), optional: true }, declare: { validate: (0, s2.assertValueType)("boolean"), optional: true }, abstract: { validate: (0, s2.assertValueType)("boolean"), optional: true } }, validate: ((0, s2.assertNodeType)("Identifier"), function(e3, t3, r3) {
            }) }), (0, s2.default)("ExportAllDeclaration", { visitor: ["source"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { source: { validate: (0, s2.assertNodeType)("StringLiteral") }, exportKind: (0, s2.validateOptional)((0, s2.assertOneOf)("type", "value")), assertions: { optional: true, validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ImportAttribute"))) } } }), (0, s2.default)("ExportDefaultDeclaration", { visitor: ["declaration"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { declaration: { validate: (0, s2.assertNodeType)("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression") } } }), (0, s2.default)("ExportNamedDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"], fields: { declaration: { optional: true, validate: (0, s2.chain)((0, s2.assertNodeType)("Declaration"), Object.assign(function(e3, t3, r3) {
            }, { oneOfNodeTypes: ["Declaration"] }), function(e3, t3, r3) {
            }) }, assertions: { optional: true, validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ImportAttribute"))) }, specifiers: { default: [], validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)(function() {
              const e3 = (0, s2.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
              return (0, s2.assertNodeType)("ExportSpecifier"), e3;
            }())) }, source: { validate: (0, s2.assertNodeType)("StringLiteral"), optional: true }, exportKind: (0, s2.validateOptional)((0, s2.assertOneOf)("type", "value")) } }), (0, s2.default)("ExportSpecifier", { visitor: ["local", "exported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s2.assertNodeType)("Identifier") }, exported: { validate: (0, s2.assertNodeType)("Identifier", "StringLiteral") } } }), (0, s2.default)("ForOfStatement", { visitor: ["left", "right", "body"], builder: ["left", "right", "body", "await"], aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"], fields: { left: { validate: (0, s2.assertNodeType)("VariableDeclaration", "LVal") }, right: { validate: (0, s2.assertNodeType)("Expression") }, body: { validate: (0, s2.assertNodeType)("Statement") }, await: { default: false } } }), (0, s2.default)("ImportDeclaration", { visitor: ["specifiers", "source"], aliases: ["Statement", "Declaration", "ModuleDeclaration"], fields: { assertions: { optional: true, validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ImportAttribute"))) }, specifiers: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"))) }, source: { validate: (0, s2.assertNodeType)("StringLiteral") }, importKind: { validate: (0, s2.assertOneOf)("type", "typeof", "value"), optional: true } } }), (0, s2.default)("ImportDefaultSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s2.assertNodeType)("Identifier") } } }), (0, s2.default)("ImportNamespaceSpecifier", { visitor: ["local"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s2.assertNodeType)("Identifier") } } }), (0, s2.default)("ImportSpecifier", { visitor: ["local", "imported"], aliases: ["ModuleSpecifier"], fields: { local: { validate: (0, s2.assertNodeType)("Identifier") }, imported: { validate: (0, s2.assertNodeType)("Identifier", "StringLiteral") }, importKind: { validate: (0, s2.assertOneOf)("type", "typeof"), optional: true } } }), (0, s2.default)("MetaProperty", { visitor: ["meta", "property"], aliases: ["Expression"], fields: { meta: { validate: (0, s2.chain)((0, s2.assertNodeType)("Identifier"), Object.assign(function(e3, t3, r3) {
            }, { oneOfNodeTypes: ["Identifier"] })) }, property: { validate: (0, s2.assertNodeType)("Identifier") } } });
            const c = { abstract: { validate: (0, s2.assertValueType)("boolean"), optional: true }, accessibility: { validate: (0, s2.assertOneOf)("public", "private", "protected"), optional: true }, static: { default: false }, override: { default: false }, computed: { default: false }, optional: { validate: (0, s2.assertValueType)("boolean"), optional: true }, key: { validate: (0, s2.chain)(function() {
              const e3 = (0, s2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral"), t3 = (0, s2.assertNodeType)("Expression");
              return function(r3, n2, s3) {
                (r3.computed ? t3 : e3)(r3, n2, s3);
              };
            }(), (0, s2.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "Expression")) } };
            t2.classMethodOrPropertyCommon = c;
            const u = Object.assign({}, i, c, { params: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"))) }, kind: { validate: (0, s2.assertOneOf)("get", "set", "method", "constructor"), default: "method" }, access: { validate: (0, s2.chain)((0, s2.assertValueType)("string"), (0, s2.assertOneOf)("public", "private", "protected")), optional: true }, decorators: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Decorator"))), optional: true } });
            t2.classMethodOrDeclareMethodCommon = u, (0, s2.default)("ClassMethod", { aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"], builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], fields: Object.assign({}, u, o, { body: { validate: (0, s2.assertNodeType)("BlockStatement") } }) }), (0, s2.default)("ObjectPattern", { visitor: ["properties", "typeAnnotation", "decorators"], builder: ["properties"], aliases: ["Pattern", "PatternLike", "LVal"], fields: Object.assign({}, l, { properties: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("RestElement", "ObjectProperty"))) } }) }), (0, s2.default)("SpreadElement", { visitor: ["argument"], aliases: ["UnaryLike"], deprecatedAlias: "SpreadProperty", fields: { argument: { validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("Super", { aliases: ["Expression"] }), (0, s2.default)("TaggedTemplateExpression", { visitor: ["tag", "quasi"], aliases: ["Expression"], fields: { tag: { validate: (0, s2.assertNodeType)("Expression") }, quasi: { validate: (0, s2.assertNodeType)("TemplateLiteral") }, typeParameters: { validate: (0, s2.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), (0, s2.default)("TemplateElement", { builder: ["value", "tail"], fields: { value: { validate: (0, s2.assertShape)({ raw: { validate: (0, s2.assertValueType)("string") }, cooked: { validate: (0, s2.assertValueType)("string"), optional: true } }) }, tail: { default: false } } }), (0, s2.default)("TemplateLiteral", { visitor: ["quasis", "expressions"], aliases: ["Expression", "Literal"], fields: { quasis: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("TemplateElement"))) }, expressions: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Expression", "TSType")), function(e3, t3, r3) {
              if (e3.quasis.length !== r3.length + 1)
                throw new TypeError(`Number of ${e3.type} quasis should be exactly one more than the number of expressions.
Expected ${r3.length + 1} quasis but got ${e3.quasis.length}`);
            }) } } }), (0, s2.default)("YieldExpression", { builder: ["argument", "delegate"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { delegate: { validate: (0, s2.chain)((0, s2.assertValueType)("boolean"), Object.assign(function(e3, t3, r3) {
            }, { type: "boolean" })), default: false }, argument: { optional: true, validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("AwaitExpression", { builder: ["argument"], visitor: ["argument"], aliases: ["Expression", "Terminatorless"], fields: { argument: { validate: (0, s2.assertNodeType)("Expression") } } }), (0, s2.default)("Import", { aliases: ["Expression"] }), (0, s2.default)("BigIntLiteral", { builder: ["value"], fields: { value: { validate: (0, s2.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, s2.default)("ExportNamespaceSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, s2.assertNodeType)("Identifier") } } }), (0, s2.default)("OptionalMemberExpression", { builder: ["object", "property", "computed", "optional"], visitor: ["object", "property"], aliases: ["Expression"], fields: { object: { validate: (0, s2.assertNodeType)("Expression") }, property: { validate: function() {
              const e3 = (0, s2.assertNodeType)("Identifier"), t3 = (0, s2.assertNodeType)("Expression"), r3 = function(r4, n2, s3) {
                (r4.computed ? t3 : e3)(r4, n2, s3);
              };
              return r3.oneOfNodeTypes = ["Expression", "Identifier"], r3;
            }() }, computed: { default: false }, optional: { validate: (0, s2.assertValueType)("boolean") } } }), (0, s2.default)("OptionalCallExpression", { visitor: ["callee", "arguments", "typeParameters", "typeArguments"], builder: ["callee", "arguments", "optional"], aliases: ["Expression"], fields: { callee: { validate: (0, s2.assertNodeType)("Expression") }, arguments: { validate: (0, s2.chain)((0, s2.assertValueType)("array"), (0, s2.assertEach)((0, s2.assertNodeType)("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder"))) }, optional: { validate: (0, s2.assertValueType)("boolean") }, typeArguments: { validate: (0, s2.assertNodeType)("TypeParameterInstantiation"), optional: true }, typeParameters: { validate: (0, s2.assertNodeType)("TSTypeParameterInstantiation"), optional: true } } });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              if (e3 === t3)
                return true;
              if (n.ALIAS_KEYS[t3])
                return false;
              const r3 = n.FLIPPED_ALIAS_KEYS[t3];
              if (r3) {
                if (r3[0] === e3)
                  return true;
                for (const t4 of r3)
                  if (e3 === t4)
                    return true;
              }
              return false;
            };
            var n = r2(11);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              if (!e3)
                return;
              const o = n.NODE_FIELDS[e3.type];
              if (!o)
                return;
              s2(e3, t3, r3, o[t3]), i(e3, t3, r3);
            }, t2.validateField = s2, t2.validateChild = i;
            var n = r2(11);
            function s2(e3, t3, r3, n2) {
              n2 != null && n2.validate && (n2.optional && r3 == null || n2.validate(e3, t3, r3));
            }
            function i(e3, t3, r3) {
              if (r3 == null)
                return;
              const s3 = n.NODE_PARENT_VALIDATIONS[r3.type];
              s3 && s3(e3, t3, r3);
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
              t3 && r2 && (t3[e3] = Array.from(new Set([].concat(t3[e3], r2[e3]).filter(Boolean))));
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              if (!e3.isExportDeclaration())
                throw new Error("Only export declarations can be split.");
              const t3 = e3.isExportDefaultDeclaration(), r3 = e3.get("declaration"), s2 = r3.isClassDeclaration();
              if (t3) {
                const t4 = r3.isFunctionDeclaration() || s2, i2 = r3.isScope() ? r3.scope.parent : r3.scope;
                let o2 = r3.node.id, a2 = false;
                o2 || (a2 = true, o2 = i2.generateUidIdentifier("default"), (t4 || r3.isFunctionExpression() || r3.isClassExpression()) && (r3.node.id = n.cloneNode(o2)));
                const l = t4 ? r3 : n.variableDeclaration("var", [n.variableDeclarator(n.cloneNode(o2), r3.node)]), c = n.exportNamedDeclaration(null, [n.exportSpecifier(n.cloneNode(o2), n.identifier("default"))]);
                return e3.insertAfter(c), e3.replaceWith(l), a2 && i2.registerDeclaration(e3), e3;
              }
              if (e3.get("specifiers").length > 0)
                throw new Error("It doesn't make sense to split exported specifiers.");
              const i = r3.getOuterBindingIdentifiers(), o = Object.keys(i).map((e4) => n.exportSpecifier(n.identifier(e4), n.identifier(e4))), a = n.exportNamedDeclaration(null, o);
              return e3.insertAfter(a), e3.replaceWith(r3.node), e3;
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              return new i(e3, t3, r3).generate();
            }, t2.CodeGenerator = void 0;
            var n = r2(416), s2 = r2(418);
            class i extends s2.default {
              constructor(e3, t3 = {}, r3) {
                super(function(e4, t4) {
                  const r4 = { auxiliaryCommentBefore: t4.auxiliaryCommentBefore, auxiliaryCommentAfter: t4.auxiliaryCommentAfter, shouldPrintComment: t4.shouldPrintComment, retainLines: t4.retainLines, retainFunctionParens: t4.retainFunctionParens, comments: t4.comments == null || t4.comments, compact: t4.compact, minified: t4.minified, concise: t4.concise, indent: { adjustMultilineComment: true, style: "  ", base: 0 }, decoratorsBeforeExport: !!t4.decoratorsBeforeExport, jsescOption: Object.assign({ quotes: "double", wrap: true, minimal: false }, t4.jsescOption), recordAndTupleSyntaxType: t4.recordAndTupleSyntaxType };
                  return r4.jsonCompatibleStrings = t4.jsonCompatibleStrings, r4.minified ? (r4.compact = true, r4.shouldPrintComment = r4.shouldPrintComment || (() => r4.comments)) : r4.shouldPrintComment = r4.shouldPrintComment || ((e5) => r4.comments || e5.indexOf("@license") >= 0 || e5.indexOf("@preserve") >= 0), r4.compact === "auto" && (r4.compact = e4.length > 5e5, r4.compact), r4.compact && (r4.indent.adjustMultilineComment = false), r4;
                }(r3, t3), t3.sourceMaps ? new n.default(t3, r3) : null), this.ast = void 0, this.ast = e3;
              }
              generate() {
                return super.generate(this.ast);
              }
            }
            t2.CodeGenerator = class {
              constructor(e3, t3, r3) {
                this._generator = void 0, this._generator = new i(e3, t3, r3);
              }
              generate() {
                return this._generator.generate();
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function({ node: e3, parent: t3, scope: r3, id: s3 }, c = false) {
              if (e3.id)
                return;
              if (!i.isObjectProperty(t3) && !i.isObjectMethod(t3, { kind: "method" }) || t3.computed && !i.isLiteral(t3.key)) {
                if (i.isVariableDeclarator(t3)) {
                  if (s3 = t3.id, i.isIdentifier(s3) && !c) {
                    const t4 = r3.parent.getBinding(s3.name);
                    if (t4 && t4.constant && r3.getBinding(s3.name) === t4)
                      return e3.id = i.cloneNode(s3), void (e3.id[i.NOT_LOCAL_BINDING] = true);
                  }
                } else if (i.isAssignmentExpression(t3, { operator: "=" }))
                  s3 = t3.left;
                else if (!s3)
                  return;
              } else
                s3 = t3.key;
              let u;
              return s3 && i.isLiteral(s3) ? u = function(e4) {
                return i.isNullLiteral(e4) ? "null" : i.isRegExpLiteral(e4) ? `_${e4.pattern}_${e4.flags}` : i.isTemplateLiteral(e4) ? e4.quasis.map((e5) => e5.value.raw).join("") : e4.value !== void 0 ? e4.value + "" : "";
              }(s3) : s3 && i.isIdentifier(s3) && (u = s3.name), u !== void 0 ? (u = i.toBindingIdentifierName(u), (s3 = i.identifier(u))[i.NOT_LOCAL_BINDING] = true, function(e4, t4, r4, s4) {
                if (e4.selfReference) {
                  if (!s4.hasBinding(r4.name) || s4.hasGlobal(r4.name)) {
                    if (!i.isFunction(t4))
                      return;
                    let e5 = o;
                    t4.generator && (e5 = a);
                    const l2 = e5({ FUNCTION: t4, FUNCTION_ID: r4, FUNCTION_KEY: s4.generateUidIdentifier(r4.name) }).expression, c4 = l2.callee.body.body[0].params;
                    for (let e6 = 0, r5 = (0, n.default)(t4); e6 < r5; e6++)
                      c4.push(s4.generateUidIdentifier("x"));
                    return l2;
                  }
                  s4.rename(r4.name);
                }
                t4.id = r4, s4.getProgramParent().references[r4.name] = true;
              }(function(e4, t4, r4) {
                const n2 = { selfAssignment: false, selfReference: false, outerDeclar: r4.getBindingIdentifier(t4), references: [], name: t4 }, s4 = r4.getOwnBinding(t4);
                return s4 ? s4.kind === "param" && (n2.selfReference = true) : (n2.outerDeclar || r4.hasGlobal(t4)) && r4.traverse(e4, l, n2), n2;
              }(e3, u, r3), e3, s3, r3) || e3) : void 0;
            };
            var n = r2(442), s2 = r2(21), i = r2(0);
            const o = (0, s2.default)("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), a = (0, s2.default)("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"), l = { "ReferencedIdentifier|BindingIdentifier"(e3, t3) {
              e3.node.name === t3.name && e3.scope.getBindingIdentifier(t3.name) === t3.outerDeclar && (t3.selfReference = true, e3.stop());
            } };
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.merge = function(e3, t3) {
              const { placeholderWhitelist: r2 = e3.placeholderWhitelist, placeholderPattern: n = e3.placeholderPattern, preserveComments: s2 = e3.preserveComments, syntacticPlaceholders: i = e3.syntacticPlaceholders } = t3;
              return { parser: Object.assign({}, e3.parser, t3.parser), placeholderWhitelist: r2, placeholderPattern: n, preserveComments: s2, syntacticPlaceholders: i };
            }, t2.validate = function(e3) {
              if (e3 != null && typeof e3 != "object")
                throw new Error("Unknown template options.");
              const t3 = e3 || {}, { placeholderWhitelist: r2, placeholderPattern: n, preserveComments: s2, syntacticPlaceholders: i } = t3, o = function(e4, t4) {
                if (e4 == null)
                  return {};
                var r3, n2, s3 = {}, i2 = Object.keys(e4);
                for (n2 = 0; n2 < i2.length; n2++)
                  r3 = i2[n2], t4.indexOf(r3) >= 0 || (s3[r3] = e4[r3]);
                return s3;
              }(t3, ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"]);
              if (r2 != null && !(r2 instanceof Set))
                throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
              if (n != null && !(n instanceof RegExp) && n !== false)
                throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
              if (s2 != null && typeof s2 != "boolean")
                throw new Error("'.preserveComments' must be a boolean, null, or undefined");
              if (i != null && typeof i != "boolean")
                throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
              if (i === true && (r2 != null || n != null))
                throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
              return { parser: o, placeholderWhitelist: r2 || void 0, placeholderPattern: n == null ? void 0 : n, preserveComments: s2 == null ? void 0 : s2, syntacticPlaceholders: i == null ? void 0 : i };
            }, t2.normalizeReplacements = function(e3) {
              if (Array.isArray(e3))
                return e3.reduce((e4, t3, r2) => (e4["$" + r2] = t3, e4), {});
              if (typeof e3 == "object" || e3 == null)
                return e3 || void 0;
              throw new Error("Template replacements must be an array, object, null, or undefined");
            };
          }, (e2) => {
            var t2 = Object.prototype.hasOwnProperty, r2 = Object.prototype.toString;
            e2.exports = function(e3, n, s2) {
              if (r2.call(n) !== "[object Function]")
                throw new TypeError("iterator must be a function");
              var i = e3.length;
              if (i === +i)
                for (var o = 0; o < i; o++)
                  n.call(s2, e3[o], o, e3);
              else
                for (var a in e3)
                  t2.call(e3, a) && n.call(s2, e3[a], a, e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = ["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"];
            e2.exports = function() {
              for (var e3 = [], t3 = 0; t3 < n.length; t3++)
                typeof r2.g[n[t3]] == "function" && (e3[e3.length] = n[t3]);
              return e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(67)("%Object.getOwnPropertyDescriptor%");
            if (n)
              try {
                n([], "length");
              } catch (e3) {
                n = null;
              }
            e2.exports = n;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(136), s2 = r2(137), i = r2(66), o = i("Object.prototype.toString"), a = r2(68)() && typeof Symbol.toStringTag == "symbol", l = s2(), c = i("Array.prototype.indexOf", true) || function(e3, t3) {
              for (var r3 = 0; r3 < e3.length; r3 += 1)
                if (e3[r3] === t3)
                  return r3;
              return -1;
            }, u = i("String.prototype.slice"), p2 = {}, f = r2(138), d = Object.getPrototypeOf;
            a && f && d && n(l, function(e3) {
              var t3 = new r2.g[e3]();
              if (!(Symbol.toStringTag in t3))
                throw new EvalError("this engine has support for Symbol.toStringTag, but " + e3 + " does not have the property! Please report this.");
              var n2 = d(t3), s3 = f(n2, Symbol.toStringTag);
              if (!s3) {
                var i2 = d(n2);
                s3 = f(i2, Symbol.toStringTag);
              }
              p2[e3] = s3.get;
            }), e2.exports = function(e3) {
              if (!e3 || typeof e3 != "object")
                return false;
              if (!a) {
                var t3 = u(o(e3), 8, -1);
                return c(l, t3) > -1;
              }
              return !!f && function(e4) {
                var t4 = false;
                return n(p2, function(r3, n2) {
                  if (!t4)
                    try {
                      t4 = r3.call(e4) === n2;
                    } catch (e5) {
                    }
                }), t4;
              }(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(40), s2 = r2(51), i = r2(142), o = r2(143), a = r2(253), l = s2(o(), Object);
            n(l, { getPolyfill: o, implementation: i, shim: a }), e2.exports = l;
          }, (e2) => {
            "use strict";
            var t2 = Object.prototype.toString;
            e2.exports = function(e3) {
              var r2 = t2.call(e3), n = r2 === "[object Arguments]";
              return n || (n = r2 !== "[object Array]" && e3 !== null && typeof e3 == "object" && typeof e3.length == "number" && e3.length >= 0 && t2.call(e3.callee) === "[object Function]"), n;
            };
          }, (e2) => {
            "use strict";
            var t2 = function(e3) {
              return e3 != e3;
            };
            e2.exports = function(e3, r2) {
              return e3 === 0 && r2 === 0 ? 1 / e3 == 1 / r2 : e3 === r2 || !(!t2(e3) || !t2(r2));
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(142);
            e2.exports = function() {
              return typeof Object.is == "function" ? Object.is : n;
            };
          }, (e2) => {
            "use strict";
            e2.exports = function(e3) {
              return e3 != e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(144);
            e2.exports = function() {
              return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : n;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.addDefault = function(e3, t3, r3) {
              return new n.default(e3).addDefault(t3, r3);
            }, t2.addNamed = function(e3, t3, r3, s3) {
              return new n.default(e3).addNamed(t3, r3, s3);
            }, t2.addNamespace = function(e3, t3, r3) {
              return new n.default(e3).addNamespace(t3, r3);
            }, t2.addSideEffect = function(e3, t3, r3) {
              return new n.default(e3).addSideEffect(t3, r3);
            }, Object.defineProperty(t2, "ImportInjector", { enumerable: true, get: function() {
              return n.default;
            } }), Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
              return s2.default;
            } });
            var n = r2(459), s2 = r2(257);
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(e3, t3, r3) !== 0;
          }, (e2, t2, r2) => {
            const n = r2(71), s2 = r2(147), i = r2(44), o = r2(74), a = r2(73), l = r2(75);
            e2.exports = (e3, t3, r3, c) => {
              switch (t3) {
                case "===":
                  return typeof e3 == "object" && (e3 = e3.version), typeof r3 == "object" && (r3 = r3.version), e3 === r3;
                case "!==":
                  return typeof e3 == "object" && (e3 = e3.version), typeof r3 == "object" && (r3 = r3.version), e3 !== r3;
                case "":
                case "=":
                case "==":
                  return n(e3, r3, c);
                case "!=":
                  return s2(e3, r3, c);
                case ">":
                  return i(e3, r3, c);
                case ">=":
                  return o(e3, r3, c);
                case "<":
                  return a(e3, r3, c);
                case "<=":
                  return l(e3, r3, c);
                default:
                  throw new TypeError(`Invalid operator: ${t3}`);
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            const n = r2(274), s2 = Symbol("max"), i = Symbol("length"), o = Symbol("lengthCalculator"), a = Symbol("allowStale"), l = Symbol("maxAge"), c = Symbol("dispose"), u = Symbol("noDisposeOnSet"), p2 = Symbol("lruList"), f = Symbol("cache"), d = Symbol("updateAgeOnGet"), h3 = () => 1, m = (e3, t3, r3) => {
              const n2 = e3[f].get(t3);
              if (n2) {
                const t4 = n2.value;
                if (y(e3, t4)) {
                  if (b(e3, n2), !e3[a])
                    return;
                } else
                  r3 && (e3[d] && (n2.value.now = Date.now()), e3[p2].unshiftNode(n2));
                return t4.value;
              }
            }, y = (e3, t3) => {
              if (!t3 || !t3.maxAge && !e3[l])
                return false;
              const r3 = Date.now() - t3.now;
              return t3.maxAge ? r3 > t3.maxAge : e3[l] && r3 > e3[l];
            }, g = (e3) => {
              if (e3[i] > e3[s2])
                for (let t3 = e3[p2].tail; e3[i] > e3[s2] && t3 !== null; ) {
                  const r3 = t3.prev;
                  b(e3, t3), t3 = r3;
                }
            }, b = (e3, t3) => {
              if (t3) {
                const r3 = t3.value;
                e3[c] && e3[c](r3.key, r3.value), e3[i] -= r3.length, e3[f].delete(r3.key), e3[p2].removeNode(t3);
              }
            };
            class v {
              constructor(e3, t3, r3, n2, s3) {
                this.key = e3, this.value = t3, this.length = r3, this.now = n2, this.maxAge = s3 || 0;
              }
            }
            const E = (e3, t3, r3, n2) => {
              let s3 = r3.value;
              y(e3, s3) && (b(e3, r3), e3[a] || (s3 = void 0)), s3 && t3.call(n2, s3.value, s3.key, e3);
            };
            e2.exports = class {
              constructor(e3) {
                if (typeof e3 == "number" && (e3 = { max: e3 }), e3 || (e3 = {}), e3.max && (typeof e3.max != "number" || e3.max < 0))
                  throw new TypeError("max must be a non-negative number");
                this[s2] = e3.max || 1 / 0;
                const t3 = e3.length || h3;
                if (this[o] = typeof t3 != "function" ? h3 : t3, this[a] = e3.stale || false, e3.maxAge && typeof e3.maxAge != "number")
                  throw new TypeError("maxAge must be a number");
                this[l] = e3.maxAge || 0, this[c] = e3.dispose, this[u] = e3.noDisposeOnSet || false, this[d] = e3.updateAgeOnGet || false, this.reset();
              }
              set max(e3) {
                if (typeof e3 != "number" || e3 < 0)
                  throw new TypeError("max must be a non-negative number");
                this[s2] = e3 || 1 / 0, g(this);
              }
              get max() {
                return this[s2];
              }
              set allowStale(e3) {
                this[a] = !!e3;
              }
              get allowStale() {
                return this[a];
              }
              set maxAge(e3) {
                if (typeof e3 != "number")
                  throw new TypeError("maxAge must be a non-negative number");
                this[l] = e3, g(this);
              }
              get maxAge() {
                return this[l];
              }
              set lengthCalculator(e3) {
                typeof e3 != "function" && (e3 = h3), e3 !== this[o] && (this[o] = e3, this[i] = 0, this[p2].forEach((e4) => {
                  e4.length = this[o](e4.value, e4.key), this[i] += e4.length;
                })), g(this);
              }
              get lengthCalculator() {
                return this[o];
              }
              get length() {
                return this[i];
              }
              get itemCount() {
                return this[p2].length;
              }
              rforEach(e3, t3) {
                t3 = t3 || this;
                for (let r3 = this[p2].tail; r3 !== null; ) {
                  const n2 = r3.prev;
                  E(this, e3, r3, t3), r3 = n2;
                }
              }
              forEach(e3, t3) {
                t3 = t3 || this;
                for (let r3 = this[p2].head; r3 !== null; ) {
                  const n2 = r3.next;
                  E(this, e3, r3, t3), r3 = n2;
                }
              }
              keys() {
                return this[p2].toArray().map((e3) => e3.key);
              }
              values() {
                return this[p2].toArray().map((e3) => e3.value);
              }
              reset() {
                this[c] && this[p2] && this[p2].length && this[p2].forEach((e3) => this[c](e3.key, e3.value)), this[f] = new Map(), this[p2] = new n(), this[i] = 0;
              }
              dump() {
                return this[p2].map((e3) => !y(this, e3) && { k: e3.key, v: e3.value, e: e3.now + (e3.maxAge || 0) }).toArray().filter((e3) => e3);
              }
              dumpLru() {
                return this[p2];
              }
              set(e3, t3, r3) {
                if ((r3 = r3 || this[l]) && typeof r3 != "number")
                  throw new TypeError("maxAge must be a number");
                const n2 = r3 ? Date.now() : 0, a2 = this[o](t3, e3);
                if (this[f].has(e3)) {
                  if (a2 > this[s2])
                    return b(this, this[f].get(e3)), false;
                  const o2 = this[f].get(e3).value;
                  return this[c] && (this[u] || this[c](e3, o2.value)), o2.now = n2, o2.maxAge = r3, o2.value = t3, this[i] += a2 - o2.length, o2.length = a2, this.get(e3), g(this), true;
                }
                const d2 = new v(e3, t3, a2, n2, r3);
                return d2.length > this[s2] ? (this[c] && this[c](e3, t3), false) : (this[i] += d2.length, this[p2].unshift(d2), this[f].set(e3, this[p2].head), g(this), true);
              }
              has(e3) {
                if (!this[f].has(e3))
                  return false;
                const t3 = this[f].get(e3).value;
                return !y(this, t3);
              }
              get(e3) {
                return m(this, e3, true);
              }
              peek(e3) {
                return m(this, e3, false);
              }
              pop() {
                const e3 = this[p2].tail;
                return e3 ? (b(this, e3), e3.value) : null;
              }
              del(e3) {
                b(this, this[f].get(e3));
              }
              load(e3) {
                this.reset();
                const t3 = Date.now();
                for (let r3 = e3.length - 1; r3 >= 0; r3--) {
                  const n2 = e3[r3], s3 = n2.e || 0;
                  if (s3 === 0)
                    this.set(n2.k, n2.v);
                  else {
                    const e4 = s3 - t3;
                    e4 > 0 && this.set(n2.k, n2.v, e4);
                  }
                }
              }
              prune() {
                this[f].forEach((e3, t3) => m(this, t3, false));
              }
            };
          }, (e2, t2) => {
            "use strict";
            function r2(e3, t3) {
              for (const r3 of Object.keys(t3)) {
                const n = t3[r3];
                n !== void 0 && (e3[r3] = n);
              }
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.mergeOptions = function(e3, t3) {
              for (const n of Object.keys(t3))
                if (n !== "parserOpts" && n !== "generatorOpts" && n !== "assumptions" || !t3[n]) {
                  const r3 = t3[n];
                  r3 !== void 0 && (e3[n] = r3);
                } else {
                  const s2 = t3[n];
                  r2(e3[n] || (e3[n] = {}), s2);
                }
            }, t2.isIterableIterator = function(e3) {
              return !!e3 && typeof e3.next == "function" && typeof e3[Symbol.iterator] == "function";
            };
          }, (e2) => {
            function t2(e3) {
              this.name = "BrowserslistError", this.message = e3, this.browserslist = true, Error.captureStackTrace && Error.captureStackTrace(this, t2);
            }
            t2.prototype = Error.prototype, e2.exports = t2;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.semverMin = l, t2.semverify = function(e3) {
              if (typeof e3 == "string" && n.valid(e3))
                return e3;
              a.invariant(typeof e3 == "number" || typeof e3 == "string" && o.test(e3), `'${e3}' is not a valid version`);
              const t3 = e3.toString().split(".");
              for (; t3.length < 3; )
                t3.push("0");
              return t3.join(".");
            }, t2.isUnreleasedVersion = function(e3, t3) {
              const r3 = i.unreleasedLabels[t3];
              return !!r3 && r3 === e3.toString().toLowerCase();
            }, t2.getLowestUnreleased = c, t2.getHighestUnreleased = function(e3, t3, r3) {
              return c(e3, t3, r3) === e3 ? t3 : e3;
            }, t2.getLowestImplementedVersion = function(e3, t3) {
              const r3 = e3[t3];
              return r3 || t3 !== "android" ? r3 : e3.chrome;
            };
            var n = r2(28), s2 = r2(297), i = r2(153);
            const o = /^(\d+|\d+.\d+)$/, a = new s2.OptionValidator("@babel/helper-compilation-targets");
            function l(e3, t3) {
              return e3 && n.lt(e3, t3) ? e3 : t3;
            }
            function c(e3, t3, r3) {
              const n2 = i.unreleasedLabels[r3], s3 = [e3, t3].some((e4) => e4 === n2);
              return s3 ? e3 === s3 ? t3 : e3 || t3 : l(e3, t3);
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.browserNameMap = t2.unreleasedLabels = void 0, t2.unreleasedLabels = { safari: "tp" }, t2.browserNameMap = { and_chr: "chrome", and_ff: "firefox", android: "android", chrome: "chrome", edge: "edge", firefox: "firefox", ie: "ie", ie_mob: "ie", ios_saf: "ios", node: "node", op_mob: "opera", opera: "opera", safari: "safari", samsung: "samsung" };
          }, (e2) => {
            "use strict";
            e2.exports.isClean = Symbol("isClean"), e2.exports.my = Symbol("my");
          }, (e2) => {
            "use strict";
            const t2 = { colon: ": ", indent: "    ", beforeDecl: "\n", beforeRule: "\n", beforeOpen: " ", beforeClose: "\n", beforeComment: "\n", after: "\n", emptyBody: "", commentLeft: " ", commentRight: " ", semicolon: false };
            e2.exports = class {
              constructor(e3) {
                this.builder = e3;
              }
              stringify(e3, t3) {
                if (!this[e3.type])
                  throw new Error("Unknown AST node type " + e3.type + ". Maybe you need to change PostCSS stringifier.");
                this[e3.type](e3, t3);
              }
              document(e3) {
                this.body(e3);
              }
              root(e3) {
                this.body(e3), e3.raws.after && this.builder(e3.raws.after);
              }
              comment(e3) {
                let t3 = this.raw(e3, "left", "commentLeft"), r2 = this.raw(e3, "right", "commentRight");
                this.builder("/*" + t3 + e3.text + r2 + "*/", e3);
              }
              decl(e3, t3) {
                let r2 = this.raw(e3, "between", "colon"), n = e3.prop + r2 + this.rawValue(e3, "value");
                e3.important && (n += e3.raws.important || " !important"), t3 && (n += ";"), this.builder(n, e3);
              }
              rule(e3) {
                this.block(e3, this.rawValue(e3, "selector")), e3.raws.ownSemicolon && this.builder(e3.raws.ownSemicolon, e3, "end");
              }
              atrule(e3, t3) {
                let r2 = "@" + e3.name, n = e3.params ? this.rawValue(e3, "params") : "";
                if (e3.raws.afterName !== void 0 ? r2 += e3.raws.afterName : n && (r2 += " "), e3.nodes)
                  this.block(e3, r2 + n);
                else {
                  let s2 = (e3.raws.between || "") + (t3 ? ";" : "");
                  this.builder(r2 + n + s2, e3);
                }
              }
              body(e3) {
                let t3 = e3.nodes.length - 1;
                for (; t3 > 0 && e3.nodes[t3].type === "comment"; )
                  t3 -= 1;
                let r2 = this.raw(e3, "semicolon");
                for (let n = 0; n < e3.nodes.length; n++) {
                  let s2 = e3.nodes[n], i = this.raw(s2, "before");
                  i && this.builder(i), this.stringify(s2, t3 !== n || r2);
                }
              }
              block(e3, t3) {
                let r2, n = this.raw(e3, "between", "beforeOpen");
                this.builder(t3 + n + "{", e3, "start"), e3.nodes && e3.nodes.length ? (this.body(e3), r2 = this.raw(e3, "after")) : r2 = this.raw(e3, "after", "emptyBody"), r2 && this.builder(r2), this.builder("}", e3, "end");
              }
              raw(e3, r2, n) {
                let s2;
                if (n || (n = r2), r2 && (s2 = e3.raws[r2], s2 !== void 0))
                  return s2;
                let i = e3.parent;
                if (n === "before") {
                  if (!i || i.type === "root" && i.first === e3)
                    return "";
                  if (i && i.type === "document")
                    return "";
                }
                if (!i)
                  return t2[n];
                let o = e3.root();
                if (o.rawCache || (o.rawCache = {}), o.rawCache[n] !== void 0)
                  return o.rawCache[n];
                if (n === "before" || n === "after")
                  return this.beforeAfter(e3, n);
                {
                  let t3 = "raw" + ((a = n)[0].toUpperCase() + a.slice(1));
                  this[t3] ? s2 = this[t3](o, e3) : o.walk((e4) => {
                    if (s2 = e4.raws[r2], s2 !== void 0)
                      return false;
                  });
                }
                var a;
                return s2 === void 0 && (s2 = t2[n]), o.rawCache[n] = s2, s2;
              }
              rawSemicolon(e3) {
                let t3;
                return e3.walk((e4) => {
                  if (e4.nodes && e4.nodes.length && e4.last.type === "decl" && (t3 = e4.raws.semicolon, t3 !== void 0))
                    return false;
                }), t3;
              }
              rawEmptyBody(e3) {
                let t3;
                return e3.walk((e4) => {
                  if (e4.nodes && e4.nodes.length === 0 && (t3 = e4.raws.after, t3 !== void 0))
                    return false;
                }), t3;
              }
              rawIndent(e3) {
                if (e3.raws.indent)
                  return e3.raws.indent;
                let t3;
                return e3.walk((r2) => {
                  let n = r2.parent;
                  if (n && n !== e3 && n.parent && n.parent === e3 && r2.raws.before !== void 0) {
                    let e4 = r2.raws.before.split("\n");
                    return t3 = e4[e4.length - 1], t3 = t3.replace(/\S/g, ""), false;
                  }
                }), t3;
              }
              rawBeforeComment(e3, t3) {
                let r2;
                return e3.walkComments((e4) => {
                  if (e4.raws.before !== void 0)
                    return r2 = e4.raws.before, r2.includes("\n") && (r2 = r2.replace(/[^\n]+$/, "")), false;
                }), r2 === void 0 ? r2 = this.raw(t3, null, "beforeDecl") : r2 && (r2 = r2.replace(/\S/g, "")), r2;
              }
              rawBeforeDecl(e3, t3) {
                let r2;
                return e3.walkDecls((e4) => {
                  if (e4.raws.before !== void 0)
                    return r2 = e4.raws.before, r2.includes("\n") && (r2 = r2.replace(/[^\n]+$/, "")), false;
                }), r2 === void 0 ? r2 = this.raw(t3, null, "beforeRule") : r2 && (r2 = r2.replace(/\S/g, "")), r2;
              }
              rawBeforeRule(e3) {
                let t3;
                return e3.walk((r2) => {
                  if (r2.nodes && (r2.parent !== e3 || e3.first !== r2) && r2.raws.before !== void 0)
                    return t3 = r2.raws.before, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
                }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
              }
              rawBeforeClose(e3) {
                let t3;
                return e3.walk((e4) => {
                  if (e4.nodes && e4.nodes.length > 0 && e4.raws.after !== void 0)
                    return t3 = e4.raws.after, t3.includes("\n") && (t3 = t3.replace(/[^\n]+$/, "")), false;
                }), t3 && (t3 = t3.replace(/\S/g, "")), t3;
              }
              rawBeforeOpen(e3) {
                let t3;
                return e3.walk((e4) => {
                  if (e4.type !== "decl" && (t3 = e4.raws.between, t3 !== void 0))
                    return false;
                }), t3;
              }
              rawColon(e3) {
                let t3;
                return e3.walkDecls((e4) => {
                  if (e4.raws.between !== void 0)
                    return t3 = e4.raws.between.replace(/[^\s:]/g, ""), false;
                }), t3;
              }
              beforeAfter(e3, t3) {
                let r2;
                r2 = e3.type === "decl" ? this.raw(e3, null, "beforeDecl") : e3.type === "comment" ? this.raw(e3, null, "beforeComment") : t3 === "before" ? this.raw(e3, null, "beforeRule") : this.raw(e3, null, "beforeClose");
                let n = e3.parent, s2 = 0;
                for (; n && n.type !== "root"; )
                  s2 += 1, n = n.parent;
                if (r2.includes("\n")) {
                  let t4 = this.raw(e3, null, "indent");
                  if (t4.length)
                    for (let e4 = 0; e4 < s2; e4++)
                      r2 += t4;
                }
                return r2;
              }
              rawValue(e3, t3) {
                let r2 = e3[t3], n = e3.raws[t3];
                return n && n.value === r2 ? n.raw : r2;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            let { isClean: n, my: s2 } = r2(154), i = r2(320), o = r2(86), a = r2(22), l = r2(87), c = (r2(322), r2(159)), u = r2(161), p2 = r2(35);
            const f = { document: "Document", root: "Root", atrule: "AtRule", rule: "Rule", decl: "Declaration", comment: "Comment" }, d = { postcssPlugin: true, prepare: true, Once: true, Document: true, Root: true, Declaration: true, Rule: true, AtRule: true, Comment: true, DeclarationExit: true, RuleExit: true, AtRuleExit: true, CommentExit: true, RootExit: true, DocumentExit: true, OnceExit: true }, h3 = { postcssPlugin: true, prepare: true, Once: true };
            function m(e3) {
              return typeof e3 == "object" && typeof e3.then == "function";
            }
            function y(e3) {
              let t3 = false, r3 = f[e3.type];
              return e3.type === "decl" ? t3 = e3.prop.toLowerCase() : e3.type === "atrule" && (t3 = e3.name.toLowerCase()), t3 && e3.append ? [r3, r3 + "-" + t3, 0, r3 + "Exit", r3 + "Exit-" + t3] : t3 ? [r3, r3 + "-" + t3, r3 + "Exit", r3 + "Exit-" + t3] : e3.append ? [r3, 0, r3 + "Exit"] : [r3, r3 + "Exit"];
            }
            function g(e3) {
              let t3;
              return t3 = e3.type === "document" ? ["Document", 0, "DocumentExit"] : e3.type === "root" ? ["Root", 0, "RootExit"] : y(e3), { node: e3, events: t3, eventIndex: 0, visitors: [], visitorIndex: 0, iterator: 0 };
            }
            function b(e3) {
              return e3[n] = false, e3.nodes && e3.nodes.forEach((e4) => b(e4)), e3;
            }
            let v = {};
            class E {
              constructor(e3, t3, r3) {
                let n2;
                if (this.stringified = false, this.processed = false, typeof t3 != "object" || t3 === null || t3.type !== "root" && t3.type !== "document")
                  if (t3 instanceof E || t3 instanceof c)
                    n2 = b(t3.root), t3.map && (r3.map === void 0 && (r3.map = {}), r3.map.inline || (r3.map.inline = false), r3.map.prev = t3.map);
                  else {
                    let e4 = u;
                    r3.syntax && (e4 = r3.syntax.parse), r3.parser && (e4 = r3.parser), e4.parse && (e4 = e4.parse);
                    try {
                      n2 = e4(t3, r3);
                    } catch (e5) {
                      this.processed = true, this.error = e5;
                    }
                    n2 && !n2[s2] && a.rebuild(n2);
                  }
                else
                  n2 = b(t3);
                this.result = new c(e3, n2, r3), this.helpers = { ...v, result: this.result, postcss: v }, this.plugins = this.processor.plugins.map((e4) => typeof e4 == "object" && e4.prepare ? { ...e4, ...e4.prepare(this.result) } : e4);
              }
              get [Symbol.toStringTag]() {
                return "LazyResult";
              }
              get processor() {
                return this.result.processor;
              }
              get opts() {
                return this.result.opts;
              }
              get css() {
                return this.stringify().css;
              }
              get content() {
                return this.stringify().content;
              }
              get map() {
                return this.stringify().map;
              }
              get root() {
                return this.sync().root;
              }
              get messages() {
                return this.sync().messages;
              }
              warnings() {
                return this.sync().warnings();
              }
              toString() {
                return this.css;
              }
              then(e3, t3) {
                return this.async().then(e3, t3);
              }
              catch(e3) {
                return this.async().catch(e3);
              }
              finally(e3) {
                return this.async().then(e3, e3);
              }
              async() {
                return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
              }
              sync() {
                if (this.error)
                  throw this.error;
                if (this.processed)
                  return this.result;
                if (this.processed = true, this.processing)
                  throw this.getAsyncError();
                for (let e3 of this.plugins)
                  if (m(this.runOnRoot(e3)))
                    throw this.getAsyncError();
                if (this.prepareVisitors(), this.hasListener) {
                  let e3 = this.result.root;
                  for (; !e3[n]; )
                    e3[n] = true, this.walkSync(e3);
                  if (this.listeners.OnceExit)
                    if (e3.type === "document")
                      for (let t3 of e3.nodes)
                        this.visitSync(this.listeners.OnceExit, t3);
                    else
                      this.visitSync(this.listeners.OnceExit, e3);
                }
                return this.result;
              }
              stringify() {
                if (this.error)
                  throw this.error;
                if (this.stringified)
                  return this.result;
                this.stringified = true, this.sync();
                let e3 = this.result.opts, t3 = o;
                e3.syntax && (t3 = e3.syntax.stringify), e3.stringifier && (t3 = e3.stringifier), t3.stringify && (t3 = t3.stringify);
                let r3 = new i(t3, this.result.root, this.result.opts).generate();
                return this.result.css = r3[0], this.result.map = r3[1], this.result;
              }
              walkSync(e3) {
                e3[n] = true;
                let t3 = y(e3);
                for (let r3 of t3)
                  if (r3 === 0)
                    e3.nodes && e3.each((e4) => {
                      e4[n] || this.walkSync(e4);
                    });
                  else {
                    let t4 = this.listeners[r3];
                    if (t4 && this.visitSync(t4, e3.toProxy()))
                      return;
                  }
              }
              visitSync(e3, t3) {
                for (let [r3, n2] of e3) {
                  let e4;
                  this.result.lastPlugin = r3;
                  try {
                    e4 = n2(t3, this.helpers);
                  } catch (e5) {
                    throw this.handleError(e5, t3.proxyOf);
                  }
                  if (t3.type !== "root" && t3.type !== "document" && !t3.parent)
                    return true;
                  if (m(e4))
                    throw this.getAsyncError();
                }
              }
              runOnRoot(e3) {
                this.result.lastPlugin = e3;
                try {
                  if (typeof e3 == "object" && e3.Once) {
                    if (this.result.root.type === "document") {
                      let t3 = this.result.root.nodes.map((t4) => e3.Once(t4, this.helpers));
                      return m(t3[0]) ? Promise.all(t3) : t3;
                    }
                    return e3.Once(this.result.root, this.helpers);
                  }
                  if (typeof e3 == "function")
                    return e3(this.result.root, this.result);
                } catch (e4) {
                  throw this.handleError(e4);
                }
              }
              getAsyncError() {
                throw new Error("Use process(css).then(cb) to work with async plugins");
              }
              handleError(e3, t3) {
                let r3 = this.result.lastPlugin;
                try {
                  t3 && t3.addToError(e3), this.error = e3, e3.name !== "CssSyntaxError" || e3.plugin ? r3.postcssVersion : (e3.plugin = r3.postcssPlugin, e3.setMessage());
                } catch (e4) {
                  console && console.error;
                }
                return e3;
              }
              async runAsync() {
                this.plugin = 0;
                for (let e3 = 0; e3 < this.plugins.length; e3++) {
                  let t3 = this.plugins[e3], r3 = this.runOnRoot(t3);
                  if (m(r3))
                    try {
                      await r3;
                    } catch (e4) {
                      throw this.handleError(e4);
                    }
                }
                if (this.prepareVisitors(), this.hasListener) {
                  let e3 = this.result.root;
                  for (; !e3[n]; ) {
                    e3[n] = true;
                    let t3 = [g(e3)];
                    for (; t3.length > 0; ) {
                      let e4 = this.visitTick(t3);
                      if (m(e4))
                        try {
                          await e4;
                        } catch (e5) {
                          let r3 = t3[t3.length - 1].node;
                          throw this.handleError(e5, r3);
                        }
                    }
                  }
                  if (this.listeners.OnceExit)
                    for (let [t3, r3] of this.listeners.OnceExit) {
                      this.result.lastPlugin = t3;
                      try {
                        if (e3.type === "document") {
                          let t4 = e3.nodes.map((e4) => r3(e4, this.helpers));
                          await Promise.all(t4);
                        } else
                          await r3(e3, this.helpers);
                      } catch (e4) {
                        throw this.handleError(e4);
                      }
                    }
                }
                return this.processed = true, this.stringify();
              }
              prepareVisitors() {
                this.listeners = {};
                let e3 = (e4, t3, r3) => {
                  this.listeners[t3] || (this.listeners[t3] = []), this.listeners[t3].push([e4, r3]);
                };
                for (let t3 of this.plugins)
                  if (typeof t3 == "object")
                    for (let r3 in t3) {
                      if (!d[r3] && /^[A-Z]/.test(r3))
                        throw new Error(`Unknown event ${r3} in ${t3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`);
                      if (!h3[r3])
                        if (typeof t3[r3] == "object")
                          for (let n2 in t3[r3])
                            e3(t3, n2 === "*" ? r3 : r3 + "-" + n2.toLowerCase(), t3[r3][n2]);
                        else
                          typeof t3[r3] == "function" && e3(t3, r3, t3[r3]);
                    }
                this.hasListener = Object.keys(this.listeners).length > 0;
              }
              visitTick(e3) {
                let t3 = e3[e3.length - 1], { node: r3, visitors: s3 } = t3;
                if (r3.type !== "root" && r3.type !== "document" && !r3.parent)
                  return void e3.pop();
                if (s3.length > 0 && t3.visitorIndex < s3.length) {
                  let [e4, n2] = s3[t3.visitorIndex];
                  t3.visitorIndex += 1, t3.visitorIndex === s3.length && (t3.visitors = [], t3.visitorIndex = 0), this.result.lastPlugin = e4;
                  try {
                    return n2(r3.toProxy(), this.helpers);
                  } catch (e5) {
                    throw this.handleError(e5, r3);
                  }
                }
                if (t3.iterator !== 0) {
                  let s4, i3 = t3.iterator;
                  for (; s4 = r3.nodes[r3.indexes[i3]]; )
                    if (r3.indexes[i3] += 1, !s4[n])
                      return s4[n] = true, void e3.push(g(s4));
                  t3.iterator = 0, delete r3.indexes[i3];
                }
                let i2 = t3.events;
                for (; t3.eventIndex < i2.length; ) {
                  let e4 = i2[t3.eventIndex];
                  if (t3.eventIndex += 1, e4 === 0)
                    return void (r3.nodes && r3.nodes.length && (r3[n] = true, t3.iterator = r3.getIterator()));
                  if (this.listeners[e4])
                    return void (t3.visitors = this.listeners[e4]);
                }
                e3.pop();
              }
            }
            E.registerPostcss = (e3) => {
              v = e3;
            }, e2.exports = E, E.default = E, p2.registerLazyResult(E), l.registerLazyResult(E);
          }, () => {
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(160);
            class s2 {
              constructor(e3, t3, r3) {
                this.processor = e3, this.messages = [], this.root = t3, this.opts = r3, this.css = void 0, this.map = void 0;
              }
              toString() {
                return this.css;
              }
              warn(e3, t3 = {}) {
                t3.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t3.plugin = this.lastPlugin.postcssPlugin);
                let r3 = new n(e3, t3);
                return this.messages.push(r3), r3;
              }
              warnings() {
                return this.messages.filter((e3) => e3.type === "warning");
              }
              get content() {
                return this.css;
              }
            }
            e2.exports = s2, s2.default = s2;
          }, (e2) => {
            "use strict";
            class t2 {
              constructor(e3, t3 = {}) {
                if (this.type = "warning", this.text = e3, t3.node && t3.node.source) {
                  let e4 = t3.node.positionBy(t3);
                  this.line = e4.line, this.column = e4.column;
                }
                for (let e4 in t3)
                  this[e4] = t3[e4];
              }
              toString() {
                return this.node ? this.node.error(this.text, { plugin: this.plugin, index: this.index, word: this.word }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
              }
            }
            e2.exports = t2, t2.default = t2;
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(22), s2 = r2(323), i = r2(90);
            function o(e3, t3) {
              let r3 = new i(e3, t3), n2 = new s2(r3);
              try {
                n2.parse();
              } catch (e4) {
                throw e4;
              }
              return n2.root;
            }
            e2.exports = o, o.default = o, n.registerParse(o);
          }, (e2) => {
            "use strict";
            let t2 = { split(e3, t3, r2) {
              let n = [], s2 = "", i = false, o = 0, a = false, l = false;
              for (let r3 of e3)
                l ? l = false : r3 === "\\" ? l = true : a ? r3 === a && (a = false) : r3 === '"' || r3 === "'" ? a = r3 : r3 === "(" ? o += 1 : r3 === ")" ? o > 0 && (o -= 1) : o === 0 && t3.includes(r3) && (i = true), i ? (s2 !== "" && n.push(s2.trim()), s2 = "", i = false) : s2 += r3;
              return (r2 || s2 !== "") && n.push(s2.trim()), n;
            }, space: (e3) => t2.split(e3, [" ", "\n", "	"]), comma: (e3) => t2.split(e3, [","], true) };
            e2.exports = t2, t2.default = t2;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(37).Buffer;
            let { SourceMapConsumer: s2, SourceMapGenerator: i } = r2(157), { existsSync: o, readFileSync: a } = r2(514), { dirname: l, join: c } = r2(158);
            class u {
              constructor(e3, t3) {
                if (t3.map === false)
                  return;
                this.loadAnnotation(e3), this.inline = this.startWith(this.annotation, "data:");
                let r3 = t3.map ? t3.map.prev : void 0, n2 = this.loadMap(t3.from, r3);
                !this.mapFile && t3.from && (this.mapFile = t3.from), this.mapFile && (this.root = l(this.mapFile)), n2 && (this.text = n2);
              }
              consumer() {
                return this.consumerCache || (this.consumerCache = new s2(this.text)), this.consumerCache;
              }
              withContent() {
                return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
              }
              startWith(e3, t3) {
                return !!e3 && e3.substr(0, t3.length) === t3;
              }
              getAnnotationURL(e3) {
                return e3.match(/\/\*\s*# sourceMappingURL=((?:(?!sourceMappingURL=).)*)\*\//)[1].trim();
              }
              loadAnnotation(e3) {
                let t3 = e3.match(/\/\*\s*# sourceMappingURL=(?:(?!sourceMappingURL=).)*\*\//gm);
                if (t3 && t3.length > 0) {
                  let e4 = t3[t3.length - 1];
                  e4 && (this.annotation = this.getAnnotationURL(e4));
                }
              }
              decodeInline(e3) {
                if (/^data:application\/json;charset=utf-?8,/.test(e3) || /^data:application\/json,/.test(e3))
                  return decodeURIComponent(e3.substr(RegExp.lastMatch.length));
                if (/^data:application\/json;charset=utf-?8;base64,/.test(e3) || /^data:application\/json;base64,/.test(e3))
                  return t3 = e3.substr(RegExp.lastMatch.length), n ? n.from(t3, "base64").toString() : window.atob(t3);
                var t3;
                let r3 = e3.match(/data:application\/json;([^,]+),/)[1];
                throw new Error("Unsupported source map encoding " + r3);
              }
              loadFile(e3) {
                if (this.root = l(e3), o(e3))
                  return this.mapFile = e3, a(e3, "utf-8").toString().trim();
              }
              loadMap(e3, t3) {
                if (t3 === false)
                  return false;
                if (t3) {
                  if (typeof t3 == "string")
                    return t3;
                  if (typeof t3 != "function") {
                    if (t3 instanceof s2)
                      return i.fromSourceMap(t3).toString();
                    if (t3 instanceof i)
                      return t3.toString();
                    if (this.isMap(t3))
                      return JSON.stringify(t3);
                    throw new Error("Unsupported previous source map format: " + t3.toString());
                  }
                  {
                    let r3 = t3(e3);
                    if (r3) {
                      let e4 = this.loadFile(r3);
                      if (!e4)
                        throw new Error("Unable to load previous source map: " + r3.toString());
                      return e4;
                    }
                  }
                } else {
                  if (this.inline)
                    return this.decodeInline(this.annotation);
                  if (this.annotation) {
                    let t4 = this.annotation;
                    return e3 && (t4 = c(l(e3), t4)), this.loadFile(t4);
                  }
                }
              }
              isMap(e3) {
                return typeof e3 == "object" && (typeof e3.mappings == "string" || typeof e3._mappings == "string" || Array.isArray(e3.sections));
              }
            }
            e2.exports = u, u.default = u;
          }, (e2) => {
            const t2 = /[$]?[\w-]+/g;
            e2.exports = (e3, r2) => {
              let n;
              for (; n = t2.exec(e3); ) {
                const s2 = r2[n[0]];
                s2 && (e3 = e3.slice(0, n.index) + s2 + e3.slice(t2.lastIndex), t2.lastIndex -= n[0].length - s2.length);
              }
              return e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = r2(422);
            Object.keys(n).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === n[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return n[e3];
              } }));
            });
            var s2 = r2(423);
            Object.keys(s2).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === s2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return s2[e3];
              } }));
            });
            var i = r2(424);
            Object.keys(i).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === i[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return i[e3];
              } }));
            });
            var o = r2(425);
            Object.keys(o).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === o[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return o[e3];
              } }));
            });
            var a = r2(426);
            Object.keys(a).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === a[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return a[e3];
              } }));
            });
            var l = r2(234);
            Object.keys(l).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === l[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return l[e3];
              } }));
            });
            var c = r2(235);
            Object.keys(c).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === c[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return c[e3];
              } }));
            });
            var u = r2(429);
            Object.keys(u).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === u[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return u[e3];
              } }));
            });
            var p2 = r2(430);
            Object.keys(p2).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === p2[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return p2[e3];
              } }));
            });
            var f = r2(431);
            Object.keys(f).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === f[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return f[e3];
              } }));
            });
            var d = r2(432);
            Object.keys(d).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === d[e3] || Object.defineProperty(t2, e3, { enumerable: true, get: function() {
                return d[e3];
              } }));
            });
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true;
            var n = r2(5);
            Object.keys(n).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === n[e3] || (t2[e3] = n[e3]));
            });
            var s2 = r2(516);
            Object.keys(s2).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === s2[e3] || (t2[e3] = s2[e3]));
            });
            var i = r2(517);
            Object.keys(i).forEach(function(e3) {
              e3 !== "default" && e3 !== "__esModule" && (e3 in t2 && t2[e3] === i[e3] || (t2[e3] = i[e3]));
            });
          }, function(e2, t2, r2) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), Object.defineProperty(e3, n2, { enumerable: true, get: function() {
                return t3[r3];
              } });
            } : function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), e3[n2] = t3[r3];
            }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
              Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
            } : function(e3, t3) {
              e3.default = t3;
            }), i = this && this.__importStar || function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = {};
              if (e3 != null)
                for (var r3 in e3)
                  r3 !== "default" && Object.prototype.hasOwnProperty.call(e3, r3) && n(t3, e3, r3);
              return s2(t3, e3), t3;
            }, o = this && this.__importDefault || function(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            };
            Object.defineProperty(t2, "__esModule", { value: true });
            const a = i(r2(0)), l = r2(146), c = r2(50), u = o(r2(169)), p2 = /^xlink([A-Z])/, f = (e3, t3) => {
              const r3 = ((e4, t4) => e4.map((e5) => {
                if (e5.isJSXText()) {
                  const r4 = c.transformJSXText(e5);
                  return r4 ? a.callExpression(c.createIdentifier(t4, "createTextVNode"), [r4]) : r4;
                }
                if (e5.isJSXExpressionContainer()) {
                  const t5 = c.transformJSXExpressionContainer(e5);
                  if (a.isIdentifier(t5)) {
                    const { name: r4 } = t5, { referencePaths: n3 = [] } = e5.scope.getBinding(r4) || {};
                    n3.forEach((e6) => {
                      c.walksScope(e6, r4, 2);
                    });
                  }
                  return t5;
                }
                if (a.isJSXSpreadChild(e5))
                  return c.transformJSXSpreadChild(e5);
                if (e5.isCallExpression())
                  return e5.node;
                if (e5.isJSXElement())
                  return f(e5, t4);
                throw new Error(`getChildren: ${e5.type} is not supported`);
              }).filter((e5) => e5 != null && !a.isJSXEmptyExpression(e5)))(e3.get("children"), t3), { tag: n2, props: s3, isComponent: i2, directives: o2, patchFlag: d, dynamicPropNames: h3, slots: m } = ((e4, t4) => {
                const r4 = c.getTag(e4, t4), n3 = c.checkIsComponent(e4.get("openingElement")), s4 = e4.get("openingElement").get("attributes"), i3 = [], o3 = new Set();
                let d2 = null, h4 = 0;
                if (s4.length === 0)
                  return { tag: r4, isComponent: n3, slots: d2, props: a.nullLiteral(), directives: i3, patchFlag: h4, dynamicPropNames: o3 };
                let m2 = [], y2 = false, g2 = false, b2 = false, v2 = false, E = false;
                const x = [], { mergeProps: S = true } = t4.opts;
                s4.forEach((s5) => {
                  if (s5.isJSXAttribute()) {
                    let h5 = c.getJSXAttributeName(s5);
                    const S2 = ((e5, t5) => {
                      const r5 = e5.get("value");
                      return r5.isJSXElement() ? f(r5, t5) : r5.isStringLiteral() ? r5.node : r5.isJSXExpressionContainer() ? c.transformJSXExpressionContainer(r5) : null;
                    })(s5, t4);
                    if (c.isConstant(S2) && h5 !== "ref" || (!n3 && c.isOn(h5) && h5.toLowerCase() !== "onclick" && h5 !== "onUpdate:modelValue" && (v2 = true), h5 === "ref" ? y2 = true : h5 !== "class" || n3 ? h5 !== "style" || n3 ? h5 === "key" || c.isDirective(h5) || h5 === "on" || o3.add(h5) : b2 = true : g2 = true), t4.opts.transformOn && (h5 === "on" || h5 === "nativeOn"))
                      return t4.get("transformOn") || t4.set("transformOn", l.addDefault(e4, "@vue/babel-helper-vue-transform-on", { nameHint: "_transformOn" })), void x.push(a.callExpression(t4.get("transformOn"), [S2 || a.booleanLiteral(true)]));
                    if (c.isDirective(h5)) {
                      const { directive: e5, modifiers: l2, values: c4, args: p3, directiveName: f2 } = u.default({ tag: r4, isComponent: n3, name: h5, path: s5, state: t4, value: S2 });
                      if (f2 === "slots")
                        return void (d2 = S2);
                      e5 ? i3.push(a.arrayExpression(e5)) : f2 === "html" ? (m2.push(a.objectProperty(a.stringLiteral("innerHTML"), c4[0])), o3.add("innerHTML")) : f2 === "text" && (m2.push(a.objectProperty(a.stringLiteral("textContent"), c4[0])), o3.add("textContent")), ["models", "model"].includes(f2) && c4.forEach((t5, r5) => {
                        var n4, s6, i4, c5;
                        const u2 = p3[r5], f3 = u2 && !a.isStringLiteral(u2) && !a.isNullLiteral(u2);
                        e5 || (m2.push(a.objectProperty(a.isNullLiteral(u2) ? a.stringLiteral("modelValue") : u2, t5, f3)), f3 || o3.add(((n4 = u2) === null || n4 === void 0 ? void 0 : n4.value) || "modelValue"), ((s6 = l2[r5]) === null || s6 === void 0 ? void 0 : s6.size) && m2.push(a.objectProperty(f3 ? a.binaryExpression("+", u2, a.stringLiteral("Modifiers")) : a.stringLiteral(`${((i4 = u2) === null || i4 === void 0 ? void 0 : i4.value) || "model"}Modifiers`), a.objectExpression([...l2[r5]].map((e6) => a.objectProperty(a.stringLiteral(e6), a.booleanLiteral(true)))), f3)));
                        const d3 = f3 ? a.binaryExpression("+", a.stringLiteral("onUpdate"), u2) : a.stringLiteral(`onUpdate:${((c5 = u2) === null || c5 === void 0 ? void 0 : c5.value) || "modelValue"}`);
                        m2.push(a.objectProperty(d3, a.arrowFunctionExpression([a.identifier("$event")], a.assignmentExpression("=", t5, a.identifier("$event"))), f3)), f3 ? E = true : o3.add(d3.value);
                      });
                    } else
                      h5.match(p2) && (h5 = h5.replace(p2, (e5, t5) => `xlink:${t5.toLowerCase()}`)), m2.push(a.objectProperty(a.stringLiteral(h5), S2 || a.booleanLiteral(true)));
                  } else
                    m2.length && S && (x.push(a.objectExpression(c.dedupeProperties(m2, S))), m2 = []), E = true, c.transformJSXSpreadAttribute(e4, s5, S, S ? x : m2);
                }), E ? h4 |= 16 : (g2 && (h4 |= 2), b2 && (h4 |= 4), o3.size && (h4 |= 8), v2 && (h4 |= 32)), h4 !== 0 && h4 !== 32 || !(y2 || i3.length > 0) || (h4 |= 512);
                let T = a.nullLiteral();
                return x.length ? (m2.length && x.push(a.objectExpression(c.dedupeProperties(m2, S))), T = x.length > 1 ? a.callExpression(c.createIdentifier(t4, "mergeProps"), x) : x[0]) : m2.length && (T = m2.length === 1 && a.isSpreadElement(m2[0]) ? m2[0].argument : a.objectExpression(c.dedupeProperties(m2, S))), { tag: r4, props: T, isComponent: n3, slots: d2, directives: i3, patchFlag: h4, dynamicPropNames: o3 };
              })(e3, t3), { optimize: y = false } = t3.opts, g = e3.getData("slotFlag") || 1;
              let b;
              if (r3.length > 1 || m)
                b = i2 ? r3.length ? a.objectExpression([!!r3.length && a.objectProperty(a.identifier("default"), a.arrowFunctionExpression([], a.arrayExpression(c.buildIIFE(e3, r3)))), ...m ? a.isObjectExpression(m) ? m.properties : [a.spreadElement(m)] : [], y && a.objectProperty(a.identifier("_"), a.numericLiteral(g))].filter(Boolean)) : m : a.arrayExpression(r3);
              else if (r3.length === 1) {
                const { enableObjectSlots: n3 = true } = t3.opts, s4 = r3[0], o3 = a.objectExpression([a.objectProperty(a.identifier("default"), a.arrowFunctionExpression([], a.arrayExpression(c.buildIIFE(e3, [s4])))), y && a.objectProperty(a.identifier("_"), a.numericLiteral(g))].filter(Boolean));
                if (a.isIdentifier(s4) && i2)
                  b = n3 ? a.conditionalExpression(a.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [s4]), s4, o3) : o3;
                else if (a.isCallExpression(s4) && s4.loc && i2)
                  if (n3) {
                    const { scope: r4 } = e3, n4 = r4.generateUidIdentifier("slot");
                    r4 && r4.push({ id: n4, kind: "let" });
                    const i3 = a.objectExpression([a.objectProperty(a.identifier("default"), a.arrowFunctionExpression([], a.arrayExpression(c.buildIIFE(e3, [n4])))), y && a.objectProperty(a.identifier("_"), a.numericLiteral(g))].filter(Boolean)), o4 = a.assignmentExpression("=", n4, s4), l2 = a.callExpression(t3.get("@vue/babel-plugin-jsx/runtimeIsSlot")(), [o4]);
                    b = a.conditionalExpression(l2, n4, i3);
                  } else
                    b = o3;
                else
                  b = a.isFunctionExpression(s4) || a.isArrowFunctionExpression(s4) ? a.objectExpression([a.objectProperty(a.identifier("default"), s4)]) : a.isObjectExpression(s4) ? a.objectExpression([...s4.properties, y && a.objectProperty(a.identifier("_"), a.numericLiteral(g))].filter(Boolean)) : i2 ? a.objectExpression([a.objectProperty(a.identifier("default"), a.arrowFunctionExpression([], a.arrayExpression([s4])))]) : a.arrayExpression([s4]);
              }
              const v = a.callExpression(c.createIdentifier(t3, "createVNode"), [n2, s3, b || a.nullLiteral(), !!d && y && a.numericLiteral(d), !!h3.size && y && a.arrayExpression([...h3.keys()].map((e4) => a.stringLiteral(e4)))].filter(Boolean));
              return o2.length ? a.callExpression(c.createIdentifier(t3, "withDirectives"), [v, a.arrayExpression(o2)]) : v;
            };
            t2.default = { JSXElement: { exit(e3, t3) {
              e3.replaceWith(f(e3, t3));
            } } };
          }, function(e2, t2, r2) {
            var n;
            e2 = r2.nmd(e2), function(s2) {
              t2 && t2.nodeType, e2 && e2.nodeType;
              var i = typeof r2.g == "object" && r2.g;
              i.global !== i && i.window !== i && i.self;
              var o, a = 2147483647, l = 36, c = /^xn--/, u = /[^\x20-\x7E]/, p2 = /[\x2E\u3002\uFF0E\uFF61]/g, f = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, d = Math.floor, h3 = String.fromCharCode;
              function m(e3) {
                throw RangeError(f[e3]);
              }
              function y(e3, t3) {
                for (var r3 = e3.length, n2 = []; r3--; )
                  n2[r3] = t3(e3[r3]);
                return n2;
              }
              function g(e3, t3) {
                var r3 = e3.split("@"), n2 = "";
                return r3.length > 1 && (n2 = r3[0] + "@", e3 = r3[1]), n2 + y((e3 = e3.replace(p2, ".")).split("."), t3).join(".");
              }
              function b(e3) {
                for (var t3, r3, n2 = [], s3 = 0, i2 = e3.length; s3 < i2; )
                  (t3 = e3.charCodeAt(s3++)) >= 55296 && t3 <= 56319 && s3 < i2 ? (64512 & (r3 = e3.charCodeAt(s3++))) == 56320 ? n2.push(((1023 & t3) << 10) + (1023 & r3) + 65536) : (n2.push(t3), s3--) : n2.push(t3);
                return n2;
              }
              function v(e3) {
                return y(e3, function(e4) {
                  var t3 = "";
                  return e4 > 65535 && (t3 += h3((e4 -= 65536) >>> 10 & 1023 | 55296), e4 = 56320 | 1023 & e4), t3 + h3(e4);
                }).join("");
              }
              function E(e3, t3) {
                return e3 + 22 + 75 * (e3 < 26) - ((t3 != 0) << 5);
              }
              function x(e3, t3, r3) {
                var n2 = 0;
                for (e3 = r3 ? d(e3 / 700) : e3 >> 1, e3 += d(e3 / t3); e3 > 455; n2 += l)
                  e3 = d(e3 / 35);
                return d(n2 + 36 * e3 / (e3 + 38));
              }
              function S(e3) {
                var t3, r3, n2, s3, i2, o2, c4, u2, p3, f2, h4, y2 = [], g2 = e3.length, b2 = 0, E2 = 128, S2 = 72;
                for ((r3 = e3.lastIndexOf("-")) < 0 && (r3 = 0), n2 = 0; n2 < r3; ++n2)
                  e3.charCodeAt(n2) >= 128 && m("not-basic"), y2.push(e3.charCodeAt(n2));
                for (s3 = r3 > 0 ? r3 + 1 : 0; s3 < g2; ) {
                  for (i2 = b2, o2 = 1, c4 = l; s3 >= g2 && m("invalid-input"), ((u2 = (h4 = e3.charCodeAt(s3++)) - 48 < 10 ? h4 - 22 : h4 - 65 < 26 ? h4 - 65 : h4 - 97 < 26 ? h4 - 97 : l) >= l || u2 > d((a - b2) / o2)) && m("overflow"), b2 += u2 * o2, !(u2 < (p3 = c4 <= S2 ? 1 : c4 >= S2 + 26 ? 26 : c4 - S2)); c4 += l)
                    o2 > d(a / (f2 = l - p3)) && m("overflow"), o2 *= f2;
                  S2 = x(b2 - i2, t3 = y2.length + 1, i2 == 0), d(b2 / t3) > a - E2 && m("overflow"), E2 += d(b2 / t3), b2 %= t3, y2.splice(b2++, 0, E2);
                }
                return v(y2);
              }
              function T(e3) {
                var t3, r3, n2, s3, i2, o2, c4, u2, p3, f2, y2, g2, v2, S2, T2, w = [];
                for (g2 = (e3 = b(e3)).length, t3 = 128, r3 = 0, i2 = 72, o2 = 0; o2 < g2; ++o2)
                  (y2 = e3[o2]) < 128 && w.push(h3(y2));
                for (n2 = s3 = w.length, s3 && w.push("-"); n2 < g2; ) {
                  for (c4 = a, o2 = 0; o2 < g2; ++o2)
                    (y2 = e3[o2]) >= t3 && y2 < c4 && (c4 = y2);
                  for (c4 - t3 > d((a - r3) / (v2 = n2 + 1)) && m("overflow"), r3 += (c4 - t3) * v2, t3 = c4, o2 = 0; o2 < g2; ++o2)
                    if ((y2 = e3[o2]) < t3 && ++r3 > a && m("overflow"), y2 == t3) {
                      for (u2 = r3, p3 = l; !(u2 < (f2 = p3 <= i2 ? 1 : p3 >= i2 + 26 ? 26 : p3 - i2)); p3 += l)
                        T2 = u2 - f2, S2 = l - f2, w.push(h3(E(f2 + T2 % S2, 0))), u2 = d(T2 / S2);
                      w.push(h3(E(u2, 0))), i2 = x(r3, v2, n2 == s3), r3 = 0, ++n2;
                    }
                  ++r3, ++t3;
                }
                return w.join("");
              }
              o = { version: "1.3.2", ucs2: { decode: b, encode: v }, decode: S, encode: T, toASCII: function(e3) {
                return g(e3, function(e4) {
                  return u.test(e4) ? "xn--" + T(e4) : e4;
                });
              }, toUnicode: function(e3) {
                return g(e3, function(e4) {
                  return c.test(e4) ? S(e4.slice(4).toLowerCase()) : e4;
                });
              } }, (n = function() {
                return o;
              }.call(t2, r2, t2, e2)) === void 0 || (e2.exports = n);
            }();
          }, function(e2, t2, r2) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), Object.defineProperty(e3, n2, { enumerable: true, get: function() {
                return t3[r3];
              } });
            } : function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), e3[n2] = t3[r3];
            }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
              Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
            } : function(e3, t3) {
              e3.default = t3;
            }), i = this && this.__importStar || function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = {};
              if (e3 != null)
                for (var r3 in e3)
                  r3 !== "default" && Object.prototype.hasOwnProperty.call(e3, r3) && n(t3, e3, r3);
              return s2(t3, e3), t3;
            };
            Object.defineProperty(t2, "__esModule", { value: true });
            const o = i(r2(0)), a = r2(50), l = (e3) => o.isArrayExpression(e3) ? e3.elements.map((e4) => o.isStringLiteral(e4) ? e4.value : "").filter(Boolean) : [], c = (e3, t3, r3, n2) => {
              var s3;
              if (n2 === "show")
                return a.createIdentifier(t3, "vShow");
              if (n2 === "model") {
                let n3;
                const i2 = ((e4) => {
                  const t4 = e4.get("attributes").find((e5) => !!o.isJSXAttribute(e5) && o.isJSXIdentifier(e5.get("name")) && e5.get("name").node.name === "type");
                  return t4 ? t4.get("value").node : null;
                })(e3.parentPath);
                switch (r3.value) {
                  case "select":
                    n3 = a.createIdentifier(t3, "vModelSelect");
                    break;
                  case "textarea":
                    n3 = a.createIdentifier(t3, "vModelText");
                    break;
                  default:
                    if (o.isStringLiteral(i2) || !i2)
                      switch ((s3 = i2) === null || s3 === void 0 ? void 0 : s3.value) {
                        case "checkbox":
                          n3 = a.createIdentifier(t3, "vModelCheckbox");
                          break;
                        case "radio":
                          n3 = a.createIdentifier(t3, "vModelRadio");
                          break;
                        default:
                          n3 = a.createIdentifier(t3, "vModelText");
                      }
                    else
                      n3 = a.createIdentifier(t3, "vModelDynamic");
                }
                return n3;
              }
              return o.callExpression(a.createIdentifier(t3, "resolveDirective"), [o.stringLiteral(n2)]);
            };
            t2.default = (e3) => {
              var t3, r3, n2;
              const { name: s3, path: i2, value: a2, state: u, tag: p2, isComponent: f } = e3, d = [], h3 = [], m = [], y = s3.split("_"), g = ((t3 = y.shift()) === null || t3 === void 0 ? void 0 : t3.replace(/^v/, "").replace(/^-/, "").replace(/^\S/, (e4) => e4.toLowerCase())) || "", b = g === "models", v = g === "model";
              if (v && !o.isJSXExpressionContainer(i2.get("value")))
                throw new Error("You have to use JSX Expression inside your v-model");
              if (b && !f)
                throw new Error("v-models can only use in custom components");
              const E = !["html", "text", "model", "models"].includes(g) || v && !f;
              let x = y;
              return o.isArrayExpression(a2) ? (b ? a2.elements : [a2]).forEach((e4) => {
                if (b && !o.isArrayExpression(e4))
                  throw new Error("You should pass a Two-dimensional Arrays to v-models");
                const { elements: t4 } = e4, [r4, n3, s4] = t4;
                !n3 || o.isArrayExpression(n3) || o.isSpreadElement(n3) ? o.isArrayExpression(n3) ? (E || d.push(o.nullLiteral()), x = l(n3)) : E || d.push(o.nullLiteral()) : (d.push(n3), x = l(s4)), m.push(new Set(x)), h3.push(r4);
              }) : v && !E ? (d.push(o.nullLiteral()), m.push(new Set(y))) : m.push(new Set(y)), { directiveName: g, modifiers: m, values: h3.length ? h3 : [a2], args: d, directive: E ? [c(i2, u, p2, g), h3[0] || a2, ((r3 = m[0]) === null || r3 === void 0 ? void 0 : r3.size) ? d[0] || o.unaryExpression("void", o.numericLiteral(0), true) : d[0], !!((n2 = m[0]) === null || n2 === void 0 ? void 0 : n2.size) && o.objectExpression([...m[0]].map((e4) => o.objectProperty(o.identifier(e4), o.booleanLiteral(true))))].filter(Boolean) : void 0 };
            };
          }, function(e2, t2, r2) {
            "use strict";
            var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), Object.defineProperty(e3, n2, { enumerable: true, get: function() {
                return t3[r3];
              } });
            } : function(e3, t3, r3, n2) {
              n2 === void 0 && (n2 = r3), e3[n2] = t3[r3];
            }), s2 = this && this.__setModuleDefault || (Object.create ? function(e3, t3) {
              Object.defineProperty(e3, "default", { enumerable: true, value: t3 });
            } : function(e3, t3) {
              e3.default = t3;
            }), i = this && this.__importStar || function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = {};
              if (e3 != null)
                for (var r3 in e3)
                  r3 !== "default" && Object.prototype.hasOwnProperty.call(e3, r3) && n(t3, e3, r3);
              return s2(t3, e3), t3;
            };
            Object.defineProperty(t2, "__esModule", { value: true });
            const o = i(r2(0)), a = r2(50);
            t2.default = { JSXFragment: { enter(e3, t3) {
              const r3 = a.createIdentifier(t3, a.FRAGMENT);
              e3.replaceWith(((e4, t4) => {
                const r4 = e4.get("children") || [];
                return o.jsxElement(o.jsxOpeningElement(t4, []), o.jsxClosingElement(t4), r4.map(({ node: e5 }) => e5), false);
              })(e3, o.isIdentifier(r3) ? o.jsxIdentifier(r3.name) : o.jsxMemberExpression(o.jsxIdentifier(r3.object.name), o.jsxIdentifier(r3.property.name))));
            } } };
          }, (e2) => {
            typeof Object.create == "function" ? e2.exports = function(e3, t2) {
              t2 && (e3.super_ = t2, e3.prototype = Object.create(t2.prototype, { constructor: { value: e3, enumerable: false, writable: true, configurable: true } }));
            } : e2.exports = function(e3, t2) {
              if (t2) {
                e3.super_ = t2;
                var r2 = function() {
                };
                r2.prototype = t2.prototype, e3.prototype = new r2(), e3.prototype.constructor = e3;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2 = (n = r2(173)) && n.__esModule ? n : { default: n }, i = function() {
              function e3(e4, t4) {
                this.func = e4 || function() {
                }, this.funcRes = null, this.options = t4;
              }
              var t3 = e3.prototype;
              return t3._shouldUpdateSelector = function(e4, t4) {
                return t4 === void 0 && (t4 = {}), Object.assign({}, this.options, t4).updateSelector !== false && typeof e4 != "string";
              }, t3._isLossy = function(e4) {
                return e4 === void 0 && (e4 = {}), Object.assign({}, this.options, e4).lossless === false;
              }, t3._root = function(e4, t4) {
                return t4 === void 0 && (t4 = {}), new s2.default(e4, this._parseOptions(t4)).root;
              }, t3._parseOptions = function(e4) {
                return { lossy: this._isLossy(e4) };
              }, t3._run = function(e4, t4) {
                var r3 = this;
                return t4 === void 0 && (t4 = {}), new Promise(function(n2, s3) {
                  try {
                    var i2 = r3._root(e4, t4);
                    Promise.resolve(r3.func(i2)).then(function(n3) {
                      var s4 = void 0;
                      return r3._shouldUpdateSelector(e4, t4) && (s4 = i2.toString(), e4.selector = s4), { transform: n3, root: i2, string: s4 };
                    }).then(n2, s3);
                  } catch (e5) {
                    return void s3(e5);
                  }
                });
              }, t3._runSync = function(e4, t4) {
                t4 === void 0 && (t4 = {});
                var r3 = this._root(e4, t4), n2 = this.func(r3);
                if (n2 && typeof n2.then == "function")
                  throw new Error("Selector processor returned a promise to a synchronous call.");
                var s3 = void 0;
                return t4.updateSelector && typeof e4 != "string" && (s3 = r3.toString(), e4.selector = s3), { transform: n2, root: r3, string: s3 };
              }, t3.ast = function(e4, t4) {
                return this._run(e4, t4).then(function(e5) {
                  return e5.root;
                });
              }, t3.astSync = function(e4, t4) {
                return this._runSync(e4, t4).root;
              }, t3.transform = function(e4, t4) {
                return this._run(e4, t4).then(function(e5) {
                  return e5.transform;
                });
              }, t3.transformSync = function(e4, t4) {
                return this._runSync(e4, t4).transform;
              }, t3.process = function(e4, t4) {
                return this._run(e4, t4).then(function(e5) {
                  return e5.string || e5.root.toString();
                });
              }, t3.processSync = function(e4, t4) {
                var r3 = this._runSync(e4, t4);
                return r3.string || r3.root.toString();
              }, e3;
            }();
            t2.default = i, e2.exports = t2.default;
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = void 0;
            var n, s2, i = w(r2(97)), o = w(r2(99)), a = w(r2(100)), l = w(r2(101)), c = w(r2(102)), u = w(r2(103)), p2 = w(r2(104)), f = w(r2(105)), d = T(r2(326)), h3 = w(r2(106)), m = w(r2(107)), y = w(r2(108)), g = w(r2(177)), b = T(r2(515)), v = T(r2(328)), E = T(r2(5)), x = r2(91);
            function S() {
              if (typeof WeakMap != "function")
                return null;
              var e3 = new WeakMap();
              return S = function() {
                return e3;
              }, e3;
            }
            function T(e3) {
              if (e3 && e3.__esModule)
                return e3;
              if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
                return { default: e3 };
              var t3 = S();
              if (t3 && t3.has(e3))
                return t3.get(e3);
              var r3 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var s3 in e3)
                if (Object.prototype.hasOwnProperty.call(e3, s3)) {
                  var i2 = n2 ? Object.getOwnPropertyDescriptor(e3, s3) : null;
                  i2 && (i2.get || i2.set) ? Object.defineProperty(r3, s3, i2) : r3[s3] = e3[s3];
                }
              return r3.default = e3, t3 && t3.set(e3, r3), r3;
            }
            function w(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            function P(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            var A = ((n = {})[v.space] = true, n[v.cr] = true, n[v.feed] = true, n[v.newline] = true, n[v.tab] = true, n), O = Object.assign({}, A, ((s2 = {})[v.comment] = true, s2));
            function C(e3) {
              return { line: e3[b.FIELDS.START_LINE], column: e3[b.FIELDS.START_COL] };
            }
            function I(e3) {
              return { line: e3[b.FIELDS.END_LINE], column: e3[b.FIELDS.END_COL] };
            }
            function k2(e3, t3, r3, n2) {
              return { start: { line: e3, column: t3 }, end: { line: r3, column: n2 } };
            }
            function N(e3) {
              return k2(e3[b.FIELDS.START_LINE], e3[b.FIELDS.START_COL], e3[b.FIELDS.END_LINE], e3[b.FIELDS.END_COL]);
            }
            function _(e3, t3) {
              if (e3)
                return k2(e3[b.FIELDS.START_LINE], e3[b.FIELDS.START_COL], t3[b.FIELDS.END_LINE], t3[b.FIELDS.END_COL]);
            }
            function j(e3, t3) {
              var r3 = e3[t3];
              if (typeof r3 == "string")
                return r3.indexOf("\\") !== -1 && ((0, x.ensureObject)(e3, "raws"), e3[t3] = (0, x.unesc)(r3), e3.raws[t3] === void 0 && (e3.raws[t3] = r3)), e3;
            }
            function D(e3, t3) {
              for (var r3 = -1, n2 = []; (r3 = e3.indexOf(t3, r3 + 1)) !== -1; )
                n2.push(r3);
              return n2;
            }
            var L = function() {
              function e3(e4, t4) {
                t4 === void 0 && (t4 = {}), this.rule = e4, this.options = Object.assign({ lossy: false, safe: false }, t4), this.position = 0, this.css = typeof this.rule == "string" ? this.rule : this.rule.selector, this.tokens = (0, b.default)({ css: this.css, error: this._errorGenerator(), safe: this.options.safe });
                var r4 = _(this.tokens[0], this.tokens[this.tokens.length - 1]);
                this.root = new i.default({ source: r4 }), this.root.errorGenerator = this._errorGenerator();
                var n3 = new o.default({ source: { start: { line: 1, column: 1 } } });
                this.root.append(n3), this.current = n3, this.loop();
              }
              var t3, r3, n2 = e3.prototype;
              return n2._errorGenerator = function() {
                var e4 = this;
                return function(t4, r4) {
                  return typeof e4.rule == "string" ? new Error(t4) : e4.rule.error(t4, r4);
                };
              }, n2.attribute = function() {
                var e4 = [], t4 = this.currToken;
                for (this.position++; this.position < this.tokens.length && this.currToken[b.FIELDS.TYPE] !== v.closeSquare; )
                  e4.push(this.currToken), this.position++;
                if (this.currToken[b.FIELDS.TYPE] !== v.closeSquare)
                  return this.expected("closing square bracket", this.currToken[b.FIELDS.START_POS]);
                var r4 = e4.length, n3 = { source: k2(t4[1], t4[2], this.currToken[3], this.currToken[4]), sourceIndex: t4[b.FIELDS.START_POS] };
                if (r4 === 1 && !~[v.word].indexOf(e4[0][b.FIELDS.TYPE]))
                  return this.expected("attribute", e4[0][b.FIELDS.START_POS]);
                for (var s3 = 0, i2 = "", o2 = "", a2 = null, l2 = false; s3 < r4; ) {
                  var c4 = e4[s3], u2 = this.content(c4), p3 = e4[s3 + 1];
                  switch (c4[b.FIELDS.TYPE]) {
                    case v.space:
                      if (l2 = true, this.options.lossy)
                        break;
                      if (a2) {
                        (0, x.ensureObject)(n3, "spaces", a2);
                        var f2 = n3.spaces[a2].after || "";
                        n3.spaces[a2].after = f2 + u2;
                        var h4 = (0, x.getProp)(n3, "raws", "spaces", a2, "after") || null;
                        h4 && (n3.raws.spaces[a2].after = h4 + u2);
                      } else
                        i2 += u2, o2 += u2;
                      break;
                    case v.asterisk:
                      p3[b.FIELDS.TYPE] === v.equals ? (n3.operator = u2, a2 = "operator") : n3.namespace && (a2 !== "namespace" || l2) || !p3 || (i2 && ((0, x.ensureObject)(n3, "spaces", "attribute"), n3.spaces.attribute.before = i2, i2 = ""), o2 && ((0, x.ensureObject)(n3, "raws", "spaces", "attribute"), n3.raws.spaces.attribute.before = i2, o2 = ""), n3.namespace = (n3.namespace || "") + u2, (0, x.getProp)(n3, "raws", "namespace") && (n3.raws.namespace += u2), a2 = "namespace"), l2 = false;
                      break;
                    case v.dollar:
                      if (a2 === "value") {
                        var m2 = (0, x.getProp)(n3, "raws", "value");
                        n3.value += "$", m2 && (n3.raws.value = m2 + "$");
                        break;
                      }
                    case v.caret:
                      p3[b.FIELDS.TYPE] === v.equals && (n3.operator = u2, a2 = "operator"), l2 = false;
                      break;
                    case v.combinator:
                      if (u2 === "~" && p3[b.FIELDS.TYPE] === v.equals && (n3.operator = u2, a2 = "operator"), u2 !== "|") {
                        l2 = false;
                        break;
                      }
                      p3[b.FIELDS.TYPE] === v.equals ? (n3.operator = u2, a2 = "operator") : n3.namespace || n3.attribute || (n3.namespace = true), l2 = false;
                      break;
                    case v.word:
                      if (p3 && this.content(p3) === "|" && e4[s3 + 2] && e4[s3 + 2][b.FIELDS.TYPE] !== v.equals && !n3.operator && !n3.namespace)
                        n3.namespace = u2, a2 = "namespace";
                      else if (!n3.attribute || a2 === "attribute" && !l2)
                        i2 && ((0, x.ensureObject)(n3, "spaces", "attribute"), n3.spaces.attribute.before = i2, i2 = ""), o2 && ((0, x.ensureObject)(n3, "raws", "spaces", "attribute"), n3.raws.spaces.attribute.before = o2, o2 = ""), n3.attribute = (n3.attribute || "") + u2, (0, x.getProp)(n3, "raws", "attribute") && (n3.raws.attribute += u2), a2 = "attribute";
                      else if (!n3.value && n3.value !== "" || a2 === "value" && !l2) {
                        var y2 = (0, x.unesc)(u2), g2 = (0, x.getProp)(n3, "raws", "value") || "", E2 = n3.value || "";
                        n3.value = E2 + y2, n3.quoteMark = null, (y2 !== u2 || g2) && ((0, x.ensureObject)(n3, "raws"), n3.raws.value = (g2 || E2) + u2), a2 = "value";
                      } else {
                        var S2 = u2 === "i" || u2 === "I";
                        !n3.value && n3.value !== "" || !n3.quoteMark && !l2 ? (n3.value || n3.value === "") && (a2 = "value", n3.value += u2, n3.raws.value && (n3.raws.value += u2)) : (n3.insensitive = S2, S2 && u2 !== "I" || ((0, x.ensureObject)(n3, "raws"), n3.raws.insensitiveFlag = u2), a2 = "insensitive", i2 && ((0, x.ensureObject)(n3, "spaces", "insensitive"), n3.spaces.insensitive.before = i2, i2 = ""), o2 && ((0, x.ensureObject)(n3, "raws", "spaces", "insensitive"), n3.raws.spaces.insensitive.before = o2, o2 = ""));
                      }
                      l2 = false;
                      break;
                    case v.str:
                      if (!n3.attribute || !n3.operator)
                        return this.error("Expected an attribute followed by an operator preceding the string.", { index: c4[b.FIELDS.START_POS] });
                      var T2 = (0, d.unescapeValue)(u2), w2 = T2.unescaped, P2 = T2.quoteMark;
                      n3.value = w2, n3.quoteMark = P2, a2 = "value", (0, x.ensureObject)(n3, "raws"), n3.raws.value = u2, l2 = false;
                      break;
                    case v.equals:
                      if (!n3.attribute)
                        return this.expected("attribute", c4[b.FIELDS.START_POS], u2);
                      if (n3.value)
                        return this.error('Unexpected "=" found; an operator was already defined.', { index: c4[b.FIELDS.START_POS] });
                      n3.operator = n3.operator ? n3.operator + u2 : u2, a2 = "operator", l2 = false;
                      break;
                    case v.comment:
                      if (a2)
                        if (l2 || p3 && p3[b.FIELDS.TYPE] === v.space || a2 === "insensitive") {
                          var A2 = (0, x.getProp)(n3, "spaces", a2, "after") || "", O2 = (0, x.getProp)(n3, "raws", "spaces", a2, "after") || A2;
                          (0, x.ensureObject)(n3, "raws", "spaces", a2), n3.raws.spaces[a2].after = O2 + u2;
                        } else {
                          var C2 = n3[a2] || "", I2 = (0, x.getProp)(n3, "raws", a2) || C2;
                          (0, x.ensureObject)(n3, "raws"), n3.raws[a2] = I2 + u2;
                        }
                      else
                        o2 += u2;
                      break;
                    default:
                      return this.error('Unexpected "' + u2 + '" found.', { index: c4[b.FIELDS.START_POS] });
                  }
                  s3++;
                }
                j(n3, "attribute"), j(n3, "namespace"), this.newNode(new d.default(n3)), this.position++;
              }, n2.parseWhitespaceEquivalentTokens = function(e4) {
                e4 < 0 && (e4 = this.tokens.length);
                var t4 = this.position, r4 = [], n3 = "", s3 = void 0;
                do {
                  if (A[this.currToken[b.FIELDS.TYPE]])
                    this.options.lossy || (n3 += this.content());
                  else if (this.currToken[b.FIELDS.TYPE] === v.comment) {
                    var i2 = {};
                    n3 && (i2.before = n3, n3 = ""), s3 = new l.default({ value: this.content(), source: N(this.currToken), sourceIndex: this.currToken[b.FIELDS.START_POS], spaces: i2 }), r4.push(s3);
                  }
                } while (++this.position < e4);
                if (n3) {
                  if (s3)
                    s3.spaces.after = n3;
                  else if (!this.options.lossy) {
                    var o2 = this.tokens[t4], a2 = this.tokens[this.position - 1];
                    r4.push(new p2.default({ value: "", source: k2(o2[b.FIELDS.START_LINE], o2[b.FIELDS.START_COL], a2[b.FIELDS.END_LINE], a2[b.FIELDS.END_COL]), sourceIndex: o2[b.FIELDS.START_POS], spaces: { before: n3, after: "" } }));
                  }
                }
                return r4;
              }, n2.convertWhitespaceNodesToSpace = function(e4, t4) {
                var r4 = this;
                t4 === void 0 && (t4 = false);
                var n3 = "", s3 = "";
                return e4.forEach(function(e5) {
                  var i2 = r4.lossySpace(e5.spaces.before, t4), o2 = r4.lossySpace(e5.rawSpaceBefore, t4);
                  n3 += i2 + r4.lossySpace(e5.spaces.after, t4 && i2.length === 0), s3 += i2 + e5.value + r4.lossySpace(e5.rawSpaceAfter, t4 && o2.length === 0);
                }), s3 === n3 && (s3 = void 0), { space: n3, rawSpace: s3 };
              }, n2.isNamedCombinator = function(e4) {
                return e4 === void 0 && (e4 = this.position), this.tokens[e4 + 0] && this.tokens[e4 + 0][b.FIELDS.TYPE] === v.slash && this.tokens[e4 + 1] && this.tokens[e4 + 1][b.FIELDS.TYPE] === v.word && this.tokens[e4 + 2] && this.tokens[e4 + 2][b.FIELDS.TYPE] === v.slash;
              }, n2.namedCombinator = function() {
                if (this.isNamedCombinator()) {
                  var e4 = this.content(this.tokens[this.position + 1]), t4 = (0, x.unesc)(e4).toLowerCase(), r4 = {};
                  t4 !== e4 && (r4.value = "/" + e4 + "/");
                  var n3 = new m.default({ value: "/" + t4 + "/", source: k2(this.currToken[b.FIELDS.START_LINE], this.currToken[b.FIELDS.START_COL], this.tokens[this.position + 2][b.FIELDS.END_LINE], this.tokens[this.position + 2][b.FIELDS.END_COL]), sourceIndex: this.currToken[b.FIELDS.START_POS], raws: r4 });
                  return this.position = this.position + 3, n3;
                }
                this.unexpected();
              }, n2.combinator = function() {
                var e4 = this;
                if (this.content() === "|")
                  return this.namespace();
                var t4 = this.locateNextMeaningfulToken(this.position);
                if (!(t4 < 0 || this.tokens[t4][b.FIELDS.TYPE] === v.comma)) {
                  var r4, n3 = this.currToken, s3 = void 0;
                  if (t4 > this.position && (s3 = this.parseWhitespaceEquivalentTokens(t4)), this.isNamedCombinator() ? r4 = this.namedCombinator() : this.currToken[b.FIELDS.TYPE] === v.combinator ? (r4 = new m.default({ value: this.content(), source: N(this.currToken), sourceIndex: this.currToken[b.FIELDS.START_POS] }), this.position++) : A[this.currToken[b.FIELDS.TYPE]] || s3 || this.unexpected(), r4) {
                    if (s3) {
                      var i2 = this.convertWhitespaceNodesToSpace(s3), o2 = i2.space, a2 = i2.rawSpace;
                      r4.spaces.before = o2, r4.rawSpaceBefore = a2;
                    }
                  } else {
                    var l2 = this.convertWhitespaceNodesToSpace(s3, true), c4 = l2.space, u2 = l2.rawSpace;
                    u2 || (u2 = c4);
                    var p3 = {}, f2 = { spaces: {} };
                    c4.endsWith(" ") && u2.endsWith(" ") ? (p3.before = c4.slice(0, c4.length - 1), f2.spaces.before = u2.slice(0, u2.length - 1)) : c4.startsWith(" ") && u2.startsWith(" ") ? (p3.after = c4.slice(1), f2.spaces.after = u2.slice(1)) : f2.value = u2, r4 = new m.default({ value: " ", source: _(n3, this.tokens[this.position - 1]), sourceIndex: n3[b.FIELDS.START_POS], spaces: p3, raws: f2 });
                  }
                  return this.currToken && this.currToken[b.FIELDS.TYPE] === v.space && (r4.spaces.after = this.optionalSpace(this.content()), this.position++), this.newNode(r4);
                }
                var d2 = this.parseWhitespaceEquivalentTokens(t4);
                if (d2.length > 0) {
                  var h4 = this.current.last;
                  if (h4) {
                    var y2 = this.convertWhitespaceNodesToSpace(d2), g2 = y2.space, E2 = y2.rawSpace;
                    E2 !== void 0 && (h4.rawSpaceAfter += E2), h4.spaces.after += g2;
                  } else
                    d2.forEach(function(t5) {
                      return e4.newNode(t5);
                    });
                }
              }, n2.comma = function() {
                if (this.position === this.tokens.length - 1)
                  return this.root.trailingComma = true, void this.position++;
                this.current._inferEndPosition();
                var e4 = new o.default({ source: { start: C(this.tokens[this.position + 1]) } });
                this.current.parent.append(e4), this.current = e4, this.position++;
              }, n2.comment = function() {
                var e4 = this.currToken;
                this.newNode(new l.default({ value: this.content(), source: N(e4), sourceIndex: e4[b.FIELDS.START_POS] })), this.position++;
              }, n2.error = function(e4, t4) {
                throw this.root.error(e4, t4);
              }, n2.missingBackslash = function() {
                return this.error("Expected a backslash preceding the semicolon.", { index: this.currToken[b.FIELDS.START_POS] });
              }, n2.missingParenthesis = function() {
                return this.expected("opening parenthesis", this.currToken[b.FIELDS.START_POS]);
              }, n2.missingSquareBracket = function() {
                return this.expected("opening square bracket", this.currToken[b.FIELDS.START_POS]);
              }, n2.unexpected = function() {
                return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[b.FIELDS.START_POS]);
              }, n2.namespace = function() {
                var e4 = this.prevToken && this.content(this.prevToken) || true;
                return this.nextToken[b.FIELDS.TYPE] === v.word ? (this.position++, this.word(e4)) : this.nextToken[b.FIELDS.TYPE] === v.asterisk ? (this.position++, this.universal(e4)) : void 0;
              }, n2.nesting = function() {
                if (this.nextToken && this.content(this.nextToken) === "|")
                  this.position++;
                else {
                  var e4 = this.currToken;
                  this.newNode(new y.default({ value: this.content(), source: N(e4), sourceIndex: e4[b.FIELDS.START_POS] })), this.position++;
                }
              }, n2.parentheses = function() {
                var e4 = this.current.last, t4 = 1;
                if (this.position++, e4 && e4.type === E.PSEUDO) {
                  var r4 = new o.default({ source: { start: C(this.tokens[this.position - 1]) } }), n3 = this.current;
                  for (e4.append(r4), this.current = r4; this.position < this.tokens.length && t4; )
                    this.currToken[b.FIELDS.TYPE] === v.openParenthesis && t4++, this.currToken[b.FIELDS.TYPE] === v.closeParenthesis && t4--, t4 ? this.parse() : (this.current.source.end = I(this.currToken), this.current.parent.source.end = I(this.currToken), this.position++);
                  this.current = n3;
                } else {
                  for (var s3, i2 = this.currToken, a2 = "("; this.position < this.tokens.length && t4; )
                    this.currToken[b.FIELDS.TYPE] === v.openParenthesis && t4++, this.currToken[b.FIELDS.TYPE] === v.closeParenthesis && t4--, s3 = this.currToken, a2 += this.parseParenthesisToken(this.currToken), this.position++;
                  e4 ? e4.appendToPropertyAndEscape("value", a2, a2) : this.newNode(new p2.default({ value: a2, source: k2(i2[b.FIELDS.START_LINE], i2[b.FIELDS.START_COL], s3[b.FIELDS.END_LINE], s3[b.FIELDS.END_COL]), sourceIndex: i2[b.FIELDS.START_POS] }));
                }
                if (t4)
                  return this.expected("closing parenthesis", this.currToken[b.FIELDS.START_POS]);
              }, n2.pseudo = function() {
                for (var e4 = this, t4 = "", r4 = this.currToken; this.currToken && this.currToken[b.FIELDS.TYPE] === v.colon; )
                  t4 += this.content(), this.position++;
                return this.currToken ? this.currToken[b.FIELDS.TYPE] !== v.word ? this.expected(["pseudo-class", "pseudo-element"], this.currToken[b.FIELDS.START_POS]) : void this.splitWord(false, function(n3, s3) {
                  t4 += n3, e4.newNode(new f.default({ value: t4, source: _(r4, e4.currToken), sourceIndex: r4[b.FIELDS.START_POS] })), s3 > 1 && e4.nextToken && e4.nextToken[b.FIELDS.TYPE] === v.openParenthesis && e4.error("Misplaced parenthesis.", { index: e4.nextToken[b.FIELDS.START_POS] });
                }) : this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
              }, n2.space = function() {
                var e4 = this.content();
                this.position === 0 || this.prevToken[b.FIELDS.TYPE] === v.comma || this.prevToken[b.FIELDS.TYPE] === v.openParenthesis || this.current.nodes.every(function(e5) {
                  return e5.type === "comment";
                }) ? (this.spaces = this.optionalSpace(e4), this.position++) : this.position === this.tokens.length - 1 || this.nextToken[b.FIELDS.TYPE] === v.comma || this.nextToken[b.FIELDS.TYPE] === v.closeParenthesis ? (this.current.last.spaces.after = this.optionalSpace(e4), this.position++) : this.combinator();
              }, n2.string = function() {
                var e4 = this.currToken;
                this.newNode(new p2.default({ value: this.content(), source: N(e4), sourceIndex: e4[b.FIELDS.START_POS] })), this.position++;
              }, n2.universal = function(e4) {
                var t4 = this.nextToken;
                if (t4 && this.content(t4) === "|")
                  return this.position++, this.namespace();
                var r4 = this.currToken;
                this.newNode(new h3.default({ value: this.content(), source: N(r4), sourceIndex: r4[b.FIELDS.START_POS] }), e4), this.position++;
              }, n2.splitWord = function(e4, t4) {
                for (var r4 = this, n3 = this.nextToken, s3 = this.content(); n3 && ~[v.dollar, v.caret, v.equals, v.word].indexOf(n3[b.FIELDS.TYPE]); ) {
                  this.position++;
                  var i2 = this.content();
                  if (s3 += i2, i2.lastIndexOf("\\") === i2.length - 1) {
                    var o2 = this.nextToken;
                    o2 && o2[b.FIELDS.TYPE] === v.space && (s3 += this.requiredSpace(this.content(o2)), this.position++);
                  }
                  n3 = this.nextToken;
                }
                var l2 = D(s3, ".").filter(function(e5) {
                  return s3[e5 - 1] !== "\\";
                }), p3 = D(s3, "#").filter(function(e5) {
                  return s3[e5 - 1] !== "\\";
                }), f2 = D(s3, "#{");
                f2.length && (p3 = p3.filter(function(e5) {
                  return !~f2.indexOf(e5);
                }));
                var d2 = (0, g.default)(function() {
                  var e5 = Array.prototype.concat.apply([], arguments);
                  return e5.filter(function(t5, r5) {
                    return r5 === e5.indexOf(t5);
                  });
                }([0].concat(l2, p3)));
                d2.forEach(function(n4, i3) {
                  var o3, f3 = d2[i3 + 1] || s3.length, h4 = s3.slice(n4, f3);
                  if (i3 === 0 && t4)
                    return t4.call(r4, h4, d2.length);
                  var m2 = r4.currToken, y2 = m2[b.FIELDS.START_POS] + d2[i3], g2 = k2(m2[1], m2[2] + n4, m2[3], m2[2] + (f3 - 1));
                  if (~l2.indexOf(n4)) {
                    var v2 = { value: h4.slice(1), source: g2, sourceIndex: y2 };
                    o3 = new a.default(j(v2, "value"));
                  } else if (~p3.indexOf(n4)) {
                    var E2 = { value: h4.slice(1), source: g2, sourceIndex: y2 };
                    o3 = new c.default(j(E2, "value"));
                  } else {
                    var x2 = { value: h4, source: g2, sourceIndex: y2 };
                    j(x2, "value"), o3 = new u.default(x2);
                  }
                  r4.newNode(o3, e4), e4 = null;
                }), this.position++;
              }, n2.word = function(e4) {
                var t4 = this.nextToken;
                return t4 && this.content(t4) === "|" ? (this.position++, this.namespace()) : this.splitWord(e4);
              }, n2.loop = function() {
                for (; this.position < this.tokens.length; )
                  this.parse(true);
                return this.current._inferEndPosition(), this.root;
              }, n2.parse = function(e4) {
                switch (this.currToken[b.FIELDS.TYPE]) {
                  case v.space:
                    this.space();
                    break;
                  case v.comment:
                    this.comment();
                    break;
                  case v.openParenthesis:
                    this.parentheses();
                    break;
                  case v.closeParenthesis:
                    e4 && this.missingParenthesis();
                    break;
                  case v.openSquare:
                    this.attribute();
                    break;
                  case v.dollar:
                  case v.caret:
                  case v.equals:
                  case v.word:
                    this.word();
                    break;
                  case v.colon:
                    this.pseudo();
                    break;
                  case v.comma:
                    this.comma();
                    break;
                  case v.asterisk:
                    this.universal();
                    break;
                  case v.ampersand:
                    this.nesting();
                    break;
                  case v.slash:
                  case v.combinator:
                    this.combinator();
                    break;
                  case v.str:
                    this.string();
                    break;
                  case v.closeSquare:
                    this.missingSquareBracket();
                  case v.semicolon:
                    this.missingBackslash();
                  default:
                    this.unexpected();
                }
              }, n2.expected = function(e4, t4, r4) {
                if (Array.isArray(e4)) {
                  var n3 = e4.pop();
                  e4 = e4.join(", ") + " or " + n3;
                }
                var s3 = /^[aeiou]/.test(e4[0]) ? "an" : "a";
                return r4 ? this.error("Expected " + s3 + " " + e4 + ', found "' + r4 + '" instead.', { index: t4 }) : this.error("Expected " + s3 + " " + e4 + ".", { index: t4 });
              }, n2.requiredSpace = function(e4) {
                return this.options.lossy ? " " : e4;
              }, n2.optionalSpace = function(e4) {
                return this.options.lossy ? "" : e4;
              }, n2.lossySpace = function(e4, t4) {
                return this.options.lossy ? t4 ? " " : "" : e4;
              }, n2.parseParenthesisToken = function(e4) {
                var t4 = this.content(e4);
                return e4[b.FIELDS.TYPE] === v.space ? this.requiredSpace(t4) : t4;
              }, n2.newNode = function(e4, t4) {
                return t4 && (/^ +$/.test(t4) && (this.options.lossy || (this.spaces = (this.spaces || "") + t4), t4 = true), e4.namespace = t4, j(e4, "namespace")), this.spaces && (e4.spaces.before = this.spaces, this.spaces = ""), this.current.append(e4);
              }, n2.content = function(e4) {
                return e4 === void 0 && (e4 = this.currToken), this.css.slice(e4[b.FIELDS.START_POS], e4[b.FIELDS.END_POS]);
              }, n2.locateNextMeaningfulToken = function(e4) {
                e4 === void 0 && (e4 = this.position + 1);
                for (var t4 = e4; t4 < this.tokens.length; ) {
                  if (!O[this.tokens[t4][b.FIELDS.TYPE]])
                    return t4;
                  t4++;
                }
                return -1;
              }, t3 = e3, (r3 = [{ key: "currToken", get: function() {
                return this.tokens[this.position];
              } }, { key: "nextToken", get: function() {
                return this.tokens[this.position + 1];
              } }, { key: "prevToken", get: function() {
                return this.tokens[this.position - 1];
              } }]) && P(t3.prototype, r3), e3;
            }();
            t2.default = L, e2.exports = t2.default;
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.default = function(e3) {
              for (var t3 = arguments.length, r2 = new Array(t3 > 1 ? t3 - 1 : 0), n = 1; n < t3; n++)
                r2[n - 1] = arguments[n];
              for (; r2.length > 0; ) {
                var s2 = r2.shift();
                if (!e3[s2])
                  return;
                e3 = e3[s2];
              }
              return e3;
            }, e2.exports = t2.default;
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.default = function(e3) {
              for (var t3 = arguments.length, r2 = new Array(t3 > 1 ? t3 - 1 : 0), n = 1; n < t3; n++)
                r2[n - 1] = arguments[n];
              for (; r2.length > 0; ) {
                var s2 = r2.shift();
                e3[s2] || (e3[s2] = {}), e3 = e3[s2];
              }
            }, e2.exports = t2.default;
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.default = function(e3) {
              for (var t3 = "", r2 = e3.indexOf("/*"), n = 0; r2 >= 0; ) {
                t3 += e3.slice(n, r2);
                var s2 = e3.indexOf("*/", r2 + 2);
                if (s2 < 0)
                  return t3;
                n = s2 + 2, r2 = e3.indexOf("/*", n);
              }
              return t3 + e3.slice(n);
            }, e2.exports = t2.default;
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.default = function(e3) {
              return e3.sort(function(e4, t3) {
                return e4 - t3;
              });
            }, e2.exports = t2.default;
          }, function(e2, t2) {
            !function(e3) {
              "use strict";
              for (var t3 = {}, r2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", n = 0; n < r2.length; n++)
                t3[r2.charCodeAt(n)] = n;
              function s2(e4, t4, r3) {
                r3 === 4 ? e4.push([t4[0], t4[1], t4[2], t4[3]]) : r3 === 5 ? e4.push([t4[0], t4[1], t4[2], t4[3], t4[4]]) : r3 === 1 && e4.push([t4[0]]);
              }
              function i(e4) {
                var t4 = "";
                e4 = e4 < 0 ? -e4 << 1 | 1 : e4 << 1;
                do {
                  var n2 = 31 & e4;
                  (e4 >>>= 5) > 0 && (n2 |= 32), t4 += r2[n2];
                } while (e4 > 0);
                return t4;
              }
              e3.decode = function(e4) {
                for (var r3 = [], n2 = [], i2 = [0, 0, 0, 0, 0], o = 0, a = 0, l = 0, c = 0; a < e4.length; a++) {
                  var u = e4.charCodeAt(a);
                  if (u === 44)
                    s2(n2, i2, o), o = 0;
                  else if (u === 59)
                    s2(n2, i2, o), o = 0, r3.push(n2), n2 = [], i2[0] = 0;
                  else {
                    var p2 = t3[u];
                    if (p2 === void 0)
                      throw new Error("Invalid character (" + String.fromCharCode(u) + ")");
                    var f = 32 & p2;
                    if (c += (p2 &= 31) << l, f)
                      l += 5;
                    else {
                      var d = 1 & c;
                      c >>>= 1, d && (c = c === 0 ? -2147483648 : -c), i2[o] += c, o++, c = l = 0;
                    }
                  }
                }
                return s2(n2, i2, o), r3.push(n2), r3;
              }, e3.encode = function(e4) {
                for (var t4 = 0, r3 = 0, n2 = 0, s3 = 0, o = "", a = 0; a < e4.length; a++) {
                  var l = e4[a];
                  if (a > 0 && (o += ";"), l.length !== 0) {
                    for (var c = 0, u = [], p2 = 0, f = l; p2 < f.length; p2++) {
                      var d = f[p2], h3 = i(d[0] - c);
                      c = d[0], d.length > 1 && (h3 += i(d[1] - t4) + i(d[2] - r3) + i(d[3] - n2), t4 = d[1], r3 = d[2], n2 = d[3]), d.length === 5 && (h3 += i(d[4] - s3), s3 = d[4]), u.push(h3);
                    }
                    o += u.join(",");
                  }
                }
                return o;
              }, Object.defineProperty(e3, "__esModule", { value: true });
            }(t2);
          }, (e2, t2, r2) => {
            "use strict";
            var n, s2 = r2(180), i = r2(31), o = r2(2), a = r2(24), l = r2(17), c = r2(181), u = r2(32), p2 = r2(119), f = r2(112).f, d = r2(188), h3 = r2(190), m = r2(54), y = r2(58), g = o.Int8Array, b = g && g.prototype, v = o.Uint8ClampedArray, E = v && v.prototype, x = g && d(g), S = b && d(b), T = Object.prototype, w = T.isPrototypeOf, P = m("toStringTag"), A = y("TYPED_ARRAY_TAG"), O = s2 && !!h3 && c(o.opera) !== "Opera", C = false, I = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }, k2 = { BigInt64Array: 8, BigUint64Array: 8 }, N = function(e3) {
              if (!a(e3))
                return false;
              var t3 = c(e3);
              return l(I, t3) || l(k2, t3);
            };
            for (n in I)
              o[n] || (O = false);
            if ((!O || typeof x != "function" || x === Function.prototype) && (x = function() {
              throw TypeError("Incorrect invocation");
            }, O))
              for (n in I)
                o[n] && h3(o[n], x);
            if ((!O || !S || S === T) && (S = x.prototype, O))
              for (n in I)
                o[n] && h3(o[n].prototype, S);
            if (O && d(E) !== S && h3(E, S), i && !l(S, P))
              for (n in C = true, f(S, P, { get: function() {
                return a(this) ? this[A] : void 0;
              } }), I)
                o[n] && u(o[n], A, n);
            e2.exports = { NATIVE_ARRAY_BUFFER_VIEWS: O, TYPED_ARRAY_TAG: C && A, aTypedArray: function(e3) {
              if (N(e3))
                return e3;
              throw TypeError("Target is not a typed array");
            }, aTypedArrayConstructor: function(e3) {
              if (h3) {
                if (w.call(x, e3))
                  return e3;
              } else
                for (var t3 in I)
                  if (l(I, n)) {
                    var r3 = o[t3];
                    if (r3 && (e3 === r3 || w.call(r3, e3)))
                      return e3;
                  }
              throw TypeError("Target is not a typed array constructor");
            }, exportTypedArrayMethod: function(e3, t3, r3) {
              if (i) {
                if (r3)
                  for (var n2 in I) {
                    var s3 = o[n2];
                    if (s3 && l(s3.prototype, e3))
                      try {
                        delete s3.prototype[e3];
                      } catch (e4) {
                      }
                  }
                S[e3] && !r3 || p2(S, e3, r3 ? t3 : O && b[e3] || t3);
              }
            }, exportTypedArrayStaticMethod: function(e3, t3, r3) {
              var n2, s3;
              if (i) {
                if (h3) {
                  if (r3) {
                    for (n2 in I)
                      if ((s3 = o[n2]) && l(s3, e3))
                        try {
                          delete s3[e3];
                        } catch (e4) {
                        }
                  }
                  if (x[e3] && !r3)
                    return;
                  try {
                    return p2(x, e3, r3 ? t3 : O && x[e3] || t3);
                  } catch (e4) {
                  }
                }
                for (n2 in I)
                  !(s3 = o[n2]) || s3[e3] && !r3 || p2(s3, e3, t3);
              }
            }, isView: function(e3) {
              if (!a(e3))
                return false;
              var t3 = c(e3);
              return t3 === "DataView" || l(I, t3) || l(k2, t3);
            }, isTypedArray: N, TypedArray: x, TypedArrayPrototype: S };
          }, (e2) => {
            e2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
          }, (e2, t2, r2) => {
            var n = r2(182), s2 = r2(60), i = r2(54)("toStringTag"), o = s2(function() {
              return arguments;
            }()) == "Arguments";
            e2.exports = n ? s2 : function(e3) {
              var t3, r3, n2;
              return e3 === void 0 ? "Undefined" : e3 === null ? "Null" : typeof (r3 = function(e4, t4) {
                try {
                  return e4[t4];
                } catch (e5) {
                }
              }(t3 = Object(e3), i)) == "string" ? r3 : o ? s2(t3) : (n2 = s2(t3)) == "Object" && typeof t3.callee == "function" ? "Arguments" : n2;
            };
          }, (e2, t2, r2) => {
            var n = {};
            n[r2(54)("toStringTag")] = "z", e2.exports = String(n) === "[object z]";
          }, (e2) => {
            e2.exports = false;
          }, (e2, t2, r2) => {
            var n = r2(2);
            e2.exports = n;
          }, (e2, t2, r2) => {
            var n = r2(117);
            e2.exports = n && !Symbol.sham && typeof Symbol.iterator == "symbol";
          }, (e2, t2, r2) => {
            var n, s2, i, o = r2(187), a = r2(2), l = r2(24), c = r2(32), u = r2(17), p2 = r2(55), f = r2(121), d = r2(122), h3 = "Object already initialized", m = a.WeakMap;
            if (o || p2.state) {
              var y = p2.state || (p2.state = new m()), g = y.get, b = y.has, v = y.set;
              n = function(e3, t3) {
                if (b.call(y, e3))
                  throw new TypeError(h3);
                return t3.facade = e3, v.call(y, e3, t3), t3;
              }, s2 = function(e3) {
                return g.call(y, e3) || {};
              }, i = function(e3) {
                return b.call(y, e3);
              };
            } else {
              var E = f("state");
              d[E] = true, n = function(e3, t3) {
                if (u(e3, E))
                  throw new TypeError(h3);
                return t3.facade = e3, c(e3, E, t3), t3;
              }, s2 = function(e3) {
                return u(e3, E) ? e3[E] : {};
              }, i = function(e3) {
                return u(e3, E);
              };
            }
            e2.exports = { set: n, get: s2, has: i, enforce: function(e3) {
              return i(e3) ? s2(e3) : n(e3, {});
            }, getterFor: function(e3) {
              return function(t3) {
                var r3;
                if (!l(t3) || (r3 = s2(t3)).type !== e3)
                  throw TypeError("Incompatible receiver, " + e3 + " required");
                return r3;
              };
            } };
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(120), i = n.WeakMap;
            e2.exports = typeof i == "function" && /native code/.test(s2(i));
          }, (e2, t2, r2) => {
            var n = r2(17), s2 = r2(109), i = r2(121), o = r2(189), a = i("IE_PROTO"), l = Object.prototype;
            e2.exports = o ? Object.getPrototypeOf : function(e3) {
              return e3 = s2(e3), n(e3, a) ? e3[a] : typeof e3.constructor == "function" && e3 instanceof e3.constructor ? e3.constructor.prototype : e3 instanceof Object ? l : null;
            };
          }, (e2, t2, r2) => {
            var n = r2(16);
            e2.exports = !n(function() {
              function e3() {
              }
              return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
            });
          }, (e2, t2, r2) => {
            var n = r2(57), s2 = r2(191);
            e2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var e3, t3 = false, r3 = {};
              try {
                (e3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(r3, []), t3 = r3 instanceof Array;
              } catch (e4) {
              }
              return function(r4, i) {
                return n(r4), s2(i), t3 ? e3.call(r4, i) : r4.__proto__ = i, r4;
              };
            }() : void 0);
          }, (e2, t2, r2) => {
            var n = r2(24);
            e2.exports = function(e3) {
              if (!n(e3) && e3 !== null)
                throw TypeError("Can't set " + String(e3) + " as a prototype");
              return e3;
            };
          }, (e2) => {
            var t2 = Math.floor, r2 = function(e3, i) {
              var o = e3.length, a = t2(o / 2);
              return o < 8 ? n(e3, i) : s2(r2(e3.slice(0, a), i), r2(e3.slice(a), i), i);
            }, n = function(e3, t3) {
              for (var r3, n2, s3 = e3.length, i = 1; i < s3; ) {
                for (n2 = i, r3 = e3[i]; n2 && t3(e3[n2 - 1], r3) > 0; )
                  e3[n2] = e3[--n2];
                n2 !== i++ && (e3[n2] = r3);
              }
              return e3;
            }, s2 = function(e3, t3, r3) {
              for (var n2 = e3.length, s3 = t3.length, i = 0, o = 0, a = []; i < n2 || o < s3; )
                i < n2 && o < s3 ? a.push(r3(e3[i], t3[o]) <= 0 ? e3[i++] : t3[o++]) : a.push(i < n2 ? e3[i++] : t3[o++]);
              return a;
            };
            e2.exports = r2;
          }, (e2, t2, r2) => {
            var n = r2(33).match(/firefox\/(\d+)/i);
            e2.exports = !!n && +n[1];
          }, (e2, t2, r2) => {
            var n = r2(33);
            e2.exports = /MSIE|Trident/.test(n);
          }, (e2, t2, r2) => {
            var n = r2(33).match(/AppleWebKit\/(\d+)\./);
            e2.exports = !!n && +n[1];
          }, (e2, t2, r2) => {
            var n = r2(2), s2 = r2(197).f, i = r2(32), o = r2(119), a = r2(56), l = r2(199), c = r2(205);
            e2.exports = function(e3, t3) {
              var r3, u, p2, f, d, h3 = e3.target, m = e3.global, y = e3.stat;
              if (r3 = m ? n : y ? n[h3] || a(h3, {}) : (n[h3] || {}).prototype)
                for (u in t3) {
                  if (f = t3[u], p2 = e3.noTargetGet ? (d = s2(r3, u)) && d.value : r3[u], !c(m ? u : h3 + (y ? "." : "#") + u, e3.forced) && p2 !== void 0) {
                    if (typeof f == typeof p2)
                      continue;
                    l(f, p2);
                  }
                  (e3.sham || p2 && p2.sham) && i(f, "sham", true), o(r3, u, f, e3);
                }
            };
          }, (e2, t2, r2) => {
            var n = r2(31), s2 = r2(358), i = r2(116), o = r2(61), a = r2(115), l = r2(17), c = r2(113), u = Object.getOwnPropertyDescriptor;
            t2.f = n ? u : function(e3, t3) {
              if (e3 = o(e3), t3 = a(t3, true), c)
                try {
                  return u(e3, t3);
                } catch (e4) {
                }
              if (l(e3, t3))
                return i(!s2.f.call(e3, t3), e3[t3]);
            };
          }, (e2, t2, r2) => {
            var n = r2(16), s2 = r2(60), i = "".split;
            e2.exports = n(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(e3) {
              return s2(e3) == "String" ? i.call(e3, "") : Object(e3);
            } : Object;
          }, (e2, t2, r2) => {
            var n = r2(17), s2 = r2(200), i = r2(197), o = r2(112);
            e2.exports = function(e3, t3) {
              for (var r3 = s2(t3), a = o.f, l = i.f, c = 0; c < r3.length; c++) {
                var u = r3[c];
                n(e3, u) || a(e3, u, l(t3, u));
              }
            };
          }, (e2, t2, r2) => {
            var n = r2(59), s2 = r2(359), i = r2(360), o = r2(57);
            e2.exports = n("Reflect", "ownKeys") || function(e3) {
              var t3 = s2.f(o(e3)), r3 = i.f;
              return r3 ? t3.concat(r3(e3)) : t3;
            };
          }, (e2, t2, r2) => {
            var n = r2(17), s2 = r2(61), i = r2(202).indexOf, o = r2(122);
            e2.exports = function(e3, t3) {
              var r3, a = s2(e3), l = 0, c = [];
              for (r3 in a)
                !n(o, r3) && n(a, r3) && c.push(r3);
              for (; t3.length > l; )
                n(a, r3 = t3[l++]) && (~i(c, r3) || c.push(r3));
              return c;
            };
          }, (e2, t2, r2) => {
            var n = r2(61), s2 = r2(124), i = r2(203), o = function(e3) {
              return function(t3, r3, o2) {
                var a, l = n(t3), c = s2(l.length), u = i(o2, c);
                if (e3 && r3 != r3) {
                  for (; c > u; )
                    if ((a = l[u++]) != a)
                      return true;
                } else
                  for (; c > u; u++)
                    if ((e3 || u in l) && l[u] === r3)
                      return e3 || u || 0;
                return !e3 && -1;
              };
            };
            e2.exports = { includes: o(true), indexOf: o(false) };
          }, (e2, t2, r2) => {
            var n = r2(125), s2 = Math.max, i = Math.min;
            e2.exports = function(e3, t3) {
              var r3 = n(e3);
              return r3 < 0 ? s2(r3 + t3, 0) : i(r3, t3);
            };
          }, (e2) => {
            e2.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
          }, (e2, t2, r2) => {
            var n = r2(16), s2 = /#|\.prototype\./, i = function(e3, t3) {
              var r3 = a[o(e3)];
              return r3 == c || r3 != l && (typeof t3 == "function" ? n(t3) : !!t3);
            }, o = i.normalize = function(e3) {
              return String(e3).replace(s2, ".").toLowerCase();
            }, a = i.data = {}, l = i.NATIVE = "N", c = i.POLYFILL = "P";
            e2.exports = i;
          }, (e2, t2, r2) => {
            var n, s2, i, o = r2(2), a = r2(16), l = r2(207), c = r2(208), u = r2(114), p2 = r2(209), f = r2(210), d = o.location, h3 = o.setImmediate, m = o.clearImmediate, y = o.process, g = o.MessageChannel, b = o.Dispatch, v = 0, E = {}, x = function(e3) {
              if (E.hasOwnProperty(e3)) {
                var t3 = E[e3];
                delete E[e3], t3();
              }
            }, S = function(e3) {
              return function() {
                x(e3);
              };
            }, T = function(e3) {
              x(e3.data);
            }, w = function(e3) {
              o.postMessage(e3 + "", d.protocol + "//" + d.host);
            };
            h3 && m || (h3 = function(e3) {
              for (var t3 = [], r3 = 1; arguments.length > r3; )
                t3.push(arguments[r3++]);
              return E[++v] = function() {
                (typeof e3 == "function" ? e3 : Function(e3)).apply(void 0, t3);
              }, n(v), v;
            }, m = function(e3) {
              delete E[e3];
            }, f ? n = function(e3) {
              y.nextTick(S(e3));
            } : b && b.now ? n = function(e3) {
              b.now(S(e3));
            } : g && !p2 ? (i = (s2 = new g()).port2, s2.port1.onmessage = T, n = l(i.postMessage, i, 1)) : o.addEventListener && typeof postMessage == "function" && !o.importScripts && d && d.protocol !== "file:" && !a(w) ? (n = w, o.addEventListener("message", T, false)) : n = "onreadystatechange" in u("script") ? function(e3) {
              c.appendChild(u("script")).onreadystatechange = function() {
                c.removeChild(this), x(e3);
              };
            } : function(e3) {
              setTimeout(S(e3), 0);
            }), e2.exports = { set: h3, clear: m };
          }, (e2, t2, r2) => {
            var n = r2(123);
            e2.exports = function(e3, t3, r3) {
              if (n(e3), t3 === void 0)
                return e3;
              switch (r3) {
                case 0:
                  return function() {
                    return e3.call(t3);
                  };
                case 1:
                  return function(r4) {
                    return e3.call(t3, r4);
                  };
                case 2:
                  return function(r4, n2) {
                    return e3.call(t3, r4, n2);
                  };
                case 3:
                  return function(r4, n2, s2) {
                    return e3.call(t3, r4, n2, s2);
                  };
              }
              return function() {
                return e3.apply(t3, arguments);
              };
            };
          }, (e2, t2, r2) => {
            var n = r2(59);
            e2.exports = n("document", "documentElement");
          }, (e2, t2, r2) => {
            var n = r2(33);
            e2.exports = /(?:iphone|ipod|ipad).*applewebkit/i.test(n);
          }, (e2, t2, r2) => {
            var n = r2(60), s2 = r2(2);
            e2.exports = n(s2.process) == "process";
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.get = u, t2.minVersion = function(e3) {
              return c(e3).minVersion();
            }, t2.getDependencies = function(e3) {
              return Array.from(c(e3).dependencies.values());
            }, t2.ensure = function(e3, t3) {
              a || (a = t3), c(e3);
            }, t2.default = t2.list = void 0;
            var n = r2(10), s2 = r2(0), i = r2(457);
            function o(e3) {
              const t3 = [];
              for (; e3.parentPath; e3 = e3.parentPath)
                t3.push(e3.key), e3.inList && t3.push(e3.listKey);
              return t3.reverse().join(".");
            }
            let a;
            const l = Object.create(null);
            function c(e3) {
              if (!l[e3]) {
                const t3 = i.default[e3];
                if (!t3)
                  throw Object.assign(new ReferenceError(`Unknown helper ${e3}`), { code: "BABEL_HELPER_UNKNOWN", helper: e3 });
                const r3 = () => {
                  const r4 = { ast: s2.file(t3.ast()) };
                  return a ? new a({ filename: `babel-helper://${e3}` }, r4) : r4;
                }, c4 = function(e4) {
                  const t4 = new Set(), r4 = new Set(), s3 = new Map();
                  let a2, l2;
                  const c5 = [], u2 = [], p3 = [], f2 = { ImportDeclaration(e5) {
                    const t5 = e5.node.source.value;
                    if (!i.default[t5])
                      throw e5.buildCodeFrameError(`Unknown helper ${t5}`);
                    if (e5.get("specifiers").length !== 1 || !e5.get("specifiers.0").isImportDefaultSpecifier())
                      throw e5.buildCodeFrameError("Helpers can only import a default value");
                    const r5 = e5.node.specifiers[0].local;
                    s3.set(r5, t5), u2.push(o(e5));
                  }, ExportDefaultDeclaration(e5) {
                    const t5 = e5.get("declaration");
                    if (t5.isFunctionDeclaration()) {
                      if (!t5.node.id)
                        throw t5.buildCodeFrameError("Helpers should give names to their exported func declaration");
                      a2 = t5.node.id.name;
                    }
                    l2 = o(e5);
                  }, ExportAllDeclaration(e5) {
                    throw e5.buildCodeFrameError("Helpers can only export default");
                  }, ExportNamedDeclaration(e5) {
                    throw e5.buildCodeFrameError("Helpers can only export default");
                  }, Statement(e5) {
                    e5.isModuleDeclaration() || e5.skip();
                  } }, d = { Program(e5) {
                    const t5 = e5.scope.getAllBindings();
                    Object.keys(t5).forEach((e6) => {
                      e6 !== a2 && (s3.has(t5[e6].identifier) || r4.add(e6));
                    });
                  }, ReferencedIdentifier(e5) {
                    const r5 = e5.node.name, n2 = e5.scope.getBinding(r5, true);
                    n2 ? s3.has(n2.identifier) && p3.push(o(e5)) : t4.add(r5);
                  }, AssignmentExpression(e5) {
                    const t5 = e5.get("left");
                    if (!(a2 in t5.getBindingIdentifiers()))
                      return;
                    if (!t5.isIdentifier())
                      throw t5.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
                    const r5 = e5.scope.getBinding(a2);
                    r5 != null && r5.scope.path.isProgram() && c5.push(o(e5));
                  } };
                  if ((0, n.default)(e4.ast, f2, e4.scope), (0, n.default)(e4.ast, d, e4.scope), !l2)
                    throw new Error("Helpers must default-export something.");
                  return c5.reverse(), { globals: Array.from(t4), localBindingNames: Array.from(r4), dependencies: s3, exportBindingAssignments: c5, exportPath: l2, exportName: a2, importBindingsReferences: p3, importPaths: u2 };
                }(r3());
                l[e3] = { build(e4, t4, i2) {
                  const o2 = r3();
                  return function(e5, t5, r4, i3, o3) {
                    if (i3 && !r4)
                      throw new Error("Unexpected local bindings for module-based helpers.");
                    if (!r4)
                      return;
                    const { localBindingNames: a2, dependencies: l2, exportBindingAssignments: c5, exportPath: u2, exportName: p3, importBindingsReferences: f2, importPaths: d } = t5, h3 = {};
                    l2.forEach((e6, t6) => {
                      h3[t6.name] = typeof o3 == "function" && o3(e6) || t6;
                    });
                    const m = {}, y = new Set(i3 || []);
                    a2.forEach((e6) => {
                      let t6 = e6;
                      for (; y.has(t6); )
                        t6 = "_" + t6;
                      t6 !== e6 && (m[e6] = t6);
                    }), r4.type === "Identifier" && p3 !== r4.name && (m[p3] = r4.name);
                    const g = { Program(e6) {
                      const t6 = e6.get(u2), n2 = d.map((t7) => e6.get(t7)), i4 = f2.map((t7) => e6.get(t7)), o4 = t6.get("declaration");
                      if (r4.type === "Identifier")
                        o4.isFunctionDeclaration() ? t6.replaceWith(o4) : t6.replaceWith(s2.variableDeclaration("var", [s2.variableDeclarator(r4, o4.node)]));
                      else {
                        if (r4.type !== "MemberExpression")
                          throw new Error("Unexpected helper format.");
                        o4.isFunctionDeclaration() ? (c5.forEach((t7) => {
                          const n3 = e6.get(t7);
                          n3.replaceWith(s2.assignmentExpression("=", r4, n3.node));
                        }), t6.replaceWith(o4), e6.pushContainer("body", s2.expressionStatement(s2.assignmentExpression("=", r4, s2.identifier(p3))))) : t6.replaceWith(s2.expressionStatement(s2.assignmentExpression("=", r4, o4.node)));
                      }
                      Object.keys(m).forEach((t7) => {
                        e6.scope.rename(t7, m[t7]);
                      });
                      for (const e7 of n2)
                        e7.remove();
                      for (const e7 of i4) {
                        const t7 = s2.cloneNode(h3[e7.node.name]);
                        e7.replaceWith(t7);
                      }
                      e6.stop();
                    } };
                    (0, n.default)(e5.ast, g, e5.scope);
                  }(o2, c4, t4, i2, e4), { nodes: o2.ast.program.body, globals: c4.globals };
                }, minVersion: () => t3.minVersion, dependencies: c4.dependencies };
              }
              return l[e3];
            }
            function u(e3, t3, r3, n2) {
              return c(e3).build(t3, r3, n2);
            }
            const p2 = Object.keys(i.default).map((e3) => e3.replace(/^_/, "")).filter((e3) => e3 !== "__esModule");
            t2.list = p2;
            var f = u;
            t2.default = f;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.ForAwaitStatement = t2.NumericLiteralTypeAnnotation = t2.ExistentialTypeParam = t2.SpreadProperty = t2.RestProperty = t2.Flow = t2.Pure = t2.Generated = t2.User = t2.Var = t2.BlockScoped = t2.Referenced = t2.Scope = t2.Expression = t2.Statement = t2.BindingIdentifier = t2.ReferencedMemberExpression = t2.ReferencedIdentifier = void 0;
            var n = r2(0);
            const s2 = { types: ["Identifier", "JSXIdentifier"], checkPath(e3, t3) {
              const { node: r3, parent: s3 } = e3;
              if (!n.isIdentifier(r3, t3) && !n.isJSXMemberExpression(s3, t3)) {
                if (!n.isJSXIdentifier(r3, t3))
                  return false;
                if (n.react.isCompatTag(r3.name))
                  return false;
              }
              return n.isReferenced(r3, s3, e3.parentPath.parent);
            } };
            t2.ReferencedIdentifier = s2;
            const i = { types: ["MemberExpression"], checkPath: ({ node: e3, parent: t3 }) => n.isMemberExpression(e3) && n.isReferenced(e3, t3) };
            t2.ReferencedMemberExpression = i;
            const o = { types: ["Identifier"], checkPath(e3) {
              const { node: t3, parent: r3 } = e3, s3 = e3.parentPath.parent;
              return n.isIdentifier(t3) && n.isBinding(t3, r3, s3);
            } };
            t2.BindingIdentifier = o;
            const a = { types: ["Statement"], checkPath({ node: e3, parent: t3 }) {
              if (n.isStatement(e3)) {
                if (n.isVariableDeclaration(e3)) {
                  if (n.isForXStatement(t3, { left: e3 }))
                    return false;
                  if (n.isForStatement(t3, { init: e3 }))
                    return false;
                }
                return true;
              }
              return false;
            } };
            t2.Statement = a;
            const l = { types: ["Expression"], checkPath: (e3) => e3.isIdentifier() ? e3.isReferencedIdentifier() : n.isExpression(e3.node) };
            t2.Expression = l;
            const c = { types: ["Scopable", "Pattern"], checkPath: (e3) => n.isScope(e3.node, e3.parent) };
            t2.Scope = c;
            const u = { checkPath: (e3) => n.isReferenced(e3.node, e3.parent) };
            t2.Referenced = u;
            const p2 = { checkPath: (e3) => n.isBlockScoped(e3.node) };
            t2.BlockScoped = p2;
            const f = { types: ["VariableDeclaration"], checkPath: (e3) => n.isVar(e3.node) };
            t2.Var = f;
            t2.User = { checkPath: (e3) => e3.node && !!e3.node.loc };
            t2.Generated = { checkPath: (e3) => !e3.isUser() };
            t2.Pure = { checkPath: (e3, t3) => e3.scope.isPure(e3.node, t3) };
            const d = { types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"], checkPath: ({ node: e3 }) => !(!n.isFlow(e3) && (n.isImportDeclaration(e3) ? e3.importKind !== "type" && e3.importKind !== "typeof" : n.isExportDeclaration(e3) ? e3.exportKind !== "type" : !n.isImportSpecifier(e3) || e3.importKind !== "type" && e3.importKind !== "typeof")) };
            t2.Flow = d;
            t2.RestProperty = { types: ["RestElement"], checkPath: (e3) => e3.parentPath && e3.parentPath.isObjectPattern() };
            t2.SpreadProperty = { types: ["RestElement"], checkPath: (e3) => e3.parentPath && e3.parentPath.isObjectExpression() }, t2.ExistentialTypeParam = { types: ["ExistsTypeAnnotation"] }, t2.NumericLiteralTypeAnnotation = { types: ["NumberLiteralTypeAnnotation"] };
            t2.ForAwaitStatement = { types: ["ForOfStatement"], checkPath: ({ node: e3 }) => e3.await === true };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = e3.split(".");
              return (e4) => (0, n.default)(e4, r3, t3);
            };
            var n = r2(214);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              if (!(0, n.isMemberExpression)(e3))
                return false;
              const s2 = Array.isArray(t3) ? t3 : t3.split("."), i = [];
              let o;
              for (o = e3; (0, n.isMemberExpression)(o); o = o.object)
                i.push(o.property);
              if (i.push(o), i.length < s2.length)
                return false;
              if (!r3 && i.length > s2.length)
                return false;
              for (let e4 = 0, t4 = i.length - 1; e4 < s2.length; e4++, t4--) {
                const r4 = i[t4];
                let o2;
                if ((0, n.isIdentifier)(r4))
                  o2 = r4.name;
                else if ((0, n.isStringLiteral)(r4))
                  o2 = r4.value;
                else {
                  if (!(0, n.isThisExpression)(r4))
                    return false;
                  o2 = "this";
                }
                if (s2[e4] !== o2)
                  return false;
              }
              return true;
            };
            var n = r2(1);
          }, (e2) => {
            "use strict";
            let t2 = null;
            function r2(e3) {
              if (t2 !== null && (t2.property, 1)) {
                const e4 = t2;
                return t2 = r2.prototype = null, e4;
              }
              return t2 = r2.prototype = e3 == null ? Object.create(null) : e3, new r2();
            }
            r2(), e2.exports = function(e3) {
              return r2(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              if (e3 === t3)
                return true;
              const r3 = n.PLACEHOLDERS_ALIAS[e3];
              if (r3) {
                for (const e4 of r3)
                  if (t3 === e4)
                    return true;
              }
              return false;
            };
            var n = r2(11);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.PLACEHOLDERS_FLIPPED_ALIAS = t2.PLACEHOLDERS_ALIAS = t2.PLACEHOLDERS = void 0;
            var n = r2(20);
            const s2 = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
            t2.PLACEHOLDERS = s2;
            const i = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
            t2.PLACEHOLDERS_ALIAS = i;
            for (const e3 of s2) {
              const t3 = n.ALIAS_KEYS[e3];
              t3 != null && t3.length && (i[e3] = t3);
            }
            const o = {};
            t2.PLACEHOLDERS_FLIPPED_ALIAS = o, Object.keys(i).forEach((e3) => {
              i[e3].forEach((t3) => {
                Object.hasOwnProperty.call(o, t3) || (o[t3] = []), o[t3].push(e3);
              });
            });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return !(!e3 || !n.VISITOR_KEYS[e3.type]);
            };
            var n = r2(11);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3) {
              const r3 = {}, i = {}, o = [], a = [];
              for (let l = 0; l < t3.length; l++) {
                const c = t3[l];
                if (c && !(a.indexOf(c) >= 0)) {
                  if ((0, n.isAnyTypeAnnotation)(c))
                    return [c];
                  if ((0, n.isFlowBaseAnnotation)(c))
                    i[c.type] = c;
                  else if ((0, n.isUnionTypeAnnotation)(c))
                    o.indexOf(c.types) < 0 && (t3 = t3.concat(c.types), o.push(c.types));
                  else if ((0, n.isGenericTypeAnnotation)(c)) {
                    const t4 = s2(c.id);
                    if (r3[t4]) {
                      let n2 = r3[t4];
                      n2.typeParameters ? c.typeParameters && (n2.typeParameters.params = e3(n2.typeParameters.params.concat(c.typeParameters.params))) : n2 = c.typeParameters;
                    } else
                      r3[t4] = c;
                  } else
                    a.push(c);
                }
              }
              for (const e4 of Object.keys(i))
                a.push(i[e4]);
              for (const e4 of Object.keys(r3))
                a.push(r3[e4]);
              return a;
            };
            var n = r2(1);
            function s2(e3) {
              return (0, n.isIdentifier)(e3) ? e3.name : `${e3.id.name}.${s2(e3.qualification)}`;
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
              if (!r2 || !e3)
                return e3;
              const n = `${t3}Comments`;
              return e3[n] ? e3[n] = t3 === "leading" ? r2.concat(e3[n]) : e3[n].concat(r2) : e3[n] = r2, e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              (0, n.default)("innerComments", e3, t3);
            };
            var n = r2(131);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              (0, n.default)("leadingComments", e3, t3);
            };
            var n = r2(131);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              return (0, n.default)(e3, t3), (0, s2.default)(e3, t3), (0, i.default)(e3, t3), e3;
            };
            var n = r2(224), s2 = r2(222), i = r2(221);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              (0, n.default)("trailingComments", e3, t3);
            };
            var n = r2(131);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              if ((0, n.isBlockStatement)(e3))
                return e3;
              let r3 = [];
              return (0, n.isEmptyStatement)(e3) ? r3 = [] : ((0, n.isStatement)(e3) || (e3 = (0, n.isFunction)(t3) ? (0, s2.returnStatement)(e3) : (0, s2.expressionStatement)(e3)), r3 = [e3]), (0, s2.blockStatement)(r3);
            };
            var n = r2(1), s2 = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              e3 += "";
              let t3 = "";
              for (const r3 of e3)
                t3 += (0, s2.isIdentifierChar)(r3.codePointAt(0)) ? r3 : "-";
              return t3 = t3.replace(/^[-0-9]+/, ""), t3 = t3.replace(/[-\s]+(.)?/g, function(e4, t4) {
                return t4 ? t4.toUpperCase() : "";
              }), (0, n.default)(t3) || (t3 = `_${t3}`), t3 || "_";
            };
            var n = r2(38), s2 = r2(63);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              return (0, n.default)(e3, s2.default, t3), e3;
            };
            var n = r2(228), s2 = r2(229);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, s2) {
              if (!t3)
                return;
              const i = n.VISITOR_KEYS[t3.type];
              if (i) {
                r3(t3, s2 = s2 || {});
                for (const n2 of i) {
                  const i2 = t3[n2];
                  if (Array.isArray(i2))
                    for (const t4 of i2)
                      e3(t4, r3, s2);
                  else
                    e3(i2, r3, s2);
                }
              }
            };
            var n = r2(11);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = {}) {
              const r3 = t3.preserveComments ? s2 : i;
              for (const t4 of r3)
                e3[t4] != null && (e3[t4] = void 0);
              for (const t4 of Object.keys(e3))
                t4[0] === "_" && e3[t4] != null && (e3[t4] = void 0);
              const n2 = Object.getOwnPropertySymbols(e3);
              for (const t4 of n2)
                e3[t4] = null;
            };
            var n = r2(25);
            const s2 = ["tokens", "start", "end", "loc", "raw", "rawValue"], i = n.COMMENT_KEYS.concat(["comments"]).concat(s2);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.isVariableDeclaration)(e3) && (e3.kind !== "var" || e3[s2.BLOCK_SCOPED_SYMBOL]);
            };
            var n = r2(1), s2 = r2(25);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(413), s2 = r2(10), i = r2(232), o = r2(414), a = r2(0), l = r2(34);
            function c(e3, t3) {
              switch (e3 == null ? void 0 : e3.type) {
                default:
                  if (a.isModuleDeclaration(e3))
                    if ((a.isExportAllDeclaration(e3) || a.isExportNamedDeclaration(e3) || a.isImportDeclaration(e3)) && e3.source)
                      c(e3.source, t3);
                    else if ((a.isExportNamedDeclaration(e3) || a.isImportDeclaration(e3)) && e3.specifiers && e3.specifiers.length)
                      for (const r3 of e3.specifiers)
                        c(r3, t3);
                    else
                      (a.isExportDefaultDeclaration(e3) || a.isExportNamedDeclaration(e3)) && e3.declaration && c(e3.declaration, t3);
                  else
                    a.isModuleSpecifier(e3) ? c(e3.local, t3) : a.isLiteral(e3) && t3.push(e3.value);
                  break;
                case "MemberExpression":
                case "OptionalMemberExpression":
                case "JSXMemberExpression":
                  c(e3.object, t3), c(e3.property, t3);
                  break;
                case "Identifier":
                case "JSXIdentifier":
                  t3.push(e3.name);
                  break;
                case "CallExpression":
                case "OptionalCallExpression":
                case "NewExpression":
                  c(e3.callee, t3);
                  break;
                case "ObjectExpression":
                case "ObjectPattern":
                  for (const r3 of e3.properties)
                    c(r3, t3);
                  break;
                case "SpreadElement":
                case "RestElement":
                  c(e3.argument, t3);
                  break;
                case "ObjectProperty":
                case "ObjectMethod":
                case "ClassProperty":
                case "ClassMethod":
                case "ClassPrivateProperty":
                case "ClassPrivateMethod":
                  c(e3.key, t3);
                  break;
                case "ThisExpression":
                  t3.push("this");
                  break;
                case "Super":
                  t3.push("super");
                  break;
                case "Import":
                  t3.push("import");
                  break;
                case "DoExpression":
                  t3.push("do");
                  break;
                case "YieldExpression":
                  t3.push("yield"), c(e3.argument, t3);
                  break;
                case "AwaitExpression":
                  t3.push("await"), c(e3.argument, t3);
                  break;
                case "AssignmentExpression":
                  c(e3.left, t3);
                  break;
                case "VariableDeclarator":
                  c(e3.id, t3);
                  break;
                case "FunctionExpression":
                case "FunctionDeclaration":
                case "ClassExpression":
                case "ClassDeclaration":
                case "PrivateName":
                  c(e3.id, t3);
                  break;
                case "ParenthesizedExpression":
                  c(e3.expression, t3);
                  break;
                case "UnaryExpression":
                case "UpdateExpression":
                  c(e3.argument, t3);
                  break;
                case "MetaProperty":
                  c(e3.meta, t3), c(e3.property, t3);
                  break;
                case "JSXElement":
                  c(e3.openingElement, t3);
                  break;
                case "JSXOpeningElement":
                  t3.push(e3.name);
                  break;
                case "JSXFragment":
                  c(e3.openingFragment, t3);
                  break;
                case "JSXOpeningFragment":
                  t3.push("Fragment");
                  break;
                case "JSXNamespacedName":
                  c(e3.namespace, t3), c(e3.name, t3);
              }
            }
            const u = { For(e3) {
              for (const t3 of a.FOR_INIT_KEYS) {
                const r3 = e3.get(t3);
                r3.isVar() && (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerBinding("var", r3);
              }
            }, Declaration(e3) {
              e3.isBlockScoped() || e3.isExportDeclaration() || (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).registerDeclaration(e3);
            }, ReferencedIdentifier(e3, t3) {
              t3.references.push(e3);
            }, ForXStatement(e3, t3) {
              const r3 = e3.get("left");
              (r3.isPattern() || r3.isIdentifier()) && t3.constantViolations.push(e3);
            }, ExportDeclaration: { exit(e3) {
              const { node: t3, scope: r3 } = e3;
              if (a.isExportAllDeclaration(t3))
                return;
              const n2 = t3.declaration;
              if (a.isClassDeclaration(n2) || a.isFunctionDeclaration(n2)) {
                const t4 = n2.id;
                if (!t4)
                  return;
                const s3 = r3.getBinding(t4.name);
                s3 && s3.reference(e3);
              } else if (a.isVariableDeclaration(n2))
                for (const t4 of n2.declarations)
                  for (const n3 of Object.keys(a.getBindingIdentifiers(t4))) {
                    const t5 = r3.getBinding(n3);
                    t5 && t5.reference(e3);
                  }
            } }, LabeledStatement(e3) {
              e3.scope.getBlockParent().registerDeclaration(e3);
            }, AssignmentExpression(e3, t3) {
              t3.assignments.push(e3);
            }, UpdateExpression(e3, t3) {
              t3.constantViolations.push(e3);
            }, UnaryExpression(e3, t3) {
              e3.node.operator === "delete" && t3.constantViolations.push(e3);
            }, BlockScoped(e3) {
              let t3 = e3.scope;
              if (t3.path === e3 && (t3 = t3.parent), t3.getBlockParent().registerDeclaration(e3), e3.isClassDeclaration() && e3.node.id) {
                const t4 = e3.node.id.name;
                e3.scope.bindings[t4] = e3.scope.parent.getBinding(t4);
              }
            }, CatchClause(e3) {
              e3.scope.registerBinding("let", e3);
            }, Function(e3) {
              e3.isFunctionExpression() && e3.has("id") && !e3.get("id").node[a.NOT_LOCAL_BINDING] && e3.scope.registerBinding("local", e3.get("id"), e3);
              const t3 = e3.get("params");
              for (const r3 of t3)
                e3.scope.registerBinding("param", r3);
            }, ClassExpression(e3) {
              e3.has("id") && !e3.get("id").node[a.NOT_LOCAL_BINDING] && e3.scope.registerBinding("local", e3);
            } };
            let p2 = 0;
            class f {
              constructor(e3) {
                this.uid = void 0, this.path = void 0, this.block = void 0, this.labels = void 0, this.inited = void 0, this.bindings = void 0, this.references = void 0, this.globals = void 0, this.uids = void 0, this.data = void 0, this.crawling = void 0;
                const { node: t3 } = e3, r3 = l.scope.get(t3);
                if ((r3 == null ? void 0 : r3.path) === e3)
                  return r3;
                l.scope.set(t3, this), this.uid = p2++, this.block = t3, this.path = e3, this.labels = new Map(), this.inited = false;
              }
              get parent() {
                var e3;
                let t3, r3 = this.path;
                do {
                  const e4 = r3.key === "key";
                  r3 = r3.parentPath, e4 && r3.isMethod() && (r3 = r3.parentPath), r3 && r3.isScope() && (t3 = r3);
                } while (r3 && !t3);
                return (e3 = t3) == null ? void 0 : e3.scope;
              }
              get parentBlock() {
                return this.path.parent;
              }
              get hub() {
                return this.path.hub;
              }
              traverse(e3, t3, r3) {
                (0, s2.default)(e3, t3, this, r3, this.path);
              }
              generateDeclaredUidIdentifier(e3) {
                const t3 = this.generateUidIdentifier(e3);
                return this.push({ id: t3 }), a.cloneNode(t3);
              }
              generateUidIdentifier(e3) {
                return a.identifier(this.generateUid(e3));
              }
              generateUid(e3 = "temp") {
                let t3;
                e3 = a.toIdentifier(e3).replace(/^_+/, "").replace(/[0-9]+$/g, "");
                let r3 = 1;
                do {
                  t3 = this._generateUid(e3, r3), r3++;
                } while (this.hasLabel(t3) || this.hasBinding(t3) || this.hasGlobal(t3) || this.hasReference(t3));
                const n2 = this.getProgramParent();
                return n2.references[t3] = true, n2.uids[t3] = true, t3;
              }
              _generateUid(e3, t3) {
                let r3 = e3;
                return t3 > 1 && (r3 += t3), `_${r3}`;
              }
              generateUidBasedOnNode(e3, t3) {
                const r3 = [];
                c(e3, r3);
                let n2 = r3.join("$");
                return n2 = n2.replace(/^_/, "") || t3 || "ref", this.generateUid(n2.slice(0, 20));
              }
              generateUidIdentifierBasedOnNode(e3, t3) {
                return a.identifier(this.generateUidBasedOnNode(e3, t3));
              }
              isStatic(e3) {
                if (a.isThisExpression(e3) || a.isSuper(e3))
                  return true;
                if (a.isIdentifier(e3)) {
                  const t3 = this.getBinding(e3.name);
                  return t3 ? t3.constant : this.hasBinding(e3.name);
                }
                return false;
              }
              maybeGenerateMemoised(e3, t3) {
                if (this.isStatic(e3))
                  return null;
                {
                  const r3 = this.generateUidIdentifierBasedOnNode(e3);
                  return t3 ? r3 : (this.push({ id: r3 }), a.cloneNode(r3));
                }
              }
              checkBlockScopedCollisions(e3, t3, r3, n2) {
                if (t3 !== "param" && e3.kind !== "local" && (t3 === "let" || e3.kind === "let" || e3.kind === "const" || e3.kind === "module" || e3.kind === "param" && (t3 === "let" || t3 === "const")))
                  throw this.hub.buildError(n2, `Duplicate declaration "${r3}"`, TypeError);
              }
              rename(e3, t3, r3) {
                const s3 = this.getBinding(e3);
                if (s3)
                  return t3 = t3 || this.generateUidIdentifier(e3).name, new n.default(s3, e3, t3).rename(r3);
              }
              _renameFromMap(e3, t3, r3, n2) {
                e3[t3] && (e3[r3] = n2, e3[t3] = null);
              }
              dump() {
                "-".repeat(60);
                let e3 = this;
                do {
                  for (const t3 of Object.keys(e3.bindings))
                    e3.bindings[t3];
                } while (e3 = e3.parent);
              }
              toArray(e3, t3, r3) {
                if (a.isIdentifier(e3)) {
                  const t4 = this.getBinding(e3.name);
                  if (t4 != null && t4.constant && t4.path.isGenericType("Array"))
                    return e3;
                }
                if (a.isArrayExpression(e3))
                  return e3;
                if (a.isIdentifier(e3, { name: "arguments" }))
                  return a.callExpression(a.memberExpression(a.memberExpression(a.memberExpression(a.identifier("Array"), a.identifier("prototype")), a.identifier("slice")), a.identifier("call")), [e3]);
                let n2;
                const s3 = [e3];
                return t3 === true ? n2 = "toConsumableArray" : t3 ? (s3.push(a.numericLiteral(t3)), n2 = "slicedToArray") : n2 = "toArray", r3 && (s3.unshift(this.hub.addHelper(n2)), n2 = "maybeArrayLike"), a.callExpression(this.hub.addHelper(n2), s3);
              }
              hasLabel(e3) {
                return !!this.getLabel(e3);
              }
              getLabel(e3) {
                return this.labels.get(e3);
              }
              registerLabel(e3) {
                this.labels.set(e3.node.label.name, e3);
              }
              registerDeclaration(e3) {
                if (e3.isLabeledStatement())
                  this.registerLabel(e3);
                else if (e3.isFunctionDeclaration())
                  this.registerBinding("hoisted", e3.get("id"), e3);
                else if (e3.isVariableDeclaration()) {
                  const t3 = e3.get("declarations");
                  for (const r3 of t3)
                    this.registerBinding(e3.node.kind, r3);
                } else if (e3.isClassDeclaration())
                  this.registerBinding("let", e3);
                else if (e3.isImportDeclaration()) {
                  const t3 = e3.get("specifiers");
                  for (const e4 of t3)
                    this.registerBinding("module", e4);
                } else if (e3.isExportDeclaration()) {
                  const t3 = e3.get("declaration");
                  (t3.isClassDeclaration() || t3.isFunctionDeclaration() || t3.isVariableDeclaration()) && this.registerDeclaration(t3);
                } else
                  this.registerBinding("unknown", e3);
              }
              buildUndefinedNode() {
                return a.unaryExpression("void", a.numericLiteral(0), true);
              }
              registerConstantViolation(e3) {
                const t3 = e3.getBindingIdentifiers();
                for (const r3 of Object.keys(t3)) {
                  const t4 = this.getBinding(r3);
                  t4 && t4.reassign(e3);
                }
              }
              registerBinding(e3, t3, r3 = t3) {
                if (!e3)
                  throw new ReferenceError("no `kind`");
                if (t3.isVariableDeclaration()) {
                  const r4 = t3.get("declarations");
                  for (const t4 of r4)
                    this.registerBinding(e3, t4);
                  return;
                }
                const n2 = this.getProgramParent(), s3 = t3.getOuterBindingIdentifiers(true);
                for (const t4 of Object.keys(s3)) {
                  n2.references[t4] = true;
                  for (const n3 of s3[t4]) {
                    const s4 = this.getOwnBinding(t4);
                    if (s4) {
                      if (s4.identifier === n3)
                        continue;
                      this.checkBlockScopedCollisions(s4, e3, t4, n3);
                    }
                    s4 ? this.registerConstantViolation(r3) : this.bindings[t4] = new i.default({ identifier: n3, scope: this, path: r3, kind: e3 });
                  }
                }
              }
              addGlobal(e3) {
                this.globals[e3.name] = e3;
              }
              hasUid(e3) {
                let t3 = this;
                do {
                  if (t3.uids[e3])
                    return true;
                } while (t3 = t3.parent);
                return false;
              }
              hasGlobal(e3) {
                let t3 = this;
                do {
                  if (t3.globals[e3])
                    return true;
                } while (t3 = t3.parent);
                return false;
              }
              hasReference(e3) {
                return !!this.getProgramParent().references[e3];
              }
              isPure(e3, t3) {
                if (a.isIdentifier(e3)) {
                  const r3 = this.getBinding(e3.name);
                  return !!r3 && (!t3 || r3.constant);
                }
                if (a.isClass(e3))
                  return !(e3.superClass && !this.isPure(e3.superClass, t3)) && this.isPure(e3.body, t3);
                if (a.isClassBody(e3)) {
                  for (const r3 of e3.body)
                    if (!this.isPure(r3, t3))
                      return false;
                  return true;
                }
                if (a.isBinary(e3))
                  return this.isPure(e3.left, t3) && this.isPure(e3.right, t3);
                if (a.isArrayExpression(e3)) {
                  for (const r3 of e3.elements)
                    if (!this.isPure(r3, t3))
                      return false;
                  return true;
                }
                if (a.isObjectExpression(e3)) {
                  for (const r3 of e3.properties)
                    if (!this.isPure(r3, t3))
                      return false;
                  return true;
                }
                if (a.isMethod(e3))
                  return !(e3.computed && !this.isPure(e3.key, t3)) && e3.kind !== "get" && e3.kind !== "set";
                if (a.isProperty(e3))
                  return !(e3.computed && !this.isPure(e3.key, t3)) && this.isPure(e3.value, t3);
                if (a.isUnaryExpression(e3))
                  return this.isPure(e3.argument, t3);
                if (a.isTaggedTemplateExpression(e3))
                  return a.matchesPattern(e3.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(e3.quasi, t3);
                if (a.isTemplateLiteral(e3)) {
                  for (const r3 of e3.expressions)
                    if (!this.isPure(r3, t3))
                      return false;
                  return true;
                }
                return a.isPureish(e3);
              }
              setData(e3, t3) {
                return this.data[e3] = t3;
              }
              getData(e3) {
                let t3 = this;
                do {
                  const r3 = t3.data[e3];
                  if (r3 != null)
                    return r3;
                } while (t3 = t3.parent);
              }
              removeData(e3) {
                let t3 = this;
                do {
                  t3.data[e3] != null && (t3.data[e3] = null);
                } while (t3 = t3.parent);
              }
              init() {
                this.inited || (this.inited = true, this.crawl());
              }
              crawl() {
                const e3 = this.path;
                this.references = Object.create(null), this.bindings = Object.create(null), this.globals = Object.create(null), this.uids = Object.create(null), this.data = Object.create(null);
                const t3 = this.getProgramParent();
                if (t3.crawling)
                  return;
                const r3 = { references: [], constantViolations: [], assignments: [] };
                if (this.crawling = true, e3.type !== "Program" && u._exploded) {
                  for (const t5 of u.enter)
                    t5(e3, r3);
                  const t4 = u[e3.type];
                  if (t4)
                    for (const n2 of t4.enter)
                      n2(e3, r3);
                }
                e3.traverse(u, r3), this.crawling = false;
                for (const e4 of r3.assignments) {
                  const r4 = e4.getBindingIdentifiers();
                  for (const n2 of Object.keys(r4))
                    e4.scope.getBinding(n2) || t3.addGlobal(r4[n2]);
                  e4.scope.registerConstantViolation(e4);
                }
                for (const e4 of r3.references) {
                  const r4 = e4.scope.getBinding(e4.node.name);
                  r4 ? r4.reference(e4) : t3.addGlobal(e4.node);
                }
                for (const e4 of r3.constantViolations)
                  e4.scope.registerConstantViolation(e4);
              }
              push(e3) {
                let t3 = this.path;
                t3.isBlockStatement() || t3.isProgram() || (t3 = this.getBlockParent().path), t3.isSwitchStatement() && (t3 = (this.getFunctionParent() || this.getProgramParent()).path), (t3.isLoop() || t3.isCatchClause() || t3.isFunction()) && (t3.ensureBlock(), t3 = t3.get("body"));
                const r3 = e3.unique, n2 = e3.kind || "var", s3 = e3._blockHoist == null ? 2 : e3._blockHoist, i2 = `declaration:${n2}:${s3}`;
                let o2 = !r3 && t3.getData(i2);
                if (!o2) {
                  const e4 = a.variableDeclaration(n2, []);
                  e4._blockHoist = s3, [o2] = t3.unshiftContainer("body", [e4]), r3 || t3.setData(i2, o2);
                }
                const l2 = a.variableDeclarator(e3.id, e3.init);
                o2.node.declarations.push(l2), this.registerBinding(n2, o2.get("declarations").pop());
              }
              getProgramParent() {
                let e3 = this;
                do {
                  if (e3.path.isProgram())
                    return e3;
                } while (e3 = e3.parent);
                throw new Error("Couldn't find a Program");
              }
              getFunctionParent() {
                let e3 = this;
                do {
                  if (e3.path.isFunctionParent())
                    return e3;
                } while (e3 = e3.parent);
                return null;
              }
              getBlockParent() {
                let e3 = this;
                do {
                  if (e3.path.isBlockParent())
                    return e3;
                } while (e3 = e3.parent);
                throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
              }
              getAllBindings() {
                const e3 = Object.create(null);
                let t3 = this;
                do {
                  for (const r3 of Object.keys(t3.bindings))
                    r3 in e3 == 0 && (e3[r3] = t3.bindings[r3]);
                  t3 = t3.parent;
                } while (t3);
                return e3;
              }
              getAllBindingsOfKind(...e3) {
                const t3 = Object.create(null);
                for (const r3 of e3) {
                  let e4 = this;
                  do {
                    for (const n2 of Object.keys(e4.bindings)) {
                      const s3 = e4.bindings[n2];
                      s3.kind === r3 && (t3[n2] = s3);
                    }
                    e4 = e4.parent;
                  } while (e4);
                }
                return t3;
              }
              bindingIdentifierEquals(e3, t3) {
                return this.getBindingIdentifier(e3) === t3;
              }
              getBinding(e3) {
                let t3, r3 = this;
                do {
                  const s3 = r3.getOwnBinding(e3);
                  var n2;
                  if (s3 && ((n2 = t3) == null || !n2.isPattern() || s3.kind === "param"))
                    return s3;
                  t3 = r3.path;
                } while (r3 = r3.parent);
              }
              getOwnBinding(e3) {
                return this.bindings[e3];
              }
              getBindingIdentifier(e3) {
                var t3;
                return (t3 = this.getBinding(e3)) == null ? void 0 : t3.identifier;
              }
              getOwnBindingIdentifier(e3) {
                const t3 = this.bindings[e3];
                return t3 == null ? void 0 : t3.identifier;
              }
              hasOwnBinding(e3) {
                return !!this.getOwnBinding(e3);
              }
              hasBinding(e3, t3) {
                return !(!e3 || !this.hasOwnBinding(e3) && !this.parentHasBinding(e3, t3) && !this.hasUid(e3) && (t3 || !f.globals.includes(e3)) && (t3 || !f.contextVariables.includes(e3)));
              }
              parentHasBinding(e3, t3) {
                var r3;
                return (r3 = this.parent) == null ? void 0 : r3.hasBinding(e3, t3);
              }
              moveBindingTo(e3, t3) {
                const r3 = this.getBinding(e3);
                r3 && (r3.scope.removeOwnBinding(e3), r3.scope = t3, t3.bindings[e3] = r3);
              }
              removeOwnBinding(e3) {
                delete this.bindings[e3];
              }
              removeBinding(e3) {
                var t3;
                (t3 = this.getBinding(e3)) == null || t3.scope.removeOwnBinding(e3);
                let r3 = this;
                do {
                  r3.uids[e3] && (r3.uids[e3] = false);
                } while (r3 = r3.parent);
              }
            }
            t2.default = f, f.globals = Object.keys(o.builtin), f.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
              constructor({ identifier: e3, scope: t3, path: r2, kind: n }) {
                this.identifier = void 0, this.scope = void 0, this.path = void 0, this.kind = void 0, this.constantViolations = [], this.constant = true, this.referencePaths = [], this.referenced = false, this.references = 0, this.identifier = e3, this.scope = t3, this.path = r2, this.kind = n, this.clearValue();
              }
              deoptValue() {
                this.clearValue(), this.hasDeoptedValue = true;
              }
              setValue(e3) {
                this.hasDeoptedValue || (this.hasValue = true, this.value = e3);
              }
              clearValue() {
                this.hasDeoptedValue = false, this.hasValue = false, this.value = null;
              }
              reassign(e3) {
                this.constant = false, this.constantViolations.indexOf(e3) === -1 && this.constantViolations.push(e3);
              }
              reference(e3) {
                this.referencePaths.indexOf(e3) === -1 && (this.referenced = true, this.references++, this.referencePaths.push(e3));
              }
              dereference() {
                this.references--, this.referenced = !!this.references;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.needsWhitespace = f, t2.needsWhitespaceBefore = function(e3, t3) {
              return f(e3, t3, "before");
            }, t2.needsWhitespaceAfter = function(e3, t3) {
              return f(e3, t3, "after");
            }, t2.needsParens = function(e3, t3, r3) {
              return !!t3 && (!(!i.isNewExpression(t3) || t3.callee !== e3 || !p2(e3)) || u(a, e3, t3, r3));
            };
            var n = r2(420), s2 = r2(421), i = r2(0);
            function o(e3) {
              const t3 = {};
              function r3(e4, r4) {
                const n2 = t3[e4];
                t3[e4] = n2 ? function(e5, t4, s3) {
                  const i2 = n2(e5, t4, s3);
                  return i2 == null ? r4(e5, t4, s3) : i2;
                } : r4;
              }
              for (const t4 of Object.keys(e3)) {
                const n2 = i.FLIPPED_ALIAS_KEYS[t4];
                if (n2)
                  for (const s3 of n2)
                    r3(s3, e3[t4]);
                else
                  r3(t4, e3[t4]);
              }
              return t3;
            }
            const a = o(s2), l = o(n.nodes), c = o(n.list);
            function u(e3, t3, r3, n2) {
              const s3 = e3[t3.type];
              return s3 ? s3(t3, r3, n2) : null;
            }
            function p2(e3) {
              return !!i.isCallExpression(e3) || i.isMemberExpression(e3) && p2(e3.object);
            }
            function f(e3, t3, r3) {
              if (!e3)
                return 0;
              i.isExpressionStatement(e3) && (e3 = e3.expression);
              let n2 = u(l, e3, t3);
              if (!n2) {
                const s3 = u(c, e3, t3);
                if (s3)
                  for (let t4 = 0; t4 < s3.length && (n2 = f(s3[t4], e3, r3), !n2); t4++)
                    ;
              }
              return typeof n2 == "object" && n2 !== null && n2[r3] || 0;
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.ImportSpecifier = function(e3) {
              e3.importKind !== "type" && e3.importKind !== "typeof" || (this.word(e3.importKind), this.space()), this.print(e3.imported, e3), e3.local && e3.local.name !== e3.imported.name && (this.space(), this.word("as"), this.space(), this.print(e3.local, e3));
            }, t2.ImportDefaultSpecifier = function(e3) {
              this.print(e3.local, e3);
            }, t2.ExportDefaultSpecifier = function(e3) {
              this.print(e3.exported, e3);
            }, t2.ExportSpecifier = function(e3) {
              this.print(e3.local, e3), e3.exported && e3.local.name !== e3.exported.name && (this.space(), this.word("as"), this.space(), this.print(e3.exported, e3));
            }, t2.ExportNamespaceSpecifier = function(e3) {
              this.token("*"), this.space(), this.word("as"), this.space(), this.print(e3.exported, e3);
            }, t2.ExportAllDeclaration = function(e3) {
              this.word("export"), this.space(), e3.exportKind === "type" && (this.word("type"), this.space()), this.token("*"), this.space(), this.word("from"), this.space(), this.print(e3.source, e3), this.printAssertions(e3), this.semicolon();
            }, t2.ExportNamedDeclaration = function(e3) {
              this.format.decoratorsBeforeExport && n.isClassDeclaration(e3.declaration) && this.printJoin(e3.declaration.decorators, e3), this.word("export"), this.space(), s2.apply(this, arguments);
            }, t2.ExportDefaultDeclaration = function(e3) {
              this.format.decoratorsBeforeExport && n.isClassDeclaration(e3.declaration) && this.printJoin(e3.declaration.decorators, e3), this.word("export"), this.space(), this.word("default"), this.space(), s2.apply(this, arguments);
            }, t2.ImportDeclaration = function(e3) {
              this.word("import"), this.space(), (e3.importKind === "type" || e3.importKind === "typeof") && (this.word(e3.importKind), this.space());
              const t3 = e3.specifiers.slice(0);
              if (t3 != null && t3.length) {
                for (; ; ) {
                  const r4 = t3[0];
                  if (!n.isImportDefaultSpecifier(r4) && !n.isImportNamespaceSpecifier(r4))
                    break;
                  this.print(t3.shift(), e3), t3.length && (this.token(","), this.space());
                }
                t3.length && (this.token("{"), this.space(), this.printList(t3, e3), this.space(), this.token("}")), this.space(), this.word("from"), this.space();
              }
              var r3;
              this.print(e3.source, e3), this.printAssertions(e3), (r3 = e3.attributes) != null && r3.length && (this.space(), this.word("with"), this.space(), this.printList(e3.attributes, e3)), this.semicolon();
            }, t2.ImportAttribute = function(e3) {
              this.print(e3.key), this.token(":"), this.space(), this.print(e3.value);
            }, t2.ImportNamespaceSpecifier = function(e3) {
              this.token("*"), this.space(), this.word("as"), this.space(), this.print(e3.local, e3);
            };
            var n = r2(0);
            function s2(e3) {
              if (e3.declaration) {
                const t3 = e3.declaration;
                this.print(t3, e3), n.isStatement(t3) || this.semicolon();
              } else {
                e3.exportKind === "type" && (this.word("type"), this.space());
                const t3 = e3.specifiers.slice(0);
                let r3 = false;
                for (; ; ) {
                  const s3 = t3[0];
                  if (!n.isExportDefaultSpecifier(s3) && !n.isExportNamespaceSpecifier(s3))
                    break;
                  r3 = true, this.print(t3.shift(), e3), t3.length && (this.token(","), this.space());
                }
                (t3.length || !t3.length && !r3) && (this.token("{"), t3.length && (this.space(), this.printList(t3, e3), this.space()), this.token("}")), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source, e3), this.printAssertions(e3)), this.semicolon();
              }
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.Identifier = function(e3) {
              this.exactSource(e3.loc, () => {
                this.word(e3.name);
              });
            }, t2.ArgumentPlaceholder = function() {
              this.token("?");
            }, t2.SpreadElement = t2.RestElement = function(e3) {
              this.token("..."), this.print(e3.argument, e3);
            }, t2.ObjectPattern = t2.ObjectExpression = function(e3) {
              const t3 = e3.properties;
              this.token("{"), this.printInnerComments(e3), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.token("}");
            }, t2.ObjectMethod = function(e3) {
              this.printJoin(e3.decorators, e3), this._methodHead(e3), this.space(), this.print(e3.body, e3);
            }, t2.ObjectProperty = function(e3) {
              if (this.printJoin(e3.decorators, e3), e3.computed)
                this.token("["), this.print(e3.key, e3), this.token("]");
              else {
                if (n.isAssignmentPattern(e3.value) && n.isIdentifier(e3.key) && e3.key.name === e3.value.left.name)
                  return void this.print(e3.value, e3);
                if (this.print(e3.key, e3), e3.shorthand && n.isIdentifier(e3.key) && n.isIdentifier(e3.value) && e3.key.name === e3.value.name)
                  return;
              }
              this.token(":"), this.space(), this.print(e3.value, e3);
            }, t2.ArrayPattern = t2.ArrayExpression = function(e3) {
              const t3 = e3.elements, r3 = t3.length;
              this.token("["), this.printInnerComments(e3);
              for (let n2 = 0; n2 < t3.length; n2++) {
                const s3 = t3[n2];
                s3 ? (n2 > 0 && this.space(), this.print(s3, e3), n2 < r3 - 1 && this.token(",")) : this.token(",");
              }
              this.token("]");
            }, t2.RecordExpression = function(e3) {
              const t3 = e3.properties;
              let r3, n2;
              if (this.format.recordAndTupleSyntaxType === "bar")
                r3 = "{|", n2 = "|}";
              else {
                if (this.format.recordAndTupleSyntaxType !== "hash")
                  throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
                r3 = "#{", n2 = "}";
              }
              this.token(r3), this.printInnerComments(e3), t3.length && (this.space(), this.printList(t3, e3, { indent: true, statement: true }), this.space()), this.token(n2);
            }, t2.TupleExpression = function(e3) {
              const t3 = e3.elements, r3 = t3.length;
              let n2, s3;
              if (this.format.recordAndTupleSyntaxType === "bar")
                n2 = "[|", s3 = "|]";
              else {
                if (this.format.recordAndTupleSyntaxType !== "hash")
                  throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
                n2 = "#[", s3 = "]";
              }
              this.token(n2), this.printInnerComments(e3);
              for (let n3 = 0; n3 < t3.length; n3++) {
                const s4 = t3[n3];
                s4 && (n3 > 0 && this.space(), this.print(s4, e3), n3 < r3 - 1 && this.token(","));
              }
              this.token(s3);
            }, t2.RegExpLiteral = function(e3) {
              this.word(`/${e3.pattern}/${e3.flags}`);
            }, t2.BooleanLiteral = function(e3) {
              this.word(e3.value ? "true" : "false");
            }, t2.NullLiteral = function() {
              this.word("null");
            }, t2.NumericLiteral = function(e3) {
              const t3 = this.getPossibleRaw(e3), r3 = this.format.jsescOption, n2 = e3.value + "";
              r3.numbers ? this.number(s2(e3.value, r3)) : t3 == null ? this.number(n2) : this.format.minified ? this.number(t3.length < n2.length ? t3 : n2) : this.number(t3);
            }, t2.StringLiteral = function(e3) {
              const t3 = this.getPossibleRaw(e3);
              if (!this.format.minified && t3 != null)
                return void this.token(t3);
              const r3 = s2(e3.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && { json: true }));
              return this.token(r3);
            }, t2.BigIntLiteral = function(e3) {
              const t3 = this.getPossibleRaw(e3);
              this.format.minified || t3 == null ? this.word(e3.value + "n") : this.word(t3);
            }, t2.DecimalLiteral = function(e3) {
              const t3 = this.getPossibleRaw(e3);
              this.format.minified || t3 == null ? this.word(e3.value + "m") : this.word(t3);
            }, t2.PipelineTopicExpression = function(e3) {
              this.print(e3.expression, e3);
            }, t2.PipelineBareFunction = function(e3) {
              this.print(e3.callee, e3);
            }, t2.PipelinePrimaryTopicReference = function() {
              this.token("#");
            };
            var n = r2(0), s2 = r2(236);
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(37).Buffer;
            const s2 = {}, i = s2.hasOwnProperty, o = (e3, t3) => {
              for (const r3 in e3)
                i.call(e3, r3) && t3(r3, e3[r3]);
            }, a = s2.toString, l = Array.isArray, c = n.isBuffer, u = { '"': '\\"', "'": "\\'", "\\": "\\\\", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t" }, p2 = /["'\\\b\f\n\r\t]/, f = /[0-9]/, d = /[ !#-&\(-\[\]-_a-~]/, h3 = (e3, t3) => {
              const r3 = () => {
                E = v, ++t3.indentLevel, v = t3.indent.repeat(t3.indentLevel);
              }, n2 = { escapeEverything: false, minimal: false, isScriptContext: false, quotes: "single", wrap: false, es6: false, json: false, compact: true, lowercaseHex: false, numbers: "decimal", indent: "	", indentLevel: 0, __inline1__: false, __inline2__: false }, s3 = t3 && t3.json;
              var i2, m;
              s3 && (n2.quotes = "double", n2.wrap = true), i2 = n2, (t3 = (m = t3) ? (o(m, (e4, t4) => {
                i2[e4] = t4;
              }), i2) : i2).quotes != "single" && t3.quotes != "double" && t3.quotes != "backtick" && (t3.quotes = "single");
              const y = t3.quotes == "double" ? '"' : t3.quotes == "backtick" ? "`" : "'", g = t3.compact, b = t3.lowercaseHex;
              let v = t3.indent.repeat(t3.indentLevel), E = "";
              const x = t3.__inline1__, S = t3.__inline2__, T = g ? "" : "\n";
              let w, P = true;
              const A = t3.numbers == "binary", O = t3.numbers == "octal", C = t3.numbers == "decimal", I = t3.numbers == "hexadecimal";
              if (s3 && e3 && typeof e3.toJSON == "function" && (e3 = e3.toJSON()), typeof (k2 = e3) != "string" && a.call(k2) != "[object String]") {
                if (((e4) => a.call(e4) == "[object Map]")(e3))
                  return e3.size == 0 ? "new Map()" : (g || (t3.__inline1__ = true, t3.__inline2__ = false), "new Map(" + h3(Array.from(e3), t3) + ")");
                if (((e4) => a.call(e4) == "[object Set]")(e3))
                  return e3.size == 0 ? "new Set()" : "new Set(" + h3(Array.from(e3), t3) + ")";
                if (c(e3))
                  return e3.length == 0 ? "Buffer.from([])" : "Buffer.from(" + h3(Array.from(e3), t3) + ")";
                if (l(e3))
                  return w = [], t3.wrap = true, x && (t3.__inline1__ = false, t3.__inline2__ = true), S || r3(), ((e4, t4) => {
                    const r4 = e4.length;
                    let n3 = -1;
                    for (; ++n3 < r4; )
                      t4(e4[n3]);
                  })(e3, (e4) => {
                    P = false, S && (t3.__inline2__ = false), w.push((g || S ? "" : v) + h3(e4, t3));
                  }), P ? "[]" : S ? "[" + w.join(", ") + "]" : "[" + T + w.join("," + T) + T + (g ? "" : E) + "]";
                if (!((e4) => typeof e4 == "number" || a.call(e4) == "[object Number]")(e3))
                  return ((e4) => a.call(e4) == "[object Object]")(e3) ? (w = [], t3.wrap = true, r3(), o(e3, (e4, r4) => {
                    P = false, w.push((g ? "" : v) + h3(e4, t3) + ":" + (g ? "" : " ") + h3(r4, t3));
                  }), P ? "{}" : "{" + T + w.join("," + T) + T + (g ? "" : E) + "}") : s3 ? JSON.stringify(e3) || "null" : String(e3);
                if (s3)
                  return JSON.stringify(e3);
                if (C)
                  return String(e3);
                if (I) {
                  let t4 = e3.toString(16);
                  return b || (t4 = t4.toUpperCase()), "0x" + t4;
                }
                if (A)
                  return "0b" + e3.toString(2);
                if (O)
                  return "0o" + e3.toString(8);
              }
              var k2;
              const N = e3;
              let _ = -1;
              const j = N.length;
              for (w = ""; ++_ < j; ) {
                const e4 = N.charAt(_);
                if (t3.es6) {
                  const e5 = N.charCodeAt(_);
                  if (e5 >= 55296 && e5 <= 56319 && j > _ + 1) {
                    const t4 = N.charCodeAt(_ + 1);
                    if (t4 >= 56320 && t4 <= 57343) {
                      let r5 = (1024 * (e5 - 55296) + t4 - 56320 + 65536).toString(16);
                      b || (r5 = r5.toUpperCase()), w += "\\u{" + r5 + "}", ++_;
                      continue;
                    }
                  }
                }
                if (!t3.escapeEverything) {
                  if (d.test(e4)) {
                    w += e4;
                    continue;
                  }
                  if (e4 == '"') {
                    w += y == e4 ? '\\"' : e4;
                    continue;
                  }
                  if (e4 == "`") {
                    w += y == e4 ? "\\`" : e4;
                    continue;
                  }
                  if (e4 == "'") {
                    w += y == e4 ? "\\'" : e4;
                    continue;
                  }
                }
                if (e4 == "\0" && !s3 && !f.test(N.charAt(_ + 1))) {
                  w += "\\0";
                  continue;
                }
                if (p2.test(e4)) {
                  w += u[e4];
                  continue;
                }
                const r4 = e4.charCodeAt(0);
                if (t3.minimal && r4 != 8232 && r4 != 8233) {
                  w += e4;
                  continue;
                }
                let n3 = r4.toString(16);
                b || (n3 = n3.toUpperCase());
                const i3 = n3.length > 2 || s3, o2 = "\\" + (i3 ? "u" : "x") + ("0000" + n3).slice(i3 ? -4 : -2);
                w += o2;
              }
              return t3.wrap && (w = y + w + y), y == "`" && (w = w.replace(/\$\{/g, "\\${")), t3.isScriptContext ? w.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, s3 ? "\\u003C!--" : "\\x3C!--") : w;
            };
            h3.version = "2.5.2", e2.exports = h3;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              const { placeholderWhitelist: o2, placeholderPattern: l, preserveComments: c, syntacticPlaceholders: u } = r3, p2 = function(e4, t4, r4) {
                const n2 = (t4.plugins || []).slice();
                r4 !== false && n2.push("placeholders"), t4 = Object.assign({ allowReturnOutsideFunction: true, allowSuperOutsideMethod: true, sourceType: "module" }, t4, { plugins: n2 });
                try {
                  return (0, s2.parse)(e4, t4);
                } catch (t5) {
                  const r5 = t5.loc;
                  throw r5 && (t5.message += "\n" + (0, i.codeFrameColumns)(e4, { start: r5 }), t5.code = "BABEL_TEMPLATE_PARSE_ERROR"), t5;
                }
              }(t3, r3.parser, u);
              n.removePropertiesDeep(p2, { preserveComments: c }), e3.validate(p2);
              const f = { placeholders: [], placeholderNames: new Set() }, d = { placeholders: [], placeholderNames: new Set() }, h3 = { value: void 0 };
              return n.traverse(p2, a, { syntactic: f, legacy: d, isLegacyRef: h3, placeholderWhitelist: o2, placeholderPattern: l, syntacticPlaceholders: u }), Object.assign({ ast: p2 }, h3.value ? d : f);
            };
            var n = r2(0), s2 = r2(27), i = r2(39);
            const o = /^[_$A-Z0-9]+$/;
            function a(e3, t3, r3) {
              var s3;
              let i2;
              if (n.isPlaceholder(e3)) {
                if (r3.syntacticPlaceholders === false)
                  throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
                i2 = e3.name.name, r3.isLegacyRef.value = false;
              } else {
                if (r3.isLegacyRef.value === false || r3.syntacticPlaceholders)
                  return;
                if (n.isIdentifier(e3) || n.isJSXIdentifier(e3))
                  i2 = e3.name, r3.isLegacyRef.value = true;
                else {
                  if (!n.isStringLiteral(e3))
                    return;
                  i2 = e3.value, r3.isLegacyRef.value = true;
                }
              }
              if (!r3.isLegacyRef.value && (r3.placeholderPattern != null || r3.placeholderWhitelist != null))
                throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
              if (r3.isLegacyRef.value && (r3.placeholderPattern === false || !(r3.placeholderPattern || o).test(i2)) && ((s3 = r3.placeholderWhitelist) == null || !s3.has(i2)))
                return;
              t3 = t3.slice();
              const { node: a2, key: l } = t3[t3.length - 1];
              let c;
              n.isStringLiteral(e3) || n.isPlaceholder(e3, { expectedNode: "StringLiteral" }) ? c = "string" : n.isNewExpression(a2) && l === "arguments" || n.isCallExpression(a2) && l === "arguments" || n.isFunction(a2) && l === "params" ? c = "param" : n.isExpressionStatement(a2) && !n.isPlaceholder(e3) ? (c = "statement", t3 = t3.slice(0, -1)) : c = n.isStatement(e3) && n.isPlaceholder(e3) ? "statement" : "other";
              const { placeholders: u, placeholderNames: p2 } = r3.isLegacyRef.value ? r3.legacy : r3.syntactic;
              u.push({ name: i2, type: c, resolve: (e4) => function(e5, t4) {
                let r4 = e5;
                for (let e6 = 0; e6 < t4.length - 1; e6++) {
                  const { key: n3, index: s5 } = t4[e6];
                  r4 = s5 === void 0 ? r4[n3] : r4[n3][s5];
                }
                const { key: n2, index: s4 } = t4[t4.length - 1];
                return { parent: r4, key: n2, index: s4 };
              }(e4, t3), isDuplicate: p2.has(i2) }), p2.add(i2);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = n.cloneNode(e3.ast);
              return t3 && (e3.placeholders.forEach((e4) => {
                if (!Object.prototype.hasOwnProperty.call(t3, e4.name)) {
                  const t4 = e4.name;
                  throw new Error(`Error: No substitution given for "${t4}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${t4}'])}
            - { placeholderPattern: /^${t4}$/ }`);
                }
              }), Object.keys(t3).forEach((t4) => {
                if (!e3.placeholderNames.has(t4))
                  throw new Error(`Unknown substitution "${t4}" given`);
              })), e3.placeholders.slice().reverse().forEach((e4) => {
                try {
                  !function(e5, t4, r4) {
                    e5.isDuplicate && (Array.isArray(r4) ? r4 = r4.map((e6) => n.cloneNode(e6)) : typeof r4 == "object" && (r4 = n.cloneNode(r4)));
                    const { parent: s2, key: i, index: o } = e5.resolve(t4);
                    if (e5.type === "string") {
                      if (typeof r4 == "string" && (r4 = n.stringLiteral(r4)), !r4 || !n.isStringLiteral(r4))
                        throw new Error("Expected string substitution");
                    } else if (e5.type === "statement")
                      o === void 0 ? r4 ? Array.isArray(r4) ? r4 = n.blockStatement(r4) : typeof r4 == "string" ? r4 = n.expressionStatement(n.identifier(r4)) : n.isStatement(r4) || (r4 = n.expressionStatement(r4)) : r4 = n.emptyStatement() : r4 && !Array.isArray(r4) && (typeof r4 == "string" && (r4 = n.identifier(r4)), n.isStatement(r4) || (r4 = n.expressionStatement(r4)));
                    else if (e5.type === "param") {
                      if (typeof r4 == "string" && (r4 = n.identifier(r4)), o === void 0)
                        throw new Error("Assertion failure.");
                    } else if (typeof r4 == "string" && (r4 = n.identifier(r4)), Array.isArray(r4))
                      throw new Error("Cannot replace single expression with an array.");
                    if (o === void 0)
                      n.validate(s2, i, r4), s2[i] = r4;
                    else {
                      const t5 = s2[i].slice();
                      e5.type === "statement" || e5.type === "param" ? r4 == null ? t5.splice(o, 1) : Array.isArray(r4) ? t5.splice(o, 1, ...r4) : t5[o] = r4 : t5[o] = r4, n.validate(s2, i, t5), s2[i] = t5;
                    }
                  }(e4, r3, t3 && t3[e4.name] || null);
                } catch (t4) {
                  throw t4.message = `@babel/template placeholder "${e4.name}": ${t4.message}`, t4;
                }
              }), r3;
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.rewriteModuleStatementsAndPrepareHeader = function(e3, { loose: t3, exportName: r3, strict: u2, allowTopLevelThis: p3, strictMode: d2, noInterop: m, importInterop: y = m ? "none" : "babel", lazy: g, esNamespaceOnly: b, constantReexports: v = t3, enumerableModuleMeta: E = t3 }) {
              (0, c.validateImportInteropOption)(y), n((0, o.isModule)(e3), "Cannot process module statements in a script"), e3.node.sourceType = "script";
              const x = (0, c.default)(e3, r3, { importInterop: y, initializeReexports: v, lazy: g, esNamespaceOnly: b });
              p3 || (0, a.default)(e3), (0, l.default)(e3, x), d2 !== false && (e3.node.directives.some((e4) => e4.value.value === "use strict") || e3.unshiftContainer("directives", s2.directive(s2.directiveLiteral("use strict"))));
              const S = [];
              (0, c.hasExports)(x) && !u2 && S.push(function(e4, t4 = false) {
                return (t4 ? i.default.statement`
        EXPORTS.__esModule = true;
      ` : i.default.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({ EXPORTS: e4.exportName });
              }(x, E));
              const T = function(e4, t4) {
                const r4 = Object.create(null);
                for (const e5 of t4.local.values())
                  for (const t5 of e5.names)
                    r4[t5] = true;
                let n2 = false;
                for (const e5 of t4.source.values()) {
                  for (const t5 of e5.reexports.keys())
                    r4[t5] = true;
                  for (const t5 of e5.reexportNamespace)
                    r4[t5] = true;
                  n2 = n2 || !!e5.reexportAll;
                }
                if (!n2 || Object.keys(r4).length === 0)
                  return null;
                const i2 = e4.scope.generateUidIdentifier("exportNames");
                return delete r4.default, { name: i2.name, statement: s2.variableDeclaration("var", [s2.variableDeclarator(i2, s2.valueToNode(r4))]) };
              }(e3, x);
              return T && (x.exportNameListName = T.name, S.push(T.statement)), S.push(...function(e4, t4, r4 = false) {
                const n2 = [], i2 = [];
                for (const [e5, r5] of t4.local)
                  r5.kind === "import" || (r5.kind === "hoisted" ? n2.push(h3(t4, r5.names, s2.identifier(e5))) : i2.push(...r5.names));
                for (const e5 of t4.source.values()) {
                  r4 || n2.push(...f(t4, e5, false));
                  for (const t5 of e5.reexportNamespace)
                    i2.push(t5);
                }
                return n2.push(...function(e5, t5) {
                  const r5 = [];
                  for (let t6 = 0; t6 < e5.length; t6 += 100)
                    r5.push(e5.slice(t6, t6 + 100));
                  return r5;
                }(i2).map((r5) => h3(t4, r5, e4.scope.buildUndefinedNode()))), n2;
              }(e3, x, v)), { meta: x, headers: S };
            }, t2.ensureStatementsHoisted = function(e3) {
              e3.forEach((e4) => {
                e4._blockHoist = 3;
              });
            }, t2.wrapInterop = function(e3, t3, r3) {
              if (r3 === "none")
                return null;
              if (r3 === "node-namespace")
                return s2.callExpression(e3.hub.addHelper("interopRequireWildcard"), [t3, s2.booleanLiteral(true)]);
              if (r3 === "node-default")
                return null;
              let n2;
              if (r3 === "default")
                n2 = "interopRequireDefault";
              else {
                if (r3 !== "namespace")
                  throw new Error(`Unknown interop: ${r3}`);
                n2 = "interopRequireWildcard";
              }
              return s2.callExpression(e3.hub.addHelper(n2), [t3]);
            }, t2.buildNamespaceInitStatements = function(e3, t3, r3 = false) {
              const n2 = [];
              let o2 = s2.identifier(t3.name);
              t3.lazy && (o2 = s2.callExpression(o2, []));
              for (const e4 of t3.importsNamespace)
                e4 !== t3.name && n2.push(i.default.statement`var NAME = SOURCE;`({ NAME: e4, SOURCE: s2.cloneNode(o2) }));
              r3 && n2.push(...f(e3, t3, true));
              for (const r4 of t3.reexportNamespace)
                n2.push((t3.lazy ? i.default.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : i.default.statement`EXPORTS.NAME = NAMESPACE;`)({ EXPORTS: e3.exportName, NAME: r4, NAMESPACE: s2.cloneNode(o2) }));
              if (t3.reexportAll) {
                const a2 = function(e4, t4, r4) {
                  return (r4 ? i.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : i.default.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({ NAMESPACE: t4, EXPORTS: e4.exportName, VERIFY_NAME_LIST: e4.exportNameListName ? i.default`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({ EXPORTS_LIST: e4.exportNameListName }) : null });
                }(e3, s2.cloneNode(o2), r3);
                a2.loc = t3.reexportAll.loc, n2.push(a2);
              }
              return n2;
            }, Object.defineProperty(t2, "isModule", { enumerable: true, get: function() {
              return o.isModule;
            } }), Object.defineProperty(t2, "rewriteThis", { enumerable: true, get: function() {
              return a.default;
            } }), Object.defineProperty(t2, "hasExports", { enumerable: true, get: function() {
              return c.hasExports;
            } }), Object.defineProperty(t2, "isSideEffectImport", { enumerable: true, get: function() {
              return c.isSideEffectImport;
            } }), Object.defineProperty(t2, "getModuleName", { enumerable: true, get: function() {
              return u.default;
            } });
            var n = r2(30), s2 = r2(0), i = r2(21), o = r2(146), a = r2(461), l = r2(462), c = r2(463), u = r2(464);
            const p2 = { constant: i.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`, constantComputed: i.default.statement`EXPORTS["EXPORT_NAME"] = NAMESPACE_IMPORT;`, spec: i.default`
    Object.defineProperty(EXPORTS, "EXPORT_NAME", {
      enumerable: true,
      get: function() {
        return NAMESPACE_IMPORT;
      },
    });
    ` }, f = (e3, t3, r3) => {
              const n2 = t3.lazy ? s2.callExpression(s2.identifier(t3.name), []) : s2.identifier(t3.name), { stringSpecifiers: i2 } = e3;
              return Array.from(t3.reexports, ([o2, a2]) => {
                let l2 = s2.cloneNode(n2);
                a2 === "default" && t3.interop === "node-default" || (l2 = i2.has(a2) ? s2.memberExpression(l2, s2.stringLiteral(a2), true) : s2.memberExpression(l2, s2.identifier(a2)));
                const c4 = { EXPORTS: e3.exportName, EXPORT_NAME: o2, NAMESPACE_IMPORT: l2 };
                return r3 || s2.isIdentifier(l2) ? i2.has(o2) ? p2.constantComputed(c4) : p2.constant(c4) : p2.spec(c4);
              });
            }, d = { computed: i.default.expression`EXPORTS["NAME"] = VALUE`, default: i.default.expression`EXPORTS.NAME = VALUE` };
            function h3(e3, t3, r3) {
              const { stringSpecifiers: n2, exportName: i2 } = e3;
              return s2.expressionStatement(t3.reduce((e4, t4) => {
                const r4 = { EXPORTS: i2, NAME: t4, VALUE: e4 };
                return n2.has(t4) ? d.computed(r4) : d.default(r4);
              }, r3));
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3) {
              return (n = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
                return typeof e4;
              } : function(e4) {
                return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
              })(e3);
            }
            function s2(e3) {
              return (s2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
                return e4.__proto__ || Object.getPrototypeOf(e4);
              })(e3);
            }
            function i(e3, t3) {
              return (i = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var o, a, l = {};
            function c(e3, t3, r3) {
              r3 || (r3 = Error);
              var o2 = function(r4) {
                function o3(r5, i2, a2) {
                  var l2;
                  return function(e4, t4) {
                    if (!(e4 instanceof t4))
                      throw new TypeError("Cannot call a class as a function");
                  }(this, o3), (l2 = function(e4, t4) {
                    return !t4 || n(t4) !== "object" && typeof t4 != "function" ? function(e5) {
                      if (e5 === void 0)
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                      return e5;
                    }(e4) : t4;
                  }(this, s2(o3).call(this, function(e4, r6, n2) {
                    return typeof t3 == "string" ? t3 : t3(e4, r6, n2);
                  }(r5, i2, a2)))).code = e3, l2;
                }
                return function(e4, t4) {
                  if (typeof t4 != "function" && t4 !== null)
                    throw new TypeError("Super expression must either be null or a function");
                  e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), t4 && i(e4, t4);
                }(o3, r4), o3;
              }(r3);
              l[e3] = o2;
            }
            function u(e3, t3) {
              if (Array.isArray(e3)) {
                var r3 = e3.length;
                return e3 = e3.map(function(e4) {
                  return String(e4);
                }), r3 > 2 ? "one of ".concat(t3, " ").concat(e3.slice(0, r3 - 1).join(", "), ", or ") + e3[r3 - 1] : r3 === 2 ? "one of ".concat(t3, " ").concat(e3[0], " or ").concat(e3[1]) : "of ".concat(t3, " ").concat(e3[0]);
              }
              return "of ".concat(t3, " ").concat(String(e3));
            }
            c("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), c("ERR_INVALID_ARG_TYPE", function(e3, t3, s3) {
              var i2, a2, l2, c4, p2;
              if (o === void 0 && (o = r2(30)), o(typeof e3 == "string", "'name' must be a string"), typeof t3 == "string" && (a2 = "not ", t3.substr(0, a2.length) === a2) ? (i2 = "must not be", t3 = t3.replace(/^not /, "")) : i2 = "must be", function(e4, t4, r3) {
                return (r3 === void 0 || r3 > e4.length) && (r3 = e4.length), e4.substring(r3 - t4.length, r3) === t4;
              }(e3, " argument"))
                l2 = "The ".concat(e3, " ").concat(i2, " ").concat(u(t3, "type"));
              else {
                var f = (typeof p2 != "number" && (p2 = 0), p2 + ".".length > (c4 = e3).length || c4.indexOf(".", p2) === -1 ? "argument" : "property");
                l2 = 'The "'.concat(e3, '" ').concat(f, " ").concat(i2, " ").concat(u(t3, "type"));
              }
              return l2 + ". Received type ".concat(n(s3));
            }, TypeError), c("ERR_INVALID_ARG_VALUE", function(e3, t3) {
              var n2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
              a === void 0 && (a = r2(36));
              var s3 = a.inspect(t3);
              return s3.length > 128 && (s3 = "".concat(s3.slice(0, 128), "...")), "The argument '".concat(e3, "' ").concat(n2, ". Received ").concat(s3);
            }, TypeError, RangeError), c("ERR_INVALID_RETURN_VALUE", function(e3, t3, r3) {
              var s3;
              return s3 = r3 && r3.constructor && r3.constructor.name ? "instance of ".concat(r3.constructor.name) : "type ".concat(n(r3)), "Expected ".concat(e3, ' to be returned from the "').concat(t3, '"') + " function but got ".concat(s3, ".");
            }, TypeError), c("ERR_MISSING_ARGS", function() {
              for (var e3 = arguments.length, t3 = new Array(e3), n2 = 0; n2 < e3; n2++)
                t3[n2] = arguments[n2];
              o === void 0 && (o = r2(30)), o(t3.length > 0, "At least one arg needs to be specified");
              var s3 = "The ", i2 = t3.length;
              switch (t3 = t3.map(function(e4) {
                return '"'.concat(e4, '"');
              }), i2) {
                case 1:
                  s3 += "".concat(t3[0], " argument");
                  break;
                case 2:
                  s3 += "".concat(t3[0], " and ").concat(t3[1], " arguments");
                  break;
                default:
                  s3 += t3.slice(0, i2 - 1).join(", "), s3 += ", and ".concat(t3[i2 - 1], " arguments");
              }
              return "".concat(s3, " must be specified");
            }, TypeError), e2.exports.codes = l;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(242), s2 = r2(246), i = r2(247), o = r2(139);
            function a(e3) {
              return e3.call.bind(e3);
            }
            var l = typeof BigInt != "undefined", c = typeof Symbol != "undefined", u = a(Object.prototype.toString), p2 = a(Number.prototype.valueOf), f = a(String.prototype.valueOf), d = a(Boolean.prototype.valueOf);
            if (l)
              var h3 = a(BigInt.prototype.valueOf);
            if (c)
              var m = a(Symbol.prototype.valueOf);
            function y(e3, t3) {
              if (typeof e3 != "object")
                return false;
              try {
                return t3(e3), true;
              } catch (e4) {
                return false;
              }
            }
            function g(e3) {
              return u(e3) === "[object Map]";
            }
            function b(e3) {
              return u(e3) === "[object Set]";
            }
            function v(e3) {
              return u(e3) === "[object WeakMap]";
            }
            function E(e3) {
              return u(e3) === "[object WeakSet]";
            }
            function x(e3) {
              return u(e3) === "[object ArrayBuffer]";
            }
            function S(e3) {
              return typeof ArrayBuffer != "undefined" && (x.working ? x(e3) : e3 instanceof ArrayBuffer);
            }
            function T(e3) {
              return u(e3) === "[object DataView]";
            }
            function w(e3) {
              return typeof DataView != "undefined" && (T.working ? T(e3) : e3 instanceof DataView);
            }
            t2.isArgumentsObject = n, t2.isGeneratorFunction = s2, t2.isTypedArray = o, t2.isPromise = function(e3) {
              return typeof Promise != "undefined" && e3 instanceof Promise || e3 !== null && typeof e3 == "object" && typeof e3.then == "function" && typeof e3.catch == "function";
            }, t2.isArrayBufferView = function(e3) {
              return typeof ArrayBuffer != "undefined" && ArrayBuffer.isView ? ArrayBuffer.isView(e3) : o(e3) || w(e3);
            }, t2.isUint8Array = function(e3) {
              return i(e3) === "Uint8Array";
            }, t2.isUint8ClampedArray = function(e3) {
              return i(e3) === "Uint8ClampedArray";
            }, t2.isUint16Array = function(e3) {
              return i(e3) === "Uint16Array";
            }, t2.isUint32Array = function(e3) {
              return i(e3) === "Uint32Array";
            }, t2.isInt8Array = function(e3) {
              return i(e3) === "Int8Array";
            }, t2.isInt16Array = function(e3) {
              return i(e3) === "Int16Array";
            }, t2.isInt32Array = function(e3) {
              return i(e3) === "Int32Array";
            }, t2.isFloat32Array = function(e3) {
              return i(e3) === "Float32Array";
            }, t2.isFloat64Array = function(e3) {
              return i(e3) === "Float64Array";
            }, t2.isBigInt64Array = function(e3) {
              return i(e3) === "BigInt64Array";
            }, t2.isBigUint64Array = function(e3) {
              return i(e3) === "BigUint64Array";
            }, g.working = typeof Map != "undefined" && g(new Map()), t2.isMap = function(e3) {
              return typeof Map != "undefined" && (g.working ? g(e3) : e3 instanceof Map);
            }, b.working = typeof Set != "undefined" && b(new Set()), t2.isSet = function(e3) {
              return typeof Set != "undefined" && (b.working ? b(e3) : e3 instanceof Set);
            }, v.working = typeof WeakMap != "undefined" && v(new WeakMap()), t2.isWeakMap = function(e3) {
              return typeof WeakMap != "undefined" && (v.working ? v(e3) : e3 instanceof WeakMap);
            }, E.working = typeof WeakSet != "undefined" && E(new WeakSet()), t2.isWeakSet = function(e3) {
              return E(e3);
            }, x.working = typeof ArrayBuffer != "undefined" && x(new ArrayBuffer()), t2.isArrayBuffer = S, T.working = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined" && T(new DataView(new ArrayBuffer(1), 0, 1)), t2.isDataView = w;
            var P = typeof SharedArrayBuffer != "undefined" ? SharedArrayBuffer : void 0;
            function A(e3) {
              return u(e3) === "[object SharedArrayBuffer]";
            }
            function O(e3) {
              return P !== void 0 && (A.working === void 0 && (A.working = A(new P())), A.working ? A(e3) : e3 instanceof P);
            }
            function C(e3) {
              return y(e3, p2);
            }
            function I(e3) {
              return y(e3, f);
            }
            function k2(e3) {
              return y(e3, d);
            }
            function N(e3) {
              return l && y(e3, h3);
            }
            function _(e3) {
              return c && y(e3, m);
            }
            t2.isSharedArrayBuffer = O, t2.isAsyncFunction = function(e3) {
              return u(e3) === "[object AsyncFunction]";
            }, t2.isMapIterator = function(e3) {
              return u(e3) === "[object Map Iterator]";
            }, t2.isSetIterator = function(e3) {
              return u(e3) === "[object Set Iterator]";
            }, t2.isGeneratorObject = function(e3) {
              return u(e3) === "[object Generator]";
            }, t2.isWebAssemblyCompiledModule = function(e3) {
              return u(e3) === "[object WebAssembly.Module]";
            }, t2.isNumberObject = C, t2.isStringObject = I, t2.isBooleanObject = k2, t2.isBigIntObject = N, t2.isSymbolObject = _, t2.isBoxedPrimitive = function(e3) {
              return C(e3) || I(e3) || k2(e3) || N(e3) || _(e3);
            }, t2.isAnyArrayBuffer = function(e3) {
              return typeof Uint8Array != "undefined" && (S(e3) || O(e3));
            }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e3) {
              Object.defineProperty(t2, e3, { enumerable: false, value: function() {
                throw new Error(e3 + " is not supported in userland");
              } });
            });
          }, (e2, t2, r2) => {
            "use strict";
            var n = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", s2 = r2(66)("Object.prototype.toString"), i = function(e3) {
              return !(n && e3 && typeof e3 == "object" && Symbol.toStringTag in e3) && s2(e3) === "[object Arguments]";
            }, o = function(e3) {
              return !!i(e3) || e3 !== null && typeof e3 == "object" && typeof e3.length == "number" && e3.length >= 0 && s2(e3) !== "[object Array]" && s2(e3.callee) === "[object Function]";
            }, a = function() {
              return i(arguments);
            }();
            i.isLegacyArguments = o, e2.exports = a ? i : o;
          }, (e2) => {
            "use strict";
            e2.exports = function() {
              if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
                return false;
              if (typeof Symbol.iterator == "symbol")
                return true;
              var e3 = {}, t2 = Symbol("test"), r2 = Object(t2);
              if (typeof t2 == "string")
                return false;
              if (Object.prototype.toString.call(t2) !== "[object Symbol]")
                return false;
              if (Object.prototype.toString.call(r2) !== "[object Symbol]")
                return false;
              for (t2 in e3[t2] = 42, e3)
                return false;
              if (typeof Object.keys == "function" && Object.keys(e3).length !== 0)
                return false;
              if (typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e3).length !== 0)
                return false;
              var n = Object.getOwnPropertySymbols(e3);
              if (n.length !== 1 || n[0] !== t2)
                return false;
              if (!Object.prototype.propertyIsEnumerable.call(e3, t2))
                return false;
              if (typeof Object.getOwnPropertyDescriptor == "function") {
                var s2 = Object.getOwnPropertyDescriptor(e3, t2);
                if (s2.value !== 42 || s2.enumerable !== true)
                  return false;
              }
              return true;
            };
          }, (e2) => {
            "use strict";
            var t2 = "Function.prototype.bind called on incompatible ", r2 = Array.prototype.slice, n = Object.prototype.toString, s2 = "[object Function]";
            e2.exports = function(e3) {
              var i = this;
              if (typeof i != "function" || n.call(i) !== s2)
                throw new TypeError(t2 + i);
              for (var o, a = r2.call(arguments, 1), l = function() {
                if (this instanceof o) {
                  var t3 = i.apply(this, a.concat(r2.call(arguments)));
                  return Object(t3) === t3 ? t3 : this;
                }
                return i.apply(e3, a.concat(r2.call(arguments)));
              }, c = Math.max(0, i.length - a.length), u = [], p2 = 0; p2 < c; p2++)
                u.push("$" + p2);
              if (o = Function("binder", "return function (" + u.join(",") + "){ return binder.apply(this,arguments); }")(l), i.prototype) {
                var f = function() {
                };
                f.prototype = i.prototype, o.prototype = new f(), f.prototype = null;
              }
              return o;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(69);
            e2.exports = n.call(Function.call, Object.prototype.hasOwnProperty);
          }, (e2) => {
            "use strict";
            var t2, r2 = Object.prototype.toString, n = Function.prototype.toString, s2 = /^\s*(?:function)?\*/, i = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", o = Object.getPrototypeOf;
            e2.exports = function(e3) {
              if (typeof e3 != "function")
                return false;
              if (s2.test(n.call(e3)))
                return true;
              if (!i)
                return r2.call(e3) === "[object GeneratorFunction]";
              if (!o)
                return false;
              if (t2 === void 0) {
                var a = function() {
                  if (!i)
                    return false;
                  try {
                    return Function("return function*() {}")();
                  } catch (e4) {
                  }
                }();
                t2 = !!a && o(a);
              }
              return o(e3) === t2;
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(136), s2 = r2(137), i = r2(66), o = i("Object.prototype.toString"), a = r2(68)() && typeof Symbol.toStringTag == "symbol", l = s2(), c = i("String.prototype.slice"), u = {}, p2 = r2(138), f = Object.getPrototypeOf;
            a && p2 && f && n(l, function(e3) {
              if (typeof r2.g[e3] == "function") {
                var t3 = new r2.g[e3]();
                if (!(Symbol.toStringTag in t3))
                  throw new EvalError("this engine has support for Symbol.toStringTag, but " + e3 + " does not have the property! Please report this.");
                var n2 = f(t3), s3 = p2(n2, Symbol.toStringTag);
                if (!s3) {
                  var i2 = f(n2);
                  s3 = p2(i2, Symbol.toStringTag);
                }
                u[e3] = s3.get;
              }
            });
            var d = r2(139);
            e2.exports = function(e3) {
              return !!d(e3) && (a ? function(e4) {
                var t3 = false;
                return n(u, function(r3, n2) {
                  if (!t3)
                    try {
                      var s3 = r3.call(e4);
                      s3 === n2 && (t3 = s3);
                    } catch (e5) {
                    }
                }), t3;
              }(e3) : c(o(e3), 8, -1));
            };
          }, (e2) => {
            e2.exports = function(e3) {
              return e3 && typeof e3 == "object" && typeof e3.copy == "function" && typeof e3.fill == "function" && typeof e3.readUInt8 == "function";
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3, t3, r3) {
              return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
            }
            function s2(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function i(e3, t3) {
              return !t3 || f(t3) !== "object" && typeof t3 != "function" ? o(e3) : t3;
            }
            function o(e3) {
              if (e3 === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e3;
            }
            function a(e3) {
              var t3 = typeof Map == "function" ? new Map() : void 0;
              return (a = function(e4) {
                if (e4 === null || (r3 = e4, Function.toString.call(r3).indexOf("[native code]") === -1))
                  return e4;
                var r3;
                if (typeof e4 != "function")
                  throw new TypeError("Super expression must either be null or a function");
                if (t3 !== void 0) {
                  if (t3.has(e4))
                    return t3.get(e4);
                  t3.set(e4, n2);
                }
                function n2() {
                  return c(e4, arguments, p2(this).constructor);
                }
                return n2.prototype = Object.create(e4.prototype, { constructor: { value: n2, enumerable: false, writable: true, configurable: true } }), u(n2, e4);
              })(e3);
            }
            function l() {
              if (typeof Reflect == "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
                })), true;
              } catch (e3) {
                return false;
              }
            }
            function c(e3, t3, r3) {
              return (c = l() ? Reflect.construct : function(e4, t4, r4) {
                var n2 = [null];
                n2.push.apply(n2, t4);
                var s3 = new (Function.bind.apply(e4, n2))();
                return r4 && u(s3, r4.prototype), s3;
              }).apply(null, arguments);
            }
            function u(e3, t3) {
              return (u = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            function p2(e3) {
              return (p2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
                return e4.__proto__ || Object.getPrototypeOf(e4);
              })(e3);
            }
            function f(e3) {
              return (f = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
                return typeof e4;
              } : function(e4) {
                return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
              })(e3);
            }
            var d = r2(36).inspect, h3 = r2(240).codes.ERR_INVALID_ARG_TYPE;
            function m(e3, t3, r3) {
              return (r3 === void 0 || r3 > e3.length) && (r3 = e3.length), e3.substring(r3 - t3.length, r3) === t3;
            }
            var y = "", g = "", b = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
            function v(e3) {
              var t3 = Object.keys(e3), r3 = Object.create(Object.getPrototypeOf(e3));
              return t3.forEach(function(t4) {
                r3[t4] = e3[t4];
              }), Object.defineProperty(r3, "message", { value: e3.message }), r3;
            }
            function E(e3) {
              return d(e3, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
            }
            var x = function(e3) {
              function t3(e4) {
                var r4;
                if (function(e5, t4) {
                  if (!(e5 instanceof t4))
                    throw new TypeError("Cannot call a class as a function");
                }(this, t3), f(e4) !== "object" || e4 === null)
                  throw new h3("options", "Object", e4);
                var n2 = e4.message, s3 = e4.operator, a3 = e4.stackStartFn, l2 = e4.actual, c4 = e4.expected, u2 = Error.stackTraceLimit;
                if (Error.stackTraceLimit = 0, n2 != null)
                  r4 = i(this, p2(t3).call(this, String(n2)));
                else if (f(l2) === "object" && l2 !== null && f(c4) === "object" && c4 !== null && "stack" in l2 && l2 instanceof Error && "stack" in c4 && c4 instanceof Error && (l2 = v(l2), c4 = v(c4)), s3 === "deepStrictEqual" || s3 === "strictEqual")
                  r4 = i(this, p2(t3).call(this, function(e5, t4, r5) {
                    var n3 = "", s4 = "", i2 = 0, o2 = "", a4 = false, l3 = E(e5), c5 = l3.split("\n"), u3 = E(t4).split("\n"), p3 = 0, d3 = "";
                    if (r5 === "strictEqual" && f(e5) === "object" && f(t4) === "object" && e5 !== null && t4 !== null && (r5 = "strictEqualObject"), c5.length === 1 && u3.length === 1 && c5[0] !== u3[0]) {
                      var h4 = c5[0].length + u3[0].length;
                      if (h4 <= 10) {
                        if (!(f(e5) === "object" && e5 !== null || f(t4) === "object" && t4 !== null || e5 === 0 && t4 === 0))
                          return "".concat(b[r5], "\n\n") + "".concat(c5[0], " !== ").concat(u3[0], "\n");
                      } else if (r5 !== "strictEqualObject" && h4 < 80) {
                        for (; c5[0][p3] === u3[0][p3]; )
                          p3++;
                        p3 > 2 && (d3 = "\n  ".concat(function(e6, t5) {
                          if (t5 = Math.floor(t5), e6.length == 0 || t5 == 0)
                            return "";
                          var r6 = e6.length * t5;
                          for (t5 = Math.floor(Math.log(t5) / Math.log(2)); t5; )
                            e6 += e6, t5--;
                          return e6 + e6.substring(0, r6 - e6.length);
                        }(" ", p3), "^"), p3 = 0);
                      }
                    }
                    for (var v2 = c5[c5.length - 1], x3 = u3[u3.length - 1]; v2 === x3 && (p3++ < 2 ? o2 = "\n  ".concat(v2).concat(o2) : n3 = v2, c5.pop(), u3.pop(), c5.length !== 0 && u3.length !== 0); )
                      v2 = c5[c5.length - 1], x3 = u3[u3.length - 1];
                    var S2 = Math.max(c5.length, u3.length);
                    if (S2 === 0) {
                      var T2 = l3.split("\n");
                      if (T2.length > 30)
                        for (T2[26] = "".concat(y, "...").concat(g); T2.length > 27; )
                          T2.pop();
                      return "".concat(b.notIdentical, "\n\n").concat(T2.join("\n"), "\n");
                    }
                    p3 > 3 && (o2 = "\n".concat(y, "...").concat(g).concat(o2), a4 = true), n3 !== "" && (o2 = "\n  ".concat(n3).concat(o2), n3 = "");
                    var w2 = 0, P = b[r5] + "\n".concat("", "+ actual").concat(g, " ").concat("", "- expected").concat(g), A = " ".concat(y, "...").concat(g, " Lines skipped");
                    for (p3 = 0; p3 < S2; p3++) {
                      var O = p3 - i2;
                      if (c5.length < p3 + 1)
                        O > 1 && p3 > 2 && (O > 4 ? (s4 += "\n".concat(y, "...").concat(g), a4 = true) : O > 3 && (s4 += "\n  ".concat(u3[p3 - 2]), w2++), s4 += "\n  ".concat(u3[p3 - 1]), w2++), i2 = p3, n3 += "\n".concat("", "-").concat(g, " ").concat(u3[p3]), w2++;
                      else if (u3.length < p3 + 1)
                        O > 1 && p3 > 2 && (O > 4 ? (s4 += "\n".concat(y, "...").concat(g), a4 = true) : O > 3 && (s4 += "\n  ".concat(c5[p3 - 2]), w2++), s4 += "\n  ".concat(c5[p3 - 1]), w2++), i2 = p3, s4 += "\n".concat("", "+").concat(g, " ").concat(c5[p3]), w2++;
                      else {
                        var C = u3[p3], I = c5[p3], k2 = I !== C && (!m(I, ",") || I.slice(0, -1) !== C);
                        k2 && m(C, ",") && C.slice(0, -1) === I && (k2 = false, I += ","), k2 ? (O > 1 && p3 > 2 && (O > 4 ? (s4 += "\n".concat(y, "...").concat(g), a4 = true) : O > 3 && (s4 += "\n  ".concat(c5[p3 - 2]), w2++), s4 += "\n  ".concat(c5[p3 - 1]), w2++), i2 = p3, s4 += "\n".concat("", "+").concat(g, " ").concat(I), n3 += "\n".concat("", "-").concat(g, " ").concat(C), w2 += 2) : (s4 += n3, n3 = "", O !== 1 && p3 !== 0 || (s4 += "\n  ".concat(I), w2++));
                      }
                      if (w2 > 20 && p3 < S2 - 2)
                        return "".concat(P).concat(A, "\n").concat(s4, "\n").concat(y, "...").concat(g).concat(n3, "\n") + "".concat(y, "...").concat(g);
                    }
                    return "".concat(P).concat(a4 ? A : "", "\n").concat(s4).concat(n3).concat(o2).concat(d3);
                  }(l2, c4, s3)));
                else if (s3 === "notDeepStrictEqual" || s3 === "notStrictEqual") {
                  var d2 = b[s3], x2 = E(l2).split("\n");
                  if (s3 === "notStrictEqual" && f(l2) === "object" && l2 !== null && (d2 = b.notStrictEqualObject), x2.length > 30)
                    for (x2[26] = "".concat(y, "...").concat(g); x2.length > 27; )
                      x2.pop();
                  r4 = x2.length === 1 ? i(this, p2(t3).call(this, "".concat(d2, " ").concat(x2[0]))) : i(this, p2(t3).call(this, "".concat(d2, "\n\n").concat(x2.join("\n"), "\n")));
                } else {
                  var S = E(l2), T = "", w = b[s3];
                  s3 === "notDeepEqual" || s3 === "notEqual" ? (S = "".concat(b[s3], "\n\n").concat(S)).length > 1024 && (S = "".concat(S.slice(0, 1021), "...")) : (T = "".concat(E(c4)), S.length > 512 && (S = "".concat(S.slice(0, 509), "...")), T.length > 512 && (T = "".concat(T.slice(0, 509), "...")), s3 === "deepEqual" || s3 === "equal" ? S = "".concat(w, "\n\n").concat(S, "\n\nshould equal\n\n") : T = " ".concat(s3, " ").concat(T)), r4 = i(this, p2(t3).call(this, "".concat(S).concat(T)));
                }
                return Error.stackTraceLimit = u2, r4.generatedMessage = !n2, Object.defineProperty(o(r4), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r4.code = "ERR_ASSERTION", r4.actual = l2, r4.expected = c4, r4.operator = s3, Error.captureStackTrace && Error.captureStackTrace(o(r4), a3), r4.stack, r4.name = "AssertionError", i(r4);
              }
              var r3, a2;
              return function(e4, t4) {
                if (typeof t4 != "function" && t4 !== null)
                  throw new TypeError("Super expression must either be null or a function");
                e4.prototype = Object.create(t4 && t4.prototype, { constructor: { value: e4, writable: true, configurable: true } }), t4 && u(e4, t4);
              }(t3, e3), r3 = t3, (a2 = [{ key: "toString", value: function() {
                return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
              } }, { key: d.custom, value: function(e4, t4) {
                return d(this, function(e5) {
                  for (var t5 = 1; t5 < arguments.length; t5++) {
                    var r4 = arguments[t5] != null ? arguments[t5] : {}, s3 = Object.keys(r4);
                    typeof Object.getOwnPropertySymbols == "function" && (s3 = s3.concat(Object.getOwnPropertySymbols(r4).filter(function(e6) {
                      return Object.getOwnPropertyDescriptor(r4, e6).enumerable;
                    }))), s3.forEach(function(t6) {
                      n(e5, t6, r4[t6]);
                    });
                  }
                  return e5;
                }({}, t4, { customInspect: false, depth: 0 }));
              } }]) && s2(r3.prototype, a2), t3;
            }(a(Error));
            e2.exports = x;
          }, (e2) => {
            "use strict";
            function t2(e3, t3) {
              if (e3 == null)
                throw new TypeError("Cannot convert first argument to object");
              for (var r2 = Object(e3), n = 1; n < arguments.length; n++) {
                var s2 = arguments[n];
                if (s2 != null)
                  for (var i = Object.keys(Object(s2)), o = 0, a = i.length; o < a; o++) {
                    var l = i[o], c = Object.getOwnPropertyDescriptor(s2, l);
                    c !== void 0 && c.enumerable && (r2[l] = s2[l]);
                  }
              }
              return r2;
            }
            e2.exports = { assign: t2, polyfill: function() {
              Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: t2 });
            } };
          }, (e2, t2, r2) => {
            "use strict";
            var n = Array.prototype.slice, s2 = r2(141), i = Object.keys, o = i ? function(e3) {
              return i(e3);
            } : r2(252), a = Object.keys;
            o.shim = function() {
              return Object.keys ? function() {
                var e3 = Object.keys(arguments);
                return e3 && e3.length === arguments.length;
              }(1, 2) || (Object.keys = function(e3) {
                return s2(e3) ? a(n.call(e3)) : a(e3);
              }) : Object.keys = o, Object.keys || o;
            }, e2.exports = o;
          }, (e2, t2, r2) => {
            "use strict";
            var n;
            if (!Object.keys) {
              var s2 = Object.prototype.hasOwnProperty, i = Object.prototype.toString, o = r2(141), a = Object.prototype.propertyIsEnumerable, l = !a.call({ toString: null }, "toString"), c = a.call(function() {
              }, "prototype"), u = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], p2 = function(e3) {
                var t3 = e3.constructor;
                return t3 && t3.prototype === e3;
              }, f = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, d = function() {
                if (typeof window == "undefined")
                  return false;
                for (var e3 in window)
                  try {
                    if (!f["$" + e3] && s2.call(window, e3) && window[e3] !== null && typeof window[e3] == "object")
                      try {
                        p2(window[e3]);
                      } catch (e4) {
                        return true;
                      }
                  } catch (e4) {
                    return true;
                  }
                return false;
              }();
              n = function(e3) {
                var t3 = e3 !== null && typeof e3 == "object", r3 = i.call(e3) === "[object Function]", n2 = o(e3), a2 = t3 && i.call(e3) === "[object String]", f2 = [];
                if (!t3 && !r3 && !n2)
                  throw new TypeError("Object.keys called on a non-object");
                var h3 = c && r3;
                if (a2 && e3.length > 0 && !s2.call(e3, 0))
                  for (var m = 0; m < e3.length; ++m)
                    f2.push(String(m));
                if (n2 && e3.length > 0)
                  for (var y = 0; y < e3.length; ++y)
                    f2.push(String(y));
                else
                  for (var g in e3)
                    h3 && g === "prototype" || !s2.call(e3, g) || f2.push(String(g));
                if (l)
                  for (var b = function(e4) {
                    if (typeof window == "undefined" || !d)
                      return p2(e4);
                    try {
                      return p2(e4);
                    } catch (e5) {
                      return false;
                    }
                  }(e3), v = 0; v < u.length; ++v)
                    b && u[v] === "constructor" || !s2.call(e3, u[v]) || f2.push(u[v]);
                return f2;
              };
            }
            e2.exports = n;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(143), s2 = r2(40);
            e2.exports = function() {
              var e3 = n();
              return s2(Object, { is: e3 }, { is: function() {
                return Object.is !== e3;
              } }), e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3, t3) {
              return function(e4) {
                if (Array.isArray(e4))
                  return e4;
              }(e3) || function(e4, t4) {
                var r3 = [], n2 = true, s3 = false, i2 = void 0;
                try {
                  for (var o2, a2 = e4[Symbol.iterator](); !(n2 = (o2 = a2.next()).done) && (r3.push(o2.value), !t4 || r3.length !== t4); n2 = true)
                    ;
                } catch (e5) {
                  s3 = true, i2 = e5;
                } finally {
                  try {
                    n2 || a2.return == null || a2.return();
                  } finally {
                    if (s3)
                      throw i2;
                  }
                }
                return r3;
              }(e3, t3) || function() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }();
            }
            function s2(e3) {
              return (s2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
                return typeof e4;
              } : function(e4) {
                return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
              })(e3);
            }
            var i = /a/g.flags !== void 0, o = function(e3) {
              var t3 = [];
              return e3.forEach(function(e4) {
                return t3.push(e4);
              }), t3;
            }, a = function(e3) {
              var t3 = [];
              return e3.forEach(function(e4, r3) {
                return t3.push([r3, e4]);
              }), t3;
            }, l = Object.is ? Object.is : r2(140), c = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
              return [];
            }, u = Number.isNaN ? Number.isNaN : r2(255);
            function p2(e3) {
              return e3.call.bind(e3);
            }
            var f = p2(Object.prototype.hasOwnProperty), d = p2(Object.prototype.propertyIsEnumerable), h3 = p2(Object.prototype.toString), m = r2(36).types, y = m.isAnyArrayBuffer, g = m.isArrayBufferView, b = m.isDate, v = m.isMap, E = m.isRegExp, x = m.isSet, S = m.isNativeError, T = m.isBoxedPrimitive, w = m.isNumberObject, P = m.isStringObject, A = m.isBooleanObject, O = m.isBigIntObject, C = m.isSymbolObject, I = m.isFloat32Array, k2 = m.isFloat64Array;
            function N(e3) {
              if (e3.length === 0 || e3.length > 10)
                return true;
              for (var t3 = 0; t3 < e3.length; t3++) {
                var r3 = e3.charCodeAt(t3);
                if (r3 < 48 || r3 > 57)
                  return true;
              }
              return e3.length === 10 && e3 >= Math.pow(2, 32);
            }
            function _(e3) {
              return Object.keys(e3).filter(N).concat(c(e3).filter(Object.prototype.propertyIsEnumerable.bind(e3)));
            }
            function j(e3, t3) {
              if (e3 === t3)
                return 0;
              for (var r3 = e3.length, n2 = t3.length, s3 = 0, i2 = Math.min(r3, n2); s3 < i2; ++s3)
                if (e3[s3] !== t3[s3]) {
                  r3 = e3[s3], n2 = t3[s3];
                  break;
                }
              return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
            }
            function D(e3, t3, r3, n2) {
              if (e3 === t3)
                return e3 !== 0 || !r3 || l(e3, t3);
              if (r3) {
                if (s2(e3) !== "object")
                  return typeof e3 == "number" && u(e3) && u(t3);
                if (s2(t3) !== "object" || e3 === null || t3 === null)
                  return false;
                if (Object.getPrototypeOf(e3) !== Object.getPrototypeOf(t3))
                  return false;
              } else {
                if (e3 === null || s2(e3) !== "object")
                  return (t3 === null || s2(t3) !== "object") && e3 == t3;
                if (t3 === null || s2(t3) !== "object")
                  return false;
              }
              var o2, a2, c4, p3, f2 = h3(e3);
              if (f2 !== h3(t3))
                return false;
              if (Array.isArray(e3)) {
                if (e3.length !== t3.length)
                  return false;
                var d2 = _(e3), m2 = _(t3);
                return d2.length === m2.length && M(e3, t3, r3, n2, 1, d2);
              }
              if (f2 === "[object Object]" && (!v(e3) && v(t3) || !x(e3) && x(t3)))
                return false;
              if (b(e3)) {
                if (!b(t3) || Date.prototype.getTime.call(e3) !== Date.prototype.getTime.call(t3))
                  return false;
              } else if (E(e3)) {
                if (!E(t3) || (c4 = e3, p3 = t3, !(i ? c4.source === p3.source && c4.flags === p3.flags : RegExp.prototype.toString.call(c4) === RegExp.prototype.toString.call(p3))))
                  return false;
              } else if (S(e3) || e3 instanceof Error) {
                if (e3.message !== t3.message || e3.name !== t3.name)
                  return false;
              } else {
                if (g(e3)) {
                  if (r3 || !I(e3) && !k2(e3)) {
                    if (!function(e4, t4) {
                      return e4.byteLength === t4.byteLength && j(new Uint8Array(e4.buffer, e4.byteOffset, e4.byteLength), new Uint8Array(t4.buffer, t4.byteOffset, t4.byteLength)) === 0;
                    }(e3, t3))
                      return false;
                  } else if (!function(e4, t4) {
                    if (e4.byteLength !== t4.byteLength)
                      return false;
                    for (var r4 = 0; r4 < e4.byteLength; r4++)
                      if (e4[r4] !== t4[r4])
                        return false;
                    return true;
                  }(e3, t3))
                    return false;
                  var N2 = _(e3), D2 = _(t3);
                  return N2.length === D2.length && M(e3, t3, r3, n2, 0, N2);
                }
                if (x(e3))
                  return !(!x(t3) || e3.size !== t3.size) && M(e3, t3, r3, n2, 2);
                if (v(e3))
                  return !(!v(t3) || e3.size !== t3.size) && M(e3, t3, r3, n2, 3);
                if (y(e3)) {
                  if (a2 = t3, (o2 = e3).byteLength !== a2.byteLength || j(new Uint8Array(o2), new Uint8Array(a2)) !== 0)
                    return false;
                } else if (T(e3) && !function(e4, t4) {
                  return w(e4) ? w(t4) && l(Number.prototype.valueOf.call(e4), Number.prototype.valueOf.call(t4)) : P(e4) ? P(t4) && String.prototype.valueOf.call(e4) === String.prototype.valueOf.call(t4) : A(e4) ? A(t4) && Boolean.prototype.valueOf.call(e4) === Boolean.prototype.valueOf.call(t4) : O(e4) ? O(t4) && BigInt.prototype.valueOf.call(e4) === BigInt.prototype.valueOf.call(t4) : C(t4) && Symbol.prototype.valueOf.call(e4) === Symbol.prototype.valueOf.call(t4);
                }(e3, t3))
                  return false;
              }
              return M(e3, t3, r3, n2, 0);
            }
            function L(e3, t3) {
              return t3.filter(function(t4) {
                return d(e3, t4);
              });
            }
            function M(e3, t3, r3, n2, s3, i2) {
              if (arguments.length === 5) {
                i2 = Object.keys(e3);
                var o2 = Object.keys(t3);
                if (i2.length !== o2.length)
                  return false;
              }
              for (var a2 = 0; a2 < i2.length; a2++)
                if (!f(t3, i2[a2]))
                  return false;
              if (r3 && arguments.length === 5) {
                var l2 = c(e3);
                if (l2.length !== 0) {
                  var u2 = 0;
                  for (a2 = 0; a2 < l2.length; a2++) {
                    var p3 = l2[a2];
                    if (d(e3, p3)) {
                      if (!d(t3, p3))
                        return false;
                      i2.push(p3), u2++;
                    } else if (d(t3, p3))
                      return false;
                  }
                  var h4 = c(t3);
                  if (l2.length !== h4.length && L(t3, h4).length !== u2)
                    return false;
                } else {
                  var m2 = c(t3);
                  if (m2.length !== 0 && L(t3, m2).length !== 0)
                    return false;
                }
              }
              if (i2.length === 0 && (s3 === 0 || s3 === 1 && e3.length === 0 || e3.size === 0))
                return true;
              if (n2 === void 0)
                n2 = { val1: new Map(), val2: new Map(), position: 0 };
              else {
                var y2 = n2.val1.get(e3);
                if (y2 !== void 0) {
                  var g2 = n2.val2.get(t3);
                  if (g2 !== void 0)
                    return y2 === g2;
                }
                n2.position++;
              }
              n2.val1.set(e3, n2.position), n2.val2.set(t3, n2.position);
              var b2 = q(e3, t3, r3, i2, n2, s3);
              return n2.val1.delete(e3), n2.val2.delete(t3), b2;
            }
            function B(e3, t3, r3, n2) {
              for (var s3 = o(e3), i2 = 0; i2 < s3.length; i2++) {
                var a2 = s3[i2];
                if (D(t3, a2, r3, n2))
                  return e3.delete(a2), true;
              }
              return false;
            }
            function R(e3) {
              switch (s2(e3)) {
                case "undefined":
                  return null;
                case "object":
                  return;
                case "symbol":
                  return false;
                case "string":
                  e3 = +e3;
                case "number":
                  if (u(e3))
                    return false;
              }
              return true;
            }
            function F(e3, t3, r3) {
              var n2 = R(r3);
              return n2 != null ? n2 : t3.has(n2) && !e3.has(n2);
            }
            function U(e3, t3, r3, n2, s3) {
              var i2 = R(r3);
              if (i2 != null)
                return i2;
              var o2 = t3.get(i2);
              return !(o2 === void 0 && !t3.has(i2) || !D(n2, o2, false, s3)) && !e3.has(i2) && D(n2, o2, false, s3);
            }
            function $(e3, t3, r3, n2, s3, i2) {
              for (var a2 = o(e3), l2 = 0; l2 < a2.length; l2++) {
                var c4 = a2[l2];
                if (D(r3, c4, s3, i2) && D(n2, t3.get(c4), s3, i2))
                  return e3.delete(c4), true;
              }
              return false;
            }
            function q(e3, t3, r3, i2, l2, c4) {
              var u2 = 0;
              if (c4 === 2) {
                if (!function(e4, t4, r4, n2) {
                  for (var i3 = null, a2 = o(e4), l3 = 0; l3 < a2.length; l3++) {
                    var c5 = a2[l3];
                    if (s2(c5) === "object" && c5 !== null)
                      i3 === null && (i3 = new Set()), i3.add(c5);
                    else if (!t4.has(c5)) {
                      if (r4)
                        return false;
                      if (!F(e4, t4, c5))
                        return false;
                      i3 === null && (i3 = new Set()), i3.add(c5);
                    }
                  }
                  if (i3 !== null) {
                    for (var u3 = o(t4), p4 = 0; p4 < u3.length; p4++) {
                      var f2 = u3[p4];
                      if (s2(f2) === "object" && f2 !== null) {
                        if (!B(i3, f2, r4, n2))
                          return false;
                      } else if (!r4 && !e4.has(f2) && !B(i3, f2, r4, n2))
                        return false;
                    }
                    return i3.size === 0;
                  }
                  return true;
                }(e3, t3, r3, l2))
                  return false;
              } else if (c4 === 3) {
                if (!function(e4, t4, r4, i3) {
                  for (var o2 = null, l3 = a(e4), c5 = 0; c5 < l3.length; c5++) {
                    var u3 = n(l3[c5], 2), p4 = u3[0], f2 = u3[1];
                    if (s2(p4) === "object" && p4 !== null)
                      o2 === null && (o2 = new Set()), o2.add(p4);
                    else {
                      var d3 = t4.get(p4);
                      if (d3 === void 0 && !t4.has(p4) || !D(f2, d3, r4, i3)) {
                        if (r4)
                          return false;
                        if (!U(e4, t4, p4, f2, i3))
                          return false;
                        o2 === null && (o2 = new Set()), o2.add(p4);
                      }
                    }
                  }
                  if (o2 !== null) {
                    for (var h5 = a(t4), m2 = 0; m2 < h5.length; m2++) {
                      var y2 = n(h5[m2], 2), g2 = (p4 = y2[0], y2[1]);
                      if (s2(p4) === "object" && p4 !== null) {
                        if (!$(o2, e4, p4, g2, r4, i3))
                          return false;
                      } else if (!(r4 || e4.has(p4) && D(e4.get(p4), g2, false, i3) || $(o2, e4, p4, g2, false, i3)))
                        return false;
                    }
                    return o2.size === 0;
                  }
                  return true;
                }(e3, t3, r3, l2))
                  return false;
              } else if (c4 === 1)
                for (; u2 < e3.length; u2++) {
                  if (!f(e3, u2)) {
                    if (f(t3, u2))
                      return false;
                    for (var p3 = Object.keys(e3); u2 < p3.length; u2++) {
                      var d2 = p3[u2];
                      if (!f(t3, d2) || !D(e3[d2], t3[d2], r3, l2))
                        return false;
                    }
                    return p3.length === Object.keys(t3).length;
                  }
                  if (!f(t3, u2) || !D(e3[u2], t3[u2], r3, l2))
                    return false;
                }
              for (u2 = 0; u2 < i2.length; u2++) {
                var h4 = i2[u2];
                if (!D(e3[h4], t3[h4], r3, l2))
                  return false;
              }
              return true;
            }
            e2.exports = { isDeepEqual: function(e3, t3) {
              return D(e3, t3, false);
            }, isDeepStrictEqual: function(e3, t3) {
              return D(e3, t3, true);
            } };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(51), s2 = r2(40), i = r2(144), o = r2(145), a = r2(256), l = n(o(), Number);
            s2(l, { getPolyfill: o, implementation: i, shim: a }), e2.exports = l;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(40), s2 = r2(145);
            e2.exports = function() {
              var e3 = s2();
              return n(Number, { isNaN: e3 }, { isNaN: function() {
                return Number.isNaN !== e3;
              } }), e3;
            };
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const { sourceType: t3 } = e3.node;
              if (t3 !== "module" && t3 !== "script")
                throw e3.buildCodeFrameError(`Unknown sourceType "${t3}", cannot transform.`);
              return e3.node.sourceType === "module";
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = Object.create(null);
              return e3 && Object.keys(e3).forEach(function(r3) {
                if (r3 !== "default") {
                  var n2 = Object.getOwnPropertyDescriptor(e3, r3);
                  Object.defineProperty(t3, r3, n2.get ? n2 : { enumerable: true, get: function() {
                    return e3[r3];
                  } });
                }
              }), t3.default = e3, Object.freeze(t3);
            }
            Object.defineProperty(t2, "__esModule", { value: true });
            var s2 = n(r2(0));
            function i(e3) {
              const t3 = e3, { node: r3, parentPath: n2 } = t3;
              if (n2.isLogicalExpression()) {
                const { operator: e4, right: t4 } = n2.node;
                if (e4 === "&&" || e4 === "||" || e4 === "??" && r3 === t4)
                  return i(n2);
              }
              if (n2.isSequenceExpression()) {
                const { expressions: e4 } = n2.node;
                return e4[e4.length - 1] !== r3 || i(n2);
              }
              return n2.isConditional({ test: r3 }) || n2.isUnaryExpression({ operator: "!" }) || n2.isLoop({ test: r3 });
            }
            class o {
              constructor() {
                this._map = void 0, this._map = new WeakMap();
              }
              has(e3) {
                return this._map.has(e3);
              }
              get(e3) {
                if (!this.has(e3))
                  return;
                const t3 = this._map.get(e3), { value: r3 } = t3;
                return t3.count--, t3.count === 0 ? s2.assignmentExpression("=", r3, e3) : r3;
              }
              set(e3, t3, r3) {
                return this._map.set(e3, { count: r3, value: t3 });
              }
            }
            function a(e3, t3) {
              const { node: r3 } = e3;
              if (e3.isOptionalMemberExpression())
                return s2.memberExpression(t3, r3.property, r3.computed);
              if (e3.isOptionalCallExpression()) {
                const n2 = e3.get("callee");
                if (e3.node.optional && n2.isOptionalMemberExpression()) {
                  const { object: i2 } = n2.node, o2 = e3.scope.maybeGenerateMemoised(i2) || i2;
                  return n2.get("object").replaceWith(s2.assignmentExpression("=", o2, i2)), s2.callExpression(s2.memberExpression(t3, s2.identifier("call")), [o2, ...r3.arguments]);
                }
                return s2.callExpression(t3, r3.arguments);
              }
              return e3.node;
            }
            const l = { memoise() {
            }, handle(e3, t3) {
              const { node: r3, parent: n2, parentPath: o2, scope: l2 } = e3;
              if (e3.isOptionalMemberExpression()) {
                if (function(e4) {
                  for (; e4 && !e4.isProgram(); ) {
                    const { parentPath: t4, container: r4, listKey: n3 } = e4, s3 = t4.node;
                    if (n3) {
                      if (r4 !== s3[n3])
                        return true;
                    } else if (r4 !== s3)
                      return true;
                    e4 = t4;
                  }
                  return false;
                }(e3))
                  return;
                const c = e3.find(({ node: t4, parent: r4, parentPath: n3 }) => n3.isOptionalMemberExpression() ? r4.optional || r4.object !== t4 : !n3.isOptionalCallExpression() || t4 !== e3.node && r4.optional || r4.callee !== t4);
                if (l2.path.isPattern())
                  return void c.replaceWith(s2.callExpression(s2.arrowFunctionExpression([], c.node), []));
                const u = i(c), p2 = c.parentPath;
                if (p2.isUpdateExpression({ argument: r3 }) || p2.isAssignmentExpression({ left: r3 }))
                  throw e3.buildCodeFrameError("can't handle assignment");
                const f = p2.isUnaryExpression({ operator: "delete" });
                if (f && c.isOptionalMemberExpression() && c.get("property").isPrivateName())
                  throw e3.buildCodeFrameError("can't delete a private class element");
                let d = e3;
                for (; ; )
                  if (d.isOptionalMemberExpression()) {
                    if (d.node.optional)
                      break;
                    d = d.get("object");
                  } else {
                    if (!d.isOptionalCallExpression())
                      throw new Error(`Internal error: unexpected ${d.node.type}`);
                    if (d.node.optional)
                      break;
                    d = d.get("callee");
                  }
                const h3 = d.isOptionalMemberExpression() ? "object" : "callee", m = d.node[h3], y = l2.maybeGenerateMemoised(m), g = y != null ? y : m, b = o2.isOptionalCallExpression({ callee: r3 }), v = o2.isCallExpression({ callee: r3 });
                d.replaceWith(a(d, g)), b ? n2.optional ? o2.replaceWith(this.optionalCall(e3, n2.arguments)) : o2.replaceWith(this.call(e3, n2.arguments)) : v ? e3.replaceWith(this.boundGet(e3)) : e3.replaceWith(this.get(e3));
                let E, x = e3.node;
                for (let t4 = e3; t4 !== c; ) {
                  const { parentPath: e4 } = t4;
                  if (e4 === c && b && n2.optional) {
                    x = e4.node;
                    break;
                  }
                  x = a(e4, x), t4 = e4;
                }
                const S = c.parentPath;
                if (s2.isMemberExpression(x) && S.isOptionalCallExpression({ callee: c.node, optional: true })) {
                  const { object: t4 } = x;
                  E = e3.scope.maybeGenerateMemoised(t4), E && (x.object = s2.assignmentExpression("=", E, t4));
                }
                let T = c;
                f && (T = S, x = S.node);
                const w = y ? s2.assignmentExpression("=", s2.cloneNode(g), s2.cloneNode(m)) : s2.cloneNode(g);
                if (u) {
                  let e4;
                  e4 = t3 ? s2.binaryExpression("!=", w, s2.nullLiteral()) : s2.logicalExpression("&&", s2.binaryExpression("!==", w, s2.nullLiteral()), s2.binaryExpression("!==", s2.cloneNode(g), l2.buildUndefinedNode())), T.replaceWith(s2.logicalExpression("&&", e4, x));
                } else {
                  let e4;
                  e4 = t3 ? s2.binaryExpression("==", w, s2.nullLiteral()) : s2.logicalExpression("||", s2.binaryExpression("===", w, s2.nullLiteral()), s2.binaryExpression("===", s2.cloneNode(g), l2.buildUndefinedNode())), T.replaceWith(s2.conditionalExpression(e4, f ? s2.booleanLiteral(true) : l2.buildUndefinedNode(), x));
                }
                if (E) {
                  const e4 = S.node;
                  S.replaceWith(s2.optionalCallExpression(s2.optionalMemberExpression(e4.callee, s2.identifier("call"), false, true), [s2.cloneNode(E), ...e4.arguments], false));
                }
              } else if (o2.isUpdateExpression({ argument: r3 })) {
                if (this.simpleSet)
                  return void e3.replaceWith(this.simpleSet(e3));
                const { operator: t4, prefix: i2 } = n2;
                this.memoise(e3, 2);
                const a2 = s2.binaryExpression(t4[0], s2.unaryExpression("+", this.get(e3)), s2.numericLiteral(1));
                if (i2)
                  o2.replaceWith(this.set(e3, a2));
                else {
                  const { scope: t5 } = e3, n3 = t5.generateUidIdentifierBasedOnNode(r3);
                  t5.push({ id: n3 }), a2.left = s2.assignmentExpression("=", s2.cloneNode(n3), a2.left), o2.replaceWith(s2.sequenceExpression([this.set(e3, a2), s2.cloneNode(n3)]));
                }
              } else if (o2.isAssignmentExpression({ left: r3 })) {
                if (this.simpleSet)
                  return void e3.replaceWith(this.simpleSet(e3));
                const { operator: t4, right: r4 } = n2;
                if (t4 === "=")
                  o2.replaceWith(this.set(e3, r4));
                else {
                  const n3 = t4.slice(0, -1);
                  s2.LOGICAL_OPERATORS.includes(n3) ? (this.memoise(e3, 1), o2.replaceWith(s2.logicalExpression(n3, this.get(e3), this.set(e3, r4)))) : (this.memoise(e3, 2), o2.replaceWith(this.set(e3, s2.binaryExpression(n3, this.get(e3), r4))));
                }
              } else {
                if (!o2.isCallExpression({ callee: r3 }))
                  return o2.isOptionalCallExpression({ callee: r3 }) ? l2.path.isPattern() ? void o2.replaceWith(s2.callExpression(s2.arrowFunctionExpression([], o2.node), [])) : void o2.replaceWith(this.optionalCall(e3, n2.arguments)) : void (o2.isForXStatement({ left: r3 }) || o2.isObjectProperty({ value: r3 }) && o2.parentPath.isObjectPattern() || o2.isAssignmentPattern({ left: r3 }) && o2.parentPath.isObjectProperty({ value: n2 }) && o2.parentPath.parentPath.isObjectPattern() || o2.isArrayPattern() || o2.isAssignmentPattern({ left: r3 }) && o2.parentPath.isArrayPattern() || o2.isRestElement() ? e3.replaceWith(this.destructureSet(e3)) : o2.isTaggedTemplateExpression() ? e3.replaceWith(this.boundGet(e3)) : e3.replaceWith(this.get(e3)));
                o2.replaceWith(this.call(e3, n2.arguments));
              }
            } };
            t2.default = function(e3, t3, r3) {
              e3.traverse(t3, Object.assign({}, l, r3, { memoiser: new o() }));
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, s2) {
              return r3.length === 1 && n.isSpreadElement(r3[0]) && n.isIdentifier(r3[0].argument, { name: "arguments" }) ? s2 ? n.optionalCallExpression(n.optionalMemberExpression(e3, n.identifier("apply"), false, true), [t3, r3[0].argument], false) : n.callExpression(n.memberExpression(e3, n.identifier("apply")), [t3, r3[0].argument]) : s2 ? n.optionalCallExpression(n.optionalMemberExpression(e3, n.identifier("call"), false, true), [t3, ...r3], false) : n.callExpression(n.memberExpression(e3, n.identifier("call")), [t3, ...r3]);
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              e3.traverse(s2, { scope: e3.scope, bindingNames: t3, seen: new WeakSet() });
            };
            var n = r2(0);
            const s2 = { UpdateExpression: { exit(e3) {
              const { scope: t3, bindingNames: r3 } = this, s3 = e3.get("argument");
              if (!s3.isIdentifier())
                return;
              const i = s3.node.name;
              if (r3.has(i) && t3.getBinding(i) === e3.scope.getBinding(i))
                if (e3.parentPath.isExpressionStatement() && !e3.isCompletionRecord()) {
                  const t4 = e3.node.operator == "++" ? "+=" : "-=";
                  e3.replaceWith(n.assignmentExpression(t4, s3.node, n.numericLiteral(1)));
                } else if (e3.node.prefix)
                  e3.replaceWith(n.assignmentExpression("=", n.identifier(i), n.binaryExpression(e3.node.operator[0], n.unaryExpression("+", s3.node), n.numericLiteral(1))));
                else {
                  const t4 = e3.scope.generateUidIdentifierBasedOnNode(s3.node, "old"), r4 = t4.name;
                  e3.scope.push({ id: t4 });
                  const i2 = n.binaryExpression(e3.node.operator[0], n.identifier(r4), n.numericLiteral(1));
                  e3.replaceWith(n.sequenceExpression([n.assignmentExpression("=", n.identifier(r4), n.unaryExpression("+", s3.node)), n.assignmentExpression("=", n.cloneNode(s3.node), i2), n.identifier(r4)]));
                }
            } }, AssignmentExpression: { exit(e3) {
              const { scope: t3, seen: r3, bindingNames: s3 } = this;
              if (e3.node.operator === "=")
                return;
              if (r3.has(e3.node))
                return;
              r3.add(e3.node);
              const i = e3.get("left");
              if (!i.isIdentifier())
                return;
              const o = i.node.name;
              s3.has(o) && t3.getBinding(o) === e3.scope.getBinding(o) && (e3.node.right = n.binaryExpression(e3.node.operator.slice(0, -1), n.cloneNode(e3.node.left), e3.node.right), e3.node.operator = "=");
            } } };
          }, (e2, t2, r2) => {
            const n = r2(29);
            e2.exports = (e3, t3) => {
              const r3 = n(e3, t3);
              return r3 ? r3.version : null;
            };
          }, (e2, t2, r2) => {
            const n = r2(29);
            e2.exports = (e3, t3) => {
              const r3 = n(e3.trim().replace(/^[=v]+/, ""), t3);
              return r3 ? r3.version : null;
            };
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3, r3, s2) => {
              typeof r3 == "string" && (s2 = r3, r3 = void 0);
              try {
                return new n(e3, r3).inc(t3, s2).version;
              } catch (e4) {
                return null;
              }
            };
          }, (e2, t2, r2) => {
            const n = r2(29), s2 = r2(71);
            e2.exports = (e3, t3) => {
              if (s2(e3, t3))
                return null;
              {
                const r3 = n(e3), s3 = n(t3), i = r3.prerelease.length || s3.prerelease.length, o = i ? "pre" : "", a = i ? "prerelease" : "";
                for (const e4 in r3)
                  if ((e4 === "major" || e4 === "minor" || e4 === "patch") && r3[e4] !== s3[e4])
                    return o + e4;
                return a;
              }
            };
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3) => new n(e3, t3).major;
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3) => new n(e3, t3).minor;
          }, (e2, t2, r2) => {
            const n = r2(3);
            e2.exports = (e3, t3) => new n(e3, t3).patch;
          }, (e2, t2, r2) => {
            const n = r2(29);
            e2.exports = (e3, t3) => {
              const r3 = n(e3, t3);
              return r3 && r3.prerelease.length ? r3.prerelease : null;
            };
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3, r3) => n(t3, e3, r3);
          }, (e2, t2, r2) => {
            const n = r2(12);
            e2.exports = (e3, t3) => n(e3, t3, true);
          }, (e2, t2, r2) => {
            const n = r2(72);
            e2.exports = (e3, t3) => e3.sort((e4, r3) => n(e4, r3, t3));
          }, (e2, t2, r2) => {
            const n = r2(72);
            e2.exports = (e3, t3) => e3.sort((e4, r3) => n(r3, e4, t3));
          }, (e2, t2, r2) => {
            const n = r2(3), s2 = r2(29), { re: i, t: o } = r2(23);
            e2.exports = (e3, t3) => {
              if (e3 instanceof n)
                return e3;
              if (typeof e3 == "number" && (e3 = String(e3)), typeof e3 != "string")
                return null;
              let r3 = null;
              if ((t3 = t3 || {}).rtl) {
                let t4;
                for (; (t4 = i[o.COERCERTL].exec(e3)) && (!r3 || r3.index + r3[0].length !== e3.length); )
                  r3 && t4.index + t4[0].length === r3.index + r3[0].length || (r3 = t4), i[o.COERCERTL].lastIndex = t4.index + t4[1].length + t4[2].length;
                i[o.COERCERTL].lastIndex = -1;
              } else
                r3 = e3.match(i[o.COERCE]);
              return r3 === null ? null : s2(`${r3[2]}.${r3[3] || "0"}.${r3[4] || "0"}`, t3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3) {
              var t3 = this;
              if (t3 instanceof n || (t3 = new n()), t3.tail = null, t3.head = null, t3.length = 0, e3 && typeof e3.forEach == "function")
                e3.forEach(function(e4) {
                  t3.push(e4);
                });
              else if (arguments.length > 0)
                for (var r3 = 0, s3 = arguments.length; r3 < s3; r3++)
                  t3.push(arguments[r3]);
              return t3;
            }
            function s2(e3, t3, r3) {
              var n2 = t3 === e3.head ? new a(r3, null, t3, e3) : new a(r3, t3, t3.next, e3);
              return n2.next === null && (e3.tail = n2), n2.prev === null && (e3.head = n2), e3.length++, n2;
            }
            function i(e3, t3) {
              e3.tail = new a(t3, e3.tail, null, e3), e3.head || (e3.head = e3.tail), e3.length++;
            }
            function o(e3, t3) {
              e3.head = new a(t3, null, e3.head, e3), e3.tail || (e3.tail = e3.head), e3.length++;
            }
            function a(e3, t3, r3, n2) {
              if (!(this instanceof a))
                return new a(e3, t3, r3, n2);
              this.list = n2, this.value = e3, t3 ? (t3.next = this, this.prev = t3) : this.prev = null, r3 ? (r3.prev = this, this.next = r3) : this.next = null;
            }
            e2.exports = n, n.Node = a, n.create = n, n.prototype.removeNode = function(e3) {
              if (e3.list !== this)
                throw new Error("removing node which does not belong to this list");
              var t3 = e3.next, r3 = e3.prev;
              return t3 && (t3.prev = r3), r3 && (r3.next = t3), e3 === this.head && (this.head = t3), e3 === this.tail && (this.tail = r3), e3.list.length--, e3.next = null, e3.prev = null, e3.list = null, t3;
            }, n.prototype.unshiftNode = function(e3) {
              if (e3 !== this.head) {
                e3.list && e3.list.removeNode(e3);
                var t3 = this.head;
                e3.list = this, e3.next = t3, t3 && (t3.prev = e3), this.head = e3, this.tail || (this.tail = e3), this.length++;
              }
            }, n.prototype.pushNode = function(e3) {
              if (e3 !== this.tail) {
                e3.list && e3.list.removeNode(e3);
                var t3 = this.tail;
                e3.list = this, e3.prev = t3, t3 && (t3.next = e3), this.tail = e3, this.head || (this.head = e3), this.length++;
              }
            }, n.prototype.push = function() {
              for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++)
                i(this, arguments[e3]);
              return this.length;
            }, n.prototype.unshift = function() {
              for (var e3 = 0, t3 = arguments.length; e3 < t3; e3++)
                o(this, arguments[e3]);
              return this.length;
            }, n.prototype.pop = function() {
              if (this.tail) {
                var e3 = this.tail.value;
                return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e3;
              }
            }, n.prototype.shift = function() {
              if (this.head) {
                var e3 = this.head.value;
                return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e3;
              }
            }, n.prototype.forEach = function(e3, t3) {
              t3 = t3 || this;
              for (var r3 = this.head, n2 = 0; r3 !== null; n2++)
                e3.call(t3, r3.value, n2, this), r3 = r3.next;
            }, n.prototype.forEachReverse = function(e3, t3) {
              t3 = t3 || this;
              for (var r3 = this.tail, n2 = this.length - 1; r3 !== null; n2--)
                e3.call(t3, r3.value, n2, this), r3 = r3.prev;
            }, n.prototype.get = function(e3) {
              for (var t3 = 0, r3 = this.head; r3 !== null && t3 < e3; t3++)
                r3 = r3.next;
              if (t3 === e3 && r3 !== null)
                return r3.value;
            }, n.prototype.getReverse = function(e3) {
              for (var t3 = 0, r3 = this.tail; r3 !== null && t3 < e3; t3++)
                r3 = r3.prev;
              if (t3 === e3 && r3 !== null)
                return r3.value;
            }, n.prototype.map = function(e3, t3) {
              t3 = t3 || this;
              for (var r3 = new n(), s3 = this.head; s3 !== null; )
                r3.push(e3.call(t3, s3.value, this)), s3 = s3.next;
              return r3;
            }, n.prototype.mapReverse = function(e3, t3) {
              t3 = t3 || this;
              for (var r3 = new n(), s3 = this.tail; s3 !== null; )
                r3.push(e3.call(t3, s3.value, this)), s3 = s3.prev;
              return r3;
            }, n.prototype.reduce = function(e3, t3) {
              var r3, n2 = this.head;
              if (arguments.length > 1)
                r3 = t3;
              else {
                if (!this.head)
                  throw new TypeError("Reduce of empty list with no initial value");
                n2 = this.head.next, r3 = this.head.value;
              }
              for (var s3 = 0; n2 !== null; s3++)
                r3 = e3(r3, n2.value, s3), n2 = n2.next;
              return r3;
            }, n.prototype.reduceReverse = function(e3, t3) {
              var r3, n2 = this.tail;
              if (arguments.length > 1)
                r3 = t3;
              else {
                if (!this.tail)
                  throw new TypeError("Reduce of empty list with no initial value");
                n2 = this.tail.prev, r3 = this.tail.value;
              }
              for (var s3 = this.length - 1; n2 !== null; s3--)
                r3 = e3(r3, n2.value, s3), n2 = n2.prev;
              return r3;
            }, n.prototype.toArray = function() {
              for (var e3 = new Array(this.length), t3 = 0, r3 = this.head; r3 !== null; t3++)
                e3[t3] = r3.value, r3 = r3.next;
              return e3;
            }, n.prototype.toArrayReverse = function() {
              for (var e3 = new Array(this.length), t3 = 0, r3 = this.tail; r3 !== null; t3++)
                e3[t3] = r3.value, r3 = r3.prev;
              return e3;
            }, n.prototype.slice = function(e3, t3) {
              (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
              var r3 = new n();
              if (t3 < e3 || t3 < 0)
                return r3;
              e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
              for (var s3 = 0, i2 = this.head; i2 !== null && s3 < e3; s3++)
                i2 = i2.next;
              for (; i2 !== null && s3 < t3; s3++, i2 = i2.next)
                r3.push(i2.value);
              return r3;
            }, n.prototype.sliceReverse = function(e3, t3) {
              (t3 = t3 || this.length) < 0 && (t3 += this.length), (e3 = e3 || 0) < 0 && (e3 += this.length);
              var r3 = new n();
              if (t3 < e3 || t3 < 0)
                return r3;
              e3 < 0 && (e3 = 0), t3 > this.length && (t3 = this.length);
              for (var s3 = this.length, i2 = this.tail; i2 !== null && s3 > t3; s3--)
                i2 = i2.prev;
              for (; i2 !== null && s3 > e3; s3--, i2 = i2.prev)
                r3.push(i2.value);
              return r3;
            }, n.prototype.splice = function(e3, t3, ...r3) {
              e3 > this.length && (e3 = this.length - 1), e3 < 0 && (e3 = this.length + e3);
              for (var n2 = 0, i2 = this.head; i2 !== null && n2 < e3; n2++)
                i2 = i2.next;
              var o2 = [];
              for (n2 = 0; i2 && n2 < t3; n2++)
                o2.push(i2.value), i2 = this.removeNode(i2);
              for (i2 === null && (i2 = this.tail), i2 !== this.head && i2 !== this.tail && (i2 = i2.prev), n2 = 0; n2 < r3.length; n2++)
                i2 = s2(this, i2, r3[n2]);
              return o2;
            }, n.prototype.reverse = function() {
              for (var e3 = this.head, t3 = this.tail, r3 = e3; r3 !== null; r3 = r3.prev) {
                var n2 = r3.prev;
                r3.prev = r3.next, r3.next = n2;
              }
              return this.head = t3, this.tail = e3, this;
            };
            try {
              r2(275)(n);
            } catch (e3) {
            }
          }, (e2) => {
            "use strict";
            e2.exports = function(e3) {
              e3.prototype[Symbol.iterator] = function* () {
                for (let e4 = this.head; e4; e4 = e4.next)
                  yield e4.value;
              };
            };
          }, (e2, t2, r2) => {
            const n = r2(13);
            e2.exports = (e3, t3) => new n(e3, t3).set.map((e4) => e4.map((e5) => e5.value).join(" ").trim().split(" "));
          }, (e2, t2, r2) => {
            const n = r2(3), s2 = r2(13);
            e2.exports = (e3, t3, r3) => {
              let i = null, o = null, a = null;
              try {
                a = new s2(t3, r3);
              } catch (e4) {
                return null;
              }
              return e3.forEach((e4) => {
                a.test(e4) && (i && o.compare(e4) !== -1 || (i = e4, o = new n(i, r3)));
              }), i;
            };
          }, (e2, t2, r2) => {
            const n = r2(3), s2 = r2(13);
            e2.exports = (e3, t3, r3) => {
              let i = null, o = null, a = null;
              try {
                a = new s2(t3, r3);
              } catch (e4) {
                return null;
              }
              return e3.forEach((e4) => {
                a.test(e4) && (i && o.compare(e4) !== 1 || (i = e4, o = new n(i, r3)));
              }), i;
            };
          }, (e2, t2, r2) => {
            const n = r2(3), s2 = r2(13), i = r2(44);
            e2.exports = (e3, t3) => {
              e3 = new s2(e3, t3);
              let r3 = new n("0.0.0");
              if (e3.test(r3))
                return r3;
              if (r3 = new n("0.0.0-0"), e3.test(r3))
                return r3;
              r3 = null;
              for (let t4 = 0; t4 < e3.set.length; ++t4) {
                const s3 = e3.set[t4];
                let o = null;
                s3.forEach((e4) => {
                  const t5 = new n(e4.semver.version);
                  switch (e4.operator) {
                    case ">":
                      t5.prerelease.length === 0 ? t5.patch++ : t5.prerelease.push(0), t5.raw = t5.format();
                    case "":
                    case ">=":
                      o && !i(t5, o) || (o = t5);
                      break;
                    case "<":
                    case "<=":
                      break;
                    default:
                      throw new Error(`Unexpected operation: ${e4.operator}`);
                  }
                }), !o || r3 && !i(r3, o) || (r3 = o);
              }
              return r3 && e3.test(r3) ? r3 : null;
            };
          }, (e2, t2, r2) => {
            const n = r2(13);
            e2.exports = (e3, t3) => {
              try {
                return new n(e3, t3).range || "*";
              } catch (e4) {
                return null;
              }
            };
          }, (e2, t2, r2) => {
            const n = r2(76);
            e2.exports = (e3, t3, r3) => n(e3, t3, ">", r3);
          }, (e2, t2, r2) => {
            const n = r2(76);
            e2.exports = (e3, t3, r3) => n(e3, t3, "<", r3);
          }, (e2, t2, r2) => {
            const n = r2(13);
            e2.exports = (e3, t3, r3) => (e3 = new n(e3, r3), t3 = new n(t3, r3), e3.intersects(t3));
          }, (e2, t2, r2) => {
            const n = r2(46), s2 = r2(12);
            e2.exports = (e3, t3, r3) => {
              const i = [];
              let o = null, a = null;
              const l = e3.sort((e4, t4) => s2(e4, t4, r3));
              for (const e4 of l)
                n(e4, t3, r3) ? (a = e4, o || (o = e4)) : (a && i.push([o, a]), a = null, o = null);
              o && i.push([o, null]);
              const c = [];
              for (const [e4, t4] of i)
                e4 === t4 ? c.push(e4) : t4 || e4 !== l[0] ? t4 ? e4 === l[0] ? c.push(`<=${t4}`) : c.push(`${e4} - ${t4}`) : c.push(`>=${e4}`) : c.push("*");
              const u = c.join(" || "), p2 = typeof t3.raw == "string" ? t3.raw : String(t3);
              return u.length < p2.length ? u : t3;
            };
          }, (e2, t2, r2) => {
            const n = r2(13), s2 = r2(45), { ANY: i } = s2, o = r2(46), a = r2(12), l = (e3, t3, r3) => {
              if (e3 === t3)
                return true;
              if (e3.length === 1 && e3[0].semver === i) {
                if (t3.length === 1 && t3[0].semver === i)
                  return true;
                e3 = r3.includePrerelease ? [new s2(">=0.0.0-0")] : [new s2(">=0.0.0")];
              }
              if (t3.length === 1 && t3[0].semver === i) {
                if (r3.includePrerelease)
                  return true;
                t3 = [new s2(">=0.0.0")];
              }
              const n2 = new Set();
              let l2, p2, f, d, h3, m, y;
              for (const t4 of e3)
                t4.operator === ">" || t4.operator === ">=" ? l2 = c(l2, t4, r3) : t4.operator === "<" || t4.operator === "<=" ? p2 = u(p2, t4, r3) : n2.add(t4.semver);
              if (n2.size > 1)
                return null;
              if (l2 && p2) {
                if (f = a(l2.semver, p2.semver, r3), f > 0)
                  return null;
                if (f === 0 && (l2.operator !== ">=" || p2.operator !== "<="))
                  return null;
              }
              for (const e4 of n2) {
                if (l2 && !o(e4, String(l2), r3))
                  return null;
                if (p2 && !o(e4, String(p2), r3))
                  return null;
                for (const n3 of t3)
                  if (!o(e4, String(n3), r3))
                    return false;
                return true;
              }
              let g = !(!p2 || r3.includePrerelease || !p2.semver.prerelease.length) && p2.semver, b = !(!l2 || r3.includePrerelease || !l2.semver.prerelease.length) && l2.semver;
              g && g.prerelease.length === 1 && p2.operator === "<" && g.prerelease[0] === 0 && (g = false);
              for (const e4 of t3) {
                if (y = y || e4.operator === ">" || e4.operator === ">=", m = m || e4.operator === "<" || e4.operator === "<=", l2) {
                  if (b && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === b.major && e4.semver.minor === b.minor && e4.semver.patch === b.patch && (b = false), e4.operator === ">" || e4.operator === ">=") {
                    if (d = c(l2, e4, r3), d === e4 && d !== l2)
                      return false;
                  } else if (l2.operator === ">=" && !o(l2.semver, String(e4), r3))
                    return false;
                }
                if (p2) {
                  if (g && e4.semver.prerelease && e4.semver.prerelease.length && e4.semver.major === g.major && e4.semver.minor === g.minor && e4.semver.patch === g.patch && (g = false), e4.operator === "<" || e4.operator === "<=") {
                    if (h3 = u(p2, e4, r3), h3 === e4 && h3 !== p2)
                      return false;
                  } else if (p2.operator === "<=" && !o(p2.semver, String(e4), r3))
                    return false;
                }
                if (!e4.operator && (p2 || l2) && f !== 0)
                  return false;
              }
              return !(l2 && m && !p2 && f !== 0 || p2 && y && !l2 && f !== 0 || b || g);
            }, c = (e3, t3, r3) => {
              if (!e3)
                return t3;
              const n2 = a(e3.semver, t3.semver, r3);
              return n2 > 0 ? e3 : n2 < 0 || t3.operator === ">" && e3.operator === ">=" ? t3 : e3;
            }, u = (e3, t3, r3) => {
              if (!e3)
                return t3;
              const n2 = a(e3.semver, t3.semver, r3);
              return n2 < 0 ? e3 : n2 > 0 || t3.operator === "<" && e3.operator === "<=" ? t3 : e3;
            };
            e2.exports = (e3, t3, r3 = {}) => {
              if (e3 === t3)
                return true;
              e3 = new n(e3, r3), t3 = new n(t3, r3);
              let s3 = false;
              e:
                for (const n2 of e3.set) {
                  for (const e4 of t3.set) {
                    const t4 = l(n2, e4, r3);
                    if (s3 = s3 || t4 !== null, t4)
                      continue e;
                  }
                  if (s3)
                    return false;
                }
              return true;
            };
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.getEnv = function(e3 = "development") {
              return "production";
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.maybeAsync = function(e3, t3) {
              return n()({ sync(...r3) {
                const n2 = e3.apply(this, r3);
                if (u(n2))
                  throw new Error(t3);
                return n2;
              }, async(...t4) {
                return Promise.resolve(e3.apply(this, t4));
              } });
            }, t2.forwardAsync = function(e3, t3) {
              const r3 = n()(e3);
              return a((e4) => {
                const n2 = r3[e4];
                return t3(n2);
              });
            }, t2.isThenable = u, t2.waitFor = t2.onFirstPause = t2.isAsync = void 0;
            const s2 = (e3) => e3, i = n()(function* (e3) {
              return yield* e3;
            }), o = n()({ sync: () => false, errback: (e3) => e3(null, true) });
            t2.isAsync = o;
            const a = n()({ sync: (e3) => e3("sync"), async: (e3) => e3("async") }), l = n()({ name: "onFirstPause", arity: 2, sync: function(e3) {
              return i.sync(e3);
            }, errback: function(e3, t3, r3) {
              let n2 = false;
              i.errback(e3, (e4, t4) => {
                n2 = true, r3(e4, t4);
              }), n2 || t3();
            } });
            t2.onFirstPause = l;
            const c = n()({ sync: s2, async: s2 });
            function u(e3) {
              return !(!e3 || typeof e3 != "object" && typeof e3 != "function" || !e3.then || typeof e3.then != "function");
            }
            t2.waitFor = c;
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.createCachedDescriptors = function(e3, t3, r3) {
              const { plugins: n2, presets: s3, passPerPreset: i2 } = t3;
              return { options: c(t3, e3), plugins: n2 ? () => d(n2, e3)(r3) : () => l([]), presets: s3 ? () => p2(s3, e3)(r3)(!!i2) : () => l([]) };
            }, t2.createUncachedDescriptors = function(e3, t3, r3) {
              let n2, s3;
              return { options: c(t3, e3), *plugins() {
                return n2 || (n2 = yield* g(t3.plugins || [], e3, r3)), n2;
              }, *presets() {
                return s3 || (s3 = yield* y(t3.presets || [], e3, r3, !!t3.passPerPreset)), s3;
              } };
            }, t2.createDescriptor = v;
            var s2 = r2(77), i = r2(80), o = r2(81), a = r2(289);
            function* l(e3) {
              return e3;
            }
            function c(e3, t3) {
              return typeof e3.browserslistConfigFile == "string" && (e3.browserslistConfigFile = (0, a.resolveBrowserslistConfigFile)(e3.browserslistConfigFile, t3)), e3;
            }
            const u = new WeakMap(), p2 = (0, o.makeWeakCacheSync)((e3, t3) => {
              const r3 = t3.using((e4) => e4);
              return (0, o.makeStrongCacheSync)((t4) => (0, o.makeStrongCache)(function* (n2) {
                return (yield* y(e3, r3, t4, n2)).map((e4) => m(u, e4));
              }));
            }), f = new WeakMap(), d = (0, o.makeWeakCacheSync)((e3, t3) => {
              const r3 = t3.using((e4) => e4);
              return (0, o.makeStrongCache)(function* (t4) {
                return (yield* g(e3, r3, t4)).map((e4) => m(f, e4));
              });
            }), h3 = {};
            function m(e3, t3) {
              const { value: r3, options: n2 = h3 } = t3;
              if (n2 === false)
                return t3;
              let s3 = e3.get(r3);
              s3 || (s3 = new WeakMap(), e3.set(r3, s3));
              let i2 = s3.get(n2);
              if (i2 || (i2 = [], s3.set(n2, i2)), i2.indexOf(t3) === -1) {
                const e4 = i2.filter((e5) => {
                  return n3 = t3, (r4 = e5).name === n3.name && r4.value === n3.value && r4.options === n3.options && r4.dirname === n3.dirname && r4.alias === n3.alias && r4.ownPass === n3.ownPass && (r4.file && r4.file.request) === (n3.file && n3.file.request) && (r4.file && r4.file.resolved) === (n3.file && n3.file.resolved);
                  var r4, n3;
                });
                if (e4.length > 0)
                  return e4[0];
                i2.push(t3);
              }
              return t3;
            }
            function* y(e3, t3, r3, n2) {
              return yield* b("preset", e3, t3, r3, n2);
            }
            function* g(e3, t3, r3) {
              return yield* b("plugin", e3, t3, r3);
            }
            function* b(e3, t3, r3, s3, i2) {
              const o2 = yield* n().all(t3.map((t4, n2) => v(t4, r3, { type: e3, alias: `${s3}$${n2}`, ownPass: !!i2 })));
              return function(e4) {
                const t4 = new Map();
                for (const r4 of e4) {
                  if (typeof r4.value != "function")
                    continue;
                  let n2 = t4.get(r4.value);
                  if (n2 || (n2 = new Set(), t4.set(r4.value, n2)), n2.has(r4.name)) {
                    const t5 = e4.filter((e5) => e5.value === r4.value);
                    throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", `${JSON.stringify(t5, null, 2)}`].join("\n"));
                  }
                  n2.add(r4.name);
                }
              }(o2), o2;
            }
            function* v(e3, t3, { type: r3, alias: n2, ownPass: o2 }) {
              const a2 = (0, i.getItemDescriptor)(e3);
              if (a2)
                return a2;
              let l2, c4, u2, p3 = e3;
              Array.isArray(p3) && (p3.length === 3 ? [p3, c4, l2] = p3 : [p3, c4] = p3);
              let f2 = null;
              if (typeof p3 == "string") {
                if (typeof r3 != "string")
                  throw new Error("To resolve a string-based item, the type of item must be given");
                const e4 = r3 === "plugin" ? s2.loadPlugin : s2.loadPreset, n3 = p3;
                ({ filepath: f2, value: p3 } = yield* e4(p3, t3)), u2 = { request: n3, resolved: f2 };
              }
              if (!p3)
                throw new Error(`Unexpected falsy value: ${String(p3)}`);
              if (typeof p3 == "object" && p3.__esModule) {
                if (!p3.default)
                  throw new Error("Must export a default export when using ES6 modules.");
                p3 = p3.default;
              }
              if (typeof p3 != "object" && typeof p3 != "function")
                throw new Error(`Unsupported format: ${typeof p3}. Expected an object or a function.`);
              if (f2 !== null && typeof p3 == "object" && p3)
                throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${f2}`);
              return { name: l2, alias: f2 || n2, value: p3, options: c4, dirname: t3, ownPass: o2, file: u2 };
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(290);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.resolveBrowserslistConfigFile = function(e3, t3) {
            }, t2.resolveTargets = function(e3, t3) {
              let r3 = e3.targets;
              return (typeof r3 == "string" || Array.isArray(r3)) && (r3 = { browsers: r3 }), r3 && r3.esmodules && (r3 = Object.assign({}, r3, { esmodules: "intersect" })), (0, n().default)(r3, { ignoreBrowserslistConfig: true, browserslistEnv: e3.browserslistEnv });
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7);
            Object.defineProperty(t2, "__esModule", { value: true }), t2.isBrowsersQueryValid = m, t2.default = function(e3 = {}, t3 = {}) {
              var r3;
              let { browsers: n2, esmodules: o2 } = e3;
              const { configPath: u2 = "." } = t3;
              !function(e4) {
                h3.invariant(e4 === void 0 || m(e4), `'${String(e4)}' is not a valid browserslist query`);
              }(n2);
              let p3 = function(e4) {
                const t4 = Object.keys(c.TargetNames);
                for (const r4 of Object.keys(e4))
                  if (!(r4 in c.TargetNames))
                    throw new Error(h3.formatMessage(`'${r4}' is not a valid target
- Did you mean '${(0, i.findSuggestion)(r4, t4)}'?`));
                return e4;
              }(function(e4) {
                const t4 = Object.assign({}, e4);
                return delete t4.esmodules, delete t4.browsers, t4;
              }(e3));
              const f2 = !!n2 || Object.keys(p3).length > 0, y2 = !t3.ignoreBrowserslistConfig && !f2;
              if (!n2 && y2 && (n2 = s2.loadConfig({ config: t3.configFile, path: u2, env: t3.browserslistEnv }), n2 == null && (n2 = [])), !o2 || o2 === "intersect" && (r3 = n2) != null && r3.length || (n2 = Object.keys(d).map((e4) => `${e4} >= ${d[e4]}`).join(", "), o2 = false), n2) {
                const e4 = function(e5) {
                  return e5.reduce((e6, t4) => {
                    const [r4, n3] = t4.split(" "), s3 = l.browserNameMap[r4];
                    if (!s3)
                      return e6;
                    try {
                      const t5 = n3.split("-")[0].toLowerCase(), i2 = (0, a.isUnreleasedVersion)(t5, r4);
                      if (!e6[s3])
                        return e6[s3] = i2 ? t5 : (0, a.semverify)(t5), e6;
                      const o3 = e6[s3], l2 = (0, a.isUnreleasedVersion)(o3, r4);
                      if (l2 && i2)
                        e6[s3] = (0, a.getLowestUnreleased)(o3, t5, r4);
                      else if (l2)
                        e6[s3] = (0, a.semverify)(t5);
                      else if (!l2 && !i2) {
                        const r5 = (0, a.semverify)(t5);
                        e6[s3] = (0, a.semverMin)(o3, r5);
                      }
                    } catch (e7) {
                    }
                    return e6;
                  }, {});
                }(s2(n2, { mobileToDesktop: true }));
                if (o2 === "intersect")
                  for (const t4 of Object.keys(e4)) {
                    const r4 = e4[t4];
                    d[t4] ? e4[t4] = (0, a.getHighestUnreleased)(r4, (0, a.semverify)(d[t4]), t4) : delete e4[t4];
                  }
                p3 = Object.assign(e4, p3);
              }
              const b = {}, v = [];
              for (const e4 of Object.keys(p3).sort()) {
                var E;
                const t4 = p3[e4];
                typeof t4 == "number" && t4 % 1 != 0 && v.push({ target: e4, value: t4 });
                const r4 = (E = g[e4]) != null ? E : g.__default, [n3, s3] = r4(e4, t4);
                s3 && (b[n3] = s3);
              }
              return (x = v).length && x.forEach(({ target: e4, value: t4 }) => {
              }), b;
              var x;
            }, Object.defineProperty(t2, "unreleasedLabels", { enumerable: true, get: function() {
              return l.unreleasedLabels;
            } }), Object.defineProperty(t2, "TargetNames", { enumerable: true, get: function() {
              return c.TargetNames;
            } }), Object.defineProperty(t2, "prettifyTargets", { enumerable: true, get: function() {
              return u.prettifyTargets;
            } }), Object.defineProperty(t2, "getInclusionReasons", { enumerable: true, get: function() {
              return p2.getInclusionReasons;
            } }), Object.defineProperty(t2, "filterItems", { enumerable: true, get: function() {
              return f.default;
            } }), Object.defineProperty(t2, "isRequired", { enumerable: true, get: function() {
              return f.isRequired;
            } });
            var s2 = r2(291), i = r2(297), o = r2(474), a = r2(152), l = r2(153), c = r2(476), u = r2(299), p2 = r2(477), f = r2(478);
            const d = o["es6.module"], h3 = new i.OptionValidator("@babel/helper-compilation-targets");
            function m(e3) {
              return typeof e3 == "string" || Array.isArray(e3) && e3.every((e4) => typeof e4 == "string");
            }
            function y(e3, t3) {
              try {
                return (0, a.semverify)(t3);
              } catch (r3) {
                throw new Error(h3.formatMessage(`'${t3}' is not a valid value for 'targets.${e3}'.`));
              }
            }
            const g = { __default: (e3, t3) => [e3, (0, a.isUnreleasedVersion)(t3, e3) ? t3.toLowerCase() : y(e3, t3)], node: (e3, t3) => [e3, t3 === true || t3 === "current" ? n.versions.node : y(e3, t3)] };
          }, (e2, t2, r2) => {
            var n = r2(7), s2 = r2(467), i = r2(468).a, o = r2(471), a = r2(472), l = r2(295), c = r2(151), u = r2(296);
            function p2(e3, t3) {
              return (e3 + ".").indexOf(t3 + ".") === 0;
            }
            function f(e3) {
              return e3.filter(function(e4) {
                return typeof e4 == "string";
              });
            }
            function d(e3) {
              var t3 = e3;
              return e3.split(".").length === 3 && (t3 = e3.split(".").slice(0, -1).join(".")), t3;
            }
            function h3(e3) {
              return function(t3) {
                return e3 + " " + t3;
              };
            }
            function m(e3) {
              return parseInt(e3.split(".")[0]);
            }
            function y(e3, t3) {
              if (e3.length === 0)
                return [];
              var r3 = g(e3.map(m)), n2 = r3[r3.length - t3];
              if (!n2)
                return e3;
              for (var s3 = [], i2 = e3.length - 1; i2 >= 0 && !(n2 > m(e3[i2])); i2--)
                s3.unshift(e3[i2]);
              return s3;
            }
            function g(e3) {
              for (var t3 = [], r3 = 0; r3 < e3.length; r3++)
                t3.indexOf(e3[r3]) === -1 && t3.push(e3[r3]);
              return t3;
            }
            function b(e3, t3, r3) {
              for (var n2 in r3)
                e3[t3 + " " + n2] = r3[n2];
            }
            function v(e3, t3) {
              return t3 = parseFloat(t3), e3 === ">" ? function(e4) {
                return parseFloat(e4) > t3;
              } : e3 === ">=" ? function(e4) {
                return parseFloat(e4) >= t3;
              } : e3 === "<" ? function(e4) {
                return parseFloat(e4) < t3;
              } : function(e4) {
                return parseFloat(e4) <= t3;
              };
            }
            function E(e3) {
              return parseInt(e3);
            }
            function x(e3, t3) {
              return e3 < t3 ? -1 : e3 > t3 ? 1 : 0;
            }
            function S(e3, t3) {
              return x(parseInt(e3[0]), parseInt(t3[0])) || x(parseInt(e3[1] || "0"), parseInt(t3[1] || "0")) || x(parseInt(e3[2] || "0"), parseInt(t3[2] || "0"));
            }
            function T(e3, t3) {
              switch ((t3 = t3.split(".").map(E))[1] === void 0 && (t3[1] = "x"), e3) {
                case "<=":
                  return function(e4) {
                    return w(e4 = e4.split(".").map(E), t3) <= 0;
                  };
                default:
                case ">=":
                  return function(e4) {
                    return w(e4 = e4.split(".").map(E), t3) >= 0;
                  };
              }
            }
            function w(e3, t3) {
              return e3[0] !== t3[0] ? e3[0] < t3[0] ? -1 : 1 : t3[1] === "x" ? 0 : e3[1] !== t3[1] ? e3[1] < t3[1] ? -1 : 1 : 0;
            }
            function P(e3, t3) {
              return function(e4, t4) {
                return e4.versions.indexOf(t4) !== -1 ? t4 : !!L.versionAliases[e4.name][t4] && L.versionAliases[e4.name][t4];
              }(e3, t3) || e3.versions.length === 1 && e3.versions[0];
            }
            function A(e3, t3) {
              return e3 /= 1e3, Object.keys(i).reduce(function(r3, n2) {
                var s3 = C(n2, t3);
                if (!s3)
                  return r3;
                var i2 = Object.keys(s3.releaseDate).filter(function(t4) {
                  return s3.releaseDate[t4] >= e3;
                });
                return r3.concat(i2.map(h3(s3.name)));
              }, []);
            }
            function O(e3) {
              return { name: e3.name, versions: e3.versions, released: e3.released, releaseDate: e3.releaseDate };
            }
            function C(e3, t3) {
              if (e3 = e3.toLowerCase(), e3 = L.aliases[e3] || e3, t3.mobileToDesktop && L.desktopNames[e3]) {
                var r3 = L.data[L.desktopNames[e3]];
                if (e3 === "android")
                  return i2 = r3, (s3 = O(L.data[e3])).released = I(s3.released, i2.released), s3.versions = I(s3.versions, i2.versions), s3;
                var n2 = O(r3);
                return n2.name = e3, e3 === "op_mob" && (n2 = function(e4, t4) {
                  e4.versions = e4.versions.map(function(e5) {
                    return t4[e5] || e5;
                  }), e4.released = e4.versions.map(function(e5) {
                    return t4[e5] || e5;
                  });
                  var r4 = {};
                  for (var n3 in e4.releaseDate)
                    r4[t4[n3] || n3] = e4.releaseDate[n3];
                  return e4.releaseDate = r4, e4;
                }(n2, { "10.0-10.1": "10" })), n2;
              }
              var s3, i2;
              return L.data[e3];
            }
            function I(e3, t3) {
              var r3 = t3[t3.length - 1];
              return e3.filter(function(e4) {
                return /^(?:[2-4]\.|[34]$)/.test(e4);
              }).concat(t3.slice(37 - r3 - 1));
            }
            function k2(e3, t3) {
              var r3 = C(e3, t3);
              if (!r3)
                throw new c("Unknown browser " + e3);
              return r3;
            }
            function N(e3) {
              return new c("Unknown browser query `" + e3 + "`. Maybe you are using old Browserslist or made typo in query.");
            }
            function _(e3, t3, r3) {
              if (r3.mobileToDesktop)
                return e3;
              var n2 = L.data.android.released, s3 = n2[n2.length - 1] - 37 - t3;
              return s3 > 0 ? e3.slice(-1) : e3.slice(s3 - 1);
            }
            function j(e3, t3) {
              return (e3 = Array.isArray(e3) ? R(e3.map(M)) : M(e3)).reduce(function(e4, r3, n2) {
                var s3 = r3.queryString, i2 = s3.indexOf("not ") === 0;
                if (i2) {
                  if (n2 === 0)
                    throw new c("Write any browsers query (for instance, `defaults`) before `" + s3 + "`");
                  s3 = s3.slice(4);
                }
                for (var o2 = 0; o2 < q.length; o2++) {
                  var a2 = q[o2], l2 = s3.match(a2.regexp);
                  if (l2) {
                    var u2 = [t3].concat(l2.slice(1)), p3 = a2.select.apply(L, u2).map(function(e5) {
                      var r4 = e5.split(" ");
                      return r4[1] === "0" ? r4[0] + " " + C(r4[0], t3).versions[0] : e5;
                    });
                    switch (r3.type) {
                      case 2:
                        return i2 ? e4.filter(function(e5) {
                          return p3.indexOf(e5) === -1;
                        }) : e4.filter(function(e5) {
                          return p3.indexOf(e5) !== -1;
                        });
                      case 1:
                      default:
                        if (i2) {
                          var f2 = {};
                          return p3.forEach(function(e5) {
                            f2[e5] = true;
                          }), e4.filter(function(e5) {
                            return !f2[e5];
                          });
                        }
                        return e4.concat(p3);
                    }
                  }
                }
                throw N(s3);
              }, []);
            }
            var D = {};
            function L(e3, t3) {
              (t3 === void 0 && (t3 = {}), t3.path === void 0 && (t3.path = a.resolve ? a.resolve(".") : "."), e3 == null) && (e3 = L.loadConfig(t3) || L.defaults);
              if (typeof e3 != "string" && !Array.isArray(e3))
                throw new c("Browser queries must be an array or string. Got " + typeof e3 + ".");
              var r3 = { ignoreUnknownVersions: t3.ignoreUnknownVersions, dangerousExtend: t3.dangerousExtend, mobileToDesktop: t3.mobileToDesktop, path: t3.path, env: t3.env };
              u.oldDataWarning(L.data);
              var s3 = u.getStat(t3, L.data);
              if (s3)
                for (var i2 in r3.customUsage = {}, s3)
                  b(r3.customUsage, i2, s3[i2]);
              var o2 = JSON.stringify([e3, r3]);
              if (D[o2])
                return D[o2];
              var l2 = g(j(e3, r3)).sort(function(e4, t4) {
                if (e4 = e4.split(" "), t4 = t4.split(" "), e4[0] === t4[0]) {
                  var r4 = e4[1].split("-")[0];
                  return S(t4[1].split("-")[0].split("."), r4.split("."));
                }
                return x(e4[0], t4[0]);
              });
              return n.env.BROWSERSLIST_DISABLE_CACHE || (D[o2] = l2), l2;
            }
            function M(e3) {
              var t3 = [];
              do {
                e3 = B(e3, t3);
              } while (e3);
              return t3;
            }
            function B(e3, t3) {
              var r3 = /^(?:,\s*|\s+or\s+)(.*)/i, n2 = /^\s+and\s+(.*)/i;
              return function(e4, t4) {
                for (var r4 = 1, n3 = e4.length; r4 <= n3; r4++)
                  if (t4(e4.substr(-r4, r4), r4, n3))
                    return e4.slice(0, -r4);
                return "";
              }(e3, function(e4, s3, i2) {
                return n2.test(e4) ? (t3.unshift({ type: 2, queryString: e4.match(n2)[1] }), true) : r3.test(e4) ? (t3.unshift({ type: 1, queryString: e4.match(r3)[1] }), true) : s3 === i2 && (t3.unshift({ type: 1, queryString: e4.trim() }), true);
              });
            }
            function R(e3) {
              return Array.isArray(e3) ? e3.reduce(function(e4, t3) {
                return e4.concat(R(t3));
              }, []) : [e3];
            }
            function F(e3, t3) {
              var r3 = s2.filter(function(e4) {
                return e4.name === "nodejs";
              }).filter(function(e4) {
                return p2(e4.version, t3);
              });
              if (r3.length === 0) {
                if (e3.ignoreUnknownVersions)
                  return [];
                throw new c("Unknown version " + t3 + " of Node.js");
              }
              return ["node " + r3[r3.length - 1].version];
            }
            function U(e3, t3, r3, n2) {
              return t3 = parseInt(t3), r3 = parseInt(r3 || "01") - 1, n2 = parseInt(n2 || "01"), A(Date.UTC(t3, r3, n2, 0, 0, 0), e3);
            }
            function $(e3, t3, r3) {
              t3 = parseFloat(t3);
              var n2 = L.usage.global;
              if (r3)
                if (r3.match(/^my\s+stats$/)) {
                  if (!e3.customUsage)
                    throw new c("Custom usage statistics was not provided");
                  n2 = e3.customUsage;
                } else {
                  var s3;
                  s3 = r3.length === 2 ? r3.toUpperCase() : r3.toLowerCase(), u.loadCountry(L.usage, s3, L.data), n2 = L.usage[s3];
                }
              for (var i2, o2 = Object.keys(n2).sort(function(e4, t4) {
                return n2[t4] - n2[e4];
              }), a2 = 0, l2 = [], p3 = 0; p3 <= o2.length && (i2 = o2[p3], n2[i2] !== 0) && (a2 += n2[i2], l2.push(i2), !(a2 >= t3)); p3++)
                ;
              return l2;
            }
            L.cache = {}, L.data = {}, L.usage = { global: {}, custom: null }, L.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"], L.aliases = { fx: "firefox", ff: "firefox", ios: "ios_saf", explorer: "ie", blackberry: "bb", explorermobile: "ie_mob", operamini: "op_mini", operamobile: "op_mob", chromeandroid: "and_chr", firefoxandroid: "and_ff", ucandroid: "and_uc", qqandroid: "and_qq" }, L.desktopNames = { and_chr: "chrome", and_ff: "firefox", ie_mob: "ie", op_mob: "opera", android: "chrome" }, L.versionAliases = {}, L.clearCaches = u.clearCaches, L.parseConfig = u.parseConfig, L.readConfig = u.readConfig, L.findConfig = u.findConfig, L.loadConfig = u.loadConfig, L.coverage = function(e3, t3) {
              var r3;
              if (t3 === void 0)
                r3 = L.usage.global;
              else if (t3 === "my stats") {
                var n2 = {};
                n2.path = a.resolve ? a.resolve(".") : ".";
                var s3 = u.getStat(n2);
                if (!s3)
                  throw new c("Custom usage statistics was not provided");
                for (var i2 in r3 = {}, s3)
                  b(r3, i2, s3[i2]);
              } else if (typeof t3 == "string")
                t3 = t3.length > 2 ? t3.toLowerCase() : t3.toUpperCase(), u.loadCountry(L.usage, t3, L.data), r3 = L.usage[t3];
              else
                for (var o2 in "dataByBrowser" in t3 && (t3 = t3.dataByBrowser), r3 = {}, t3)
                  for (var l2 in t3[o2])
                    r3[o2 + " " + l2] = t3[o2][l2];
              return e3.reduce(function(e4, t4) {
                var n3 = r3[t4];
                return n3 === void 0 && (n3 = r3[t4.replace(/ \S+$/, " 0")]), e4 + (n3 || 0);
              }, 0);
            };
            var q = [{ regexp: /^last\s+(\d+)\s+major\s+versions?$/i, select: function(e3, t3) {
              return Object.keys(i).reduce(function(r3, n2) {
                var s3 = C(n2, e3);
                if (!s3)
                  return r3;
                var i2 = y(s3.released, t3);
                return i2 = i2.map(h3(s3.name)), s3.name === "android" && (i2 = _(i2, t3, e3)), r3.concat(i2);
              }, []);
            } }, { regexp: /^last\s+(\d+)\s+versions?$/i, select: function(e3, t3) {
              return Object.keys(i).reduce(function(r3, n2) {
                var s3 = C(n2, e3);
                if (!s3)
                  return r3;
                var i2 = s3.released.slice(-t3);
                return i2 = i2.map(h3(s3.name)), s3.name === "android" && (i2 = _(i2, t3, e3)), r3.concat(i2);
              }, []);
            } }, { regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i, select: function(e3, t3) {
              return y(Object.keys(l), t3).map(function(e4) {
                return "chrome " + l[e4];
              });
            } }, { regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i, select: function(e3, t3, r3) {
              var n2 = k2(r3, e3), s3 = y(n2.released, t3).map(h3(n2.name));
              return n2.name === "android" && (s3 = _(s3, t3, e3)), s3;
            } }, { regexp: /^last\s+(\d+)\s+electron\s+versions?$/i, select: function(e3, t3) {
              return Object.keys(l).slice(-t3).map(function(e4) {
                return "chrome " + l[e4];
              });
            } }, { regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i, select: function(e3, t3, r3) {
              var n2 = k2(r3, e3), s3 = n2.released.slice(-t3).map(h3(n2.name));
              return n2.name === "android" && (s3 = _(s3, t3, e3)), s3;
            } }, { regexp: /^unreleased\s+versions$/i, select: function(e3) {
              return Object.keys(i).reduce(function(t3, r3) {
                var n2 = C(r3, e3);
                if (!n2)
                  return t3;
                var s3 = n2.versions.filter(function(e4) {
                  return n2.released.indexOf(e4) === -1;
                });
                return s3 = s3.map(h3(n2.name)), t3.concat(s3);
              }, []);
            } }, { regexp: /^unreleased\s+electron\s+versions?$/i, select: function() {
              return [];
            } }, { regexp: /^unreleased\s+(\w+)\s+versions?$/i, select: function(e3, t3) {
              var r3 = k2(t3, e3);
              return r3.versions.filter(function(e4) {
                return r3.released.indexOf(e4) === -1;
              }).map(h3(r3.name));
            } }, { regexp: /^last\s+(\d*.?\d+)\s+years?$/i, select: function(e3, t3) {
              return A(Date.now() - 315584329824e-1 * t3, e3);
            } }, { regexp: /^since (\d+)$/i, select: U }, { regexp: /^since (\d+)-(\d+)$/i, select: U }, { regexp: /^since (\d+)-(\d+)-(\d+)$/i, select: U }, { regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/, select: function(e3, t3, r3) {
              r3 = parseFloat(r3);
              var n2 = L.usage.global;
              return Object.keys(n2).reduce(function(e4, s3) {
                return t3 === ">" ? n2[s3] > r3 && e4.push(s3) : t3 === "<" ? n2[s3] < r3 && e4.push(s3) : t3 === "<=" ? n2[s3] <= r3 && e4.push(s3) : n2[s3] >= r3 && e4.push(s3), e4;
              }, []);
            } }, { regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/, select: function(e3, t3, r3) {
              if (r3 = parseFloat(r3), !e3.customUsage)
                throw new c("Custom usage statistics was not provided");
              var n2 = e3.customUsage;
              return Object.keys(n2).reduce(function(e4, s3) {
                return t3 === ">" ? n2[s3] > r3 && e4.push(s3) : t3 === "<" ? n2[s3] < r3 && e4.push(s3) : t3 === "<=" ? n2[s3] <= r3 && e4.push(s3) : n2[s3] >= r3 && e4.push(s3), e4;
              }, []);
            } }, { regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/, select: function(e3, t3, r3, n2) {
              r3 = parseFloat(r3);
              var s3 = u.loadStat(e3, n2, L.data);
              if (s3)
                for (var i2 in e3.customUsage = {}, s3)
                  b(e3.customUsage, i2, s3[i2]);
              if (!e3.customUsage)
                throw new c("Custom usage statistics was not provided");
              var o2 = e3.customUsage;
              return Object.keys(o2).reduce(function(e4, n3) {
                return t3 === ">" ? o2[n3] > r3 && e4.push(n3) : t3 === "<" ? o2[n3] < r3 && e4.push(n3) : t3 === "<=" ? o2[n3] <= r3 && e4.push(n3) : o2[n3] >= r3 && e4.push(n3), e4;
              }, []);
            } }, { regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/, select: function(e3, t3, r3, n2) {
              r3 = parseFloat(r3), n2 = n2.length === 2 ? n2.toUpperCase() : n2.toLowerCase(), u.loadCountry(L.usage, n2, L.data);
              var s3 = L.usage[n2];
              return Object.keys(s3).reduce(function(e4, n3) {
                return t3 === ">" ? s3[n3] > r3 && e4.push(n3) : t3 === "<" ? s3[n3] < r3 && e4.push(n3) : t3 === "<=" ? s3[n3] <= r3 && e4.push(n3) : s3[n3] >= r3 && e4.push(n3), e4;
              }, []);
            } }, { regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/, select: $ }, { regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/, select: $ }, { regexp: /^supports\s+([\w-]+)$/, select: function(e3, t3) {
              u.loadFeature(L.cache, t3);
              var r3 = L.cache[t3];
              return Object.keys(r3).reduce(function(e4, t4) {
                var n2 = r3[t4];
                return (n2.indexOf("y") >= 0 || n2.indexOf("a") >= 0) && e4.push(t4), e4;
              }, []);
            } }, { regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3, r3) {
              var n2 = d(t3), s3 = d(r3);
              if (!l[n2])
                throw new c("Unknown version " + t3 + " of electron");
              if (!l[s3])
                throw new c("Unknown version " + r3 + " of electron");
              return t3 = parseFloat(t3), r3 = parseFloat(r3), Object.keys(l).filter(function(e4) {
                var n3 = parseFloat(e4);
                return n3 >= t3 && n3 <= r3;
              }).map(function(e4) {
                return "chrome " + l[e4];
              });
            } }, { regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3, r3) {
              return s2.filter(function(e4) {
                return e4.name === "nodejs";
              }).map(function(e4) {
                return e4.version;
              }).filter(T(">=", t3)).filter(T("<=", r3)).map(function(e4) {
                return "node " + e4;
              });
            } }, { regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i, select: function(e3, t3, r3, n2) {
              var s3 = k2(t3, e3);
              return r3 = parseFloat(P(s3, r3) || r3), n2 = parseFloat(P(s3, n2) || n2), s3.released.filter(function(e4) {
                var t4 = parseFloat(e4);
                return t4 >= r3 && t4 <= n2;
              }).map(h3(s3.name));
            } }, { regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3, r3) {
              var n2 = d(r3);
              return Object.keys(l).filter(v(t3, n2)).map(function(e4) {
                return "chrome " + l[e4];
              });
            } }, { regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i, select: function(e3, t3, r3) {
              return s2.filter(function(e4) {
                return e4.name === "nodejs";
              }).map(function(e4) {
                return e4.version;
              }).filter(function(e4, t4) {
                return (t4 = t4.split(".").map(E))[1] = t4[1] || 0, t4[2] = t4[2] || 0, e4 === ">" ? function(e5) {
                  return S(e5 = e5.split(".").map(E), t4) > 0;
                } : e4 === ">=" ? function(e5) {
                  return S(e5 = e5.split(".").map(E), t4) >= 0;
                } : e4 === "<" ? function(e5) {
                  return e5 = e5.split(".").map(E), S(t4, e5) > 0;
                } : function(e5) {
                  return e5 = e5.split(".").map(E), S(t4, e5) >= 0;
                };
              }(t3, r3)).map(function(e4) {
                return "node " + e4;
              });
            } }, { regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/, select: function(e3, t3, r3, n2) {
              var s3 = k2(t3, e3), i2 = L.versionAliases[s3.name][n2];
              return i2 && (n2 = i2), s3.released.filter(v(r3, n2)).map(function(e4) {
                return s3.name + " " + e4;
              });
            } }, { regexp: /^(firefox|ff|fx)\s+esr$/i, select: function() {
              return ["firefox 78"];
            } }, { regexp: /(operamini|op_mini)\s+all/i, select: function() {
              return ["op_mini all"];
            } }, { regexp: /^electron\s+([\d.]+)$/i, select: function(e3, t3) {
              var r3 = d(t3), n2 = l[r3];
              if (!n2)
                throw new c("Unknown version " + t3 + " of electron");
              return ["chrome " + n2];
            } }, { regexp: /^node\s+(\d+)$/i, select: F }, { regexp: /^node\s+(\d+\.\d+)$/i, select: F }, { regexp: /^node\s+(\d+\.\d+\.\d+)$/i, select: F }, { regexp: /^current\s+node$/i, select: function(e3) {
              return [u.currentNode(j, e3)];
            } }, { regexp: /^maintained\s+node\s+versions$/i, select: function(e3) {
              var t3 = Date.now();
              return j(Object.keys(o).filter(function(e4) {
                return t3 < Date.parse(o[e4].end) && t3 > Date.parse(o[e4].start) && (r3 = e4.slice(1), s2.some(function(e5) {
                  return p2(e5.version, r3);
                }));
                var r3;
              }).map(function(e4) {
                return "node " + e4.slice(1);
              }), e3);
            } }, { regexp: /^phantomjs\s+1.9$/i, select: function() {
              return ["safari 5"];
            } }, { regexp: /^phantomjs\s+2.1$/i, select: function() {
              return ["safari 6"];
            } }, { regexp: /^(\w+)\s+(tp|[\d.]+)$/i, select: function(e3, t3, r3) {
              /^tp$/i.test(r3) && (r3 = "TP");
              var n2 = k2(t3, e3), s3 = P(n2, r3);
              if (s3)
                r3 = s3;
              else {
                if (!(s3 = P(n2, s3 = r3.indexOf(".") === -1 ? r3 + ".0" : r3.replace(/\.0$/, "")))) {
                  if (e3.ignoreUnknownVersions)
                    return [];
                  throw new c("Unknown version " + r3 + " of " + t3);
                }
                r3 = s3;
              }
              return [n2.name + " " + r3];
            } }, { regexp: /^browserslist config$/i, select: function(e3) {
              return L(void 0, e3);
            } }, { regexp: /^extends (.+)$/i, select: function(e3, t3) {
              return j(u.loadQueries(e3, t3), e3);
            } }, { regexp: /^defaults$/i, select: function(e3) {
              return j(L.defaults, e3);
            } }, { regexp: /^dead$/i, select: function(e3) {
              return j(["ie <= 10", "ie_mob <= 11", "bb <= 10", "op_mob <= 12.1", "samsung 4"], e3);
            } }, { regexp: /^(\w+)$/i, select: function(e3, t3) {
              throw C(t3, e3) ? new c("Specify versions in Browserslist query for browser " + t3) : N(t3);
            } }];
            !function() {
              for (var e3 in i) {
                var t3 = i[e3];
                L.data[e3] = { name: e3, versions: f(i[e3].versions), released: f(i[e3].versions.slice(0, -3)), releaseDate: i[e3].release_date }, b(L.usage.global, e3, t3.usage_global), L.versionAliases[e3] = {};
                for (var r3 = 0; r3 < t3.versions.length; r3++) {
                  var n2 = t3.versions[r3];
                  if (n2 && n2.indexOf("-") !== -1)
                    for (var s3 = n2.split("-"), o2 = 0; o2 < s3.length; o2++)
                      L.versionAliases[e3][s3[o2]] = n2;
                }
              }
              L.versionAliases.op_mob[59] = "58";
            }(), e2.exports = L;
          }, (e2) => {
            e2.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
          }, (e2) => {
            e2.exports = { 0: "43", 1: "44", 2: "45", 3: "46", 4: "47", 5: "48", 6: "49", 7: "50", 8: "51", 9: "52", A: "10", B: "11", C: "12", D: "7", E: "8", F: "9", G: "15", H: "91", I: "4", J: "6", K: "13", L: "14", M: "16", N: "17", O: "18", P: "89", Q: "62", R: "79", S: "80", T: "81", U: "83", V: "84", W: "85", X: "86", Y: "87", Z: "88", a: "90", b: "5", c: "19", d: "20", e: "21", f: "22", g: "23", h: "24", i: "25", j: "26", k: "27", l: "28", m: "29", n: "30", o: "31", p: "32", q: "33", r: "34", s: "35", t: "36", u: "37", v: "38", w: "39", x: "40", y: "41", z: "42", AB: "53", BB: "54", CB: "55", DB: "56", EB: "57", FB: "58", GB: "60", HB: "63", IB: "64", JB: "65", KB: "66", LB: "67", MB: "68", NB: "69", OB: "70", PB: "71", QB: "72", RB: "73", SB: "74", TB: "75", UB: "76", VB: "77", WB: "11.1", XB: "12.1", YB: "3", ZB: "59", aB: "61", bB: "78", cB: "3.2", dB: "10.1", eB: "11.5", fB: "4.2-4.3", gB: "5.5", hB: "2", iB: "82", jB: "3.5", kB: "3.6", lB: "92", mB: "93", nB: "94", oB: "3.1", pB: "5.1", qB: "6.1", rB: "7.1", sB: "9.1", tB: "13.1", uB: "14.1", vB: "TP", wB: "9.5-9.6", xB: "10.0-10.1", yB: "10.5", zB: "10.6", "0B": "11.6", "1B": "4.0-4.1", "2B": "5.0-5.1", "3B": "6.0-6.1", "4B": "7.0-7.1", "5B": "8.1-8.4", "6B": "9.0-9.2", "7B": "9.3", "8B": "10.0-10.2", "9B": "10.3", AC: "11.0-11.2", BC: "11.3-11.4", CC: "12.0-12.1", DC: "12.2-12.4", EC: "13.0-13.1", FC: "13.2", GC: "13.3", HC: "13.4-13.7", IC: "14.0-14.4", JC: "14.5-14.7", KC: "all", LC: "2.1", MC: "2.2", NC: "2.3", OC: "4.1", PC: "4.4", QC: "4.4.3-4.4.4", RC: "12.12", SC: "5.0-5.4", TC: "6.2-6.4", UC: "7.2-7.4", VC: "8.2", WC: "9.2", XC: "11.1-11.2", YC: "12.0", ZC: "13.0", aC: "14.0", bC: "10.4", cC: "7.12", dC: "2.5" };
          }, (e2) => {
            e2.exports = { A: { A: { J: 0.0131217, D: 621152e-8, E: 0.0202173, F: 0.0943475, A: 67391e-7, B: 0.849127, gB: 9298e-6 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gB", "J", "D", "E", "F", "A", "B", "", "", ""], E: "IE", F: { gB: 962323200, J: 998870400, D: 1161129600, E: 1237420800, F: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { C: 8402e-6, K: 4267e-6, L: 4201e-6, G: 4201e-6, M: 8402e-6, N: 0.025206, O: 0.08402, R: 0, S: 4298e-6, T: 944e-5, U: 415e-5, V: 8402e-6, W: 8402e-6, X: 8402e-6, Y: 8402e-6, Z: 8402e-6, P: 0.029407, a: 0.121829, H: 3.18436 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "K", "L", "G", "M", "N", "O", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "P", "a", "H", "", "", ""], E: "Edge", F: { C: 1438128e3, K: 1447286400, L: 1470096e3, G: 1491868800, M: 1508198400, N: 1525046400, O: 1542067200, R: 1579046400, S: 1581033600, T: 1586736e3, U: 1590019200, V: 1594857600, W: 1598486400, X: 1602201600, Y: 1605830400, Z: 161136e4, P: 1614816e3, a: 1618358400, H: 1622073600 }, D: { C: "ms", K: "ms", L: "ms", G: "ms", M: "ms", N: "ms", O: "ms" } }, C: { A: { 0: 0.054613, 1: 4201e-6, 2: 4201e-6, 3: 4525e-6, 4: 4201e-6, 5: 8402e-6, 6: 4538e-6, 7: 4267e-6, 8: 4204e-6, 9: 0.071417, hB: 0.012813, YB: 4271e-6, I: 0.021005, b: 4879e-6, J: 0.020136, D: 5725e-6, E: 4525e-6, F: 533e-5, A: 4283e-6, B: 0.012603, C: 4471e-6, K: 4486e-6, L: 453e-5, G: 8542e-6, M: 4417e-6, N: 4425e-6, O: 8542e-6, c: 4443e-6, d: 4283e-6, e: 8542e-6, f: 0.013698, g: 8542e-6, h: 8786e-6, i: 0.017084, j: 4317e-6, k: 4393e-6, l: 4418e-6, m: 8834e-6, n: 8542e-6, o: 8928e-6, p: 4471e-6, q: 9284e-6, r: 4707e-6, s: 9076e-6, t: 4425e-6, u: 4783e-6, v: 4271e-6, w: 4783e-6, x: 487e-5, y: 5029e-6, z: 47e-4, AB: 4335e-6, BB: 4201e-6, CB: 4201e-6, DB: 0.012603, EB: 4425e-6, FB: 4204e-6, ZB: 4201e-6, GB: 8402e-6, aB: 472e-5, Q: 4425e-6, HB: 0.012603, IB: 415e-5, JB: 4267e-6, KB: 8402e-6, LB: 4267e-6, MB: 0.012603, NB: 415e-5, OB: 8402e-6, PB: 4425e-6, QB: 0.016804, RB: 415e-5, SB: 415e-5, TB: 8542e-6, UB: 4298e-6, VB: 4201e-6, bB: 0.151236, R: 8402e-6, S: 8402e-6, T: 8402e-6, iB: 0.016804, U: 8402e-6, V: 0.021005, W: 0.012603, X: 0.016804, Y: 0.029407, Z: 0.399095, P: 1.91986, a: 0.029407, H: 0, jB: 8786e-6, kB: 487e-5 }, B: "moz", C: ["hB", "YB", "jB", "kB", "I", "b", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "ZB", "GB", "aB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "bB", "R", "S", "T", "iB", "U", "V", "W", "X", "Y", "Z", "P", "a", "H", ""], E: "Firefox", F: { 0: 1450137600, 1: 1453852800, 2: 1457395200, 3: 1461628800, 4: 1465257600, 5: 1470096e3, 6: 1474329600, 7: 1479168e3, 8: 1485216e3, 9: 1488844800, hB: 1161648e3, YB: 1213660800, jB: 124632e4, kB: 1264032e3, I: 1300752e3, b: 1308614400, J: 1313452800, D: 1317081600, E: 1317081600, F: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, K: 1335225600, L: 1338854400, G: 1342483200, M: 1346112e3, N: 1349740800, O: 1353628800, c: 1357603200, d: 1361232e3, e: 1364860800, f: 1368489600, g: 1372118400, h: 1375747200, i: 1379376e3, j: 1386633600, k: 1391472e3, l: 1395100800, m: 1398729600, n: 1402358400, o: 1405987200, p: 1409616e3, q: 1413244800, r: 1417392e3, s: 1421107200, t: 1424736e3, u: 1428278400, v: 1431475200, w: 1435881600, x: 1439251200, y: 144288e4, z: 1446508800, AB: 149256e4, BB: 1497312e3, CB: 1502150400, DB: 1506556800, EB: 1510617600, FB: 1516665600, ZB: 1520985600, GB: 1525824e3, aB: 1529971200, Q: 1536105600, HB: 1540252800, IB: 1544486400, JB: 154872e4, KB: 1552953600, LB: 1558396800, MB: 1562630400, NB: 1567468800, OB: 1571788800, PB: 1575331200, QB: 1578355200, RB: 1581379200, SB: 1583798400, TB: 1586304e3, UB: 1588636800, VB: 1591056e3, bB: 1593475200, R: 1595894400, S: 1598313600, T: 1600732800, iB: 1603152e3, U: 1605571200, V: 1607990400, W: 1611619200, X: 1614038400, Y: 1616457600, Z: 1618790400, P: 1622505600, a: null, H: null } }, D: { A: { 0: 8402e-6, 1: 4465e-6, 2: 4642e-6, 3: 4891e-6, 4: 0.012603, 5: 0.021005, 6: 0.197447, 7: 4201e-6, 8: 4201e-6, 9: 4201e-6, I: 4706e-6, b: 4879e-6, J: 4879e-6, D: 5591e-6, E: 5591e-6, F: 5591e-6, A: 4534e-6, B: 4464e-6, C: 0.010424, K: 83e-4, L: 4706e-6, G: 0.015087, M: 4393e-6, N: 4393e-6, O: 8652e-6, c: 8542e-6, d: 4393e-6, e: 4317e-6, f: 0.012603, g: 8786e-6, h: 8408e-6, i: 4461e-6, j: 4201e-6, k: 4326e-6, l: 47e-4, m: 4538e-6, n: 8542e-6, o: 8596e-6, p: 4566e-6, q: 4204e-6, r: 8402e-6, s: 8402e-6, t: 4335e-6, u: 4464e-6, v: 0.025206, w: 4464e-6, x: 0.012603, y: 0.0236, z: 4403e-6, AB: 0.025206, BB: 8402e-6, CB: 8402e-6, DB: 0.04201, EB: 8402e-6, FB: 8402e-6, ZB: 8402e-6, GB: 0.016804, aB: 0.088221, Q: 8402e-6, HB: 0.016804, IB: 0.029407, JB: 0.021005, KB: 0.021005, LB: 0.021005, MB: 0.012603, NB: 0.067216, OB: 0.063015, PB: 0.025206, QB: 0.054613, RB: 0.016804, SB: 0.075618, TB: 0.088221, UB: 0.063015, VB: 0.029407, bB: 0.063015, R: 0.21005, S: 0.105025, T: 0.075618, U: 0.105025, V: 0.100824, W: 0.285668, X: 0.121829, Y: 0.273065, Z: 0.184844, P: 0.411698, a: 3.44902, H: 19.459, lB: 0.029407, mB: 0.025206, nB: 0 }, B: "webkit", C: ["", "", "", "I", "b", "J", "D", "E", "F", "A", "B", "C", "K", "L", "G", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "ZB", "GB", "aB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "bB", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "P", "a", "H", "lB", "mB", "nB"], E: "Chrome", F: { 0: 143208e4, 1: 1437523200, 2: 1441152e3, 3: 1444780800, 4: 1449014400, 5: 1453248e3, 6: 1456963200, 7: 1460592e3, 8: 1464134400, 9: 1469059200, I: 1264377600, b: 1274745600, J: 1283385600, D: 1287619200, E: 1291248e3, F: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, K: 1312243200, L: 1316131200, G: 1316131200, M: 1319500800, N: 1323734400, O: 1328659200, c: 1332892800, d: 133704e4, e: 1340668800, f: 1343692800, g: 1348531200, h: 1352246400, i: 1357862400, j: 1361404800, k: 1364428800, l: 1369094400, m: 1374105600, n: 1376956800, o: 1384214400, p: 1389657600, q: 1392940800, r: 1397001600, s: 1400544e3, t: 1405468800, u: 1409011200, v: 141264e4, w: 1416268800, x: 1421798400, y: 1425513600, z: 1429401600, AB: 1472601600, BB: 1476230400, CB: 1480550400, DB: 1485302400, EB: 1489017600, FB: 149256e4, ZB: 1496707200, GB: 1500940800, aB: 1504569600, Q: 1508198400, HB: 1512518400, IB: 1516752e3, JB: 1520294400, KB: 1523923200, LB: 1527552e3, MB: 1532390400, NB: 1536019200, OB: 1539648e3, PB: 1543968e3, QB: 154872e4, RB: 1552348800, SB: 1555977600, TB: 1559606400, UB: 1564444800, VB: 1568073600, bB: 1571702400, R: 1575936e3, S: 1580860800, T: 1586304e3, U: 1589846400, V: 1594684800, W: 1598313600, X: 1601942400, Y: 1605571200, Z: 1611014400, P: 1614556800, a: 1618272e3, H: 1621987200, lB: null, mB: null, nB: null } }, E: { A: { I: 0, b: 8542e-6, J: 4656e-6, D: 4465e-6, E: 0.12603, F: 4891e-6, A: 4425e-6, B: 8402e-6, C: 0.012603, K: 0.08402, L: 1.2729, G: 4201e-6, oB: 0, cB: 8692e-6, pB: 0.105025, qB: 456e-5, rB: 4283e-6, sB: 0.025206, dB: 0.021005, WB: 0.058814, XB: 0.088221, tB: 0.470512, uB: 1.72241, vB: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "oB", "cB", "I", "b", "pB", "J", "qB", "D", "rB", "E", "F", "sB", "A", "dB", "B", "WB", "C", "XB", "K", "tB", "L", "uB", "G", "vB", ""], E: "Safari", F: { oB: 1205798400, cB: 1226534400, I: 1244419200, b: 1275868800, pB: 131112e4, J: 1343174400, qB: 13824e5, D: 13824e5, rB: 1410998400, E: 1413417600, F: 1443657600, sB: 1458518400, A: 1474329600, dB: 1490572800, B: 1505779200, WB: 1522281600, C: 1537142400, XB: 1553472e3, K: 1568851200, tB: 1585008e3, L: 1600214400, uB: 1619395200, G: null, vB: null } }, F: { A: { 0: 8542e-6, 1: 4227e-6, 2: 4725e-6, 3: 8402e-6, 4: 8942e-6, 5: 4707e-6, 6: 4827e-6, 7: 4707e-6, 8: 4707e-6, 9: 4326e-6, F: 82e-4, B: 0.016581, C: 4317e-6, G: 685e-5, M: 685e-5, N: 685e-5, O: 5014e-6, c: 6015e-6, d: 4879e-6, e: 6597e-6, f: 6597e-6, g: 0.013434, h: 6702e-6, i: 6015e-6, j: 5595e-6, k: 4393e-6, l: 8652e-6, m: 4879e-6, n: 4879e-6, o: 4201e-6, p: 5152e-6, q: 5014e-6, r: 9758e-6, s: 4879e-6, t: 8402e-6, u: 4283e-6, v: 4367e-6, w: 4534e-6, x: 8402e-6, y: 4227e-6, z: 4418e-6, AB: 8922e-6, BB: 0.014349, CB: 4425e-6, DB: 472e-5, EB: 4425e-6, FB: 4425e-6, GB: 472e-5, Q: 4532e-6, HB: 4566e-6, IB: 0.02283, JB: 867e-5, KB: 4656e-6, LB: 4642e-6, MB: 4298e-6, NB: 944e-5, OB: 415e-5, PB: 4271e-6, QB: 4298e-6, RB: 0.096692, SB: 4201e-6, TB: 0.243658, UB: 0.46211, VB: 0.193246, wB: 685e-5, xB: 0, yB: 8392e-6, zB: 4706e-6, WB: 6229e-6, eB: 4879e-6, "0B": 8786e-6, XB: 472e-5 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "wB", "xB", "yB", "zB", "B", "WB", "eB", "0B", "C", "XB", "G", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "", "", ""], E: "Opera", F: { 0: 1486425600, 1: 1490054400, 2: 1494374400, 3: 1498003200, 4: 1502236800, 5: 1506470400, 6: 1510099200, 7: 1515024e3, 8: 1517961600, 9: 1521676800, F: 1150761600, wB: 1223424e3, xB: 1251763200, yB: 1267488e3, zB: 1277942400, B: 1292457600, WB: 1302566400, eB: 1309219200, "0B": 1323129600, C: 1323129600, XB: 1352073600, G: 1372723200, M: 1377561600, N: 1381104e3, O: 1386288e3, c: 1390867200, d: 1393891200, e: 1399334400, f: 1401753600, g: 1405987200, h: 1409616e3, i: 1413331200, j: 1417132800, k: 1422316800, l: 1425945600, m: 1430179200, n: 1433808e3, o: 1438646400, p: 1442448e3, q: 1445904e3, r: 1449100800, s: 1454371200, t: 1457308800, u: 146232e4, v: 1465344e3, w: 1470096e3, x: 1474329600, y: 1477267200, z: 1481587200, AB: 1525910400, BB: 1530144e3, CB: 1534982400, DB: 1537833600, EB: 1543363200, FB: 1548201600, GB: 1554768e3, Q: 1561593600, HB: 1566259200, IB: 1570406400, JB: 1573689600, KB: 1578441600, LB: 1583971200, MB: 1587513600, NB: 1592956800, OB: 1595894400, PB: 1600128e3, QB: 1603238400, RB: 161352e4, SB: 1612224e3, TB: 1616544e3, UB: 1619568e3, VB: 1623715200 }, D: { F: "o", B: "o", C: "o", wB: "o", xB: "o", yB: "o", zB: "o", WB: "o", eB: "o", "0B": "o", XB: "o" } }, G: { A: { E: 144232e-8, cB: 0, "1B": 0, fB: 288464e-8, "2B": 865392e-8, "3B": 0.0187502, "4B": 0.0302887, "5B": 0.0201925, "6B": 0.0245194, "7B": 0.145674, "8B": 0.0302887, "9B": 0.147117, AC: 0.0908662, BC: 0.0692314, CC: 0.0750006, DC: 0.222117, EC: 0.0605774, FC: 0.0274041, GC: 0.160098, HC: 0.536543, IC: 5.13466, JC: 6.98371 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cB", "1B", "fB", "2B", "3B", "4B", "E", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "", "", ""], E: "Safari on iOS", F: { cB: 1270252800, "1B": 1283904e3, fB: 1299628800, "2B": 1331078400, "3B": 1359331200, "4B": 1394409600, E: 1410912e3, "5B": 1413763200, "6B": 1442361600, "7B": 1458518400, "8B": 1473724800, "9B": 1490572800, AC: 1505779200, BC: 1522281600, CC: 1537142400, DC: 1553472e3, EC: 1568851200, FC: 1572220800, GC: 1580169600, HC: 1585008e3, IC: 1600214400, JC: 1619395200 } }, H: { A: { KC: 1.13096 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""], E: "Opera Mini", F: { KC: 1426464e3 } }, I: { A: { YB: 0, I: 0.0119202, H: 0, LC: 0, MC: 0, NC: 0, OC: 0.0208603, fB: 0.0655609, PC: 0, QC: 0.330785 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "LC", "MC", "NC", "YB", "I", "OC", "fB", "PC", "QC", "H", "", "", ""], E: "Android Browser", F: { LC: 1256515200, MC: 1274313600, NC: 1291593600, YB: 1298332800, I: 1318896e3, OC: 1341792e3, fB: 1374624e3, PC: 1386547200, QC: 1401667200, H: 1621987200 } }, J: { A: { D: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""], E: "Blackberry Browser", F: { D: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, Q: 0.0111391, WB: 0, eB: 0, XB: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "WB", "eB", "C", "XB", "Q", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, WB: 1314835200, eB: 1318291200, C: 1330300800, XB: 1349740800, Q: 1613433600 }, D: { Q: "webkit" } }, L: { A: { H: 39.6819 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "", "", ""], E: "Chrome for Android", F: { H: 1621987200 } }, M: { A: { P: 0.295749 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "P", "", "", ""], E: "Firefox for Android", F: { P: 1622505600 } }, N: { A: { A: 0.0115934, B: 0.022664 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { RC: 1.33957 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "", "", ""], E: "UC Browser for Android", F: { RC: 1471392e3 }, D: { RC: "webkit" } }, P: { A: { I: 0.31012, SC: 0.0103543, TC: 0.010304, UC: 0.0826988, VC: 0.0103584, WC: 0.0620241, dB: 0.031012, XC: 0.15506, YC: 0.0930361, ZC: 0.299783, aC: 2.29489 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "I", "SC", "TC", "UC", "VC", "WC", "dB", "XC", "YC", "ZC", "aC", "", "", ""], E: "Samsung Internet", F: { I: 1461024e3, SC: 1481846400, TC: 1509408e3, UC: 1528329600, VC: 1546128e3, WC: 1554163200, dB: 1567900800, XC: 1582588800, YC: 1593475200, ZC: 1605657600, aC: 1618531200 } }, Q: { A: { bC: 0.191367 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "bC", "", "", ""], E: "QQ Browser", F: { bC: 1589846400 } }, R: { A: { cC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cC", "", "", ""], E: "Baidu Browser", F: { cC: 1491004800 } }, S: { A: { dC: 0.104382 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "dC", "", "", ""], E: "KaiOS Browser", F: { dC: 1527811200 } } };
          }, (e2) => {
            e2.exports = { "0.20": "39", 0.21: "41", 0.22: "41", 0.23: "41", 0.24: "41", 0.25: "42", 0.26: "42", 0.27: "43", 0.28: "43", 0.29: "43", "0.30": "44", 0.31: "45", 0.32: "45", 0.33: "45", 0.34: "45", 0.35: "45", 0.36: "47", 0.37: "49", "1.0": "49", 1.1: "50", 1.2: "51", 1.3: "52", 1.4: "53", 1.5: "54", 1.6: "56", 1.7: "58", 1.8: "59", "2.0": "61", 2.1: "61", "3.0": "66", 3.1: "66", "4.0": "69", 4.1: "69", 4.2: "69", "5.0": "73", "6.0": "76", 6.1: "76", "7.0": "78", 7.1: "78", 7.2: "78", 7.3: "78", "8.0": "80", 8.1: "80", 8.2: "80", 8.3: "80", 8.4: "80", 8.5: "80", "9.0": "83", 9.1: "83", 9.2: "83", 9.3: "83", 9.4: "83", "10.0": "85", 10.1: "85", 10.2: "85", 10.3: "85", 10.4: "85", "11.0": "87", 11.1: "87", 11.2: "87", 11.3: "87", 11.4: "87", "12.0": "89", "13.0": "91", 13.1: "91", "14.0": "93" };
          }, (e2, t2, r2) => {
            var n = r2(151);
            function s2() {
            }
            e2.exports = { loadQueries: function() {
              throw new n("Sharable configs are not supported in client-side build of Browserslist");
            }, getStat: function(e3) {
              return e3.stats;
            }, loadConfig: function(e3) {
              if (e3.config)
                throw new n("Browserslist config are not supported in client-side build");
            }, loadCountry: function() {
              throw new n("Country statistics are not supported in client-side build of Browserslist");
            }, loadFeature: function() {
              throw new n("Supports queries are not available in client-side build of Browserslist");
            }, currentNode: function(e3, t3) {
              return e3(["maintained node versions"], t3)[0];
            }, parseConfig: s2, readConfig: s2, findConfig: s2, clearCaches: s2, oldDataWarning: s2 };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "OptionValidator", { enumerable: true, get: function() {
              return n.OptionValidator;
            } }), Object.defineProperty(t2, "findSuggestion", { enumerable: true, get: function() {
              return s2.findSuggestion;
            } });
            var n = r2(473), s2 = r2(298);
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.findSuggestion = function(e3, t3) {
              const n = t3.map((t4) => function(e4, t5) {
                let n2, s2, i = [], o = [];
                const a = e4.length, l = t5.length;
                if (!a)
                  return l;
                if (!l)
                  return a;
                for (s2 = 0; s2 <= l; s2++)
                  i[s2] = s2;
                for (n2 = 1; n2 <= a; n2++) {
                  for (o = [n2], s2 = 1; s2 <= l; s2++)
                    o[s2] = e4[n2 - 1] === t5[s2 - 1] ? i[s2 - 1] : r2(i[s2 - 1], i[s2], o[s2 - 1]) + 1;
                  i = o;
                }
                return o[l];
              }(t4, e3));
              return t3[n.indexOf(r2(...n))];
            };
            const { min: r2 } = Math;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.prettifyVersion = i, t2.prettifyTargets = function(e3) {
              return Object.keys(e3).reduce((t3, r3) => {
                let n2 = e3[r3];
                const o = s2.unreleasedLabels[r3];
                return typeof n2 == "string" && o !== n2 && (n2 = i(n2)), t3[r3] = n2, t3;
              }, {});
            };
            var n = r2(28), s2 = r2(153);
            function i(e3) {
              if (typeof e3 != "string")
                return e3;
              const t3 = [n.major(e3)], r3 = n.minor(e3), s3 = n.patch(e3);
              return (r3 || s3) && t3.push(r3), s3 && t3.push(s3), t3.join(".");
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(8);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(65);
              return s2 = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.buildPresetChain = function* (e3, t3) {
              const r3 = yield* f(e3, t3);
              return r3 ? { plugins: B(r3.plugins), presets: B(r3.presets), options: r3.options.map((e4) => M(e4)), files: new Set() } : null;
            }, t2.buildRootChain = function* (e3, t3) {
              let r3, s3;
              const i2 = new a.ConfigPrinter(), c4 = yield* E({ options: e3, dirname: t3.cwd }, t3, void 0, i2);
              if (!c4)
                return null;
              let u2;
              yield* i2.output(), typeof e3.configFile == "string" ? u2 = yield* (0, l.loadConfig)(e3.configFile, t3.cwd, t3.envName, t3.caller) : e3.configFile !== false && (u2 = yield* (0, l.findRootConfig)(t3.root, t3.envName, t3.caller));
              let { babelrc: p3, babelrcRoots: f2 } = e3, d2 = t3.cwd;
              const h4 = L(), m2 = new a.ConfigPrinter();
              if (u2) {
                const e4 = g(u2), n2 = yield* S(e4, t3, void 0, m2);
                if (!n2)
                  return null;
                r3 = yield* m2.output(), p3 === void 0 && (p3 = e4.options.babelrc), f2 === void 0 && (d2 = e4.dirname, f2 = e4.options.babelrcRoots), j(h4, n2);
              }
              let y2, v2, x2 = false;
              const T2 = L();
              if ((p3 === true || p3 === void 0) && typeof t3.filename == "string") {
                const e4 = yield* (0, l.findPackageData)(t3.filename);
                if (e4 && function(e5, t4, r4, s4) {
                  if (typeof r4 == "boolean")
                    return r4;
                  const i3 = e5.root;
                  if (r4 === void 0)
                    return t4.directories.indexOf(i3) !== -1;
                  let a2 = r4;
                  return Array.isArray(a2) || (a2 = [a2]), a2 = a2.map((e6) => typeof e6 == "string" ? n().resolve(s4, e6) : e6), a2.length === 1 && a2[0] === i3 ? t4.directories.indexOf(i3) !== -1 : a2.some((r5) => (typeof r5 == "string" && (r5 = (0, o.default)(r5, s4)), t4.directories.some((t5) => q(r5, s4, t5, e5))));
                }(t3, e4, f2, d2)) {
                  if ({ ignore: y2, config: v2 } = yield* (0, l.findRelativeConfig)(e4, t3.envName, t3.caller), y2 && T2.files.add(y2.filepath), y2 && U(t3, y2.ignore, null, y2.dirname) && (x2 = true), v2 && !x2) {
                    const e5 = b(v2), r4 = new a.ConfigPrinter(), n2 = yield* S(e5, t3, void 0, r4);
                    n2 ? (s3 = yield* r4.output(), j(T2, n2)) : x2 = true;
                  }
                  v2 && x2 && T2.files.add(v2.filepath);
                }
              }
              t3.showConfig;
              const w2 = j(j(j(L(), h4), T2), c4);
              return { plugins: x2 ? [] : B(w2.plugins), presets: x2 ? [] : B(w2.presets), options: x2 ? [] : w2.options.map((e4) => M(e4)), fileHandling: x2 ? "ignored" : "transpile", ignore: y2 || void 0, babelrc: v2 || void 0, config: u2 || void 0, files: w2.files };
            }, t2.buildPresetChainWalker = void 0;
            var i = r2(82), o = r2(482), a = r2(483), l = r2(77), c = r2(81), u = r2(288);
            const p2 = s2()("babel:config:config-chain"), f = N({ root: (e3) => d(e3), env: (e3, t3) => h3(e3)(t3), overrides: (e3, t3) => m(e3)(t3), overridesEnv: (e3, t3, r3) => y(e3)(t3)(r3), createLogger: () => () => {
            } });
            t2.buildPresetChainWalker = f;
            const d = (0, c.makeWeakCacheSync)((e3) => O(e3, e3.alias, u.createUncachedDescriptors)), h3 = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => C(e3, e3.alias, u.createUncachedDescriptors, t3))), m = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => I(e3, e3.alias, u.createUncachedDescriptors, t3))), y = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => (0, c.makeStrongCacheSync)((r3) => k2(e3, e3.alias, u.createUncachedDescriptors, t3, r3)))), g = (0, c.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i.validate)("configfile", e3.options) })), b = (0, c.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i.validate)("babelrcfile", e3.options) })), v = (0, c.makeWeakCacheSync)((e3) => ({ filepath: e3.filepath, dirname: e3.dirname, options: (0, i.validate)("extendsfile", e3.options) })), E = N({ root: (e3) => O(e3, "base", u.createCachedDescriptors), env: (e3, t3) => C(e3, "base", u.createCachedDescriptors, t3), overrides: (e3, t3) => I(e3, "base", u.createCachedDescriptors, t3), overridesEnv: (e3, t3, r3) => k2(e3, "base", u.createCachedDescriptors, t3, r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
              var n2;
              return r4 ? r4.configure(t4.showConfig, a.ChainFormatter.Programmatic, { callerName: (n2 = t4.caller) == null ? void 0 : n2.name }) : () => {
              };
            }(0, t3, r3) }), x = N({ root: (e3) => T(e3), env: (e3, t3) => w(e3)(t3), overrides: (e3, t3) => P(e3)(t3), overridesEnv: (e3, t3, r3) => A(e3)(t3)(r3), createLogger: (e3, t3, r3) => function(e4, t4, r4) {
              return r4 ? r4.configure(t4.showConfig, a.ChainFormatter.Config, { filepath: e4 }) : () => {
              };
            }(e3.filepath, t3, r3) });
            function* S(e3, t3, r3, n2) {
              const s3 = yield* x(e3, t3, r3, n2);
              return s3 && s3.files.add(e3.filepath), s3;
            }
            const T = (0, c.makeWeakCacheSync)((e3) => O(e3, e3.filepath, u.createUncachedDescriptors)), w = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => C(e3, e3.filepath, u.createUncachedDescriptors, t3))), P = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => I(e3, e3.filepath, u.createUncachedDescriptors, t3))), A = (0, c.makeWeakCacheSync)((e3) => (0, c.makeStrongCacheSync)((t3) => (0, c.makeStrongCacheSync)((r3) => k2(e3, e3.filepath, u.createUncachedDescriptors, t3, r3))));
            function O({ dirname: e3, options: t3 }, r3, n2) {
              return n2(e3, t3, r3);
            }
            function C({ dirname: e3, options: t3 }, r3, n2, s3) {
              const i2 = t3.env && t3.env[s3];
              return i2 ? n2(e3, i2, `${r3}.env["${s3}"]`) : null;
            }
            function I({ dirname: e3, options: t3 }, r3, n2, s3) {
              const i2 = t3.overrides && t3.overrides[s3];
              if (!i2)
                throw new Error("Assertion failure - missing override");
              return n2(e3, i2, `${r3}.overrides[${s3}]`);
            }
            function k2({ dirname: e3, options: t3 }, r3, n2, s3, i2) {
              const o2 = t3.overrides && t3.overrides[s3];
              if (!o2)
                throw new Error("Assertion failure - missing override");
              const a2 = o2.env && o2.env[i2];
              return a2 ? n2(e3, a2, `${r3}.overrides[${s3}].env["${i2}"]`) : null;
            }
            function N({ root: e3, env: t3, overrides: r3, overridesEnv: n2, createLogger: s3 }) {
              return function* (i2, o2, a2 = new Set(), l2) {
                const { dirname: c4 } = i2, u2 = [], p3 = e3(i2);
                if (R(p3, c4, o2)) {
                  u2.push({ config: p3, envName: void 0, index: void 0 });
                  const e4 = t3(i2, o2.envName);
                  e4 && R(e4, c4, o2) && u2.push({ config: e4, envName: o2.envName, index: void 0 }), (p3.options.overrides || []).forEach((e5, t4) => {
                    const s4 = r3(i2, t4);
                    if (R(s4, c4, o2)) {
                      u2.push({ config: s4, index: t4, envName: void 0 });
                      const e6 = n2(i2, t4, o2.envName);
                      e6 && R(e6, c4, o2) && u2.push({ config: e6, index: t4, envName: o2.envName });
                    }
                  });
                }
                if (u2.some(({ config: { options: { ignore: e4, only: t4 } } }) => U(o2, e4, t4, c4)))
                  return null;
                const f2 = L(), d2 = s3(i2, o2, l2);
                for (const { config: e4, index: t4, envName: r4 } of u2) {
                  if (!(yield* _(f2, e4.options, c4, o2, a2, l2)))
                    return null;
                  d2(e4, t4, r4), yield* D(f2, e4);
                }
                return f2;
              };
            }
            function* _(e3, t3, r3, n2, s3, i2) {
              if (t3.extends === void 0)
                return true;
              const o2 = yield* (0, l.loadConfig)(t3.extends, r3, n2.envName, n2.caller);
              if (s3.has(o2))
                throw new Error(`Configuration cycle detected loading ${o2.filepath}.
File already loaded following the config chain:
` + Array.from(s3, (e4) => ` - ${e4.filepath}`).join("\n"));
              s3.add(o2);
              const a2 = yield* S(v(o2), n2, s3, i2);
              return s3.delete(o2), !!a2 && (j(e3, a2), true);
            }
            function j(e3, t3) {
              e3.options.push(...t3.options), e3.plugins.push(...t3.plugins), e3.presets.push(...t3.presets);
              for (const r3 of t3.files)
                e3.files.add(r3);
              return e3;
            }
            function* D(e3, { options: t3, plugins: r3, presets: n2 }) {
              return e3.options.push(t3), e3.plugins.push(...yield* r3()), e3.presets.push(...yield* n2()), e3;
            }
            function L() {
              return { options: [], presets: [], plugins: [], files: new Set() };
            }
            function M(e3) {
              const t3 = Object.assign({}, e3);
              return delete t3.extends, delete t3.env, delete t3.overrides, delete t3.plugins, delete t3.presets, delete t3.passPerPreset, delete t3.ignore, delete t3.only, delete t3.test, delete t3.include, delete t3.exclude, Object.prototype.hasOwnProperty.call(t3, "sourceMap") && (t3.sourceMaps = t3.sourceMap, delete t3.sourceMap), t3;
            }
            function B(e3) {
              const t3 = new Map(), r3 = [];
              for (const n2 of e3)
                if (typeof n2.value == "function") {
                  const e4 = n2.value;
                  let s3 = t3.get(e4);
                  s3 || (s3 = new Map(), t3.set(e4, s3));
                  let i2 = s3.get(n2.name);
                  i2 ? i2.value = n2 : (i2 = { value: n2 }, r3.push(i2), n2.ownPass || s3.set(n2.name, i2));
                } else
                  r3.push({ value: n2 });
              return r3.reduce((e4, t4) => (e4.push(t4.value), e4), []);
            }
            function R({ options: e3 }, t3, r3) {
              return (e3.test === void 0 || F(r3, e3.test, t3)) && (e3.include === void 0 || F(r3, e3.include, t3)) && (e3.exclude === void 0 || !F(r3, e3.exclude, t3));
            }
            function F(e3, t3, r3) {
              return $(e3, Array.isArray(t3) ? t3 : [t3], r3);
            }
            function U(e3, t3, r3, n2) {
              if (t3 && $(e3, t3, n2)) {
                var s3;
                const r4 = `No config is applied to "${(s3 = e3.filename) != null ? s3 : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(t3)}\` from "${n2}"`;
                return p2(r4), e3.showConfig, true;
              }
              if (r3 && !$(e3, r3, n2)) {
                var i2;
                const t4 = `No config is applied to "${(i2 = e3.filename) != null ? i2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(r3)}\` from "${n2}"`;
                return p2(t4), e3.showConfig, true;
              }
              return false;
            }
            function $(e3, t3, r3) {
              return t3.some((t4) => q(t4, r3, e3.filename, e3));
            }
            function q(e3, t3, r3, n2) {
              if (typeof e3 == "function")
                return !!e3(r3, { dirname: t3, envName: n2.envName, caller: n2.caller });
              if (typeof r3 != "string")
                throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
              return typeof e3 == "string" && (e3 = (0, o.default)(e3, t3)), e3.test(r3);
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(290);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.msg = i, t2.access = o, t2.assertRootMode = function(e3, t3) {
              if (t3 !== void 0 && t3 !== "root" && t3 !== "upward" && t3 !== "upward-optional")
                throw new Error(`${i(e3)} must be a "root", "upward", "upward-optional" or undefined`);
              return t3;
            }, t2.assertSourceMaps = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "boolean" && t3 !== "inline" && t3 !== "both")
                throw new Error(`${i(e3)} must be a boolean, "inline", "both", or undefined`);
              return t3;
            }, t2.assertCompact = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "boolean" && t3 !== "auto")
                throw new Error(`${i(e3)} must be a boolean, "auto", or undefined`);
              return t3;
            }, t2.assertSourceType = function(e3, t3) {
              if (t3 !== void 0 && t3 !== "module" && t3 !== "script" && t3 !== "unambiguous")
                throw new Error(`${i(e3)} must be "module", "script", "unambiguous", or undefined`);
              return t3;
            }, t2.assertCallerMetadata = function(e3, t3) {
              const r3 = l(e3, t3);
              if (r3) {
                if (typeof r3.name != "string")
                  throw new Error(`${i(e3)} set but does not contain "name" property string`);
                for (const t4 of Object.keys(r3)) {
                  const n2 = o(e3, t4), s3 = r3[t4];
                  if (s3 != null && typeof s3 != "boolean" && typeof s3 != "string" && typeof s3 != "number")
                    throw new Error(`${i(n2)} must be null, undefined, a boolean, a string, or a number.`);
                }
              }
              return t3;
            }, t2.assertInputSourceMap = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "boolean" && (typeof t3 != "object" || !t3))
                throw new Error(`${i(e3)} must be a boolean, object, or undefined`);
              return t3;
            }, t2.assertString = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "string")
                throw new Error(`${i(e3)} must be a string, or undefined`);
              return t3;
            }, t2.assertFunction = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "function")
                throw new Error(`${i(e3)} must be a function, or undefined`);
              return t3;
            }, t2.assertBoolean = a, t2.assertObject = l, t2.assertArray = c, t2.assertIgnoreList = function(e3, t3) {
              const r3 = c(e3, t3);
              return r3 && r3.forEach((t4, r4) => function(e4, t5) {
                if (typeof t5 != "string" && typeof t5 != "function" && !(t5 instanceof RegExp))
                  throw new Error(`${i(e4)} must be an array of string/Function/RegExp values, or undefined`);
                return t5;
              }(o(e3, r4), t4)), r3;
            }, t2.assertConfigApplicableTest = function(e3, t3) {
              if (t3 === void 0)
                return t3;
              if (Array.isArray(t3))
                t3.forEach((t4, r3) => {
                  if (!u(t4))
                    throw new Error(`${i(o(e3, r3))} must be a string/Function/RegExp.`);
                });
              else if (!u(t3))
                throw new Error(`${i(e3)} must be a string/Function/RegExp, or an array of those`);
              return t3;
            }, t2.assertConfigFileSearch = function(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "boolean" && typeof t3 != "string")
                throw new Error(`${i(e3)} must be a undefined, a boolean, a string, got ${JSON.stringify(t3)}`);
              return t3;
            }, t2.assertBabelrcSearch = function(e3, t3) {
              if (t3 === void 0 || typeof t3 == "boolean")
                return t3;
              if (Array.isArray(t3))
                t3.forEach((t4, r3) => {
                  if (!u(t4))
                    throw new Error(`${i(o(e3, r3))} must be a string/Function/RegExp.`);
                });
              else if (!u(t3))
                throw new Error(`${i(e3)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(t3)}`);
              return t3;
            }, t2.assertPluginList = function(e3, t3) {
              const r3 = c(e3, t3);
              return r3 && r3.forEach((t4, r4) => function(e4, t5) {
                if (Array.isArray(t5)) {
                  if (t5.length === 0)
                    throw new Error(`${i(e4)} must include an object`);
                  if (t5.length > 3)
                    throw new Error(`${i(e4)} may only be a two-tuple or three-tuple`);
                  if (p2(o(e4, 0), t5[0]), t5.length > 1) {
                    const r5 = t5[1];
                    if (r5 !== void 0 && r5 !== false && (typeof r5 != "object" || Array.isArray(r5) || r5 === null))
                      throw new Error(`${i(o(e4, 1))} must be an object, false, or undefined`);
                  }
                  if (t5.length === 3) {
                    const r5 = t5[2];
                    if (r5 !== void 0 && typeof r5 != "string")
                      throw new Error(`${i(o(e4, 2))} must be a string, or undefined`);
                  }
                } else
                  p2(e4, t5);
                return t5;
              }(o(e3, r4), t4)), r3;
            }, t2.assertTargets = function(e3, t3) {
              if ((0, n().isBrowsersQueryValid)(t3))
                return t3;
              if (typeof t3 != "object" || !t3 || Array.isArray(t3))
                throw new Error(`${i(e3)} must be a string, an array of strings or an object`);
              const r3 = o(e3, "browsers"), s3 = o(e3, "esmodules");
              f(r3, t3.browsers), a(s3, t3.esmodules);
              for (const r4 of Object.keys(t3)) {
                const s4 = t3[r4], l2 = o(e3, r4);
                if (r4 === "esmodules")
                  a(l2, s4);
                else if (r4 === "browsers")
                  f(l2, s4);
                else {
                  if (!Object.hasOwnProperty.call(n().TargetNames, r4)) {
                    const e4 = Object.keys(n().TargetNames).join(", ");
                    throw new Error(`${i(l2)} is not a valid target. Supported targets are ${e4}`);
                  }
                  d(l2, s4);
                }
              }
              return t3;
            }, t2.assertAssumptions = function(e3, t3) {
              if (t3 === void 0)
                return;
              if (typeof t3 != "object" || t3 === null)
                throw new Error(`${i(e3)} must be an object or undefined.`);
              let r3 = e3;
              do {
                r3 = r3.parent;
              } while (r3.type !== "root");
              const n2 = r3.source === "preset";
              for (const r4 of Object.keys(t3)) {
                const a2 = o(e3, r4);
                if (!s2.assumptionsNames.has(r4))
                  throw new Error(`${i(a2)} is not a supported assumption.`);
                if (typeof t3[r4] != "boolean")
                  throw new Error(`${i(a2)} must be a boolean.`);
                if (n2 && t3[r4] === false)
                  throw new Error(`${i(a2)} cannot be set to 'false' inside presets.`);
              }
              return t3;
            };
            var s2 = r2(82);
            function i(e3) {
              switch (e3.type) {
                case "root":
                  return "";
                case "env":
                  return `${i(e3.parent)}.env["${e3.name}"]`;
                case "overrides":
                  return `${i(e3.parent)}.overrides[${e3.index}]`;
                case "option":
                  return `${i(e3.parent)}.${e3.name}`;
                case "access":
                  return `${i(e3.parent)}[${JSON.stringify(e3.name)}]`;
                default:
                  throw new Error(`Assertion failure: Unknown type ${e3.type}`);
              }
            }
            function o(e3, t3) {
              return { type: "access", name: t3, parent: e3 };
            }
            function a(e3, t3) {
              if (t3 !== void 0 && typeof t3 != "boolean")
                throw new Error(`${i(e3)} must be a boolean, or undefined`);
              return t3;
            }
            function l(e3, t3) {
              if (t3 !== void 0 && (typeof t3 != "object" || Array.isArray(t3) || !t3))
                throw new Error(`${i(e3)} must be an object, or undefined`);
              return t3;
            }
            function c(e3, t3) {
              if (t3 != null && !Array.isArray(t3))
                throw new Error(`${i(e3)} must be an array, or undefined`);
              return t3;
            }
            function u(e3) {
              return typeof e3 == "string" || typeof e3 == "function" || e3 instanceof RegExp;
            }
            function p2(e3, t3) {
              if ((typeof t3 != "object" || !t3) && typeof t3 != "string" && typeof t3 != "function")
                throw new Error(`${i(e3)} must be a string, object, function`);
              return t3;
            }
            function f(e3, t3) {
              if (t3 !== void 0 && !(0, n().isBrowsersQueryValid)(t3))
                throw new Error(`${i(e3)} must be undefined, a string or an array of strings`);
            }
            function d(e3, t3) {
              if ((typeof t3 != "number" || Math.round(t3) !== t3) && typeof t3 != "string")
                throw new Error(`${i(e3)} must be a string or an integer number`);
            }
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(8);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(14);
              return s2 = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = d, t2.loadPartialConfig = void 0;
            var i = r2(79), o = r2(150), a = r2(80), l = r2(300), c = r2(286), u = r2(82), p2 = r2(77), f = r2(289);
            function* d(e3) {
              if (e3 != null && (typeof e3 != "object" || Array.isArray(e3)))
                throw new Error("Babel options must be an object, null, or undefined");
              const t3 = e3 ? (0, u.validate)("arguments", e3) : {}, { envName: r3 = (0, c.getEnv)(), cwd: s3 = ".", root: i2 = ".", rootMode: d2 = "root", caller: h4, cloneInputAst: m2 = true } = t3, y = n().resolve(s3), g = function(e4, t4) {
                switch (t4) {
                  case "root":
                    return e4;
                  case "upward-optional": {
                    const t5 = (0, p2.findConfigUpwards)(e4);
                    return t5 === null ? e4 : t5;
                  }
                  case "upward": {
                    const t5 = (0, p2.findConfigUpwards)(e4);
                    if (t5 !== null)
                      return t5;
                    throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${e4}".
One of the following config files must be in the directory tree: "${p2.ROOT_CONFIG_FILENAMES.join(", ")}".`), { code: "BABEL_ROOT_NOT_FOUND", dirname: e4 });
                  }
                  default:
                    throw new Error("Assertion failure - unknown rootMode value.");
                }
              }(n().resolve(y, i2), d2), b = typeof t3.filename == "string" ? n().resolve(s3, t3.filename) : void 0, v = { filename: b, cwd: y, root: g, envName: r3, caller: h4, showConfig: (yield* (0, p2.resolveShowConfigPath)(y)) === b }, E = yield* (0, l.buildRootChain)(t3, v);
              if (!E)
                return null;
              const x = { assumptions: {} };
              return E.options.forEach((e4) => {
                (0, o.mergeOptions)(x, e4);
              }), { options: Object.assign({}, x, { targets: (0, f.resolveTargets)(x, g), cloneInputAst: m2, babelrc: false, configFile: false, browserslistConfigFile: false, passPerPreset: false, envName: v.envName, cwd: v.cwd, root: v.root, rootMode: "root", filename: typeof v.filename == "string" ? v.filename : void 0, plugins: E.plugins.map((e4) => (0, a.createItemFromDescriptor)(e4)), presets: E.presets.map((e4) => (0, a.createItemFromDescriptor)(e4)) }), context: v, fileHandling: E.fileHandling, ignore: E.ignore, babelrc: E.babelrc, config: E.config, files: E.files };
            }
            const h3 = s2()(function* (e3) {
              let t3 = false;
              if (typeof e3 == "object" && e3 !== null && !Array.isArray(e3)) {
                var r3 = e3;
                ({ showIgnoredFiles: t3 } = r3), e3 = function(e4, t4) {
                  if (e4 == null)
                    return {};
                  var r4, n3, s4 = {}, i2 = Object.keys(e4);
                  for (n3 = 0; n3 < i2.length; n3++)
                    r4 = i2[n3], t4.indexOf(r4) >= 0 || (s4[r4] = e4[r4]);
                  return s4;
                }(r3, ["showIgnoredFiles"]);
              }
              const n2 = yield* d(e3);
              if (!n2)
                return null;
              const { options: s3, babelrc: o2, ignore: a2, config: l2, fileHandling: c4, files: u2 } = n2;
              return c4 !== "ignored" || t3 ? ((s3.plugins || []).forEach((e4) => {
                if (e4.value instanceof i.default)
                  throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
              }), new m(s3, o2 ? o2.filepath : void 0, a2 ? a2.filepath : void 0, l2 ? l2.filepath : void 0, c4, u2)) : null;
            });
            t2.loadPartialConfig = h3;
            class m {
              constructor(e3, t3, r3, n2, s3, i2) {
                this.options = void 0, this.babelrc = void 0, this.babelignore = void 0, this.config = void 0, this.fileHandling = void 0, this.files = void 0, this.options = e3, this.babelignore = r3, this.babelrc = t3, this.config = n2, this.fileHandling = s3, this.files = i2, Object.freeze(this);
              }
              hasFilesystemConfig() {
                return this.babelrc !== void 0 || this.config !== void 0;
              }
            }
            Object.freeze(m.prototype);
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(10);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.run = function* (e3, t3, r3) {
              const u = yield* (0, a.default)(e3.passes, (0, o.default)(e3), t3, r3), p2 = u.opts;
              try {
                yield* function* (e4, t4) {
                  for (const r4 of t4) {
                    const t5 = [], o2 = [], a2 = [];
                    for (const n2 of r4.concat([(0, i.default)()])) {
                      const r5 = new s2.default(e4, n2.key, n2.options);
                      t5.push([n2, r5]), o2.push(r5), a2.push(n2.visitor);
                    }
                    for (const [r5, n2] of t5) {
                      const t6 = r5.pre;
                      if (t6) {
                        const r6 = t6.call(n2, e4);
                        if (yield* [], c(r6))
                          throw new Error("You appear to be using an plugin with an async .pre, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                      }
                    }
                    const l2 = n().default.visitors.merge(a2, o2, e4.opts.wrapPluginVisitorMethod);
                    (0, n().default)(e4.ast, l2, e4.scope);
                    for (const [r5, n2] of t5) {
                      const t6 = r5.post;
                      if (t6) {
                        const r6 = t6.call(n2, e4);
                        if (yield* [], c(r6))
                          throw new Error("You appear to be using an plugin with an async .post, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                      }
                    }
                  }
                }(u, e3.passes);
              } catch (e4) {
                var f;
                throw e4.message = `${(f = p2.filename) != null ? f : "unknown"}: ${e4.message}`, e4.code || (e4.code = "BABEL_TRANSFORM_ERROR"), e4;
              }
              let d, h3;
              try {
                p2.code !== false && ({ outputCode: d, outputMap: h3 } = (0, l.default)(e3.passes, u));
              } catch (e4) {
                var m;
                throw e4.message = `${(m = p2.filename) != null ? m : "unknown"}: ${e4.message}`, e4.code || (e4.code = "BABEL_GENERATE_ERROR"), e4;
              }
              return { metadata: u.metadata, options: p2, ast: p2.ast === true ? u.ast : null, code: d === void 0 ? null : d, map: h3 === void 0 ? null : h3, sourceType: u.ast.program.sourceType };
            };
            var s2 = r2(487), i = r2(488), o = r2(305), a = r2(489), l = r2(494);
            function c(e3) {
              return !(!e3 || typeof e3 != "object" && typeof e3 != "function" || !e3.then || typeof e3.then != "function");
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(8);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const { filename: t3, cwd: r3, filenameRelative: s2 = typeof t3 == "string" ? n().relative(r3, t3) : "unknown", sourceType: i = "module", inputSourceMap: o, sourceMaps: a = !!o, sourceRoot: l = e3.options.moduleRoot, sourceFileName: c = n().basename(s2), comments: u = true, compact: p2 = "auto" } = e3.options, f = e3.options, d = Object.assign({}, f, { parserOpts: Object.assign({ sourceType: n().extname(s2) === ".mjs" ? "module" : i, sourceFileName: t3, plugins: [] }, f.parserOpts), generatorOpts: Object.assign({ filename: t3, auxiliaryCommentBefore: f.auxiliaryCommentBefore, auxiliaryCommentAfter: f.auxiliaryCommentAfter, retainLines: f.retainLines, comments: u, shouldPrintComment: f.shouldPrintComment, compact: p2, minified: f.minified, sourceMaps: a, sourceRoot: l, sourceFileName: c }, f.generatorOpts) });
              for (const t4 of e3.passes)
                for (const e4 of t4)
                  e4.manipulateOptions && e4.manipulateOptions(d, d.parserOpts);
              return d;
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(27);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(39);
              return s2 = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, { parserOpts: t3, highlightCode: r3 = true, filename: o = "unknown" }, a) {
              try {
                const r4 = [];
                for (const s3 of e3)
                  for (const e4 of s3) {
                    const { parserOverride: s4 } = e4;
                    if (s4) {
                      const e5 = s4(a, t3, n().parse);
                      e5 !== void 0 && r4.push(e5);
                    }
                  }
                if (r4.length === 0)
                  return (0, n().parse)(a, t3);
                if (r4.length === 1) {
                  if (yield* [], typeof r4[0].then == "function")
                    throw new Error("You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                  return r4[0];
                }
                throw new Error("More than one plugin attempted to override parsing.");
              } catch (e4) {
                e4.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED" && (e4.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.");
                const { loc: t4, missingPlugin: n2 } = e4;
                if (t4) {
                  const l = (0, s2().codeFrameColumns)(a, { start: { line: t4.line, column: t4.column + 1 } }, { highlightCode: r3 });
                  e4.message = n2 ? `${o}: ` + (0, i.default)(n2[0], t4, l) : `${o}: ${e4.message}

` + l, e4.code = "BABEL_PARSE_ERROR";
                }
                throw e4;
              }
            };
            var i = r2(492);
          }, (e2) => {
            "use strict";
            e2.exports = { isString: function(e3) {
              return typeof e3 == "string";
            }, isObject: function(e3) {
              return typeof e3 == "object" && e3 !== null;
            }, isNull: function(e3) {
              return e3 === null;
            }, isNullOrUndefined: function(e3) {
              return e3 == null;
            } };
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(156), s2 = r2(87), i = r2(35);
            class o {
              constructor(e3 = []) {
                this.version = "8.3.5", this.plugins = this.normalize(e3);
              }
              use(e3) {
                return this.plugins = this.plugins.concat(this.normalize([e3])), this;
              }
              process(e3, t3 = {}) {
                return this.plugins.length !== 0 || t3.parser !== void 0 || t3.stringifier !== void 0 || t3.syntax !== void 0 || t3.hideNothingWarning, new n(this, e3, t3);
              }
              normalize(e3) {
                let t3 = [];
                for (let r3 of e3)
                  if (r3.postcss === true ? r3 = r3() : r3.postcss && (r3 = r3.postcss), typeof r3 == "object" && Array.isArray(r3.plugins))
                    t3 = t3.concat(r3.plugins);
                  else if (typeof r3 == "object" && r3.postcssPlugin)
                    t3.push(r3);
                  else if (typeof r3 == "function")
                    t3.push(r3);
                  else if (typeof r3 != "object" || !r3.parse && !r3.stringify)
                    throw new Error(r3 + " is not a PostCSS plugin");
                return t3;
              }
            }
            e2.exports = o, o.default = o, i.registerProcessor(o), s2.registerProcessor(o);
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(47), s2 = r2(163), i = r2(49), o = r2(88), a = r2(90), l = r2(35), c = r2(89);
            function u(e3, t3) {
              if (Array.isArray(e3))
                return e3.map((e4) => u(e4));
              let { inputs: r3, ...p2 } = e3;
              if (r3) {
                t3 = [];
                for (let e4 of r3) {
                  let r4 = { ...e4, __proto__: a.prototype };
                  r4.map && (r4.map = { ...r4.map, __proto__: s2.prototype }), t3.push(r4);
                }
              }
              if (p2.nodes && (p2.nodes = e3.nodes.map((e4) => u(e4, t3))), p2.source) {
                let { inputId: e4, ...r4 } = p2.source;
                p2.source = r4, e4 != null && (p2.source.input = t3[e4]);
              }
              if (p2.type === "root")
                return new l(p2);
              if (p2.type === "decl")
                return new n(p2);
              if (p2.type === "rule")
                return new c(p2);
              if (p2.type === "comment")
                return new i(p2);
              if (p2.type === "atrule")
                return new o(p2);
              throw new Error("Unknown node type: " + e3.type);
            }
            e2.exports = u, u.default = u;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7), s2 = f(r2(84)), i = f(r2(330)), o = f(r2(331)), a = f(r2(332)), l = f(r2(522)), c = f(r2(525)), u = f(r2(526)), p2 = r2(528);
            function f(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            const d = "postcss-modules";
            function h3(e3) {
              return e3.replace(/-+(\w)/g, (e4, t3) => t3.toUpperCase());
            }
            e2.exports = (e3 = {}) => ({ postcssPlugin: d, OnceExit(t3, { result: r3 }) {
              return (f2 = function* () {
                const f3 = e3.getJSON || u.default, m = t3.source.input.file, y = function(e4, t4) {
                  const r4 = e4.globalModulePaths || null, s3 = e4.exportGlobals || false, i2 = function(e5) {
                    return e5.scopeBehaviour && (0, p2.isValidBehaviour)(e5.scopeBehaviour) ? e5.scopeBehaviour : p2.behaviours.LOCAL;
                  }(e4), a2 = function(e5) {
                    const t5 = e5.generateScopedName || c.default;
                    return typeof t5 == "function" ? t5 : (0, o.default)(t5, { context: n.cwd(), hashPrefix: e5.hashPrefix });
                  }(e4);
                  return r4 && function(e5, t5) {
                    return e5.some((e6) => t5.match(e6));
                  }(r4, t4) ? (0, p2.getDefaultPlugins)({ behaviour: p2.behaviours.GLOBAL, generateScopedName: a2, exportGlobals: s3 }) : (0, p2.getDefaultPlugins)({ behaviour: i2, generateScopedName: a2, exportGlobals: s3 });
                }(e3, m), g = r3.processor.plugins.findIndex(function(e4) {
                  return function(e5) {
                    return e5.postcssPlugin === d;
                  }(e4);
                });
                if (g === -1)
                  throw new Error("Plugin missing from options.");
                const b = [...r3.processor.plugins.slice(0, g), ...y], v = function(e4, t4) {
                  const r4 = e4.root === void 0 ? "/" : e4.root;
                  return typeof e4.Loader == "function" ? new e4.Loader(r4, t4) : new l.default(r4, t4);
                }(e3, b), E = new a.default(v.fetch.bind(v));
                yield (0, s2.default)([...y, E.plugin()]).process(t3, { from: m });
                const x = v.finalSource;
                if (x && t3.prepend(x), e3.localsConvention) {
                  const t4 = typeof e3.localsConvention == "function";
                  E.exportTokens = Object.entries(E.exportTokens).reduce(function(r4, [n2, s3]) {
                    if (t4)
                      return r4[e3.localsConvention(n2, s3, m)] = s3, r4;
                    switch (e3.localsConvention) {
                      case "camelCase":
                        r4[n2] = s3, r4[(0, i.default)(n2)] = s3;
                        break;
                      case "camelCaseOnly":
                        r4[(0, i.default)(n2)] = s3;
                        break;
                      case "dashes":
                        r4[n2] = s3, r4[h3(n2)] = s3;
                        break;
                      case "dashesOnly":
                        r4[h3(n2)] = s3;
                    }
                    return r4;
                  }, {});
                }
                return r3.messages.push({ type: "export", plugin: "postcss-modules", exportTokens: E.exportTokens }), f3(t3.source.input.file, E.exportTokens, r3.opts.to);
              }, function() {
                var e4 = f2.apply(this, arguments);
                return new Promise(function(t4, r4) {
                  return function n2(s3, i2) {
                    try {
                      var o2 = e4[s3](i2), a2 = o2.value;
                    } catch (e5) {
                      return void r4(e5);
                    }
                    if (!o2.done)
                      return Promise.resolve(a2).then(function(e5) {
                        n2("next", e5);
                      }, function(e5) {
                        n2("throw", e5);
                      });
                    t4(a2);
                  }("next");
                });
              })();
              var f2;
            } }), e2.exports.postcss = true;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.hasOwnDecorators = o, t2.hasDecorators = function(e3) {
              return o(e3) || e3.body.body.some(o);
            }, t2.buildDecoratedClass = function(e3, t3, r3, s3) {
              const { node: i2, scope: o2 } = t3, a2 = o2.generateUidIdentifier("initialize"), c4 = i2.id && t3.isDeclaration(), p2 = t3.isInStrictMode(), { superClass: f } = i2;
              let d;
              i2.type = "ClassDeclaration", i2.id || (i2.id = n.types.cloneNode(e3)), f && (d = o2.generateUidIdentifierBasedOnNode(i2.superClass, "super"), i2.superClass = d);
              const h3 = l(i2), m = n.types.arrayExpression(r3.filter((e4) => !e4.node.abstract).map(u.bind(s3, i2.id, d))), y = n.template.expression.ast`
    ${function(e4) {
                try {
                  return e4.addHelper("decorate");
                } catch (e5) {
                  throw e5.code === "BABEL_HELPER_UNKNOWN" && (e5.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode requires '@babel/core' version ^7.0.2 and you appear to be using an older version."), e5;
                }
              }(s3)}(
      ${h3 || n.types.nullLiteral()},
      function (${a2}, ${f ? n.types.cloneNode(d) : null}) {
        ${i2}
        return { F: ${n.types.cloneNode(i2.id)}, d: ${m} };
      },
      ${f}
    )
  `;
              p2 || y.arguments[1].body.directives.push(n.types.directive(n.types.directiveLiteral("use strict")));
              let g = y, b = "arguments.1.body.body.0";
              return c4 && (g = n.template.statement.ast`let ${e3} = ${y}`, b = "declarations.0.init." + b), { instanceNodes: [n.template.statement.ast`${n.types.cloneNode(a2)}(this)`], wrapClass: (e4) => (e4.replaceWith(g), e4.get(b)) };
            };
            var n = r2(9), s2 = r2(70), i = r2(134);
            function o(e3) {
              return !(!e3.decorators || !e3.decorators.length);
            }
            function a(e3, t3) {
              return t3 ? n.types.objectProperty(n.types.identifier(e3), t3) : null;
            }
            function l(e3) {
              let t3;
              return e3.decorators && e3.decorators.length > 0 && (t3 = n.types.arrayExpression(e3.decorators.map((e4) => e4.expression))), e3.decorators = void 0, t3;
            }
            function c(e3) {
              return e3.computed ? e3.key : n.types.isIdentifier(e3.key) ? n.types.stringLiteral(e3.key.name) : n.types.stringLiteral(String(e3.key.value));
            }
            function u(e3, t3, r3) {
              const { node: o2, scope: u2 } = r3, p2 = r3.isClassMethod();
              if (r3.isPrivate())
                throw r3.buildCodeFrameError(`Private ${p2 ? "methods" : "fields"} in decorated classes are not supported yet.`);
              new s2.default({ methodPath: r3, objectRef: e3, superRef: t3, file: this, refToPreserve: e3 }).replace();
              const f = [a("kind", n.types.stringLiteral(p2 ? o2.kind : "field")), a("decorators", l(o2)), a("static", o2.static && n.types.booleanLiteral(true)), a("key", c(o2))].filter(Boolean);
              if (p2) {
                const e4 = o2.computed ? null : o2.key;
                n.types.toExpression(o2), f.push(a("value", (0, i.default)({ node: o2, id: e4, scope: u2 }) || o2));
              } else
                o2.value ? f.push(("value", d = n.template.statements.ast`return ${o2.value}`, n.types.objectMethod("method", n.types.identifier("value"), [], n.types.blockStatement(d)))) : f.push(a("value", u2.buildUndefinedNode()));
              var d;
              return r3.remove(), n.types.objectExpression(f);
            }
          }, (e2) => {
            function t2(e3) {
              var t3 = new Error("Cannot find module '" + e3 + "'");
              throw t3.code = "MODULE_NOT_FOUND", t3;
            }
            t2.keys = () => [], t2.resolve = t2, t2.id = 312, e2.exports = t2;
          }, (e2) => {
            e2.exports = function(e3) {
              "use strict";
              var t2 = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
              function r2(e4, t3) {
                var r3 = e4[0], n2 = e4[1], s3 = e4[2], i2 = e4[3];
                n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & s3 | ~n2 & i2) + t3[0] - 680876936 | 0) << 7 | r3 >>> 25) + n2 | 0) & n2 | ~r3 & s3) + t3[1] - 389564586 | 0) << 12 | i2 >>> 20) + r3 | 0) & r3 | ~i2 & n2) + t3[2] + 606105819 | 0) << 17 | s3 >>> 15) + i2 | 0) & i2 | ~s3 & r3) + t3[3] - 1044525330 | 0) << 22 | n2 >>> 10) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & s3 | ~n2 & i2) + t3[4] - 176418897 | 0) << 7 | r3 >>> 25) + n2 | 0) & n2 | ~r3 & s3) + t3[5] + 1200080426 | 0) << 12 | i2 >>> 20) + r3 | 0) & r3 | ~i2 & n2) + t3[6] - 1473231341 | 0) << 17 | s3 >>> 15) + i2 | 0) & i2 | ~s3 & r3) + t3[7] - 45705983 | 0) << 22 | n2 >>> 10) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & s3 | ~n2 & i2) + t3[8] + 1770035416 | 0) << 7 | r3 >>> 25) + n2 | 0) & n2 | ~r3 & s3) + t3[9] - 1958414417 | 0) << 12 | i2 >>> 20) + r3 | 0) & r3 | ~i2 & n2) + t3[10] - 42063 | 0) << 17 | s3 >>> 15) + i2 | 0) & i2 | ~s3 & r3) + t3[11] - 1990404162 | 0) << 22 | n2 >>> 10) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & s3 | ~n2 & i2) + t3[12] + 1804603682 | 0) << 7 | r3 >>> 25) + n2 | 0) & n2 | ~r3 & s3) + t3[13] - 40341101 | 0) << 12 | i2 >>> 20) + r3 | 0) & r3 | ~i2 & n2) + t3[14] - 1502002290 | 0) << 17 | s3 >>> 15) + i2 | 0) & i2 | ~s3 & r3) + t3[15] + 1236535329 | 0) << 22 | n2 >>> 10) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & i2 | s3 & ~i2) + t3[1] - 165796510 | 0) << 5 | r3 >>> 27) + n2 | 0) & s3 | n2 & ~s3) + t3[6] - 1069501632 | 0) << 9 | i2 >>> 23) + r3 | 0) & n2 | r3 & ~n2) + t3[11] + 643717713 | 0) << 14 | s3 >>> 18) + i2 | 0) & r3 | i2 & ~r3) + t3[0] - 373897302 | 0) << 20 | n2 >>> 12) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & i2 | s3 & ~i2) + t3[5] - 701558691 | 0) << 5 | r3 >>> 27) + n2 | 0) & s3 | n2 & ~s3) + t3[10] + 38016083 | 0) << 9 | i2 >>> 23) + r3 | 0) & n2 | r3 & ~n2) + t3[15] - 660478335 | 0) << 14 | s3 >>> 18) + i2 | 0) & r3 | i2 & ~r3) + t3[4] - 405537848 | 0) << 20 | n2 >>> 12) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & i2 | s3 & ~i2) + t3[9] + 568446438 | 0) << 5 | r3 >>> 27) + n2 | 0) & s3 | n2 & ~s3) + t3[14] - 1019803690 | 0) << 9 | i2 >>> 23) + r3 | 0) & n2 | r3 & ~n2) + t3[3] - 187363961 | 0) << 14 | s3 >>> 18) + i2 | 0) & r3 | i2 & ~r3) + t3[8] + 1163531501 | 0) << 20 | n2 >>> 12) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 & i2 | s3 & ~i2) + t3[13] - 1444681467 | 0) << 5 | r3 >>> 27) + n2 | 0) & s3 | n2 & ~s3) + t3[2] - 51403784 | 0) << 9 | i2 >>> 23) + r3 | 0) & n2 | r3 & ~n2) + t3[7] + 1735328473 | 0) << 14 | s3 >>> 18) + i2 | 0) & r3 | i2 & ~r3) + t3[12] - 1926607734 | 0) << 20 | n2 >>> 12) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 ^ s3 ^ i2) + t3[5] - 378558 | 0) << 4 | r3 >>> 28) + n2 | 0) ^ n2 ^ s3) + t3[8] - 2022574463 | 0) << 11 | i2 >>> 21) + r3 | 0) ^ r3 ^ n2) + t3[11] + 1839030562 | 0) << 16 | s3 >>> 16) + i2 | 0) ^ i2 ^ r3) + t3[14] - 35309556 | 0) << 23 | n2 >>> 9) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 ^ s3 ^ i2) + t3[1] - 1530992060 | 0) << 4 | r3 >>> 28) + n2 | 0) ^ n2 ^ s3) + t3[4] + 1272893353 | 0) << 11 | i2 >>> 21) + r3 | 0) ^ r3 ^ n2) + t3[7] - 155497632 | 0) << 16 | s3 >>> 16) + i2 | 0) ^ i2 ^ r3) + t3[10] - 1094730640 | 0) << 23 | n2 >>> 9) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 ^ s3 ^ i2) + t3[13] + 681279174 | 0) << 4 | r3 >>> 28) + n2 | 0) ^ n2 ^ s3) + t3[0] - 358537222 | 0) << 11 | i2 >>> 21) + r3 | 0) ^ r3 ^ n2) + t3[3] - 722521979 | 0) << 16 | s3 >>> 16) + i2 | 0) ^ i2 ^ r3) + t3[6] + 76029189 | 0) << 23 | n2 >>> 9) + s3 | 0, n2 = ((n2 += ((s3 = ((s3 += ((i2 = ((i2 += ((r3 = ((r3 += (n2 ^ s3 ^ i2) + t3[9] - 640364487 | 0) << 4 | r3 >>> 28) + n2 | 0) ^ n2 ^ s3) + t3[12] - 421815835 | 0) << 11 | i2 >>> 21) + r3 | 0) ^ r3 ^ n2) + t3[15] + 530742520 | 0) << 16 | s3 >>> 16) + i2 | 0) ^ i2 ^ r3) + t3[2] - 995338651 | 0) << 23 | n2 >>> 9) + s3 | 0, n2 = ((n2 += ((i2 = ((i2 += (n2 ^ ((r3 = ((r3 += (s3 ^ (n2 | ~i2)) + t3[0] - 198630844 | 0) << 6 | r3 >>> 26) + n2 | 0) | ~s3)) + t3[7] + 1126891415 | 0) << 10 | i2 >>> 22) + r3 | 0) ^ ((s3 = ((s3 += (r3 ^ (i2 | ~n2)) + t3[14] - 1416354905 | 0) << 15 | s3 >>> 17) + i2 | 0) | ~r3)) + t3[5] - 57434055 | 0) << 21 | n2 >>> 11) + s3 | 0, n2 = ((n2 += ((i2 = ((i2 += (n2 ^ ((r3 = ((r3 += (s3 ^ (n2 | ~i2)) + t3[12] + 1700485571 | 0) << 6 | r3 >>> 26) + n2 | 0) | ~s3)) + t3[3] - 1894986606 | 0) << 10 | i2 >>> 22) + r3 | 0) ^ ((s3 = ((s3 += (r3 ^ (i2 | ~n2)) + t3[10] - 1051523 | 0) << 15 | s3 >>> 17) + i2 | 0) | ~r3)) + t3[1] - 2054922799 | 0) << 21 | n2 >>> 11) + s3 | 0, n2 = ((n2 += ((i2 = ((i2 += (n2 ^ ((r3 = ((r3 += (s3 ^ (n2 | ~i2)) + t3[8] + 1873313359 | 0) << 6 | r3 >>> 26) + n2 | 0) | ~s3)) + t3[15] - 30611744 | 0) << 10 | i2 >>> 22) + r3 | 0) ^ ((s3 = ((s3 += (r3 ^ (i2 | ~n2)) + t3[6] - 1560198380 | 0) << 15 | s3 >>> 17) + i2 | 0) | ~r3)) + t3[13] + 1309151649 | 0) << 21 | n2 >>> 11) + s3 | 0, n2 = ((n2 += ((i2 = ((i2 += (n2 ^ ((r3 = ((r3 += (s3 ^ (n2 | ~i2)) + t3[4] - 145523070 | 0) << 6 | r3 >>> 26) + n2 | 0) | ~s3)) + t3[11] - 1120210379 | 0) << 10 | i2 >>> 22) + r3 | 0) ^ ((s3 = ((s3 += (r3 ^ (i2 | ~n2)) + t3[2] + 718787259 | 0) << 15 | s3 >>> 17) + i2 | 0) | ~r3)) + t3[9] - 343485551 | 0) << 21 | n2 >>> 11) + s3 | 0, e4[0] = r3 + e4[0] | 0, e4[1] = n2 + e4[1] | 0, e4[2] = s3 + e4[2] | 0, e4[3] = i2 + e4[3] | 0;
              }
              function n(e4) {
                var t3, r3 = [];
                for (t3 = 0; t3 < 64; t3 += 4)
                  r3[t3 >> 2] = e4.charCodeAt(t3) + (e4.charCodeAt(t3 + 1) << 8) + (e4.charCodeAt(t3 + 2) << 16) + (e4.charCodeAt(t3 + 3) << 24);
                return r3;
              }
              function s2(e4) {
                var t3, r3 = [];
                for (t3 = 0; t3 < 64; t3 += 4)
                  r3[t3 >> 2] = e4[t3] + (e4[t3 + 1] << 8) + (e4[t3 + 2] << 16) + (e4[t3 + 3] << 24);
                return r3;
              }
              function i(e4) {
                var t3, s3, i2, o2, a2, l2, c4 = e4.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
                for (t3 = 64; t3 <= c4; t3 += 64)
                  r2(u2, n(e4.substring(t3 - 64, t3)));
                for (s3 = (e4 = e4.substring(t3 - 64)).length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t3 = 0; t3 < s3; t3 += 1)
                  i2[t3 >> 2] |= e4.charCodeAt(t3) << (t3 % 4 << 3);
                if (i2[t3 >> 2] |= 128 << (t3 % 4 << 3), t3 > 55)
                  for (r2(u2, i2), t3 = 0; t3 < 16; t3 += 1)
                    i2[t3] = 0;
                return o2 = (o2 = 8 * c4).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(o2[2], 16), l2 = parseInt(o2[1], 16) || 0, i2[14] = a2, i2[15] = l2, r2(u2, i2), u2;
              }
              function o(e4) {
                var r3, n2 = "";
                for (r3 = 0; r3 < 4; r3 += 1)
                  n2 += t2[e4 >> 8 * r3 + 4 & 15] + t2[e4 >> 8 * r3 & 15];
                return n2;
              }
              function a(e4) {
                var t3;
                for (t3 = 0; t3 < e4.length; t3 += 1)
                  e4[t3] = o(e4[t3]);
                return e4.join("");
              }
              function l(e4) {
                return /[\u0080-\uFFFF]/.test(e4) && (e4 = unescape(encodeURIComponent(e4))), e4;
              }
              function c(e4) {
                var t3, r3 = [], n2 = e4.length;
                for (t3 = 0; t3 < n2 - 1; t3 += 2)
                  r3.push(parseInt(e4.substr(t3, 2), 16));
                return String.fromCharCode.apply(String, r3);
              }
              function u() {
                this.reset();
              }
              return a(i("hello")), typeof ArrayBuffer == "undefined" || ArrayBuffer.prototype.slice || function() {
                function e4(e5, t3) {
                  return (e5 = 0 | e5 || 0) < 0 ? Math.max(e5 + t3, 0) : Math.min(e5, t3);
                }
                ArrayBuffer.prototype.slice = function(t3, r3) {
                  var n2, s3, i2, o2, a2 = this.byteLength, l2 = e4(t3, a2), c4 = a2;
                  return r3 !== void 0 && (c4 = e4(r3, a2)), l2 > c4 ? new ArrayBuffer(0) : (n2 = c4 - l2, s3 = new ArrayBuffer(n2), i2 = new Uint8Array(s3), o2 = new Uint8Array(this, l2, n2), i2.set(o2), s3);
                };
              }(), u.prototype.append = function(e4) {
                return this.appendBinary(l(e4)), this;
              }, u.prototype.appendBinary = function(e4) {
                this._buff += e4, this._length += e4.length;
                var t3, s3 = this._buff.length;
                for (t3 = 64; t3 <= s3; t3 += 64)
                  r2(this._hash, n(this._buff.substring(t3 - 64, t3)));
                return this._buff = this._buff.substring(t3 - 64), this;
              }, u.prototype.end = function(e4) {
                var t3, r3, n2 = this._buff, s3 = n2.length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (t3 = 0; t3 < s3; t3 += 1)
                  i2[t3 >> 2] |= n2.charCodeAt(t3) << (t3 % 4 << 3);
                return this._finish(i2, s3), r3 = a(this._hash), e4 && (r3 = c(r3)), this.reset(), r3;
              }, u.prototype.reset = function() {
                return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
              }, u.prototype.getState = function() {
                return { buff: this._buff, length: this._length, hash: this._hash.slice() };
              }, u.prototype.setState = function(e4) {
                return this._buff = e4.buff, this._length = e4.length, this._hash = e4.hash, this;
              }, u.prototype.destroy = function() {
                delete this._hash, delete this._buff, delete this._length;
              }, u.prototype._finish = function(e4, t3) {
                var n2, s3, i2, o2 = t3;
                if (e4[o2 >> 2] |= 128 << (o2 % 4 << 3), o2 > 55)
                  for (r2(this._hash, e4), o2 = 0; o2 < 16; o2 += 1)
                    e4[o2] = 0;
                n2 = (n2 = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), s3 = parseInt(n2[2], 16), i2 = parseInt(n2[1], 16) || 0, e4[14] = s3, e4[15] = i2, r2(this._hash, e4);
              }, u.hash = function(e4, t3) {
                return u.hashBinary(l(e4), t3);
              }, u.hashBinary = function(e4, t3) {
                var r3 = a(i(e4));
                return t3 ? c(r3) : r3;
              }, u.ArrayBuffer = function() {
                this.reset();
              }, u.ArrayBuffer.prototype.append = function(e4) {
                var t3, n2, i2, o2, a2, l2 = (n2 = this._buff.buffer, i2 = e4, o2 = true, (a2 = new Uint8Array(n2.byteLength + i2.byteLength)).set(new Uint8Array(n2)), a2.set(new Uint8Array(i2), n2.byteLength), o2 ? a2 : a2.buffer), c4 = l2.length;
                for (this._length += e4.byteLength, t3 = 64; t3 <= c4; t3 += 64)
                  r2(this._hash, s2(l2.subarray(t3 - 64, t3)));
                return this._buff = t3 - 64 < c4 ? new Uint8Array(l2.buffer.slice(t3 - 64)) : new Uint8Array(0), this;
              }, u.ArrayBuffer.prototype.end = function(e4) {
                var t3, r3, n2 = this._buff, s3 = n2.length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
                for (t3 = 0; t3 < s3; t3 += 1)
                  i2[t3 >> 2] |= n2[t3] << (t3 % 4 << 3);
                return this._finish(i2, s3), r3 = a(this._hash), e4 && (r3 = c(r3)), this.reset(), r3;
              }, u.ArrayBuffer.prototype.reset = function() {
                return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this;
              }, u.ArrayBuffer.prototype.getState = function() {
                var e4, t3 = u.prototype.getState.call(this);
                return t3.buff = (e4 = t3.buff, String.fromCharCode.apply(null, new Uint8Array(e4))), t3;
              }, u.ArrayBuffer.prototype.setState = function(e4) {
                return e4.buff = function(e5, t3) {
                  var r3, n2 = e5.length, s3 = new ArrayBuffer(n2), i2 = new Uint8Array(s3);
                  for (r3 = 0; r3 < n2; r3 += 1)
                    i2[r3] = e5.charCodeAt(r3);
                  return t3 ? i2 : s3;
                }(e4.buff, true), u.prototype.setState.call(this, e4);
              }, u.ArrayBuffer.prototype.destroy = u.prototype.destroy, u.ArrayBuffer.prototype._finish = u.prototype._finish, u.ArrayBuffer.hash = function(e4, t3) {
                var n2 = a(function(e5) {
                  var t4, n3, i2, o2, a2, l2, c4 = e5.length, u2 = [1732584193, -271733879, -1732584194, 271733878];
                  for (t4 = 64; t4 <= c4; t4 += 64)
                    r2(u2, s2(e5.subarray(t4 - 64, t4)));
                  for (n3 = (e5 = t4 - 64 < c4 ? e5.subarray(t4 - 64) : new Uint8Array(0)).length, i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t4 = 0; t4 < n3; t4 += 1)
                    i2[t4 >> 2] |= e5[t4] << (t4 % 4 << 3);
                  if (i2[t4 >> 2] |= 128 << (t4 % 4 << 3), t4 > 55)
                    for (r2(u2, i2), t4 = 0; t4 < 16; t4 += 1)
                      i2[t4] = 0;
                  return o2 = (o2 = 8 * c4).toString(16).match(/(.*?)(.{0,8})$/), a2 = parseInt(o2[2], 16), l2 = parseInt(o2[1], 16) || 0, i2[14] = a2, i2[15] = l2, r2(u2, i2), u2;
                }(new Uint8Array(e4)));
                return t3 ? c(n2) : n2;
              }, u;
            }();
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = r2(315), s2 = r2(83);
            const i = Symbol(""), o = Symbol(""), a = Symbol(""), l = Symbol(""), c = Symbol(""), u = Symbol(""), p2 = Symbol(""), f = Symbol(""), d = Symbol(""), h3 = Symbol("");
            n.registerRuntimeHelpers({ [i]: "vModelRadio", [o]: "vModelCheckbox", [a]: "vModelText", [l]: "vModelSelect", [c]: "vModelDynamic", [u]: "withModifiers", [p2]: "withKeys", [f]: "vShow", [d]: "Transition", [h3]: "TransitionGroup" });
            var m = { GT: ">", gt: ">", LT: "<", lt: "<", "ac;": "\u223E", "af;": "\u2061", AMP: "&", amp: "&", "ap;": "\u2248", "DD;": "\u2145", "dd;": "\u2146", deg: "\xB0", "ee;": "\u2147", "eg;": "\u2A9A", "el;": "\u2A99", ETH: "\xD0", eth: "\xF0", "gE;": "\u2267", "ge;": "\u2265", "Gg;": "\u22D9", "gg;": "\u226B", "gl;": "\u2277", "GT;": ">", "Gt;": "\u226B", "gt;": ">", "ic;": "\u2063", "ii;": "\u2148", "Im;": "\u2111", "in;": "\u2208", "it;": "\u2062", "lE;": "\u2266", "le;": "\u2264", "lg;": "\u2276", "Ll;": "\u22D8", "ll;": "\u226A", "LT;": "<", "Lt;": "\u226A", "lt;": "<", "mp;": "\u2213", "Mu;": "\u039C", "mu;": "\u03BC", "ne;": "\u2260", "ni;": "\u220B", not: "\xAC", "Nu;": "\u039D", "nu;": "\u03BD", "Or;": "\u2A54", "or;": "\u2228", "oS;": "\u24C8", "Pi;": "\u03A0", "pi;": "\u03C0", "pm;": "\xB1", "Pr;": "\u2ABB", "pr;": "\u227A", "Re;": "\u211C", REG: "\xAE", reg: "\xAE", "rx;": "\u211E", "Sc;": "\u2ABC", "sc;": "\u227B", shy: "\xAD", uml: "\xA8", "wp;": "\u2118", "wr;": "\u2240", "Xi;": "\u039E", "xi;": "\u03BE", yen: "\xA5", "acd;": "\u223F", "acE;": "\u223E\u0333", "Acy;": "\u0410", "acy;": "\u0430", "Afr;": "\u{1D504}", "afr;": "\u{1D51E}", "AMP;": "&", "amp;": "&", "And;": "\u2A53", "and;": "\u2227", "ang;": "\u2220", "apE;": "\u2A70", "ape;": "\u224A", "ast;": "*", Auml: "\xC4", auml: "\xE4", "Bcy;": "\u0411", "bcy;": "\u0431", "Bfr;": "\u{1D505}", "bfr;": "\u{1D51F}", "bne;": "=\u20E5", "bot;": "\u22A5", "Cap;": "\u22D2", "cap;": "\u2229", cent: "\xA2", "Cfr;": "\u212D", "cfr;": "\u{1D520}", "Chi;": "\u03A7", "chi;": "\u03C7", "cir;": "\u25CB", COPY: "\xA9", copy: "\xA9", "Cup;": "\u22D3", "cup;": "\u222A", "Dcy;": "\u0414", "dcy;": "\u0434", "deg;": "\xB0", "Del;": "\u2207", "Dfr;": "\u{1D507}", "dfr;": "\u{1D521}", "die;": "\xA8", "div;": "\xF7", "Dot;": "\xA8", "dot;": "\u02D9", "Ecy;": "\u042D", "ecy;": "\u044D", "Efr;": "\u{1D508}", "efr;": "\u{1D522}", "egs;": "\u2A96", "ell;": "\u2113", "els;": "\u2A95", "ENG;": "\u014A", "eng;": "\u014B", "Eta;": "\u0397", "eta;": "\u03B7", "ETH;": "\xD0", "eth;": "\xF0", Euml: "\xCB", euml: "\xEB", "Fcy;": "\u0424", "fcy;": "\u0444", "Ffr;": "\u{1D509}", "ffr;": "\u{1D523}", "gap;": "\u2A86", "Gcy;": "\u0413", "gcy;": "\u0433", "gEl;": "\u2A8C", "gel;": "\u22DB", "geq;": "\u2265", "ges;": "\u2A7E", "Gfr;": "\u{1D50A}", "gfr;": "\u{1D524}", "ggg;": "\u22D9", "gla;": "\u2AA5", "glE;": "\u2A92", "glj;": "\u2AA4", "gnE;": "\u2269", "gne;": "\u2A88", "Hat;": "^", "Hfr;": "\u210C", "hfr;": "\u{1D525}", "Icy;": "\u0418", "icy;": "\u0438", "iff;": "\u21D4", "Ifr;": "\u2111", "ifr;": "\u{1D526}", "Int;": "\u222C", "int;": "\u222B", Iuml: "\xCF", iuml: "\xEF", "Jcy;": "\u0419", "jcy;": "\u0439", "Jfr;": "\u{1D50D}", "jfr;": "\u{1D527}", "Kcy;": "\u041A", "kcy;": "\u043A", "Kfr;": "\u{1D50E}", "kfr;": "\u{1D528}", "lap;": "\u2A85", "lat;": "\u2AAB", "Lcy;": "\u041B", "lcy;": "\u043B", "lEg;": "\u2A8B", "leg;": "\u22DA", "leq;": "\u2264", "les;": "\u2A7D", "Lfr;": "\u{1D50F}", "lfr;": "\u{1D529}", "lgE;": "\u2A91", "lnE;": "\u2268", "lne;": "\u2A87", "loz;": "\u25CA", "lrm;": "\u200E", "Lsh;": "\u21B0", "lsh;": "\u21B0", macr: "\xAF", "Map;": "\u2905", "map;": "\u21A6", "Mcy;": "\u041C", "mcy;": "\u043C", "Mfr;": "\u{1D510}", "mfr;": "\u{1D52A}", "mho;": "\u2127", "mid;": "\u2223", "nap;": "\u2249", nbsp: "\xA0", "Ncy;": "\u041D", "ncy;": "\u043D", "Nfr;": "\u{1D511}", "nfr;": "\u{1D52B}", "ngE;": "\u2267\u0338", "nge;": "\u2271", "nGg;": "\u22D9\u0338", "nGt;": "\u226B\u20D2", "ngt;": "\u226F", "nis;": "\u22FC", "niv;": "\u220B", "nlE;": "\u2266\u0338", "nle;": "\u2270", "nLl;": "\u22D8\u0338", "nLt;": "\u226A\u20D2", "nlt;": "\u226E", "Not;": "\u2AEC", "not;": "\xAC", "npr;": "\u2280", "nsc;": "\u2281", "num;": "#", "Ocy;": "\u041E", "ocy;": "\u043E", "Ofr;": "\u{1D512}", "ofr;": "\u{1D52C}", "ogt;": "\u29C1", "ohm;": "\u03A9", "olt;": "\u29C0", "ord;": "\u2A5D", ordf: "\xAA", ordm: "\xBA", "orv;": "\u2A5B", Ouml: "\xD6", ouml: "\xF6", "par;": "\u2225", para: "\xB6", "Pcy;": "\u041F", "pcy;": "\u043F", "Pfr;": "\u{1D513}", "pfr;": "\u{1D52D}", "Phi;": "\u03A6", "phi;": "\u03C6", "piv;": "\u03D6", "prE;": "\u2AB3", "pre;": "\u2AAF", "Psi;": "\u03A8", "psi;": "\u03C8", "Qfr;": "\u{1D514}", "qfr;": "\u{1D52E}", QUOT: '"', quot: '"', "Rcy;": "\u0420", "rcy;": "\u0440", "REG;": "\xAE", "reg;": "\xAE", "Rfr;": "\u211C", "rfr;": "\u{1D52F}", "Rho;": "\u03A1", "rho;": "\u03C1", "rlm;": "\u200F", "Rsh;": "\u21B1", "rsh;": "\u21B1", "scE;": "\u2AB4", "sce;": "\u2AB0", "Scy;": "\u0421", "scy;": "\u0441", sect: "\xA7", "Sfr;": "\u{1D516}", "sfr;": "\u{1D530}", "shy;": "\xAD", "sim;": "\u223C", "smt;": "\u2AAA", "sol;": "/", "squ;": "\u25A1", "Sub;": "\u22D0", "sub;": "\u2282", "Sum;": "\u2211", "sum;": "\u2211", "Sup;": "\u22D1", "sup;": "\u2283", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", "Tab;": "	", "Tau;": "\u03A4", "tau;": "\u03C4", "Tcy;": "\u0422", "tcy;": "\u0442", "Tfr;": "\u{1D517}", "tfr;": "\u{1D531}", "top;": "\u22A4", "Ucy;": "\u0423", "ucy;": "\u0443", "Ufr;": "\u{1D518}", "ufr;": "\u{1D532}", "uml;": "\xA8", Uuml: "\xDC", uuml: "\xFC", "Vcy;": "\u0412", "vcy;": "\u0432", "Vee;": "\u22C1", "vee;": "\u2228", "Vfr;": "\u{1D519}", "vfr;": "\u{1D533}", "Wfr;": "\u{1D51A}", "wfr;": "\u{1D534}", "Xfr;": "\u{1D51B}", "xfr;": "\u{1D535}", "Ycy;": "\u042B", "ycy;": "\u044B", "yen;": "\xA5", "Yfr;": "\u{1D51C}", "yfr;": "\u{1D536}", yuml: "\xFF", "Zcy;": "\u0417", "zcy;": "\u0437", "Zfr;": "\u2128", "zfr;": "\u{1D537}", "zwj;": "\u200D", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", "andd;": "\u2A5C", "andv;": "\u2A5A", "ange;": "\u29A4", "Aopf;": "\u{1D538}", "aopf;": "\u{1D552}", "apid;": "\u224B", "apos;": "'", Aring: "\xC5", aring: "\xE5", "Ascr;": "\u{1D49C}", "ascr;": "\u{1D4B6}", "Auml;": "\xC4", "auml;": "\xE4", "Barv;": "\u2AE7", "bbrk;": "\u23B5", "Beta;": "\u0392", "beta;": "\u03B2", "beth;": "\u2136", "bNot;": "\u2AED", "bnot;": "\u2310", "Bopf;": "\u{1D539}", "bopf;": "\u{1D553}", "boxH;": "\u2550", "boxh;": "\u2500", "boxV;": "\u2551", "boxv;": "\u2502", "Bscr;": "\u212C", "bscr;": "\u{1D4B7}", "bsim;": "\u223D", "bsol;": "\\", "bull;": "\u2022", "bump;": "\u224E", "caps;": "\u2229\uFE00", "Cdot;": "\u010A", "cdot;": "\u010B", cedil: "\xB8", "cent;": "\xA2", "CHcy;": "\u0427", "chcy;": "\u0447", "circ;": "\u02C6", "cirE;": "\u29C3", "cire;": "\u2257", "comp;": "\u2201", "cong;": "\u2245", "Copf;": "\u2102", "copf;": "\u{1D554}", "COPY;": "\xA9", "copy;": "\xA9", "Cscr;": "\u{1D49E}", "cscr;": "\u{1D4B8}", "csub;": "\u2ACF", "csup;": "\u2AD0", "cups;": "\u222A\uFE00", "Darr;": "\u21A1", "dArr;": "\u21D3", "darr;": "\u2193", "dash;": "\u2010", "dHar;": "\u2965", "diam;": "\u22C4", "DJcy;": "\u0402", "djcy;": "\u0452", "Dopf;": "\u{1D53B}", "dopf;": "\u{1D555}", "Dscr;": "\u{1D49F}", "dscr;": "\u{1D4B9}", "DScy;": "\u0405", "dscy;": "\u0455", "dsol;": "\u29F6", "dtri;": "\u25BF", "DZcy;": "\u040F", "dzcy;": "\u045F", "ecir;": "\u2256", Ecirc: "\xCA", ecirc: "\xEA", "Edot;": "\u0116", "eDot;": "\u2251", "edot;": "\u0117", "emsp;": "\u2003", "ensp;": "\u2002", "Eopf;": "\u{1D53C}", "eopf;": "\u{1D556}", "epar;": "\u22D5", "epsi;": "\u03B5", "Escr;": "\u2130", "escr;": "\u212F", "Esim;": "\u2A73", "esim;": "\u2242", "Euml;": "\xCB", "euml;": "\xEB", "euro;": "\u20AC", "excl;": "!", "flat;": "\u266D", "fnof;": "\u0192", "Fopf;": "\u{1D53D}", "fopf;": "\u{1D557}", "fork;": "\u22D4", "Fscr;": "\u2131", "fscr;": "\u{1D4BB}", "Gdot;": "\u0120", "gdot;": "\u0121", "geqq;": "\u2267", "gesl;": "\u22DB\uFE00", "GJcy;": "\u0403", "gjcy;": "\u0453", "gnap;": "\u2A8A", "gneq;": "\u2A88", "Gopf;": "\u{1D53E}", "gopf;": "\u{1D558}", "Gscr;": "\u{1D4A2}", "gscr;": "\u210A", "gsim;": "\u2273", "gtcc;": "\u2AA7", "gvnE;": "\u2269\uFE00", "half;": "\xBD", "hArr;": "\u21D4", "harr;": "\u2194", "hbar;": "\u210F", "Hopf;": "\u210D", "hopf;": "\u{1D559}", "Hscr;": "\u210B", "hscr;": "\u{1D4BD}", Icirc: "\xCE", icirc: "\xEE", "Idot;": "\u0130", "IEcy;": "\u0415", "iecy;": "\u0435", iexcl: "\xA1", "imof;": "\u22B7", "IOcy;": "\u0401", "iocy;": "\u0451", "Iopf;": "\u{1D540}", "iopf;": "\u{1D55A}", "Iota;": "\u0399", "iota;": "\u03B9", "Iscr;": "\u2110", "iscr;": "\u{1D4BE}", "isin;": "\u2208", "Iuml;": "\xCF", "iuml;": "\xEF", "Jopf;": "\u{1D541}", "jopf;": "\u{1D55B}", "Jscr;": "\u{1D4A5}", "jscr;": "\u{1D4BF}", "KHcy;": "\u0425", "khcy;": "\u0445", "KJcy;": "\u040C", "kjcy;": "\u045C", "Kopf;": "\u{1D542}", "kopf;": "\u{1D55C}", "Kscr;": "\u{1D4A6}", "kscr;": "\u{1D4C0}", "Lang;": "\u27EA", "lang;": "\u27E8", laquo: "\xAB", "Larr;": "\u219E", "lArr;": "\u21D0", "larr;": "\u2190", "late;": "\u2AAD", "lcub;": "{", "ldca;": "\u2936", "ldsh;": "\u21B2", "leqq;": "\u2266", "lesg;": "\u22DA\uFE00", "lHar;": "\u2962", "LJcy;": "\u0409", "ljcy;": "\u0459", "lnap;": "\u2A89", "lneq;": "\u2A87", "Lopf;": "\u{1D543}", "lopf;": "\u{1D55D}", "lozf;": "\u29EB", "lpar;": "(", "Lscr;": "\u2112", "lscr;": "\u{1D4C1}", "lsim;": "\u2272", "lsqb;": "[", "ltcc;": "\u2AA6", "ltri;": "\u25C3", "lvnE;": "\u2268\uFE00", "macr;": "\xAF", "male;": "\u2642", "malt;": "\u2720", micro: "\xB5", "mlcp;": "\u2ADB", "mldr;": "\u2026", "Mopf;": "\u{1D544}", "mopf;": "\u{1D55E}", "Mscr;": "\u2133", "mscr;": "\u{1D4C2}", "nang;": "\u2220\u20D2", "napE;": "\u2A70\u0338", "nbsp;": "\xA0", "ncap;": "\u2A43", "ncup;": "\u2A42", "ngeq;": "\u2271", "nges;": "\u2A7E\u0338", "ngtr;": "\u226F", "nGtv;": "\u226B\u0338", "nisd;": "\u22FA", "NJcy;": "\u040A", "njcy;": "\u045A", "nldr;": "\u2025", "nleq;": "\u2270", "nles;": "\u2A7D\u0338", "nLtv;": "\u226A\u0338", "nmid;": "\u2224", "Nopf;": "\u2115", "nopf;": "\u{1D55F}", "npar;": "\u2226", "npre;": "\u2AAF\u0338", "nsce;": "\u2AB0\u0338", "Nscr;": "\u{1D4A9}", "nscr;": "\u{1D4C3}", "nsim;": "\u2241", "nsub;": "\u2284", "nsup;": "\u2285", "ntgl;": "\u2279", "ntlg;": "\u2278", "nvap;": "\u224D\u20D2", "nvge;": "\u2265\u20D2", "nvgt;": ">\u20D2", "nvle;": "\u2264\u20D2", "nvlt;": "<\u20D2", "oast;": "\u229B", "ocir;": "\u229A", Ocirc: "\xD4", ocirc: "\xF4", "odiv;": "\u2A38", "odot;": "\u2299", "ogon;": "\u02DB", "oint;": "\u222E", "omid;": "\u29B6", "Oopf;": "\u{1D546}", "oopf;": "\u{1D560}", "opar;": "\u29B7", "ordf;": "\xAA", "ordm;": "\xBA", "oror;": "\u2A56", "Oscr;": "\u{1D4AA}", "oscr;": "\u2134", "osol;": "\u2298", "Ouml;": "\xD6", "ouml;": "\xF6", "para;": "\xB6", "part;": "\u2202", "perp;": "\u22A5", "phiv;": "\u03D5", "plus;": "+", "Popf;": "\u2119", "popf;": "\u{1D561}", pound: "\xA3", "prap;": "\u2AB7", "prec;": "\u227A", "prnE;": "\u2AB5", "prod;": "\u220F", "prop;": "\u221D", "Pscr;": "\u{1D4AB}", "pscr;": "\u{1D4C5}", "qint;": "\u2A0C", "Qopf;": "\u211A", "qopf;": "\u{1D562}", "Qscr;": "\u{1D4AC}", "qscr;": "\u{1D4C6}", "QUOT;": '"', "quot;": '"', "race;": "\u223D\u0331", "Rang;": "\u27EB", "rang;": "\u27E9", raquo: "\xBB", "Rarr;": "\u21A0", "rArr;": "\u21D2", "rarr;": "\u2192", "rcub;": "}", "rdca;": "\u2937", "rdsh;": "\u21B3", "real;": "\u211C", "rect;": "\u25AD", "rHar;": "\u2964", "rhov;": "\u03F1", "ring;": "\u02DA", "Ropf;": "\u211D", "ropf;": "\u{1D563}", "rpar;": ")", "Rscr;": "\u211B", "rscr;": "\u{1D4C7}", "rsqb;": "]", "rtri;": "\u25B9", "scap;": "\u2AB8", "scnE;": "\u2AB6", "sdot;": "\u22C5", "sect;": "\xA7", "semi;": ";", "sext;": "\u2736", "SHcy;": "\u0428", "shcy;": "\u0448", "sime;": "\u2243", "simg;": "\u2A9E", "siml;": "\u2A9D", "smid;": "\u2223", "smte;": "\u2AAC", "solb;": "\u29C4", "Sopf;": "\u{1D54A}", "sopf;": "\u{1D564}", "spar;": "\u2225", "Sqrt;": "\u221A", "squf;": "\u25AA", "Sscr;": "\u{1D4AE}", "sscr;": "\u{1D4C8}", "Star;": "\u22C6", "star;": "\u2606", "subE;": "\u2AC5", "sube;": "\u2286", "succ;": "\u227B", "sung;": "\u266A", "sup1;": "\xB9", "sup2;": "\xB2", "sup3;": "\xB3", "supE;": "\u2AC6", "supe;": "\u2287", szlig: "\xDF", "tbrk;": "\u23B4", "tdot;": "\u20DB", THORN: "\xDE", thorn: "\xFE", times: "\xD7", "tint;": "\u222D", "toea;": "\u2928", "Topf;": "\u{1D54B}", "topf;": "\u{1D565}", "tosa;": "\u2929", "trie;": "\u225C", "Tscr;": "\u{1D4AF}", "tscr;": "\u{1D4C9}", "TScy;": "\u0426", "tscy;": "\u0446", "Uarr;": "\u219F", "uArr;": "\u21D1", "uarr;": "\u2191", Ucirc: "\xDB", ucirc: "\xFB", "uHar;": "\u2963", "Uopf;": "\u{1D54C}", "uopf;": "\u{1D566}", "Upsi;": "\u03D2", "upsi;": "\u03C5", "Uscr;": "\u{1D4B0}", "uscr;": "\u{1D4CA}", "utri;": "\u25B5", "Uuml;": "\xDC", "uuml;": "\xFC", "vArr;": "\u21D5", "varr;": "\u2195", "Vbar;": "\u2AEB", "vBar;": "\u2AE8", "Vert;": "\u2016", "vert;": "|", "Vopf;": "\u{1D54D}", "vopf;": "\u{1D567}", "Vscr;": "\u{1D4B1}", "vscr;": "\u{1D4CB}", "Wopf;": "\u{1D54E}", "wopf;": "\u{1D568}", "Wscr;": "\u{1D4B2}", "wscr;": "\u{1D4CC}", "xcap;": "\u22C2", "xcup;": "\u22C3", "xmap;": "\u27FC", "xnis;": "\u22FB", "Xopf;": "\u{1D54F}", "xopf;": "\u{1D569}", "Xscr;": "\u{1D4B3}", "xscr;": "\u{1D4CD}", "xvee;": "\u22C1", "YAcy;": "\u042F", "yacy;": "\u044F", "YIcy;": "\u0407", "yicy;": "\u0457", "Yopf;": "\u{1D550}", "yopf;": "\u{1D56A}", "Yscr;": "\u{1D4B4}", "yscr;": "\u{1D4CE}", "YUcy;": "\u042E", "yucy;": "\u044E", "Yuml;": "\u0178", "yuml;": "\xFF", "Zdot;": "\u017B", "zdot;": "\u017C", "Zeta;": "\u0396", "zeta;": "\u03B6", "ZHcy;": "\u0416", "zhcy;": "\u0436", "Zopf;": "\u2124", "zopf;": "\u{1D56B}", "Zscr;": "\u{1D4B5}", "zscr;": "\u{1D4CF}", "zwnj;": "\u200C", Aacute: "\xC1", aacute: "\xE1", "Acirc;": "\xC2", "acirc;": "\xE2", "acute;": "\xB4", "AElig;": "\xC6", "aelig;": "\xE6", Agrave: "\xC0", agrave: "\xE0", "aleph;": "\u2135", "Alpha;": "\u0391", "alpha;": "\u03B1", "Amacr;": "\u0100", "amacr;": "\u0101", "amalg;": "\u2A3F", "angle;": "\u2220", "angrt;": "\u221F", "angst;": "\xC5", "Aogon;": "\u0104", "aogon;": "\u0105", "Aring;": "\xC5", "aring;": "\xE5", "asymp;": "\u2248", Atilde: "\xC3", atilde: "\xE3", "awint;": "\u2A11", "bcong;": "\u224C", "bdquo;": "\u201E", "bepsi;": "\u03F6", "blank;": "\u2423", "blk12;": "\u2592", "blk14;": "\u2591", "blk34;": "\u2593", "block;": "\u2588", "boxDL;": "\u2557", "boxDl;": "\u2556", "boxdL;": "\u2555", "boxdl;": "\u2510", "boxDR;": "\u2554", "boxDr;": "\u2553", "boxdR;": "\u2552", "boxdr;": "\u250C", "boxHD;": "\u2566", "boxHd;": "\u2564", "boxhD;": "\u2565", "boxhd;": "\u252C", "boxHU;": "\u2569", "boxHu;": "\u2567", "boxhU;": "\u2568", "boxhu;": "\u2534", "boxUL;": "\u255D", "boxUl;": "\u255C", "boxuL;": "\u255B", "boxul;": "\u2518", "boxUR;": "\u255A", "boxUr;": "\u2559", "boxuR;": "\u2558", "boxur;": "\u2514", "boxVH;": "\u256C", "boxVh;": "\u256B", "boxvH;": "\u256A", "boxvh;": "\u253C", "boxVL;": "\u2563", "boxVl;": "\u2562", "boxvL;": "\u2561", "boxvl;": "\u2524", "boxVR;": "\u2560", "boxVr;": "\u255F", "boxvR;": "\u255E", "boxvr;": "\u251C", "Breve;": "\u02D8", "breve;": "\u02D8", brvbar: "\xA6", "bsemi;": "\u204F", "bsime;": "\u22CD", "bsolb;": "\u29C5", "bumpE;": "\u2AAE", "bumpe;": "\u224F", "caret;": "\u2041", "caron;": "\u02C7", "ccaps;": "\u2A4D", Ccedil: "\xC7", ccedil: "\xE7", "Ccirc;": "\u0108", "ccirc;": "\u0109", "ccups;": "\u2A4C", "cedil;": "\xB8", "check;": "\u2713", "clubs;": "\u2663", "Colon;": "\u2237", "colon;": ":", "comma;": ",", "crarr;": "\u21B5", "Cross;": "\u2A2F", "cross;": "\u2717", "csube;": "\u2AD1", "csupe;": "\u2AD2", "ctdot;": "\u22EF", "cuepr;": "\u22DE", "cuesc;": "\u22DF", "cupor;": "\u2A45", curren: "\xA4", "cuvee;": "\u22CE", "cuwed;": "\u22CF", "cwint;": "\u2231", "Dashv;": "\u2AE4", "dashv;": "\u22A3", "dblac;": "\u02DD", "ddarr;": "\u21CA", "Delta;": "\u0394", "delta;": "\u03B4", "dharl;": "\u21C3", "dharr;": "\u21C2", "diams;": "\u2666", "disin;": "\u22F2", divide: "\xF7", "doteq;": "\u2250", "dtdot;": "\u22F1", "dtrif;": "\u25BE", "duarr;": "\u21F5", "duhar;": "\u296F", Eacute: "\xC9", eacute: "\xE9", "Ecirc;": "\xCA", "ecirc;": "\xEA", "eDDot;": "\u2A77", "efDot;": "\u2252", Egrave: "\xC8", egrave: "\xE8", "Emacr;": "\u0112", "emacr;": "\u0113", "empty;": "\u2205", "Eogon;": "\u0118", "eogon;": "\u0119", "eplus;": "\u2A71", "epsiv;": "\u03F5", "eqsim;": "\u2242", "Equal;": "\u2A75", "equiv;": "\u2261", "erarr;": "\u2971", "erDot;": "\u2253", "esdot;": "\u2250", "exist;": "\u2203", "fflig;": "\uFB00", "filig;": "\uFB01", "fjlig;": "fj", "fllig;": "\uFB02", "fltns;": "\u25B1", "forkv;": "\u2AD9", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", "frasl;": "\u2044", "frown;": "\u2322", "Gamma;": "\u0393", "gamma;": "\u03B3", "Gcirc;": "\u011C", "gcirc;": "\u011D", "gescc;": "\u2AA9", "gimel;": "\u2137", "gneqq;": "\u2269", "gnsim;": "\u22E7", "grave;": "`", "gsime;": "\u2A8E", "gsiml;": "\u2A90", "gtcir;": "\u2A7A", "gtdot;": "\u22D7", "Hacek;": "\u02C7", "harrw;": "\u21AD", "Hcirc;": "\u0124", "hcirc;": "\u0125", "hoarr;": "\u21FF", Iacute: "\xCD", iacute: "\xED", "Icirc;": "\xCE", "icirc;": "\xEE", "iexcl;": "\xA1", Igrave: "\xCC", igrave: "\xEC", "iiint;": "\u222D", "iiota;": "\u2129", "IJlig;": "\u0132", "ijlig;": "\u0133", "Imacr;": "\u012A", "imacr;": "\u012B", "image;": "\u2111", "imath;": "\u0131", "imped;": "\u01B5", "infin;": "\u221E", "Iogon;": "\u012E", "iogon;": "\u012F", "iprod;": "\u2A3C", iquest: "\xBF", "isinE;": "\u22F9", "isins;": "\u22F4", "isinv;": "\u2208", "Iukcy;": "\u0406", "iukcy;": "\u0456", "Jcirc;": "\u0134", "jcirc;": "\u0135", "jmath;": "\u0237", "Jukcy;": "\u0404", "jukcy;": "\u0454", "Kappa;": "\u039A", "kappa;": "\u03BA", "lAarr;": "\u21DA", "langd;": "\u2991", "laquo;": "\xAB", "larrb;": "\u21E4", "lates;": "\u2AAD\uFE00", "lBarr;": "\u290E", "lbarr;": "\u290C", "lbbrk;": "\u2772", "lbrke;": "\u298B", "lceil;": "\u2308", "ldquo;": "\u201C", "lescc;": "\u2AA8", "lhard;": "\u21BD", "lharu;": "\u21BC", "lhblk;": "\u2584", "llarr;": "\u21C7", "lltri;": "\u25FA", "lneqq;": "\u2268", "lnsim;": "\u22E6", "loang;": "\u27EC", "loarr;": "\u21FD", "lobrk;": "\u27E6", "lopar;": "\u2985", "lrarr;": "\u21C6", "lrhar;": "\u21CB", "lrtri;": "\u22BF", "lsime;": "\u2A8D", "lsimg;": "\u2A8F", "lsquo;": "\u2018", "ltcir;": "\u2A79", "ltdot;": "\u22D6", "ltrie;": "\u22B4", "ltrif;": "\u25C2", "mdash;": "\u2014", "mDDot;": "\u223A", "micro;": "\xB5", middot: "\xB7", "minus;": "\u2212", "mumap;": "\u22B8", "nabla;": "\u2207", "napid;": "\u224B\u0338", "napos;": "\u0149", "natur;": "\u266E", "nbump;": "\u224E\u0338", "ncong;": "\u2247", "ndash;": "\u2013", "neArr;": "\u21D7", "nearr;": "\u2197", "nedot;": "\u2250\u0338", "nesim;": "\u2242\u0338", "ngeqq;": "\u2267\u0338", "ngsim;": "\u2275", "nhArr;": "\u21CE", "nharr;": "\u21AE", "nhpar;": "\u2AF2", "nlArr;": "\u21CD", "nlarr;": "\u219A", "nleqq;": "\u2266\u0338", "nless;": "\u226E", "nlsim;": "\u2274", "nltri;": "\u22EA", "notin;": "\u2209", "notni;": "\u220C", "npart;": "\u2202\u0338", "nprec;": "\u2280", "nrArr;": "\u21CF", "nrarr;": "\u219B", "nrtri;": "\u22EB", "nsime;": "\u2244", "nsmid;": "\u2224", "nspar;": "\u2226", "nsubE;": "\u2AC5\u0338", "nsube;": "\u2288", "nsucc;": "\u2281", "nsupE;": "\u2AC6\u0338", "nsupe;": "\u2289", Ntilde: "\xD1", ntilde: "\xF1", "numsp;": "\u2007", "nvsim;": "\u223C\u20D2", "nwArr;": "\u21D6", "nwarr;": "\u2196", Oacute: "\xD3", oacute: "\xF3", "Ocirc;": "\xD4", "ocirc;": "\xF4", "odash;": "\u229D", "OElig;": "\u0152", "oelig;": "\u0153", "ofcir;": "\u29BF", Ograve: "\xD2", ograve: "\xF2", "ohbar;": "\u29B5", "olarr;": "\u21BA", "olcir;": "\u29BE", "oline;": "\u203E", "Omacr;": "\u014C", "omacr;": "\u014D", "Omega;": "\u03A9", "omega;": "\u03C9", "operp;": "\u29B9", "oplus;": "\u2295", "orarr;": "\u21BB", "order;": "\u2134", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", "ovbar;": "\u233D", "parsl;": "\u2AFD", "phone;": "\u260E", "plusb;": "\u229E", "pluse;": "\u2A72", plusmn: "\xB1", "pound;": "\xA3", "prcue;": "\u227C", "Prime;": "\u2033", "prime;": "\u2032", "prnap;": "\u2AB9", "prsim;": "\u227E", "quest;": "?", "rAarr;": "\u21DB", "radic;": "\u221A", "rangd;": "\u2992", "range;": "\u29A5", "raquo;": "\xBB", "rarrb;": "\u21E5", "rarrc;": "\u2933", "rarrw;": "\u219D", "ratio;": "\u2236", "RBarr;": "\u2910", "rBarr;": "\u290F", "rbarr;": "\u290D", "rbbrk;": "\u2773", "rbrke;": "\u298C", "rceil;": "\u2309", "rdquo;": "\u201D", "reals;": "\u211D", "rhard;": "\u21C1", "rharu;": "\u21C0", "rlarr;": "\u21C4", "rlhar;": "\u21CC", "rnmid;": "\u2AEE", "roang;": "\u27ED", "roarr;": "\u21FE", "robrk;": "\u27E7", "ropar;": "\u2986", "rrarr;": "\u21C9", "rsquo;": "\u2019", "rtrie;": "\u22B5", "rtrif;": "\u25B8", "sbquo;": "\u201A", "sccue;": "\u227D", "Scirc;": "\u015C", "scirc;": "\u015D", "scnap;": "\u2ABA", "scsim;": "\u227F", "sdotb;": "\u22A1", "sdote;": "\u2A66", "seArr;": "\u21D8", "searr;": "\u2198", "setmn;": "\u2216", "sharp;": "\u266F", "Sigma;": "\u03A3", "sigma;": "\u03C3", "simeq;": "\u2243", "simgE;": "\u2AA0", "simlE;": "\u2A9F", "simne;": "\u2246", "slarr;": "\u2190", "smile;": "\u2323", "smtes;": "\u2AAC\uFE00", "sqcap;": "\u2293", "sqcup;": "\u2294", "sqsub;": "\u228F", "sqsup;": "\u2290", "srarr;": "\u2192", "starf;": "\u2605", "strns;": "\xAF", "subnE;": "\u2ACB", "subne;": "\u228A", "supnE;": "\u2ACC", "supne;": "\u228B", "swArr;": "\u21D9", "swarr;": "\u2199", "szlig;": "\xDF", "Theta;": "\u0398", "theta;": "\u03B8", "thkap;": "\u2248", "THORN;": "\xDE", "thorn;": "\xFE", "Tilde;": "\u223C", "tilde;": "\u02DC", "times;": "\xD7", "TRADE;": "\u2122", "trade;": "\u2122", "trisb;": "\u29CD", "TSHcy;": "\u040B", "tshcy;": "\u045B", "twixt;": "\u226C", Uacute: "\xDA", uacute: "\xFA", "Ubrcy;": "\u040E", "ubrcy;": "\u045E", "Ucirc;": "\xDB", "ucirc;": "\xFB", "udarr;": "\u21C5", "udhar;": "\u296E", Ugrave: "\xD9", ugrave: "\xF9", "uharl;": "\u21BF", "uharr;": "\u21BE", "uhblk;": "\u2580", "ultri;": "\u25F8", "Umacr;": "\u016A", "umacr;": "\u016B", "Union;": "\u22C3", "Uogon;": "\u0172", "uogon;": "\u0173", "uplus;": "\u228E", "upsih;": "\u03D2", "UpTee;": "\u22A5", "Uring;": "\u016E", "uring;": "\u016F", "urtri;": "\u25F9", "utdot;": "\u22F0", "utrif;": "\u25B4", "uuarr;": "\u21C8", "varpi;": "\u03D6", "vBarv;": "\u2AE9", "VDash;": "\u22AB", "Vdash;": "\u22A9", "vDash;": "\u22A8", "vdash;": "\u22A2", "veeeq;": "\u225A", "vltri;": "\u22B2", "vnsub;": "\u2282\u20D2", "vnsup;": "\u2283\u20D2", "vprop;": "\u221D", "vrtri;": "\u22B3", "Wcirc;": "\u0174", "wcirc;": "\u0175", "Wedge;": "\u22C0", "wedge;": "\u2227", "xcirc;": "\u25EF", "xdtri;": "\u25BD", "xhArr;": "\u27FA", "xharr;": "\u27F7", "xlArr;": "\u27F8", "xlarr;": "\u27F5", "xodot;": "\u2A00", "xrArr;": "\u27F9", "xrarr;": "\u27F6", "xutri;": "\u25B3", Yacute: "\xDD", yacute: "\xFD", "Ycirc;": "\u0176", "ycirc;": "\u0177", "Aacute;": "\xC1", "aacute;": "\xE1", "Abreve;": "\u0102", "abreve;": "\u0103", "Agrave;": "\xC0", "agrave;": "\xE0", "andand;": "\u2A55", "angmsd;": "\u2221", "angsph;": "\u2222", "apacir;": "\u2A6F", "approx;": "\u2248", "Assign;": "\u2254", "Atilde;": "\xC3", "atilde;": "\xE3", "barvee;": "\u22BD", "Barwed;": "\u2306", "barwed;": "\u2305", "becaus;": "\u2235", "bernou;": "\u212C", "bigcap;": "\u22C2", "bigcup;": "\u22C3", "bigvee;": "\u22C1", "bkarow;": "\u290D", "bottom;": "\u22A5", "bowtie;": "\u22C8", "boxbox;": "\u29C9", "bprime;": "\u2035", "brvbar;": "\xA6", "bullet;": "\u2022", "Bumpeq;": "\u224E", "bumpeq;": "\u224F", "Cacute;": "\u0106", "cacute;": "\u0107", "capand;": "\u2A44", "capcap;": "\u2A4B", "capcup;": "\u2A47", "capdot;": "\u2A40", "Ccaron;": "\u010C", "ccaron;": "\u010D", "Ccedil;": "\xC7", "ccedil;": "\xE7", "circeq;": "\u2257", "cirmid;": "\u2AEF", "Colone;": "\u2A74", "colone;": "\u2254", "commat;": "@", "compfn;": "\u2218", "Conint;": "\u222F", "conint;": "\u222E", "coprod;": "\u2210", "copysr;": "\u2117", "cularr;": "\u21B6", "CupCap;": "\u224D", "cupcap;": "\u2A46", "cupcup;": "\u2A4A", "cupdot;": "\u228D", "curarr;": "\u21B7", "curren;": "\xA4", "cylcty;": "\u232D", "Dagger;": "\u2021", "dagger;": "\u2020", "daleth;": "\u2138", "Dcaron;": "\u010E", "dcaron;": "\u010F", "dfisht;": "\u297F", "divide;": "\xF7", "divonx;": "\u22C7", "dlcorn;": "\u231E", "dlcrop;": "\u230D", "dollar;": "$", "DotDot;": "\u20DC", "drcorn;": "\u231F", "drcrop;": "\u230C", "Dstrok;": "\u0110", "dstrok;": "\u0111", "Eacute;": "\xC9", "eacute;": "\xE9", "easter;": "\u2A6E", "Ecaron;": "\u011A", "ecaron;": "\u011B", "ecolon;": "\u2255", "Egrave;": "\xC8", "egrave;": "\xE8", "egsdot;": "\u2A98", "elsdot;": "\u2A97", "emptyv;": "\u2205", "emsp13;": "\u2004", "emsp14;": "\u2005", "eparsl;": "\u29E3", "eqcirc;": "\u2256", "equals;": "=", "equest;": "\u225F", "Exists;": "\u2203", "female;": "\u2640", "ffilig;": "\uFB03", "ffllig;": "\uFB04", "ForAll;": "\u2200", "forall;": "\u2200", "frac12;": "\xBD", "frac13;": "\u2153", "frac14;": "\xBC", "frac15;": "\u2155", "frac16;": "\u2159", "frac18;": "\u215B", "frac23;": "\u2154", "frac25;": "\u2156", "frac34;": "\xBE", "frac35;": "\u2157", "frac38;": "\u215C", "frac45;": "\u2158", "frac56;": "\u215A", "frac58;": "\u215D", "frac78;": "\u215E", "gacute;": "\u01F5", "Gammad;": "\u03DC", "gammad;": "\u03DD", "Gbreve;": "\u011E", "gbreve;": "\u011F", "Gcedil;": "\u0122", "gesdot;": "\u2A80", "gesles;": "\u2A94", "gtlPar;": "\u2995", "gtrarr;": "\u2978", "gtrdot;": "\u22D7", "gtrsim;": "\u2273", "hairsp;": "\u200A", "hamilt;": "\u210B", "HARDcy;": "\u042A", "hardcy;": "\u044A", "hearts;": "\u2665", "hellip;": "\u2026", "hercon;": "\u22B9", "homtht;": "\u223B", "horbar;": "\u2015", "hslash;": "\u210F", "Hstrok;": "\u0126", "hstrok;": "\u0127", "hybull;": "\u2043", "hyphen;": "\u2010", "Iacute;": "\xCD", "iacute;": "\xED", "Igrave;": "\xCC", "igrave;": "\xEC", "iiiint;": "\u2A0C", "iinfin;": "\u29DC", "incare;": "\u2105", "inodot;": "\u0131", "intcal;": "\u22BA", "iquest;": "\xBF", "isinsv;": "\u22F3", "Itilde;": "\u0128", "itilde;": "\u0129", "Jsercy;": "\u0408", "jsercy;": "\u0458", "kappav;": "\u03F0", "Kcedil;": "\u0136", "kcedil;": "\u0137", "kgreen;": "\u0138", "Lacute;": "\u0139", "lacute;": "\u013A", "lagran;": "\u2112", "Lambda;": "\u039B", "lambda;": "\u03BB", "langle;": "\u27E8", "larrfs;": "\u291D", "larrhk;": "\u21A9", "larrlp;": "\u21AB", "larrpl;": "\u2939", "larrtl;": "\u21A2", "lAtail;": "\u291B", "latail;": "\u2919", "lbrace;": "{", "lbrack;": "[", "Lcaron;": "\u013D", "lcaron;": "\u013E", "Lcedil;": "\u013B", "lcedil;": "\u013C", "ldquor;": "\u201E", "lesdot;": "\u2A7F", "lesges;": "\u2A93", "lfisht;": "\u297C", "lfloor;": "\u230A", "lharul;": "\u296A", "llhard;": "\u296B", "Lmidot;": "\u013F", "lmidot;": "\u0140", "lmoust;": "\u23B0", "loplus;": "\u2A2D", "lowast;": "\u2217", "lowbar;": "_", "lparlt;": "\u2993", "lrhard;": "\u296D", "lsaquo;": "\u2039", "lsquor;": "\u201A", "Lstrok;": "\u0141", "lstrok;": "\u0142", "lthree;": "\u22CB", "ltimes;": "\u22C9", "ltlarr;": "\u2976", "ltrPar;": "\u2996", "mapsto;": "\u21A6", "marker;": "\u25AE", "mcomma;": "\u2A29", "midast;": "*", "midcir;": "\u2AF0", "middot;": "\xB7", "minusb;": "\u229F", "minusd;": "\u2238", "mnplus;": "\u2213", "models;": "\u22A7", "mstpos;": "\u223E", "Nacute;": "\u0143", "nacute;": "\u0144", "nbumpe;": "\u224F\u0338", "Ncaron;": "\u0147", "ncaron;": "\u0148", "Ncedil;": "\u0145", "ncedil;": "\u0146", "nearhk;": "\u2924", "nequiv;": "\u2262", "nesear;": "\u2928", "nexist;": "\u2204", "nltrie;": "\u22EC", "notinE;": "\u22F9\u0338", "nparsl;": "\u2AFD\u20E5", "nprcue;": "\u22E0", "nrarrc;": "\u2933\u0338", "nrarrw;": "\u219D\u0338", "nrtrie;": "\u22ED", "nsccue;": "\u22E1", "nsimeq;": "\u2244", "Ntilde;": "\xD1", "ntilde;": "\xF1", "numero;": "\u2116", "nVDash;": "\u22AF", "nVdash;": "\u22AE", "nvDash;": "\u22AD", "nvdash;": "\u22AC", "nvHarr;": "\u2904", "nvlArr;": "\u2902", "nvrArr;": "\u2903", "nwarhk;": "\u2923", "nwnear;": "\u2927", "Oacute;": "\xD3", "oacute;": "\xF3", "Odblac;": "\u0150", "odblac;": "\u0151", "odsold;": "\u29BC", "Ograve;": "\xD2", "ograve;": "\xF2", "ominus;": "\u2296", "origof;": "\u22B6", "Oslash;": "\xD8", "oslash;": "\xF8", "Otilde;": "\xD5", "otilde;": "\xF5", "Otimes;": "\u2A37", "otimes;": "\u2297", "parsim;": "\u2AF3", "percnt;": "%", "period;": ".", "permil;": "\u2030", "phmmat;": "\u2133", "planck;": "\u210F", "plankv;": "\u210F", "plusdo;": "\u2214", "plusdu;": "\u2A25", "plusmn;": "\xB1", "preceq;": "\u2AAF", "primes;": "\u2119", "prnsim;": "\u22E8", "propto;": "\u221D", "prurel;": "\u22B0", "puncsp;": "\u2008", "qprime;": "\u2057", "Racute;": "\u0154", "racute;": "\u0155", "rangle;": "\u27E9", "rarrap;": "\u2975", "rarrfs;": "\u291E", "rarrhk;": "\u21AA", "rarrlp;": "\u21AC", "rarrpl;": "\u2945", "Rarrtl;": "\u2916", "rarrtl;": "\u21A3", "rAtail;": "\u291C", "ratail;": "\u291A", "rbrace;": "}", "rbrack;": "]", "Rcaron;": "\u0158", "rcaron;": "\u0159", "Rcedil;": "\u0156", "rcedil;": "\u0157", "rdquor;": "\u201D", "rfisht;": "\u297D", "rfloor;": "\u230B", "rharul;": "\u296C", "rmoust;": "\u23B1", "roplus;": "\u2A2E", "rpargt;": "\u2994", "rsaquo;": "\u203A", "rsquor;": "\u2019", "rthree;": "\u22CC", "rtimes;": "\u22CA", "Sacute;": "\u015A", "sacute;": "\u015B", "Scaron;": "\u0160", "scaron;": "\u0161", "Scedil;": "\u015E", "scedil;": "\u015F", "scnsim;": "\u22E9", "searhk;": "\u2925", "seswar;": "\u2929", "sfrown;": "\u2322", "SHCHcy;": "\u0429", "shchcy;": "\u0449", "sigmaf;": "\u03C2", "sigmav;": "\u03C2", "simdot;": "\u2A6A", "smashp;": "\u2A33", "SOFTcy;": "\u042C", "softcy;": "\u044C", "solbar;": "\u233F", "spades;": "\u2660", "sqcaps;": "\u2293\uFE00", "sqcups;": "\u2294\uFE00", "sqsube;": "\u2291", "sqsupe;": "\u2292", "Square;": "\u25A1", "square;": "\u25A1", "squarf;": "\u25AA", "ssetmn;": "\u2216", "ssmile;": "\u2323", "sstarf;": "\u22C6", "subdot;": "\u2ABD", "Subset;": "\u22D0", "subset;": "\u2282", "subsim;": "\u2AC7", "subsub;": "\u2AD5", "subsup;": "\u2AD3", "succeq;": "\u2AB0", "supdot;": "\u2ABE", "Supset;": "\u22D1", "supset;": "\u2283", "supsim;": "\u2AC8", "supsub;": "\u2AD4", "supsup;": "\u2AD6", "swarhk;": "\u2926", "swnwar;": "\u292A", "target;": "\u2316", "Tcaron;": "\u0164", "tcaron;": "\u0165", "Tcedil;": "\u0162", "tcedil;": "\u0163", "telrec;": "\u2315", "there4;": "\u2234", "thetav;": "\u03D1", "thinsp;": "\u2009", "thksim;": "\u223C", "timesb;": "\u22A0", "timesd;": "\u2A30", "topbot;": "\u2336", "topcir;": "\u2AF1", "tprime;": "\u2034", "tridot;": "\u25EC", "Tstrok;": "\u0166", "tstrok;": "\u0167", "Uacute;": "\xDA", "uacute;": "\xFA", "Ubreve;": "\u016C", "ubreve;": "\u016D", "Udblac;": "\u0170", "udblac;": "\u0171", "ufisht;": "\u297E", "Ugrave;": "\xD9", "ugrave;": "\xF9", "ulcorn;": "\u231C", "ulcrop;": "\u230F", "urcorn;": "\u231D", "urcrop;": "\u230E", "Utilde;": "\u0168", "utilde;": "\u0169", "vangrt;": "\u299C", "varphi;": "\u03D5", "varrho;": "\u03F1", "Vdashl;": "\u2AE6", "veebar;": "\u22BB", "vellip;": "\u22EE", "Verbar;": "\u2016", "verbar;": "|", "vsubnE;": "\u2ACB\uFE00", "vsubne;": "\u228A\uFE00", "vsupnE;": "\u2ACC\uFE00", "vsupne;": "\u228B\uFE00", "Vvdash;": "\u22AA", "wedbar;": "\u2A5F", "wedgeq;": "\u2259", "weierp;": "\u2118", "wreath;": "\u2240", "xoplus;": "\u2A01", "xotime;": "\u2A02", "xsqcup;": "\u2A06", "xuplus;": "\u2A04", "xwedge;": "\u22C0", "Yacute;": "\xDD", "yacute;": "\xFD", "Zacute;": "\u0179", "zacute;": "\u017A", "Zcaron;": "\u017D", "zcaron;": "\u017E", "zeetrf;": "\u2128", "alefsym;": "\u2135", "angrtvb;": "\u22BE", "angzarr;": "\u237C", "asympeq;": "\u224D", "backsim;": "\u223D", "Because;": "\u2235", "because;": "\u2235", "bemptyv;": "\u29B0", "between;": "\u226C", "bigcirc;": "\u25EF", "bigodot;": "\u2A00", "bigstar;": "\u2605", "bnequiv;": "\u2261\u20E5", "boxplus;": "\u229E", "Cayleys;": "\u212D", "Cconint;": "\u2230", "ccupssm;": "\u2A50", "Cedilla;": "\xB8", "cemptyv;": "\u29B2", "cirscir;": "\u29C2", "coloneq;": "\u2254", "congdot;": "\u2A6D", "cudarrl;": "\u2938", "cudarrr;": "\u2935", "cularrp;": "\u293D", "curarrm;": "\u293C", "dbkarow;": "\u290F", "ddagger;": "\u2021", "ddotseq;": "\u2A77", "demptyv;": "\u29B1", "Diamond;": "\u22C4", "diamond;": "\u22C4", "digamma;": "\u03DD", "dotplus;": "\u2214", "DownTee;": "\u22A4", "dwangle;": "\u29A6", "Element;": "\u2208", "Epsilon;": "\u0395", "epsilon;": "\u03B5", "eqcolon;": "\u2255", "equivDD;": "\u2A78", "gesdoto;": "\u2A82", "gtquest;": "\u2A7C", "gtrless;": "\u2277", "harrcir;": "\u2948", "Implies;": "\u21D2", "intprod;": "\u2A3C", "isindot;": "\u22F5", "larrbfs;": "\u291F", "larrsim;": "\u2973", "lbrksld;": "\u298F", "lbrkslu;": "\u298D", "ldrdhar;": "\u2967", "LeftTee;": "\u22A3", "lesdoto;": "\u2A81", "lessdot;": "\u22D6", "lessgtr;": "\u2276", "lesssim;": "\u2272", "lotimes;": "\u2A34", "lozenge;": "\u25CA", "ltquest;": "\u2A7B", "luruhar;": "\u2966", "maltese;": "\u2720", "minusdu;": "\u2A2A", "napprox;": "\u2249", "natural;": "\u266E", "nearrow;": "\u2197", "NewLine;": "\n", "nexists;": "\u2204", "NoBreak;": "\u2060", "notinva;": "\u2209", "notinvb;": "\u22F7", "notinvc;": "\u22F6", "NotLess;": "\u226E", "notniva;": "\u220C", "notnivb;": "\u22FE", "notnivc;": "\u22FD", "npolint;": "\u2A14", "npreceq;": "\u2AAF\u0338", "nsqsube;": "\u22E2", "nsqsupe;": "\u22E3", "nsubset;": "\u2282\u20D2", "nsucceq;": "\u2AB0\u0338", "nsupset;": "\u2283\u20D2", "nvinfin;": "\u29DE", "nvltrie;": "\u22B4\u20D2", "nvrtrie;": "\u22B5\u20D2", "nwarrow;": "\u2196", "olcross;": "\u29BB", "Omicron;": "\u039F", "omicron;": "\u03BF", "orderof;": "\u2134", "orslope;": "\u2A57", "OverBar;": "\u203E", "pertenk;": "\u2031", "planckh;": "\u210E", "pluscir;": "\u2A22", "plussim;": "\u2A26", "plustwo;": "\u2A27", "precsim;": "\u227E", "Product;": "\u220F", "quatint;": "\u2A16", "questeq;": "\u225F", "rarrbfs;": "\u2920", "rarrsim;": "\u2974", "rbrksld;": "\u298E", "rbrkslu;": "\u2990", "rdldhar;": "\u2969", "realine;": "\u211B", "rotimes;": "\u2A35", "ruluhar;": "\u2968", "searrow;": "\u2198", "simplus;": "\u2A24", "simrarr;": "\u2972", "subedot;": "\u2AC3", "submult;": "\u2AC1", "subplus;": "\u2ABF", "subrarr;": "\u2979", "succsim;": "\u227F", "supdsub;": "\u2AD8", "supedot;": "\u2AC4", "suphsol;": "\u27C9", "suphsub;": "\u2AD7", "suplarr;": "\u297B", "supmult;": "\u2AC2", "supplus;": "\u2AC0", "swarrow;": "\u2199", "topfork;": "\u2ADA", "triplus;": "\u2A39", "tritime;": "\u2A3B", "UpArrow;": "\u2191", "Uparrow;": "\u21D1", "uparrow;": "\u2191", "Upsilon;": "\u03A5", "upsilon;": "\u03C5", "uwangle;": "\u29A7", "vzigzag;": "\u299A", "zigrarr;": "\u21DD", "andslope;": "\u2A58", "angmsdaa;": "\u29A8", "angmsdab;": "\u29A9", "angmsdac;": "\u29AA", "angmsdad;": "\u29AB", "angmsdae;": "\u29AC", "angmsdaf;": "\u29AD", "angmsdag;": "\u29AE", "angmsdah;": "\u29AF", "angrtvbd;": "\u299D", "approxeq;": "\u224A", "awconint;": "\u2233", "backcong;": "\u224C", "barwedge;": "\u2305", "bbrktbrk;": "\u23B6", "bigoplus;": "\u2A01", "bigsqcup;": "\u2A06", "biguplus;": "\u2A04", "bigwedge;": "\u22C0", "boxminus;": "\u229F", "boxtimes;": "\u22A0", "bsolhsub;": "\u27C8", "capbrcup;": "\u2A49", "circledR;": "\xAE", "circledS;": "\u24C8", "cirfnint;": "\u2A10", "clubsuit;": "\u2663", "cupbrcap;": "\u2A48", "curlyvee;": "\u22CE", "cwconint;": "\u2232", "DDotrahd;": "\u2911", "doteqdot;": "\u2251", "DotEqual;": "\u2250", "dotminus;": "\u2238", "drbkarow;": "\u2910", "dzigrarr;": "\u27FF", "elinters;": "\u23E7", "emptyset;": "\u2205", "eqvparsl;": "\u29E5", "fpartint;": "\u2A0D", "geqslant;": "\u2A7E", "gesdotol;": "\u2A84", "gnapprox;": "\u2A8A", "hksearow;": "\u2925", "hkswarow;": "\u2926", "imagline;": "\u2110", "imagpart;": "\u2111", "infintie;": "\u29DD", "integers;": "\u2124", "Integral;": "\u222B", "intercal;": "\u22BA", "intlarhk;": "\u2A17", "laemptyv;": "\u29B4", "ldrushar;": "\u294B", "leqslant;": "\u2A7D", "lesdotor;": "\u2A83", "LessLess;": "\u2AA1", "llcorner;": "\u231E", "lnapprox;": "\u2A89", "lrcorner;": "\u231F", "lurdshar;": "\u294A", "mapstoup;": "\u21A5", "multimap;": "\u22B8", "naturals;": "\u2115", "ncongdot;": "\u2A6D\u0338", "NotEqual;": "\u2260", "notindot;": "\u22F5\u0338", "NotTilde;": "\u2241", "otimesas;": "\u2A36", "parallel;": "\u2225", "PartialD;": "\u2202", "plusacir;": "\u2A23", "pointint;": "\u2A15", "Precedes;": "\u227A", "precneqq;": "\u2AB5", "precnsim;": "\u22E8", "profalar;": "\u232E", "profline;": "\u2312", "profsurf;": "\u2313", "raemptyv;": "\u29B3", "realpart;": "\u211C", "RightTee;": "\u22A2", "rppolint;": "\u2A12", "rtriltri;": "\u29CE", "scpolint;": "\u2A13", "setminus;": "\u2216", "shortmid;": "\u2223", "smeparsl;": "\u29E4", "sqsubset;": "\u228F", "sqsupset;": "\u2290", "subseteq;": "\u2286", "Succeeds;": "\u227B", "succneqq;": "\u2AB6", "succnsim;": "\u22E9", "SuchThat;": "\u220B", "Superset;": "\u2283", "supseteq;": "\u2287", "thetasym;": "\u03D1", "thicksim;": "\u223C", "timesbar;": "\u2A31", "triangle;": "\u25B5", "triminus;": "\u2A3A", "trpezium;": "\u23E2", "Uarrocir;": "\u2949", "ulcorner;": "\u231C", "UnderBar;": "_", "urcorner;": "\u231D", "varkappa;": "\u03F0", "varsigma;": "\u03C2", "vartheta;": "\u03D1", "backprime;": "\u2035", "backsimeq;": "\u22CD", "Backslash;": "\u2216", "bigotimes;": "\u2A02", "CenterDot;": "\xB7", "centerdot;": "\xB7", "checkmark;": "\u2713", "CircleDot;": "\u2299", "complexes;": "\u2102", "Congruent;": "\u2261", "Coproduct;": "\u2210", "dotsquare;": "\u22A1", "DoubleDot;": "\xA8", "DownArrow;": "\u2193", "Downarrow;": "\u21D3", "downarrow;": "\u2193", "DownBreve;": "\u0311", "gtrapprox;": "\u2A86", "gtreqless;": "\u22DB", "gvertneqq;": "\u2269\uFE00", "heartsuit;": "\u2665", "HumpEqual;": "\u224F", "LeftArrow;": "\u2190", "Leftarrow;": "\u21D0", "leftarrow;": "\u2190", "LeftFloor;": "\u230A", "lesseqgtr;": "\u22DA", "LessTilde;": "\u2272", "lvertneqq;": "\u2268\uFE00", "Mellintrf;": "\u2133", "MinusPlus;": "\u2213", "ngeqslant;": "\u2A7E\u0338", "nleqslant;": "\u2A7D\u0338", "NotCupCap;": "\u226D", "NotExists;": "\u2204", "NotSubset;": "\u2282\u20D2", "nparallel;": "\u2226", "nshortmid;": "\u2224", "nsubseteq;": "\u2288", "nsupseteq;": "\u2289", "OverBrace;": "\u23DE", "pitchfork;": "\u22D4", "PlusMinus;": "\xB1", "rationals;": "\u211A", "spadesuit;": "\u2660", "subseteqq;": "\u2AC5", "subsetneq;": "\u228A", "supseteqq;": "\u2AC6", "supsetneq;": "\u228B", "Therefore;": "\u2234", "therefore;": "\u2234", "ThinSpace;": "\u2009", "triangleq;": "\u225C", "TripleDot;": "\u20DB", "UnionPlus;": "\u228E", "varpropto;": "\u221D", "Bernoullis;": "\u212C", "circledast;": "\u229B", "CirclePlus;": "\u2295", "complement;": "\u2201", "curlywedge;": "\u22CF", "eqslantgtr;": "\u2A96", "EqualTilde;": "\u2242", "Fouriertrf;": "\u2131", "gtreqqless;": "\u2A8C", "ImaginaryI;": "\u2148", "Laplacetrf;": "\u2112", "LeftVector;": "\u21BC", "lessapprox;": "\u2A85", "lesseqqgtr;": "\u2A8B", "Lleftarrow;": "\u21DA", "lmoustache;": "\u23B0", "longmapsto;": "\u27FC", "mapstodown;": "\u21A7", "mapstoleft;": "\u21A4", "nLeftarrow;": "\u21CD", "nleftarrow;": "\u219A", "NotElement;": "\u2209", "NotGreater;": "\u226F", "nsubseteqq;": "\u2AC5\u0338", "nsupseteqq;": "\u2AC6\u0338", "precapprox;": "\u2AB7", "Proportion;": "\u2237", "RightArrow;": "\u2192", "Rightarrow;": "\u21D2", "rightarrow;": "\u2192", "RightFloor;": "\u230B", "rmoustache;": "\u23B1", "sqsubseteq;": "\u2291", "sqsupseteq;": "\u2292", "subsetneqq;": "\u2ACB", "succapprox;": "\u2AB8", "supsetneqq;": "\u2ACC", "ThickSpace;": "\u205F\u200A", "TildeEqual;": "\u2243", "TildeTilde;": "\u2248", "UnderBrace;": "\u23DF", "UpArrowBar;": "\u2912", "UpTeeArrow;": "\u21A5", "upuparrows;": "\u21C8", "varepsilon;": "\u03F5", "varnothing;": "\u2205", "backepsilon;": "\u03F6", "blacksquare;": "\u25AA", "circledcirc;": "\u229A", "circleddash;": "\u229D", "CircleMinus;": "\u2296", "CircleTimes;": "\u2297", "curlyeqprec;": "\u22DE", "curlyeqsucc;": "\u22DF", "diamondsuit;": "\u2666", "eqslantless;": "\u2A95", "Equilibrium;": "\u21CC", "expectation;": "\u2130", "GreaterLess;": "\u2277", "LeftCeiling;": "\u2308", "LessGreater;": "\u2276", "MediumSpace;": "\u205F", "NotLessLess;": "\u226A\u0338", "NotPrecedes;": "\u2280", "NotSucceeds;": "\u2281", "NotSuperset;": "\u2283\u20D2", "nRightarrow;": "\u21CF", "nrightarrow;": "\u219B", "OverBracket;": "\u23B4", "preccurlyeq;": "\u227C", "precnapprox;": "\u2AB9", "quaternions;": "\u210D", "RightVector;": "\u21C0", "Rrightarrow;": "\u21DB", "RuleDelayed;": "\u29F4", "SmallCircle;": "\u2218", "SquareUnion;": "\u2294", "straightphi;": "\u03D5", "SubsetEqual;": "\u2286", "succcurlyeq;": "\u227D", "succnapprox;": "\u2ABA", "thickapprox;": "\u2248", "UpDownArrow;": "\u2195", "Updownarrow;": "\u21D5", "updownarrow;": "\u2195", "VerticalBar;": "\u2223", "blacklozenge;": "\u29EB", "DownArrowBar;": "\u2913", "DownTeeArrow;": "\u21A7", "ExponentialE;": "\u2147", "exponentiale;": "\u2147", "GreaterEqual;": "\u2265", "GreaterTilde;": "\u2273", "HilbertSpace;": "\u210B", "HumpDownHump;": "\u224E", "Intersection;": "\u22C2", "LeftArrowBar;": "\u21E4", "LeftTeeArrow;": "\u21A4", "LeftTriangle;": "\u22B2", "LeftUpVector;": "\u21BF", "NotCongruent;": "\u2262", "NotHumpEqual;": "\u224F\u0338", "NotLessEqual;": "\u2270", "NotLessTilde;": "\u2274", "Proportional;": "\u221D", "RightCeiling;": "\u2309", "risingdotseq;": "\u2253", "RoundImplies;": "\u2970", "ShortUpArrow;": "\u2191", "SquareSubset;": "\u228F", "triangledown;": "\u25BF", "triangleleft;": "\u25C3", "UnderBracket;": "\u23B5", "varsubsetneq;": "\u228A\uFE00", "varsupsetneq;": "\u228B\uFE00", "VerticalLine;": "|", "ApplyFunction;": "\u2061", "bigtriangleup;": "\u25B3", "blacktriangle;": "\u25B4", "DifferentialD;": "\u2146", "divideontimes;": "\u22C7", "DoubleLeftTee;": "\u2AE4", "DoubleUpArrow;": "\u21D1", "fallingdotseq;": "\u2252", "hookleftarrow;": "\u21A9", "leftarrowtail;": "\u21A2", "leftharpoonup;": "\u21BC", "LeftTeeVector;": "\u295A", "LeftVectorBar;": "\u2952", "LessFullEqual;": "\u2266", "LongLeftArrow;": "\u27F5", "Longleftarrow;": "\u27F8", "longleftarrow;": "\u27F5", "looparrowleft;": "\u21AB", "measuredangle;": "\u2221", "NotEqualTilde;": "\u2242\u0338", "NotTildeEqual;": "\u2244", "NotTildeTilde;": "\u2249", "ntriangleleft;": "\u22EA", "Poincareplane;": "\u210C", "PrecedesEqual;": "\u2AAF", "PrecedesTilde;": "\u227E", "RightArrowBar;": "\u21E5", "RightTeeArrow;": "\u21A6", "RightTriangle;": "\u22B3", "RightUpVector;": "\u21BE", "shortparallel;": "\u2225", "smallsetminus;": "\u2216", "SucceedsEqual;": "\u2AB0", "SucceedsTilde;": "\u227F", "SupersetEqual;": "\u2287", "triangleright;": "\u25B9", "UpEquilibrium;": "\u296E", "upharpoonleft;": "\u21BF", "varsubsetneqq;": "\u2ACB\uFE00", "varsupsetneqq;": "\u2ACC\uFE00", "VerticalTilde;": "\u2240", "VeryThinSpace;": "\u200A", "curvearrowleft;": "\u21B6", "DiacriticalDot;": "\u02D9", "doublebarwedge;": "\u2306", "DoubleRightTee;": "\u22A8", "downdownarrows;": "\u21CA", "DownLeftVector;": "\u21BD", "GreaterGreater;": "\u2AA2", "hookrightarrow;": "\u21AA", "HorizontalLine;": "\u2500", "InvisibleComma;": "\u2063", "InvisibleTimes;": "\u2062", "LeftDownVector;": "\u21C3", "leftleftarrows;": "\u21C7", "LeftRightArrow;": "\u2194", "Leftrightarrow;": "\u21D4", "leftrightarrow;": "\u2194", "leftthreetimes;": "\u22CB", "LessSlantEqual;": "\u2A7D", "LongRightArrow;": "\u27F6", "Longrightarrow;": "\u27F9", "longrightarrow;": "\u27F6", "looparrowright;": "\u21AC", "LowerLeftArrow;": "\u2199", "NestedLessLess;": "\u226A", "NotGreaterLess;": "\u2279", "NotLessGreater;": "\u2278", "NotSubsetEqual;": "\u2288", "NotVerticalBar;": "\u2224", "nshortparallel;": "\u2226", "ntriangleright;": "\u22EB", "OpenCurlyQuote;": "\u2018", "ReverseElement;": "\u220B", "rightarrowtail;": "\u21A3", "rightharpoonup;": "\u21C0", "RightTeeVector;": "\u295B", "RightVectorBar;": "\u2953", "ShortDownArrow;": "\u2193", "ShortLeftArrow;": "\u2190", "SquareSuperset;": "\u2290", "TildeFullEqual;": "\u2245", "trianglelefteq;": "\u22B4", "upharpoonright;": "\u21BE", "UpperLeftArrow;": "\u2196", "ZeroWidthSpace;": "\u200B", "bigtriangledown;": "\u25BD", "circlearrowleft;": "\u21BA", "CloseCurlyQuote;": "\u2019", "ContourIntegral;": "\u222E", "curvearrowright;": "\u21B7", "DoubleDownArrow;": "\u21D3", "DoubleLeftArrow;": "\u21D0", "downharpoonleft;": "\u21C3", "DownRightVector;": "\u21C1", "leftharpoondown;": "\u21BD", "leftrightarrows;": "\u21C6", "LeftRightVector;": "\u294E", "LeftTriangleBar;": "\u29CF", "LeftUpTeeVector;": "\u2960", "LeftUpVectorBar;": "\u2958", "LowerRightArrow;": "\u2198", "nLeftrightarrow;": "\u21CE", "nleftrightarrow;": "\u21AE", "NotGreaterEqual;": "\u2271", "NotGreaterTilde;": "\u2275", "NotHumpDownHump;": "\u224E\u0338", "NotLeftTriangle;": "\u22EA", "NotSquareSubset;": "\u228F\u0338", "ntrianglelefteq;": "\u22EC", "OverParenthesis;": "\u23DC", "RightDownVector;": "\u21C2", "rightleftarrows;": "\u21C4", "rightsquigarrow;": "\u219D", "rightthreetimes;": "\u22CC", "ShortRightArrow;": "\u2192", "straightepsilon;": "\u03F5", "trianglerighteq;": "\u22B5", "UpperRightArrow;": "\u2197", "vartriangleleft;": "\u22B2", "circlearrowright;": "\u21BB", "DiacriticalAcute;": "\xB4", "DiacriticalGrave;": "`", "DiacriticalTilde;": "\u02DC", "DoubleRightArrow;": "\u21D2", "DownArrowUpArrow;": "\u21F5", "downharpoonright;": "\u21C2", "EmptySmallSquare;": "\u25FB", "GreaterEqualLess;": "\u22DB", "GreaterFullEqual;": "\u2267", "LeftAngleBracket;": "\u27E8", "LeftUpDownVector;": "\u2951", "LessEqualGreater;": "\u22DA", "NonBreakingSpace;": "\xA0", "NotPrecedesEqual;": "\u2AAF\u0338", "NotRightTriangle;": "\u22EB", "NotSucceedsEqual;": "\u2AB0\u0338", "NotSucceedsTilde;": "\u227F\u0338", "NotSupersetEqual;": "\u2289", "ntrianglerighteq;": "\u22ED", "rightharpoondown;": "\u21C1", "rightrightarrows;": "\u21C9", "RightTriangleBar;": "\u29D0", "RightUpTeeVector;": "\u295C", "RightUpVectorBar;": "\u2954", "twoheadleftarrow;": "\u219E", "UnderParenthesis;": "\u23DD", "UpArrowDownArrow;": "\u21C5", "vartriangleright;": "\u22B3", "blacktriangledown;": "\u25BE", "blacktriangleleft;": "\u25C2", "DoubleUpDownArrow;": "\u21D5", "DoubleVerticalBar;": "\u2225", "DownLeftTeeVector;": "\u295E", "DownLeftVectorBar;": "\u2956", "FilledSmallSquare;": "\u25FC", "GreaterSlantEqual;": "\u2A7E", "LeftDoubleBracket;": "\u27E6", "LeftDownTeeVector;": "\u2961", "LeftDownVectorBar;": "\u2959", "leftrightharpoons;": "\u21CB", "LeftTriangleEqual;": "\u22B4", "NegativeThinSpace;": "\u200B", "NotGreaterGreater;": "\u226B\u0338", "NotLessSlantEqual;": "\u2A7D\u0338", "NotNestedLessLess;": "\u2AA1\u0338", "NotReverseElement;": "\u220C", "NotSquareSuperset;": "\u2290\u0338", "NotTildeFullEqual;": "\u2247", "RightAngleBracket;": "\u27E9", "rightleftharpoons;": "\u21CC", "RightUpDownVector;": "\u294F", "SquareSubsetEqual;": "\u2291", "twoheadrightarrow;": "\u21A0", "VerticalSeparator;": "\u2758", "blacktriangleright;": "\u25B8", "DownRightTeeVector;": "\u295F", "DownRightVectorBar;": "\u2957", "LongLeftRightArrow;": "\u27F7", "Longleftrightarrow;": "\u27FA", "longleftrightarrow;": "\u27F7", "NegativeThickSpace;": "\u200B", "NotLeftTriangleBar;": "\u29CF\u0338", "PrecedesSlantEqual;": "\u227C", "ReverseEquilibrium;": "\u21CB", "RightDoubleBracket;": "\u27E7", "RightDownTeeVector;": "\u295D", "RightDownVectorBar;": "\u2955", "RightTriangleEqual;": "\u22B5", "SquareIntersection;": "\u2293", "SucceedsSlantEqual;": "\u227D", "DoubleLongLeftArrow;": "\u27F8", "DownLeftRightVector;": "\u2950", "LeftArrowRightArrow;": "\u21C6", "leftrightsquigarrow;": "\u21AD", "NegativeMediumSpace;": "\u200B", "NotGreaterFullEqual;": "\u2267\u0338", "NotRightTriangleBar;": "\u29D0\u0338", "RightArrowLeftArrow;": "\u21C4", "SquareSupersetEqual;": "\u2292", "CapitalDifferentialD;": "\u2145", "DoubleLeftRightArrow;": "\u21D4", "DoubleLongRightArrow;": "\u27F9", "EmptyVerySmallSquare;": "\u25AB", "NestedGreaterGreater;": "\u226B", "NotDoubleVerticalBar;": "\u2226", "NotGreaterSlantEqual;": "\u2A7E\u0338", "NotLeftTriangleEqual;": "\u22EC", "NotSquareSubsetEqual;": "\u22E2", "OpenCurlyDoubleQuote;": "\u201C", "ReverseUpEquilibrium;": "\u296F", "CloseCurlyDoubleQuote;": "\u201D", "DoubleContourIntegral;": "\u222F", "FilledVerySmallSquare;": "\u25AA", "NegativeVeryThinSpace;": "\u200B", "NotPrecedesSlantEqual;": "\u22E0", "NotRightTriangleEqual;": "\u22ED", "NotSucceedsSlantEqual;": "\u22E1", "DiacriticalDoubleAcute;": "\u02DD", "NotSquareSupersetEqual;": "\u22E3", "NotNestedGreaterGreater;": "\u2AA2\u0338", "ClockwiseContourIntegral;": "\u2232", "DoubleLongLeftRightArrow;": "\u27FA", "CounterClockwiseContourIntegral;": "\u2233" };
            let y;
            const g = { 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 }, b = s2.makeMap("style,iframe,script,noscript", true), v = { isVoidTag: s2.isVoidTag, isNativeTag: (e3) => s2.isHTMLTag(e3) || s2.isSVGTag(e3), isPreTag: (e3) => e3 === "pre", decodeEntities: (e3, t3) => {
              let r3 = 0;
              const n2 = e3.length;
              let s3 = "";
              function i2(t4) {
                r3 += t4, e3 = e3.slice(t4);
              }
              for (; r3 < n2; ) {
                const o2 = /&(?:#x?)?/i.exec(e3);
                if (!o2 || r3 + o2.index >= n2) {
                  const t4 = n2 - r3;
                  s3 += e3.slice(0, t4), i2(t4);
                  break;
                }
                if (s3 += e3.slice(0, o2.index), i2(o2.index), o2[0] === "&") {
                  let r4, n3 = "";
                  if (/[0-9a-z]/i.test(e3[1])) {
                    y || (y = Object.keys(m).reduce((e4, t4) => Math.max(e4, t4.length), 0));
                    for (let t4 = y; !r4 && t4 > 0; --t4)
                      n3 = e3.substr(1, t4), r4 = m[n3];
                    if (r4) {
                      const o3 = n3.endsWith(";");
                      t3 && !o3 && /[=a-z0-9]/i.test(e3[n3.length + 1] || "") ? (s3 += "&" + n3, i2(1 + n3.length)) : (s3 += r4, i2(1 + n3.length));
                    } else
                      s3 += "&" + n3, i2(1 + n3.length);
                  } else
                    s3 += "&", i2(1);
                } else {
                  const t4 = o2[0] === "&#x", r4 = (t4 ? /^&#x([0-9a-f]+);?/i : /^&#([0-9]+);?/).exec(e3);
                  if (r4) {
                    let e4 = Number.parseInt(r4[1], t4 ? 16 : 10);
                    e4 === 0 || e4 > 1114111 || e4 >= 55296 && e4 <= 57343 ? e4 = 65533 : e4 >= 64976 && e4 <= 65007 || (65534 & e4) == 65534 || (e4 >= 1 && e4 <= 8 || e4 === 11 || e4 >= 13 && e4 <= 31 || e4 >= 127 && e4 <= 159) && (e4 = g[e4] || e4), s3 += String.fromCodePoint(e4), i2(r4[0].length);
                  } else
                    s3 += o2[0], i2(o2[0].length);
                }
              }
              return s3;
            }, isBuiltInComponent: (e3) => n.isBuiltInType(e3, "Transition") ? d : n.isBuiltInType(e3, "TransitionGroup") ? h3 : void 0, getNamespace(e3, t3) {
              let r3 = t3 ? t3.ns : 0;
              if (t3 && r3 === 2)
                if (t3.tag === "annotation-xml") {
                  if (e3 === "svg")
                    return 1;
                  t3.props.some((e4) => e4.type === 6 && e4.name === "encoding" && e4.value != null && (e4.value.content === "text/html" || e4.value.content === "application/xhtml+xml")) && (r3 = 0);
                } else
                  /^m(?:[ions]|text)$/.test(t3.tag) && e3 !== "mglyph" && e3 !== "malignmark" && (r3 = 0);
              else
                t3 && r3 === 1 && (t3.tag !== "foreignObject" && t3.tag !== "desc" && t3.tag !== "title" || (r3 = 0));
              if (r3 === 0) {
                if (e3 === "svg")
                  return 1;
                if (e3 === "math")
                  return 2;
              }
              return r3;
            }, getTextMode({ tag: e3, ns: t3 }) {
              if (t3 === 0) {
                if (e3 === "textarea" || e3 === "title")
                  return 1;
                if (b(e3))
                  return 2;
              }
              return 0;
            } }, E = (e3) => {
              e3.type === 1 && e3.props.forEach((t3, r3) => {
                t3.type === 6 && t3.name === "style" && t3.value && (e3.props[r3] = { type: 7, name: "bind", arg: n.createSimpleExpression("style", true, t3.loc), exp: x(t3.value.content, t3.loc), modifiers: [], loc: t3.loc });
              });
            }, x = (e3, t3) => {
              const r3 = s2.parseStringStyle(e3);
              return n.createSimpleExpression(JSON.stringify(r3), false, t3, 3);
            };
            function S(e3, t3) {
              return n.createCompilerError(e3, t3, T);
            }
            const T = { 49: "v-html is missing expression.", 50: "v-html will override element children.", 51: "v-text is missing expression.", 52: "v-text will override element children.", 53: "v-model can only be used on <input>, <textarea> and <select> elements.", 54: "v-model argument is not supported on plain elements.", 55: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.", 56: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.", 57: "v-show is missing expression.", 58: "<Transition> expects exactly one child element or component.", 59: "Tags with side effect (<script> and <style>) are ignored in client component templates." }, w = s2.makeMap("passive,once,capture"), P = s2.makeMap("stop,prevent,self,ctrl,shift,alt,meta,exact,middle"), A = s2.makeMap("left,right"), O = s2.makeMap("onkeyup,onkeydown,onkeypress", true), C = (e3, t3) => n.isStaticExp(e3) && e3.content.toLowerCase() === "onclick" ? n.createSimpleExpression(t3, true) : e3.type !== 4 ? n.createCompoundExpression(["(", e3, `) === "onClick" ? "${t3}" : (`, e3, ")"]) : e3, I = (e3, t3, r3) => {
              if (t3.scopes.vSlot > 0)
                return;
              let s3 = 0, i2 = 0;
              const o2 = [], a2 = (r4) => {
                if (s3 >= 20 || i2 >= 5) {
                  const s4 = n.createCallExpression(t3.helper(n.CREATE_STATIC), [JSON.stringify(o2.map((e4) => M(e4, t3)).join("")), String(o2.length)]);
                  if (j(o2[0], s4, t3), o2.length > 1) {
                    for (let e4 = 1; e4 < o2.length; e4++)
                      j(o2[e4], null, t3);
                    const n2 = o2.length - 1;
                    return e3.splice(r4 - o2.length + 1, n2), n2;
                  }
                }
                return 0;
              };
              let l2 = 0;
              for (; l2 < e3.length; l2++) {
                const t4 = e3[l2];
                if (k2(t4)) {
                  const e4 = t4, r4 = L(e4);
                  if (r4) {
                    s3 += r4[0], i2 += r4[1], o2.push(e4);
                    continue;
                  }
                }
                l2 -= a2(l2), s3 = 0, i2 = 0, o2.length = 0;
              }
              a2(l2);
            }, k2 = (e3) => (e3.type === 1 && e3.tagType === 0 || e3.type == 12) && e3.codegenNode && e3.codegenNode.type === 4 && e3.codegenNode.hoisted, N = /^(data|aria)-/, _ = (e3) => s2.isKnownAttr(e3) || N.test(e3), j = (e3, t3, r3) => {
              const n2 = e3.codegenNode.hoisted;
              r3.hoists[r3.hoists.indexOf(n2)] = t3;
            }, D = s2.makeMap("caption,thead,tr,th,tbody,td,tfoot,colgroup,col");
            function L(e3) {
              if (e3.type === 1 && D(e3.tag))
                return false;
              if (e3.type === 12)
                return [1, 0];
              let t3 = 1, r3 = e3.props.length > 0 ? 1 : 0, n2 = false;
              const s3 = () => (n2 = true, false);
              return !!function e4(i2) {
                for (let e5 = 0; e5 < i2.props.length; e5++) {
                  const t4 = i2.props[e5];
                  if (t4.type === 6 && !_(t4.name))
                    return s3();
                  if (t4.type === 7 && t4.name === "bind" && t4.arg && (t4.arg.type === 8 || t4.arg.isStatic && !_(t4.arg.content)))
                    return s3();
                }
                for (let s4 = 0; s4 < i2.children.length; s4++) {
                  t3++;
                  const o2 = i2.children[s4];
                  if (o2.type === 1 && (o2.props.length > 0 && r3++, e4(o2), n2))
                    return false;
                }
                return true;
              }(e3) && [t3, r3];
            }
            function M(e3, t3) {
              if (s2.isString(e3))
                return e3;
              if (s2.isSymbol(e3))
                return "";
              switch (e3.type) {
                case 1:
                  return function(e4, t4) {
                    let r3 = `<${e4.tag}`;
                    for (let t5 = 0; t5 < e4.props.length; t5++) {
                      const n2 = e4.props[t5];
                      if (n2.type === 6)
                        r3 += ` ${n2.name}`, n2.value && (r3 += `="${s2.escapeHtml(n2.value.content)}"`);
                      else if (n2.type === 7 && n2.name === "bind") {
                        let e5 = B(n2.exp);
                        if (e5 != null) {
                          const t6 = n2.arg && n2.arg.content;
                          t6 === "class" ? e5 = s2.normalizeClass(e5) : t6 === "style" && (e5 = s2.stringifyStyle(s2.normalizeStyle(e5))), r3 += ` ${n2.arg.content}="${s2.escapeHtml(e5)}"`;
                        }
                      }
                    }
                    t4.scopeId && (r3 += ` ${t4.scopeId}`), r3 += ">";
                    for (let n2 = 0; n2 < e4.children.length; n2++)
                      r3 += M(e4.children[n2], t4);
                    return s2.isVoidTag(e4.tag) || (r3 += `</${e4.tag}>`), r3;
                  }(e3, t3);
                case 2:
                  return s2.escapeHtml(e3.content);
                case 3:
                  return `<!--${s2.escapeHtml(e3.content)}-->`;
                case 5:
                  return s2.escapeHtml(s2.toDisplayString(B(e3.content)));
                case 8:
                  return s2.escapeHtml(B(e3));
                case 12:
                  return M(e3.content, t3);
                default:
                  return "";
              }
            }
            function B(e3) {
              if (e3.type === 4)
                return new Function(`return ${e3.content}`)();
              {
                let t3 = "";
                return e3.children.forEach((e4) => {
                  s2.isString(e4) || s2.isSymbol(e4) || (e4.type === 2 ? t3 += e4.content : e4.type === 5 ? t3 += s2.toDisplayString(B(e4.content)) : t3 += B(e4));
                }), t3;
              }
            }
            const R = (e3, t3) => {
              e3.type !== 1 || e3.tagType !== 0 || e3.tag !== "script" && e3.tag !== "style" || (t3.onError(S(59, e3.loc)), t3.removeNode());
            }, F = [E], U = { cloak: n.noopDirectiveTransform, html: (e3, t3, r3) => {
              const { exp: s3, loc: i2 } = e3;
              return s3 || r3.onError(S(49, i2)), t3.children.length && (r3.onError(S(50, i2)), t3.children.length = 0), { props: [n.createObjectProperty(n.createSimpleExpression("innerHTML", true, i2), s3 || n.createSimpleExpression("", true))] };
            }, text: (e3, t3, r3) => {
              const { exp: s3, loc: i2 } = e3;
              return s3 || r3.onError(S(51, i2)), t3.children.length && (r3.onError(S(52, i2)), t3.children.length = 0), { props: [n.createObjectProperty(n.createSimpleExpression("textContent", true), s3 ? n.createCallExpression(r3.helperString(n.TO_DISPLAY_STRING), [s3], i2) : n.createSimpleExpression("", true))] };
            }, model: (e3, t3, r3) => {
              const s3 = n.transformModel(e3, t3, r3);
              if (!s3.props.length || t3.tagType === 1)
                return s3;
              e3.arg && r3.onError(S(54, e3.arg.loc));
              const { tag: u2 } = t3, p3 = r3.isCustomElement(u2);
              if (u2 === "input" || u2 === "textarea" || u2 === "select" || p3) {
                let f2 = a, d2 = false;
                if (u2 === "input" || p3) {
                  const s4 = n.findProp(t3, "type");
                  if (s4) {
                    if (s4.type === 7)
                      f2 = c;
                    else if (s4.value)
                      switch (s4.value.content) {
                        case "radio":
                          f2 = i;
                          break;
                        case "checkbox":
                          f2 = o;
                          break;
                        case "file":
                          d2 = true, r3.onError(S(55, e3.loc));
                      }
                  } else
                    n.hasDynamicKeyVBind(t3) && (f2 = c);
                } else
                  u2 === "select" && (f2 = l);
                d2 || (s3.needRuntime = r3.helper(f2));
              } else
                r3.onError(S(53, e3.loc));
              return s3.props = s3.props.filter((e4) => !(e4.key.type === 4 && e4.key.content === "modelValue")), s3;
            }, on: (e3, t3, r3) => n.transformOn(e3, t3, r3, (t4) => {
              const { modifiers: i2 } = e3;
              if (!i2.length)
                return t4;
              let { key: o2, value: a2 } = t4.props[0];
              const { keyModifiers: l2, nonKeyModifiers: c4, eventOptionModifiers: f2 } = ((e4, t5, r4, s3) => {
                const i3 = [], o3 = [], a3 = [];
                for (let l3 = 0; l3 < t5.length; l3++) {
                  const c5 = t5[l3];
                  c5 === "native" && n.checkCompatEnabled("COMPILER_V_ON_NATIVE", r4, s3) || w(c5) ? a3.push(c5) : A(c5) ? n.isStaticExp(e4) ? O(e4.content) ? i3.push(c5) : o3.push(c5) : (i3.push(c5), o3.push(c5)) : P(c5) ? o3.push(c5) : i3.push(c5);
                }
                return { keyModifiers: i3, nonKeyModifiers: o3, eventOptionModifiers: a3 };
              })(o2, i2, r3, e3.loc);
              if (c4.includes("right") && (o2 = C(o2, "onContextmenu")), c4.includes("middle") && (o2 = C(o2, "onMouseup")), c4.length && (a2 = n.createCallExpression(r3.helper(u), [a2, JSON.stringify(c4)])), !l2.length || n.isStaticExp(o2) && !O(o2.content) || (a2 = n.createCallExpression(r3.helper(p2), [a2, JSON.stringify(l2)])), f2.length) {
                const e4 = f2.map(s2.capitalize).join("");
                o2 = n.isStaticExp(o2) ? n.createSimpleExpression(`${o2.content}${e4}`, true) : n.createCompoundExpression(["(", o2, `) + "${e4}"`]);
              }
              return { props: [n.createObjectProperty(o2, a2)] };
            }), show: (e3, t3, r3) => {
              const { exp: n2, loc: s3 } = e3;
              return n2 || r3.onError(S(57, s3)), { props: [], needRuntime: r3.helper(f) };
            } };
            Object.keys(n).forEach(function(e3) {
              e3 !== "default" && (t2[e3] = n[e3]);
            }), t2.DOMDirectiveTransforms = U, t2.DOMNodeTransforms = F, t2.TRANSITION = d, t2.TRANSITION_GROUP = h3, t2.V_MODEL_CHECKBOX = o, t2.V_MODEL_DYNAMIC = c, t2.V_MODEL_RADIO = i, t2.V_MODEL_SELECT = l, t2.V_MODEL_TEXT = a, t2.V_ON_WITH_KEYS = p2, t2.V_ON_WITH_MODIFIERS = u, t2.V_SHOW = f, t2.compile = function(e3, t3 = {}) {
              return n.baseCompile(e3, s2.extend({}, v, t3, { nodeTransforms: [R, ...F, ...t3.nodeTransforms || []], directiveTransforms: s2.extend({}, U, t3.directiveTransforms || {}), transformHoist: I }));
            }, t2.createDOMCompilerError = S, t2.parse = function(e3, t3 = {}) {
              return n.baseParse(e3, s2.extend({}, v, t3));
            }, t2.parserOptions = v, t2.transformStyle = E;
          }, (e2, t2, r2) => {
            "use strict";
            e2.exports = r2(506);
          }, (e2) => {
            "use strict";
            function t2(e3, t3) {
              var r3, n;
              if (t3.length === 0)
                return e3;
              for (r3 = 0, n = t3.length; r3 < n; r3++)
                e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
              return e3 < 0 ? -2 * e3 : e3;
            }
            function r2(e3, n, s2, i) {
              var o, a = t2(t2(t2(e3, s2), (o = n, Object.prototype.toString.call(o))), typeof n);
              if (n === null)
                return t2(a, "null");
              if (n === void 0)
                return t2(a, "undefined");
              if (typeof n == "object" || typeof n == "function") {
                if (i.indexOf(n) !== -1)
                  return t2(a, "[Circular]" + s2);
                i.push(n);
                var l = function(e4, t3, n2) {
                  return Object.keys(t3).sort().reduce(function(e5, s3) {
                    return r2(e5, t3[s3], s3, n2);
                  }, e4);
                }(a, n, i);
                if (!("valueOf" in n) || typeof n.valueOf != "function")
                  return l;
                try {
                  return t2(l, String(n.valueOf()));
                } catch (e4) {
                  return t2(l, "[valueOf exception]" + (e4.stack || e4.message));
                }
              }
              return t2(a, n.toString());
            }
            e2.exports = function(e3) {
              return function(e4, t3) {
                for (; e4.length < 8; )
                  e4 = "0" + e4;
                return e4;
              }(r2(0, e3, "", []).toString(16));
            };
          }, (e2) => {
            "use strict";
            function t2(e3, t3) {
              return Object.prototype.hasOwnProperty.call(e3, t3);
            }
            e2.exports = function(e3, r2, n, s2) {
              r2 = r2 || "&", n = n || "=";
              var i = {};
              if (typeof e3 != "string" || e3.length === 0)
                return i;
              var o = /\+/g;
              e3 = e3.split(r2);
              var a = 1e3;
              s2 && typeof s2.maxKeys == "number" && (a = s2.maxKeys);
              var l = e3.length;
              a > 0 && l > a && (l = a);
              for (var c = 0; c < l; ++c) {
                var u, p2, f, d, h3 = e3[c].replace(o, "%20"), m = h3.indexOf(n);
                m >= 0 ? (u = h3.substr(0, m), p2 = h3.substr(m + 1)) : (u = h3, p2 = ""), f = decodeURIComponent(u), d = decodeURIComponent(p2), t2(i, f) ? Array.isArray(i[f]) ? i[f].push(d) : i[f] = [i[f], d] : i[f] = d;
              }
              return i;
            };
          }, (e2) => {
            "use strict";
            var t2 = function(e3) {
              switch (typeof e3) {
                case "string":
                  return e3;
                case "boolean":
                  return e3 ? "true" : "false";
                case "number":
                  return isFinite(e3) ? e3 : "";
                default:
                  return "";
              }
            };
            e2.exports = function(e3, r2, n, s2) {
              return r2 = r2 || "&", n = n || "=", e3 === null && (e3 = void 0), typeof e3 == "object" ? Object.keys(e3).map(function(s3) {
                var i = encodeURIComponent(t2(s3)) + n;
                return Array.isArray(e3[s3]) ? e3[s3].map(function(e4) {
                  return i + encodeURIComponent(t2(e4));
                }).join(r2) : i + encodeURIComponent(t2(e3[s3]));
              }).join(r2) : s2 ? encodeURIComponent(t2(s2)) + n + encodeURIComponent(t2(e3)) : "";
            };
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(37).Buffer;
            let { SourceMapConsumer: s2, SourceMapGenerator: i } = r2(157), { dirname: o, resolve: a, relative: l, sep: c } = r2(158), { pathToFileURL: u } = r2(321), p2 = Boolean(s2 && i), f = Boolean(o && a && l && c);
            e2.exports = class {
              constructor(e3, t3, r3) {
                this.stringify = e3, this.mapOpts = r3.map || {}, this.root = t3, this.opts = r3;
              }
              isMap() {
                return this.opts.map !== void 0 ? !!this.opts.map : this.previous().length > 0;
              }
              previous() {
                return this.previousMaps || (this.previousMaps = [], this.root.walk((e3) => {
                  if (e3.source && e3.source.input.map) {
                    let t3 = e3.source.input.map;
                    this.previousMaps.includes(t3) || this.previousMaps.push(t3);
                  }
                })), this.previousMaps;
              }
              isInline() {
                if (this.mapOpts.inline !== void 0)
                  return this.mapOpts.inline;
                let e3 = this.mapOpts.annotation;
                return (e3 === void 0 || e3 === true) && (!this.previous().length || this.previous().some((e4) => e4.inline));
              }
              isSourcesContent() {
                return this.mapOpts.sourcesContent !== void 0 ? this.mapOpts.sourcesContent : !this.previous().length || this.previous().some((e3) => e3.withContent());
              }
              clearAnnotation() {
                if (this.mapOpts.annotation === false)
                  return;
                let e3;
                for (let t3 = this.root.nodes.length - 1; t3 >= 0; t3--)
                  e3 = this.root.nodes[t3], e3.type === "comment" && e3.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t3);
              }
              setSourcesContent() {
                let e3 = {};
                this.root.walk((t3) => {
                  if (t3.source) {
                    let r3 = t3.source.input.from;
                    r3 && !e3[r3] && (e3[r3] = true, this.map.setSourceContent(this.toUrl(this.path(r3)), t3.source.input.css));
                  }
                });
              }
              applyPrevMaps() {
                for (let e3 of this.previous()) {
                  let t3, r3 = this.toUrl(this.path(e3.file)), n2 = e3.root || o(e3.file);
                  this.mapOpts.sourcesContent === false ? (t3 = new s2(e3.text), t3.sourcesContent && (t3.sourcesContent = t3.sourcesContent.map(() => null))) : t3 = e3.consumer(), this.map.applySourceMap(t3, r3, this.toUrl(this.path(n2)));
                }
              }
              isAnnotation() {
                return !!this.isInline() || (this.mapOpts.annotation !== void 0 ? this.mapOpts.annotation : !this.previous().length || this.previous().some((e3) => e3.annotation));
              }
              toBase64(e3) {
                return n ? n.from(e3).toString("base64") : window.btoa(unescape(encodeURIComponent(e3)));
              }
              addAnnotation() {
                let e3;
                e3 = this.isInline() ? "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? this.mapOpts.annotation(this.opts.to, this.root) : this.outputFile() + ".map";
                let t3 = "\n";
                this.css.includes("\r\n") && (t3 = "\r\n"), this.css += t3 + "/*# sourceMappingURL=" + e3 + " */";
              }
              outputFile() {
                return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
              }
              generateMap() {
                return this.generateString(), this.isSourcesContent() && this.setSourcesContent(), this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
              }
              path(e3) {
                if (e3.indexOf("<") === 0)
                  return e3;
                if (/^\w+:\/\//.test(e3))
                  return e3;
                if (this.mapOpts.absolute)
                  return e3;
                let t3 = this.opts.to ? o(this.opts.to) : ".";
                return typeof this.mapOpts.annotation == "string" && (t3 = o(a(t3, this.mapOpts.annotation))), l(t3, e3);
              }
              toUrl(e3) {
                return c === "\\" && (e3 = e3.replace(/\\/g, "/")), encodeURI(e3).replace(/[#?]/g, encodeURIComponent);
              }
              sourcePath(e3) {
                if (this.mapOpts.from)
                  return this.toUrl(this.mapOpts.from);
                if (this.mapOpts.absolute) {
                  if (u)
                    return u(e3.source.input.from).toString();
                  throw new Error("`map.absolute` option is not available in this PostCSS build");
                }
                return this.toUrl(this.path(e3.source.input.from));
              }
              generateString() {
                this.css = "", this.map = new i({ file: this.outputFile() });
                let e3, t3, r3 = 1, n2 = 1, s3 = "<no source>", o2 = { source: "", generated: { line: 0, column: 0 }, original: { line: 0, column: 0 } };
                this.stringify(this.root, (i2, a2, l2) => {
                  if (this.css += i2, a2 && l2 !== "end" && (o2.generated.line = r3, o2.generated.column = n2 - 1, a2.source && a2.source.start ? (o2.source = this.sourcePath(a2), o2.original.line = a2.source.start.line, o2.original.column = a2.source.start.column - 1, this.map.addMapping(o2)) : (o2.source = s3, o2.original.line = 1, o2.original.column = 0, this.map.addMapping(o2))), e3 = i2.match(/\n/g), e3 ? (r3 += e3.length, t3 = i2.lastIndexOf("\n"), n2 = i2.length - t3) : n2 += i2.length, a2 && l2 !== "start") {
                    let e4 = a2.parent || { raws: {} };
                    (a2.type !== "decl" || a2 !== e4.last || e4.raws.semicolon) && (a2.source && a2.source.end ? (o2.source = this.sourcePath(a2), o2.original.line = a2.source.end.line, o2.original.column = a2.source.end.column - 1, o2.generated.line = r3, o2.generated.column = n2 - 2, this.map.addMapping(o2)) : (o2.source = s3, o2.original.line = 1, o2.original.column = 0, o2.generated.line = r3, o2.generated.column = n2 - 1, this.map.addMapping(o2)));
                  }
                });
              }
              generate() {
                if (this.clearAnnotation(), f && p2 && this.isMap())
                  return this.generateMap();
                let e3 = "";
                return this.stringify(this.root, (t3) => {
                  e3 += t3;
                }), [e3];
              }
            };
          }, () => {
          }, (e2) => {
            "use strict";
            let t2 = {};
            e2.exports = function(e3) {
              t2[e3] || (t2[e3] = true, typeof console != "undefined" && console.warn);
            };
          }, (e2, t2, r2) => {
            "use strict";
            let n = r2(47), s2 = r2(324), i = r2(49), o = r2(88), a = r2(35), l = r2(89);
            e2.exports = class {
              constructor(e3) {
                this.input = e3, this.root = new a(), this.current = this.root, this.spaces = "", this.semicolon = false, this.customProperty = false, this.createTokenizer(), this.root.source = { input: e3, start: { offset: 0, line: 1, column: 1 } };
              }
              createTokenizer() {
                this.tokenizer = s2(this.input);
              }
              parse() {
                let e3;
                for (; !this.tokenizer.endOfFile(); )
                  switch (e3 = this.tokenizer.nextToken(), e3[0]) {
                    case "space":
                      this.spaces += e3[1];
                      break;
                    case ";":
                      this.freeSemicolon(e3);
                      break;
                    case "}":
                      this.end(e3);
                      break;
                    case "comment":
                      this.comment(e3);
                      break;
                    case "at-word":
                      this.atrule(e3);
                      break;
                    case "{":
                      this.emptyRule(e3);
                      break;
                    default:
                      this.other(e3);
                  }
                this.endFile();
              }
              comment(e3) {
                let t3 = new i();
                this.init(t3, e3[2]), t3.source.end = this.getPosition(e3[3] || e3[2]);
                let r3 = e3[1].slice(2, -2);
                if (/^\s*$/.test(r3))
                  t3.text = "", t3.raws.left = r3, t3.raws.right = "";
                else {
                  let e4 = r3.match(/^(\s*)([^]*\S)(\s*)$/);
                  t3.text = e4[2], t3.raws.left = e4[1], t3.raws.right = e4[3];
                }
              }
              emptyRule(e3) {
                let t3 = new l();
                this.init(t3, e3[2]), t3.selector = "", t3.raws.between = "", this.current = t3;
              }
              other(e3) {
                let t3 = false, r3 = null, n2 = false, s3 = null, i2 = [], o2 = e3[1].startsWith("--"), a2 = [], l2 = e3;
                for (; l2; ) {
                  if (r3 = l2[0], a2.push(l2), r3 === "(" || r3 === "[")
                    s3 || (s3 = l2), i2.push(r3 === "(" ? ")" : "]");
                  else if (o2 && n2 && r3 === "{")
                    s3 || (s3 = l2), i2.push("}");
                  else if (i2.length === 0) {
                    if (r3 === ";") {
                      if (n2)
                        return void this.decl(a2, o2);
                      break;
                    }
                    if (r3 === "{")
                      return void this.rule(a2);
                    if (r3 === "}") {
                      this.tokenizer.back(a2.pop()), t3 = true;
                      break;
                    }
                    r3 === ":" && (n2 = true);
                  } else
                    r3 === i2[i2.length - 1] && (i2.pop(), i2.length === 0 && (s3 = null));
                  l2 = this.tokenizer.nextToken();
                }
                if (this.tokenizer.endOfFile() && (t3 = true), i2.length > 0 && this.unclosedBracket(s3), t3 && n2) {
                  for (; a2.length && (l2 = a2[a2.length - 1][0], l2 === "space" || l2 === "comment"); )
                    this.tokenizer.back(a2.pop());
                  this.decl(a2, o2);
                } else
                  this.unknownWord(a2);
              }
              rule(e3) {
                e3.pop();
                let t3 = new l();
                this.init(t3, e3[0][2]), t3.raws.between = this.spacesAndCommentsFromEnd(e3), this.raw(t3, "selector", e3), this.current = t3;
              }
              decl(e3, t3) {
                let r3 = new n();
                this.init(r3, e3[0][2]);
                let s3, i2 = e3[e3.length - 1];
                for (i2[0] === ";" && (this.semicolon = true, e3.pop()), r3.source.end = this.getPosition(i2[3] || i2[2]); e3[0][0] !== "word"; )
                  e3.length === 1 && this.unknownWord(e3), r3.raws.before += e3.shift()[1];
                for (r3.source.start = this.getPosition(e3[0][2]), r3.prop = ""; e3.length; ) {
                  let t4 = e3[0][0];
                  if (t4 === ":" || t4 === "space" || t4 === "comment")
                    break;
                  r3.prop += e3.shift()[1];
                }
                for (r3.raws.between = ""; e3.length; ) {
                  if (s3 = e3.shift(), s3[0] === ":") {
                    r3.raws.between += s3[1];
                    break;
                  }
                  s3[0] === "word" && /\w/.test(s3[1]) && this.unknownWord([s3]), r3.raws.between += s3[1];
                }
                r3.prop[0] !== "_" && r3.prop[0] !== "*" || (r3.raws.before += r3.prop[0], r3.prop = r3.prop.slice(1));
                let o2 = this.spacesAndCommentsFromStart(e3);
                this.precheckMissedSemicolon(e3);
                for (let t4 = e3.length - 1; t4 >= 0; t4--) {
                  if (s3 = e3[t4], s3[1].toLowerCase() === "!important") {
                    r3.important = true;
                    let n2 = this.stringFrom(e3, t4);
                    n2 = this.spacesFromEnd(e3) + n2, n2 !== " !important" && (r3.raws.important = n2);
                    break;
                  }
                  if (s3[1].toLowerCase() === "important") {
                    let n2 = e3.slice(0), s4 = "";
                    for (let e4 = t4; e4 > 0; e4--) {
                      let t5 = n2[e4][0];
                      if (s4.trim().indexOf("!") === 0 && t5 !== "space")
                        break;
                      s4 = n2.pop()[1] + s4;
                    }
                    s4.trim().indexOf("!") === 0 && (r3.important = true, r3.raws.important = s4, e3 = n2);
                  }
                  if (s3[0] !== "space" && s3[0] !== "comment")
                    break;
                }
                let a2 = e3.some((e4) => e4[0] !== "space" && e4[0] !== "comment");
                this.raw(r3, "value", e3), a2 ? r3.raws.between += o2 : r3.value = o2 + r3.value, r3.value.includes(":") && !t3 && this.checkMissedSemicolon(e3);
              }
              atrule(e3) {
                let t3, r3, n2, s3 = new o();
                s3.name = e3[1].slice(1), s3.name === "" && this.unnamedAtrule(s3, e3), this.init(s3, e3[2]);
                let i2 = false, a2 = false, l2 = [], c = [];
                for (; !this.tokenizer.endOfFile(); ) {
                  if (t3 = (e3 = this.tokenizer.nextToken())[0], t3 === "(" || t3 === "[" ? c.push(t3 === "(" ? ")" : "]") : t3 === "{" && c.length > 0 ? c.push("}") : t3 === c[c.length - 1] && c.pop(), c.length === 0) {
                    if (t3 === ";") {
                      s3.source.end = this.getPosition(e3[2]), this.semicolon = true;
                      break;
                    }
                    if (t3 === "{") {
                      a2 = true;
                      break;
                    }
                    if (t3 === "}") {
                      if (l2.length > 0) {
                        for (n2 = l2.length - 1, r3 = l2[n2]; r3 && r3[0] === "space"; )
                          r3 = l2[--n2];
                        r3 && (s3.source.end = this.getPosition(r3[3] || r3[2]));
                      }
                      this.end(e3);
                      break;
                    }
                    l2.push(e3);
                  } else
                    l2.push(e3);
                  if (this.tokenizer.endOfFile()) {
                    i2 = true;
                    break;
                  }
                }
                s3.raws.between = this.spacesAndCommentsFromEnd(l2), l2.length ? (s3.raws.afterName = this.spacesAndCommentsFromStart(l2), this.raw(s3, "params", l2), i2 && (e3 = l2[l2.length - 1], s3.source.end = this.getPosition(e3[3] || e3[2]), this.spaces = s3.raws.between, s3.raws.between = "")) : (s3.raws.afterName = "", s3.params = ""), a2 && (s3.nodes = [], this.current = s3);
              }
              end(e3) {
                this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = false, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e3[2]), this.current = this.current.parent) : this.unexpectedClose(e3);
              }
              endFile() {
                this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
              }
              freeSemicolon(e3) {
                if (this.spaces += e3[1], this.current.nodes) {
                  let e4 = this.current.nodes[this.current.nodes.length - 1];
                  e4 && e4.type === "rule" && !e4.raws.ownSemicolon && (e4.raws.ownSemicolon = this.spaces, this.spaces = "");
                }
              }
              getPosition(e3) {
                let t3 = this.input.fromOffset(e3);
                return { offset: e3, line: t3.line, column: t3.col };
              }
              init(e3, t3) {
                this.current.push(e3), e3.source = { start: this.getPosition(t3), input: this.input }, e3.raws.before = this.spaces, this.spaces = "", e3.type !== "comment" && (this.semicolon = false);
              }
              raw(e3, t3, r3) {
                let n2, s3, i2, o2, a2 = r3.length, l2 = "", c = true, u = /^([#.|])?(\w)+/i;
                for (let t4 = 0; t4 < a2; t4 += 1)
                  n2 = r3[t4], s3 = n2[0], s3 !== "comment" || e3.type !== "rule" ? s3 === "comment" || s3 === "space" && t4 === a2 - 1 ? c = false : l2 += n2[1] : (o2 = r3[t4 - 1], i2 = r3[t4 + 1], o2[0] !== "space" && i2[0] !== "space" && u.test(o2[1]) && u.test(i2[1]) ? l2 += n2[1] : c = false);
                if (!c) {
                  let n3 = r3.reduce((e4, t4) => e4 + t4[1], "");
                  e3.raws[t3] = { value: l2, raw: n3 };
                }
                e3[t3] = l2;
              }
              spacesAndCommentsFromEnd(e3) {
                let t3, r3 = "";
                for (; e3.length && (t3 = e3[e3.length - 1][0], t3 === "space" || t3 === "comment"); )
                  r3 = e3.pop()[1] + r3;
                return r3;
              }
              spacesAndCommentsFromStart(e3) {
                let t3, r3 = "";
                for (; e3.length && (t3 = e3[0][0], t3 === "space" || t3 === "comment"); )
                  r3 += e3.shift()[1];
                return r3;
              }
              spacesFromEnd(e3) {
                let t3, r3 = "";
                for (; e3.length && (t3 = e3[e3.length - 1][0], t3 === "space"); )
                  r3 = e3.pop()[1] + r3;
                return r3;
              }
              stringFrom(e3, t3) {
                let r3 = "";
                for (let n2 = t3; n2 < e3.length; n2++)
                  r3 += e3[n2][1];
                return e3.splice(t3, e3.length - t3), r3;
              }
              colon(e3) {
                let t3, r3, n2, s3 = 0;
                for (let [i2, o2] of e3.entries()) {
                  if (t3 = o2, r3 = t3[0], r3 === "(" && (s3 += 1), r3 === ")" && (s3 -= 1), s3 === 0 && r3 === ":") {
                    if (n2) {
                      if (n2[0] === "word" && n2[1] === "progid")
                        continue;
                      return i2;
                    }
                    this.doubleColon(t3);
                  }
                  n2 = t3;
                }
                return false;
              }
              unclosedBracket(e3) {
                throw this.input.error("Unclosed bracket", e3[2]);
              }
              unknownWord(e3) {
                throw this.input.error("Unknown word", e3[0][2]);
              }
              unexpectedClose(e3) {
                throw this.input.error("Unexpected }", e3[2]);
              }
              unclosedBlock() {
                let e3 = this.current.source.start;
                throw this.input.error("Unclosed block", e3.line, e3.column);
              }
              doubleColon(e3) {
                throw this.input.error("Double colon", e3[2]);
              }
              unnamedAtrule(e3, t3) {
                throw this.input.error("At-rule without name", t3[2]);
              }
              precheckMissedSemicolon() {
              }
              checkMissedSemicolon(e3) {
                let t3 = this.colon(e3);
                if (t3 === false)
                  return;
                let r3, n2 = 0;
                for (let s3 = t3 - 1; s3 >= 0 && (r3 = e3[s3], r3[0] === "space" || (n2 += 1, n2 !== 2)); s3--)
                  ;
                throw this.input.error("Missed semicolon", r3[2]);
              }
            };
          }, (e2) => {
            "use strict";
            const t2 = "'".charCodeAt(0), r2 = '"'.charCodeAt(0), n = "\\".charCodeAt(0), s2 = "/".charCodeAt(0), i = "\n".charCodeAt(0), o = " ".charCodeAt(0), a = "\f".charCodeAt(0), l = "	".charCodeAt(0), c = "\r".charCodeAt(0), u = "[".charCodeAt(0), p2 = "]".charCodeAt(0), f = "(".charCodeAt(0), d = ")".charCodeAt(0), h3 = "{".charCodeAt(0), m = "}".charCodeAt(0), y = ";".charCodeAt(0), g = "*".charCodeAt(0), b = ":".charCodeAt(0), v = "@".charCodeAt(0), E = /[\t\n\f\r "#'()/;[\\\]{}]/g, x = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, S = /.[\n"'(/\\]/, T = /[\da-f]/i;
            e2.exports = function(e3, w = {}) {
              let P, A, O, C, I, k2, N, _, j, D, L = e3.css.valueOf(), M = w.ignoreErrors, B = L.length, R = 0, F = [], U = [];
              function $(t3) {
                throw e3.error("Unclosed " + t3, R);
              }
              return { back: function(e4) {
                U.push(e4);
              }, nextToken: function(e4) {
                if (U.length)
                  return U.pop();
                if (R >= B)
                  return;
                let w2 = !!e4 && e4.ignoreUnclosed;
                switch (P = L.charCodeAt(R), P) {
                  case i:
                  case o:
                  case l:
                  case c:
                  case a:
                    A = R;
                    do {
                      A += 1, P = L.charCodeAt(A);
                    } while (P === o || P === i || P === l || P === c || P === a);
                    D = ["space", L.slice(R, A)], R = A - 1;
                    break;
                  case u:
                  case p2:
                  case h3:
                  case m:
                  case b:
                  case y:
                  case d: {
                    let e5 = String.fromCharCode(P);
                    D = [e5, e5, R];
                    break;
                  }
                  case f:
                    if (_ = F.length ? F.pop()[1] : "", j = L.charCodeAt(R + 1), _ === "url" && j !== t2 && j !== r2 && j !== o && j !== i && j !== l && j !== a && j !== c) {
                      A = R;
                      do {
                        if (k2 = false, A = L.indexOf(")", A + 1), A === -1) {
                          if (M || w2) {
                            A = R;
                            break;
                          }
                          $("bracket");
                        }
                        for (N = A; L.charCodeAt(N - 1) === n; )
                          N -= 1, k2 = !k2;
                      } while (k2);
                      D = ["brackets", L.slice(R, A + 1), R, A], R = A;
                    } else
                      A = L.indexOf(")", R + 1), C = L.slice(R, A + 1), A === -1 || S.test(C) ? D = ["(", "(", R] : (D = ["brackets", C, R, A], R = A);
                    break;
                  case t2:
                  case r2:
                    O = P === t2 ? "'" : '"', A = R;
                    do {
                      if (k2 = false, A = L.indexOf(O, A + 1), A === -1) {
                        if (M || w2) {
                          A = R + 1;
                          break;
                        }
                        $("string");
                      }
                      for (N = A; L.charCodeAt(N - 1) === n; )
                        N -= 1, k2 = !k2;
                    } while (k2);
                    D = ["string", L.slice(R, A + 1), R, A], R = A;
                    break;
                  case v:
                    E.lastIndex = R + 1, E.test(L), A = E.lastIndex === 0 ? L.length - 1 : E.lastIndex - 2, D = ["at-word", L.slice(R, A + 1), R, A], R = A;
                    break;
                  case n:
                    for (A = R, I = true; L.charCodeAt(A + 1) === n; )
                      A += 1, I = !I;
                    if (P = L.charCodeAt(A + 1), I && P !== s2 && P !== o && P !== i && P !== l && P !== c && P !== a && (A += 1, T.test(L.charAt(A)))) {
                      for (; T.test(L.charAt(A + 1)); )
                        A += 1;
                      L.charCodeAt(A + 1) === o && (A += 1);
                    }
                    D = ["word", L.slice(R, A + 1), R, A], R = A;
                    break;
                  default:
                    P === s2 && L.charCodeAt(R + 1) === g ? (A = L.indexOf("*/", R + 2) + 1, A === 0 && (M || w2 ? A = L.length : $("comment")), D = ["comment", L.slice(R, A + 1), R, A], R = A) : (x.lastIndex = R + 1, x.test(L), A = x.lastIndex === 0 ? L.length - 1 : x.lastIndex - 2, D = ["word", L.slice(R, A + 1), R, A], F.push(D), R = A);
                }
                return R++, D;
              }, endOfFile: function() {
                return U.length === 0 && R >= B;
              }, position: function() {
                return R;
              } };
            };
          }, (e2) => {
            e2.exports = { nanoid: (e3 = 21) => {
              let t2 = "", r2 = e3;
              for (; r2--; )
                t2 += "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW"[64 * Math.random() | 0];
              return t2;
            }, customAlphabet: (e3, t2) => () => {
              let r2 = "", n = t2;
              for (; n--; )
                r2 += e3[Math.random() * e3.length | 0];
              return r2;
            } };
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.unescapeValue = y, t2.default = void 0;
            var n, s2 = l(r2(92)), i = l(r2(98)), o = l(r2(53)), a = r2(5);
            function l(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            function c(e3, t3) {
              for (var r3 = 0; r3 < t3.length; r3++) {
                var n2 = t3[r3];
                n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
              }
            }
            function u(e3, t3) {
              return (u = Object.setPrototypeOf || function(e4, t4) {
                return e4.__proto__ = t4, e4;
              })(e3, t3);
            }
            var p2 = r2(327), f = /^('|")([^]*)\1$/, d = p2(function() {
            }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead."), h3 = p2(function() {
            }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead."), m = p2(function() {
            }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
            function y(e3) {
              var t3 = false, r3 = null, n2 = e3, s3 = n2.match(f);
              return s3 && (r3 = s3[1], n2 = s3[2]), (n2 = (0, i.default)(n2)) !== e3 && (t3 = true), { deprecatedUsage: t3, unescaped: n2, quoteMark: r3 };
            }
            var g = function(e3) {
              var t3, r3;
              function n2(t4) {
                var r4;
                return t4 === void 0 && (t4 = {}), (r4 = e3.call(this, function(e4) {
                  if (e4.quoteMark !== void 0)
                    return e4;
                  if (e4.value === void 0)
                    return e4;
                  m();
                  var t5 = y(e4.value), r5 = t5.quoteMark, n3 = t5.unescaped;
                  return e4.raws || (e4.raws = {}), e4.raws.value === void 0 && (e4.raws.value = e4.value), e4.value = n3, e4.quoteMark = r5, e4;
                }(t4)) || this).type = a.ATTRIBUTE, r4.raws = r4.raws || {}, Object.defineProperty(r4.raws, "unquoted", { get: p2(function() {
                  return r4.value;
                }, "attr.raws.unquoted is deprecated. Call attr.value instead."), set: p2(function() {
                  return r4.value;
                }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.") }), r4._constructed = true, r4;
              }
              r3 = e3, (t3 = n2).prototype = Object.create(r3.prototype), t3.prototype.constructor = t3, u(t3, r3);
              var i2, o2, l2 = n2.prototype;
              return l2.getQuotedValue = function(e4) {
                e4 === void 0 && (e4 = {});
                var t4 = this._determineQuoteMark(e4), r4 = b[t4];
                return (0, s2.default)(this._value, r4);
              }, l2._determineQuoteMark = function(e4) {
                return e4.smart ? this.smartQuoteMark(e4) : this.preferredQuoteMark(e4);
              }, l2.setValue = function(e4, t4) {
                t4 === void 0 && (t4 = {}), this._value = e4, this._quoteMark = this._determineQuoteMark(t4), this._syncRawValue();
              }, l2.smartQuoteMark = function(e4) {
                var t4 = this.value, r4 = t4.replace(/[^']/g, "").length, i3 = t4.replace(/[^"]/g, "").length;
                if (r4 + i3 === 0) {
                  var o3 = (0, s2.default)(t4, { isIdentifier: true });
                  if (o3 === t4)
                    return n2.NO_QUOTE;
                  var a2 = this.preferredQuoteMark(e4);
                  if (a2 === n2.NO_QUOTE) {
                    var l3 = this.quoteMark || e4.quoteMark || n2.DOUBLE_QUOTE, c4 = b[l3];
                    if ((0, s2.default)(t4, c4).length < o3.length)
                      return l3;
                  }
                  return a2;
                }
                return i3 === r4 ? this.preferredQuoteMark(e4) : i3 < r4 ? n2.DOUBLE_QUOTE : n2.SINGLE_QUOTE;
              }, l2.preferredQuoteMark = function(e4) {
                var t4 = e4.preferCurrentQuoteMark ? this.quoteMark : e4.quoteMark;
                return t4 === void 0 && (t4 = e4.preferCurrentQuoteMark ? e4.quoteMark : this.quoteMark), t4 === void 0 && (t4 = n2.DOUBLE_QUOTE), t4;
              }, l2._syncRawValue = function() {
                var e4 = (0, s2.default)(this._value, b[this.quoteMark]);
                e4 === this._value ? this.raws && delete this.raws.value : this.raws.value = e4;
              }, l2._handleEscapes = function(e4, t4) {
                if (this._constructed) {
                  var r4 = (0, s2.default)(t4, { isIdentifier: true });
                  r4 !== t4 ? this.raws[e4] = r4 : delete this.raws[e4];
                }
              }, l2._spacesFor = function(e4) {
                var t4 = this.spaces[e4] || {}, r4 = this.raws.spaces && this.raws.spaces[e4] || {};
                return Object.assign({ before: "", after: "" }, t4, r4);
              }, l2._stringFor = function(e4, t4, r4) {
                t4 === void 0 && (t4 = e4), r4 === void 0 && (r4 = v);
                var n3 = this._spacesFor(t4);
                return r4(this.stringifyProperty(e4), n3);
              }, l2.offsetOf = function(e4) {
                var t4 = 1, r4 = this._spacesFor("attribute");
                if (t4 += r4.before.length, e4 === "namespace" || e4 === "ns")
                  return this.namespace ? t4 : -1;
                if (e4 === "attributeNS")
                  return t4;
                if (t4 += this.namespaceString.length, this.namespace && (t4 += 1), e4 === "attribute")
                  return t4;
                t4 += this.stringifyProperty("attribute").length, t4 += r4.after.length;
                var n3 = this._spacesFor("operator");
                t4 += n3.before.length;
                var s3 = this.stringifyProperty("operator");
                if (e4 === "operator")
                  return s3 ? t4 : -1;
                t4 += s3.length, t4 += n3.after.length;
                var i3 = this._spacesFor("value");
                t4 += i3.before.length;
                var o3 = this.stringifyProperty("value");
                return e4 === "value" ? o3 ? t4 : -1 : (t4 += o3.length, t4 += i3.after.length, t4 += this._spacesFor("insensitive").before.length, e4 === "insensitive" && this.insensitive ? t4 : -1);
              }, l2.toString = function() {
                var e4 = this, t4 = [this.rawSpaceBefore, "["];
                return t4.push(this._stringFor("qualifiedAttribute", "attribute")), this.operator && (this.value || this.value === "") && (t4.push(this._stringFor("operator")), t4.push(this._stringFor("value")), t4.push(this._stringFor("insensitiveFlag", "insensitive", function(t5, r4) {
                  return !(t5.length > 0) || e4.quoted || r4.before.length !== 0 || e4.spaces.value && e4.spaces.value.after || (r4.before = " "), v(t5, r4);
                }))), t4.push("]"), t4.push(this.rawSpaceAfter), t4.join("");
              }, i2 = n2, (o2 = [{ key: "quoted", get: function() {
                var e4 = this.quoteMark;
                return e4 === "'" || e4 === '"';
              }, set: function(e4) {
                h3();
              } }, { key: "quoteMark", get: function() {
                return this._quoteMark;
              }, set: function(e4) {
                this._constructed ? this._quoteMark !== e4 && (this._quoteMark = e4, this._syncRawValue()) : this._quoteMark = e4;
              } }, { key: "qualifiedAttribute", get: function() {
                return this.qualifiedName(this.raws.attribute || this.attribute);
              } }, { key: "insensitiveFlag", get: function() {
                return this.insensitive ? "i" : "";
              } }, { key: "value", get: function() {
                return this._value;
              }, set: function(e4) {
                if (this._constructed) {
                  var t4 = y(e4), r4 = t4.deprecatedUsage, n3 = t4.unescaped, s3 = t4.quoteMark;
                  if (r4 && d(), n3 === this._value && s3 === this._quoteMark)
                    return;
                  this._value = n3, this._quoteMark = s3, this._syncRawValue();
                } else
                  this._value = e4;
              } }, { key: "attribute", get: function() {
                return this._attribute;
              }, set: function(e4) {
                this._handleEscapes("attribute", e4), this._attribute = e4;
              } }]) && c(i2.prototype, o2), n2;
            }(o.default);
            t2.default = g, g.NO_QUOTE = null, g.SINGLE_QUOTE = "'", g.DOUBLE_QUOTE = '"';
            var b = ((n = { "'": { quotes: "single", wrap: true }, '"': { quotes: "double", wrap: true } }).null = { isIdentifier: true }, n);
            function v(e3, t3) {
              return "" + t3.before + e3 + t3.after;
            }
          }, (e2, t2, r2) => {
            function n(e3) {
              try {
                if (!r2.g.localStorage)
                  return false;
              } catch (e4) {
                return false;
              }
              var t3 = r2.g.localStorage[e3];
              return t3 != null && String(t3).toLowerCase() === "true";
            }
            e2.exports = function(e3, t3) {
              if (n("noDeprecation"))
                return e3;
              var r3 = false;
              return function() {
                if (!r3) {
                  if (n("throwDeprecation"))
                    throw new Error(t3);
                  n("traceDeprecation"), r3 = true;
                }
                return e3.apply(this, arguments);
              };
            };
          }, (e2, t2) => {
            "use strict";
            t2.__esModule = true, t2.combinator = t2.word = t2.comment = t2.str = t2.tab = t2.newline = t2.feed = t2.cr = t2.backslash = t2.bang = t2.slash = t2.doubleQuote = t2.singleQuote = t2.space = t2.greaterThan = t2.pipe = t2.equals = t2.plus = t2.caret = t2.tilde = t2.dollar = t2.closeSquare = t2.openSquare = t2.closeParenthesis = t2.openParenthesis = t2.semicolon = t2.colon = t2.comma = t2.at = t2.asterisk = t2.ampersand = void 0, t2.ampersand = 38, t2.asterisk = 42, t2.at = 64, t2.comma = 44, t2.colon = 58, t2.semicolon = 59, t2.openParenthesis = 40, t2.closeParenthesis = 41, t2.openSquare = 91, t2.closeSquare = 93, t2.dollar = 36, t2.tilde = 126, t2.caret = 94, t2.plus = 43, t2.equals = 61, t2.pipe = 124, t2.greaterThan = 62, t2.space = 32, t2.singleQuote = 39, t2.doubleQuote = 34, t2.slash = 47, t2.bang = 33, t2.backslash = 92, t2.cr = 13, t2.feed = 12, t2.newline = 10, t2.tab = 9, t2.str = 39, t2.comment = -1, t2.word = -2, t2.combinator = -3;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(37).Buffer, s2 = r2(178), i = function e3(t3) {
              this.bits = t3 instanceof e3 ? t3.bits.slice() : [];
            };
            i.prototype.add = function(e3) {
              this.bits[e3 >> 5] |= 1 << (31 & e3);
            }, i.prototype.has = function(e3) {
              return !!(this.bits[e3 >> 5] & 1 << (31 & e3));
            };
            var o = function(e3, t3, r3) {
              this.start = e3, this.end = t3, this.original = r3, this.intro = "", this.outro = "", this.content = r3, this.storeName = false, this.edited = false, Object.defineProperties(this, { previous: { writable: true, value: null }, next: { writable: true, value: null } });
            };
            o.prototype.appendLeft = function(e3) {
              this.outro += e3;
            }, o.prototype.appendRight = function(e3) {
              this.intro = this.intro + e3;
            }, o.prototype.clone = function() {
              var e3 = new o(this.start, this.end, this.original);
              return e3.intro = this.intro, e3.outro = this.outro, e3.content = this.content, e3.storeName = this.storeName, e3.edited = this.edited, e3;
            }, o.prototype.contains = function(e3) {
              return this.start < e3 && e3 < this.end;
            }, o.prototype.eachNext = function(e3) {
              for (var t3 = this; t3; )
                e3(t3), t3 = t3.next;
            }, o.prototype.eachPrevious = function(e3) {
              for (var t3 = this; t3; )
                e3(t3), t3 = t3.previous;
            }, o.prototype.edit = function(e3, t3, r3) {
              return this.content = e3, r3 || (this.intro = "", this.outro = ""), this.storeName = t3, this.edited = true, this;
            }, o.prototype.prependLeft = function(e3) {
              this.outro = e3 + this.outro;
            }, o.prototype.prependRight = function(e3) {
              this.intro = e3 + this.intro;
            }, o.prototype.split = function(e3) {
              var t3 = e3 - this.start, r3 = this.original.slice(0, t3), n2 = this.original.slice(t3);
              this.original = r3;
              var s3 = new o(e3, this.end, n2);
              return s3.outro = this.outro, this.outro = "", this.end = e3, this.edited ? (s3.edit("", false), this.content = "") : this.content = r3, s3.next = this.next, s3.next && (s3.next.previous = s3), s3.previous = this, this.next = s3, s3;
            }, o.prototype.toString = function() {
              return this.intro + this.content + this.outro;
            }, o.prototype.trimEnd = function(e3) {
              if (this.outro = this.outro.replace(e3, ""), this.outro.length)
                return true;
              var t3 = this.content.replace(e3, "");
              return t3.length ? (t3 !== this.content && this.split(this.start + t3.length).edit("", void 0, true), true) : (this.edit("", void 0, true), this.intro = this.intro.replace(e3, ""), !!this.intro.length || void 0);
            }, o.prototype.trimStart = function(e3) {
              if (this.intro = this.intro.replace(e3, ""), this.intro.length)
                return true;
              var t3 = this.content.replace(e3, "");
              return t3.length ? (t3 !== this.content && (this.split(this.end - t3.length), this.edit("", void 0, true)), true) : (this.edit("", void 0, true), this.outro = this.outro.replace(e3, ""), !!this.outro.length || void 0);
            };
            var a = function() {
              throw new Error("Unsupported environment: `window.btoa` or `Buffer` should be supported.");
            };
            typeof window != "undefined" && typeof window.btoa == "function" ? a = function(e3) {
              return window.btoa(unescape(encodeURIComponent(e3)));
            } : typeof n == "function" && (a = function(e3) {
              return n.from(e3, "utf-8").toString("base64");
            });
            var l = function(e3) {
              this.version = 3, this.file = e3.file, this.sources = e3.sources, this.sourcesContent = e3.sourcesContent, this.names = e3.names, this.mappings = s2.encode(e3.mappings);
            };
            function c(e3) {
              var t3 = e3.split("\n"), r3 = t3.filter(function(e4) {
                return /^\t+/.test(e4);
              }), n2 = t3.filter(function(e4) {
                return /^ {2,}/.test(e4);
              });
              if (r3.length === 0 && n2.length === 0)
                return null;
              if (r3.length >= n2.length)
                return "	";
              var s3 = n2.reduce(function(e4, t4) {
                var r4 = /^ +/.exec(t4)[0].length;
                return Math.min(r4, e4);
              }, 1 / 0);
              return new Array(s3 + 1).join(" ");
            }
            function u(e3, t3) {
              var r3 = e3.split(/[/\\]/), n2 = t3.split(/[/\\]/);
              for (r3.pop(); r3[0] === n2[0]; )
                r3.shift(), n2.shift();
              if (r3.length)
                for (var s3 = r3.length; s3--; )
                  r3[s3] = "..";
              return r3.concat(n2).join("/");
            }
            l.prototype.toString = function() {
              return JSON.stringify(this);
            }, l.prototype.toUrl = function() {
              return "data:application/json;charset=utf-8;base64," + a(this.toString());
            };
            var p2 = Object.prototype.toString;
            function f(e3) {
              return p2.call(e3) === "[object Object]";
            }
            function d(e3) {
              for (var t3 = e3.split("\n"), r3 = [], n2 = 0, s3 = 0; n2 < t3.length; n2++)
                r3.push(s3), s3 += t3[n2].length + 1;
              return function(e4) {
                for (var t4 = 0, n3 = r3.length; t4 < n3; ) {
                  var s4 = t4 + n3 >> 1;
                  e4 < r3[s4] ? n3 = s4 : t4 = s4 + 1;
                }
                var i2 = t4 - 1;
                return { line: i2, column: e4 - r3[i2] };
              };
            }
            var h3 = function(e3) {
              this.hires = e3, this.generatedCodeLine = 0, this.generatedCodeColumn = 0, this.raw = [], this.rawSegments = this.raw[this.generatedCodeLine] = [], this.pending = null;
            };
            h3.prototype.addEdit = function(e3, t3, r3, n2) {
              if (t3.length) {
                var s3 = [this.generatedCodeColumn, e3, r3.line, r3.column];
                n2 >= 0 && s3.push(n2), this.rawSegments.push(s3);
              } else
                this.pending && this.rawSegments.push(this.pending);
              this.advance(t3), this.pending = null;
            }, h3.prototype.addUneditedChunk = function(e3, t3, r3, n2, s3) {
              for (var i2 = t3.start, o2 = true; i2 < t3.end; )
                (this.hires || o2 || s3.has(i2)) && this.rawSegments.push([this.generatedCodeColumn, e3, n2.line, n2.column]), r3[i2] === "\n" ? (n2.line += 1, n2.column = 0, this.generatedCodeLine += 1, this.raw[this.generatedCodeLine] = this.rawSegments = [], this.generatedCodeColumn = 0, o2 = true) : (n2.column += 1, this.generatedCodeColumn += 1, o2 = false), i2 += 1;
              this.pending = null;
            }, h3.prototype.advance = function(e3) {
              if (e3) {
                var t3 = e3.split("\n");
                if (t3.length > 1) {
                  for (var r3 = 0; r3 < t3.length - 1; r3++)
                    this.generatedCodeLine++, this.raw[this.generatedCodeLine] = this.rawSegments = [];
                  this.generatedCodeColumn = 0;
                }
                this.generatedCodeColumn += t3[t3.length - 1].length;
              }
            };
            var m = "\n", y = { insertLeft: false, insertRight: false, storeName: false }, g = function(e3, t3) {
              t3 === void 0 && (t3 = {});
              var r3 = new o(0, e3.length, e3);
              Object.defineProperties(this, { original: { writable: true, value: e3 }, outro: { writable: true, value: "" }, intro: { writable: true, value: "" }, firstChunk: { writable: true, value: r3 }, lastChunk: { writable: true, value: r3 }, lastSearchedChunk: { writable: true, value: r3 }, byStart: { writable: true, value: {} }, byEnd: { writable: true, value: {} }, filename: { writable: true, value: t3.filename }, indentExclusionRanges: { writable: true, value: t3.indentExclusionRanges }, sourcemapLocations: { writable: true, value: new i() }, storedNames: { writable: true, value: {} }, indentStr: { writable: true, value: c(e3) } }), this.byStart[0] = r3, this.byEnd[e3.length] = r3;
            };
            g.prototype.addSourcemapLocation = function(e3) {
              this.sourcemapLocations.add(e3);
            }, g.prototype.append = function(e3) {
              if (typeof e3 != "string")
                throw new TypeError("outro content must be a string");
              return this.outro += e3, this;
            }, g.prototype.appendLeft = function(e3, t3) {
              if (typeof t3 != "string")
                throw new TypeError("inserted content must be a string");
              this._split(e3);
              var r3 = this.byEnd[e3];
              return r3 ? r3.appendLeft(t3) : this.intro += t3, this;
            }, g.prototype.appendRight = function(e3, t3) {
              if (typeof t3 != "string")
                throw new TypeError("inserted content must be a string");
              this._split(e3);
              var r3 = this.byStart[e3];
              return r3 ? r3.appendRight(t3) : this.outro += t3, this;
            }, g.prototype.clone = function() {
              for (var e3 = new g(this.original, { filename: this.filename }), t3 = this.firstChunk, r3 = e3.firstChunk = e3.lastSearchedChunk = t3.clone(); t3; ) {
                e3.byStart[r3.start] = r3, e3.byEnd[r3.end] = r3;
                var n2 = t3.next, s3 = n2 && n2.clone();
                s3 && (r3.next = s3, s3.previous = r3, r3 = s3), t3 = n2;
              }
              return e3.lastChunk = r3, this.indentExclusionRanges && (e3.indentExclusionRanges = this.indentExclusionRanges.slice()), e3.sourcemapLocations = new i(this.sourcemapLocations), e3.intro = this.intro, e3.outro = this.outro, e3;
            }, g.prototype.generateDecodedMap = function(e3) {
              var t3 = this;
              e3 = e3 || {};
              var r3 = Object.keys(this.storedNames), n2 = new h3(e3.hires), s3 = d(this.original);
              return this.intro && n2.advance(this.intro), this.firstChunk.eachNext(function(e4) {
                var i2 = s3(e4.start);
                e4.intro.length && n2.advance(e4.intro), e4.edited ? n2.addEdit(0, e4.content, i2, e4.storeName ? r3.indexOf(e4.original) : -1) : n2.addUneditedChunk(0, e4, t3.original, i2, t3.sourcemapLocations), e4.outro.length && n2.advance(e4.outro);
              }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : null, sources: [e3.source ? u(e3.file || "", e3.source) : null], sourcesContent: e3.includeContent ? [this.original] : [null], names: r3, mappings: n2.raw };
            }, g.prototype.generateMap = function(e3) {
              return new l(this.generateDecodedMap(e3));
            }, g.prototype.getIndentString = function() {
              return this.indentStr === null ? "	" : this.indentStr;
            }, g.prototype.indent = function(e3, t3) {
              var r3 = /^[^\r\n]/gm;
              if (f(e3) && (t3 = e3, e3 = void 0), (e3 = e3 !== void 0 ? e3 : this.indentStr || "	") === "")
                return this;
              var n2 = {};
              (t3 = t3 || {}).exclude && (typeof t3.exclude[0] == "number" ? [t3.exclude] : t3.exclude).forEach(function(e4) {
                for (var t4 = e4[0]; t4 < e4[1]; t4 += 1)
                  n2[t4] = true;
              });
              var s3 = t3.indentStart !== false, i2 = function(t4) {
                return s3 ? "" + e3 + t4 : (s3 = true, t4);
              };
              this.intro = this.intro.replace(r3, i2);
              for (var o2 = 0, a2 = this.firstChunk; a2; ) {
                var l2 = a2.end;
                if (a2.edited)
                  n2[o2] || (a2.content = a2.content.replace(r3, i2), a2.content.length && (s3 = a2.content[a2.content.length - 1] === "\n"));
                else
                  for (o2 = a2.start; o2 < l2; ) {
                    if (!n2[o2]) {
                      var c4 = this.original[o2];
                      c4 === "\n" ? s3 = true : c4 !== "\r" && s3 && (s3 = false, o2 === a2.start ? a2.prependRight(e3) : (this._splitChunk(a2, o2), (a2 = a2.next).prependRight(e3)));
                    }
                    o2 += 1;
                  }
                o2 = a2.end, a2 = a2.next;
              }
              return this.outro = this.outro.replace(r3, i2), this;
            }, g.prototype.insert = function() {
              throw new Error("magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)");
            }, g.prototype.insertLeft = function(e3, t3) {
              return y.insertLeft || (y.insertLeft = true), this.appendLeft(e3, t3);
            }, g.prototype.insertRight = function(e3, t3) {
              return y.insertRight || (y.insertRight = true), this.prependRight(e3, t3);
            }, g.prototype.move = function(e3, t3, r3) {
              if (r3 >= e3 && r3 <= t3)
                throw new Error("Cannot move a selection inside itself");
              this._split(e3), this._split(t3), this._split(r3);
              var n2 = this.byStart[e3], s3 = this.byEnd[t3], i2 = n2.previous, o2 = s3.next, a2 = this.byStart[r3];
              if (!a2 && s3 === this.lastChunk)
                return this;
              var l2 = a2 ? a2.previous : this.lastChunk;
              return i2 && (i2.next = o2), o2 && (o2.previous = i2), l2 && (l2.next = n2), a2 && (a2.previous = s3), n2.previous || (this.firstChunk = s3.next), s3.next || (this.lastChunk = n2.previous, this.lastChunk.next = null), n2.previous = l2, s3.next = a2 || null, l2 || (this.firstChunk = n2), a2 || (this.lastChunk = s3), this;
            }, g.prototype.overwrite = function(e3, t3, r3, n2) {
              if (typeof r3 != "string")
                throw new TypeError("replacement content must be a string");
              for (; e3 < 0; )
                e3 += this.original.length;
              for (; t3 < 0; )
                t3 += this.original.length;
              if (t3 > this.original.length)
                throw new Error("end is out of bounds");
              if (e3 === t3)
                throw new Error("Cannot overwrite a zero-length range \u2013 use appendLeft or prependRight instead");
              this._split(e3), this._split(t3), n2 === true && (y.storeName || (y.storeName = true), n2 = { storeName: true });
              var s3 = n2 !== void 0 && n2.storeName, i2 = n2 !== void 0 && n2.contentOnly;
              if (s3) {
                var a2 = this.original.slice(e3, t3);
                this.storedNames[a2] = true;
              }
              var l2 = this.byStart[e3], c4 = this.byEnd[t3];
              if (l2) {
                if (t3 > l2.end && l2.next !== this.byStart[l2.end])
                  throw new Error("Cannot overwrite across a split point");
                if (l2.edit(r3, s3, i2), l2 !== c4) {
                  for (var u2 = l2.next; u2 !== c4; )
                    u2.edit("", false), u2 = u2.next;
                  u2.edit("", false);
                }
              } else {
                var p3 = new o(e3, t3, "").edit(r3, s3);
                c4.next = p3, p3.previous = c4;
              }
              return this;
            }, g.prototype.prepend = function(e3) {
              if (typeof e3 != "string")
                throw new TypeError("outro content must be a string");
              return this.intro = e3 + this.intro, this;
            }, g.prototype.prependLeft = function(e3, t3) {
              if (typeof t3 != "string")
                throw new TypeError("inserted content must be a string");
              this._split(e3);
              var r3 = this.byEnd[e3];
              return r3 ? r3.prependLeft(t3) : this.intro = t3 + this.intro, this;
            }, g.prototype.prependRight = function(e3, t3) {
              if (typeof t3 != "string")
                throw new TypeError("inserted content must be a string");
              this._split(e3);
              var r3 = this.byStart[e3];
              return r3 ? r3.prependRight(t3) : this.outro = t3 + this.outro, this;
            }, g.prototype.remove = function(e3, t3) {
              for (; e3 < 0; )
                e3 += this.original.length;
              for (; t3 < 0; )
                t3 += this.original.length;
              if (e3 === t3)
                return this;
              if (e3 < 0 || t3 > this.original.length)
                throw new Error("Character is out of bounds");
              if (e3 > t3)
                throw new Error("end must be greater than start");
              this._split(e3), this._split(t3);
              for (var r3 = this.byStart[e3]; r3; )
                r3.intro = "", r3.outro = "", r3.edit(""), r3 = t3 > r3.end ? this.byStart[r3.end] : null;
              return this;
            }, g.prototype.lastChar = function() {
              if (this.outro.length)
                return this.outro[this.outro.length - 1];
              var e3 = this.lastChunk;
              do {
                if (e3.outro.length)
                  return e3.outro[e3.outro.length - 1];
                if (e3.content.length)
                  return e3.content[e3.content.length - 1];
                if (e3.intro.length)
                  return e3.intro[e3.intro.length - 1];
              } while (e3 = e3.previous);
              return this.intro.length ? this.intro[this.intro.length - 1] : "";
            }, g.prototype.lastLine = function() {
              var e3 = this.outro.lastIndexOf(m);
              if (e3 !== -1)
                return this.outro.substr(e3 + 1);
              var t3 = this.outro, r3 = this.lastChunk;
              do {
                if (r3.outro.length > 0) {
                  if ((e3 = r3.outro.lastIndexOf(m)) !== -1)
                    return r3.outro.substr(e3 + 1) + t3;
                  t3 = r3.outro + t3;
                }
                if (r3.content.length > 0) {
                  if ((e3 = r3.content.lastIndexOf(m)) !== -1)
                    return r3.content.substr(e3 + 1) + t3;
                  t3 = r3.content + t3;
                }
                if (r3.intro.length > 0) {
                  if ((e3 = r3.intro.lastIndexOf(m)) !== -1)
                    return r3.intro.substr(e3 + 1) + t3;
                  t3 = r3.intro + t3;
                }
              } while (r3 = r3.previous);
              return (e3 = this.intro.lastIndexOf(m)) !== -1 ? this.intro.substr(e3 + 1) + t3 : this.intro + t3;
            }, g.prototype.slice = function(e3, t3) {
              for (e3 === void 0 && (e3 = 0), t3 === void 0 && (t3 = this.original.length); e3 < 0; )
                e3 += this.original.length;
              for (; t3 < 0; )
                t3 += this.original.length;
              for (var r3 = "", n2 = this.firstChunk; n2 && (n2.start > e3 || n2.end <= e3); ) {
                if (n2.start < t3 && n2.end >= t3)
                  return r3;
                n2 = n2.next;
              }
              if (n2 && n2.edited && n2.start !== e3)
                throw new Error("Cannot use replaced character " + e3 + " as slice start anchor.");
              for (var s3 = n2; n2; ) {
                !n2.intro || s3 === n2 && n2.start !== e3 || (r3 += n2.intro);
                var i2 = n2.start < t3 && n2.end >= t3;
                if (i2 && n2.edited && n2.end !== t3)
                  throw new Error("Cannot use replaced character " + t3 + " as slice end anchor.");
                var o2 = s3 === n2 ? e3 - n2.start : 0, a2 = i2 ? n2.content.length + t3 - n2.end : n2.content.length;
                if (r3 += n2.content.slice(o2, a2), !n2.outro || i2 && n2.end !== t3 || (r3 += n2.outro), i2)
                  break;
                n2 = n2.next;
              }
              return r3;
            }, g.prototype.snip = function(e3, t3) {
              var r3 = this.clone();
              return r3.remove(0, e3), r3.remove(t3, r3.original.length), r3;
            }, g.prototype._split = function(e3) {
              if (!this.byStart[e3] && !this.byEnd[e3])
                for (var t3 = this.lastSearchedChunk, r3 = e3 > t3.end; t3; ) {
                  if (t3.contains(e3))
                    return this._splitChunk(t3, e3);
                  t3 = r3 ? this.byStart[t3.end] : this.byEnd[t3.start];
                }
            }, g.prototype._splitChunk = function(e3, t3) {
              if (e3.edited && e3.content.length) {
                var r3 = d(this.original)(t3);
                throw new Error("Cannot split a chunk that has already been edited (" + r3.line + ":" + r3.column + ' \u2013 "' + e3.original + '")');
              }
              var n2 = e3.split(t3);
              return this.byEnd[t3] = e3, this.byStart[t3] = n2, this.byEnd[n2.end] = n2, e3 === this.lastChunk && (this.lastChunk = n2), this.lastSearchedChunk = e3, true;
            }, g.prototype.toString = function() {
              for (var e3 = this.intro, t3 = this.firstChunk; t3; )
                e3 += t3.toString(), t3 = t3.next;
              return e3 + this.outro;
            }, g.prototype.isEmpty = function() {
              var e3 = this.firstChunk;
              do {
                if (e3.intro.length && e3.intro.trim() || e3.content.length && e3.content.trim() || e3.outro.length && e3.outro.trim())
                  return false;
              } while (e3 = e3.next);
              return true;
            }, g.prototype.length = function() {
              var e3 = this.firstChunk, t3 = 0;
              do {
                t3 += e3.intro.length + e3.content.length + e3.outro.length;
              } while (e3 = e3.next);
              return t3;
            }, g.prototype.trimLines = function() {
              return this.trim("[\\r\\n]");
            }, g.prototype.trim = function(e3) {
              return this.trimStart(e3).trimEnd(e3);
            }, g.prototype.trimEndAborted = function(e3) {
              var t3 = new RegExp((e3 || "\\s") + "+$");
              if (this.outro = this.outro.replace(t3, ""), this.outro.length)
                return true;
              var r3 = this.lastChunk;
              do {
                var n2 = r3.end, s3 = r3.trimEnd(t3);
                if (r3.end !== n2 && (this.lastChunk === r3 && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), s3)
                  return true;
                r3 = r3.previous;
              } while (r3);
              return false;
            }, g.prototype.trimEnd = function(e3) {
              return this.trimEndAborted(e3), this;
            }, g.prototype.trimStartAborted = function(e3) {
              var t3 = new RegExp("^" + (e3 || "\\s") + "+");
              if (this.intro = this.intro.replace(t3, ""), this.intro.length)
                return true;
              var r3 = this.firstChunk;
              do {
                var n2 = r3.end, s3 = r3.trimStart(t3);
                if (r3.end !== n2 && (r3 === this.lastChunk && (this.lastChunk = r3.next), this.byEnd[r3.end] = r3, this.byStart[r3.next.start] = r3.next, this.byEnd[r3.next.end] = r3.next), s3)
                  return true;
                r3 = r3.next;
              } while (r3);
              return false;
            }, g.prototype.trimStart = function(e3) {
              return this.trimStartAborted(e3), this;
            };
            var b = Object.prototype.hasOwnProperty, v = function(e3) {
              e3 === void 0 && (e3 = {}), this.intro = e3.intro || "", this.separator = e3.separator !== void 0 ? e3.separator : "\n", this.sources = [], this.uniqueSources = [], this.uniqueSourceIndexByFilename = {};
            };
            v.prototype.addSource = function(e3) {
              if (e3 instanceof g)
                return this.addSource({ content: e3, filename: e3.filename, separator: this.separator });
              if (!f(e3) || !e3.content)
                throw new Error("bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`");
              if (["filename", "indentExclusionRanges", "separator"].forEach(function(t4) {
                b.call(e3, t4) || (e3[t4] = e3.content[t4]);
              }), e3.separator === void 0 && (e3.separator = this.separator), e3.filename)
                if (b.call(this.uniqueSourceIndexByFilename, e3.filename)) {
                  var t3 = this.uniqueSources[this.uniqueSourceIndexByFilename[e3.filename]];
                  if (e3.content.original !== t3.content)
                    throw new Error("Illegal source: same filename (" + e3.filename + "), different contents");
                } else
                  this.uniqueSourceIndexByFilename[e3.filename] = this.uniqueSources.length, this.uniqueSources.push({ filename: e3.filename, content: e3.content.original });
              return this.sources.push(e3), this;
            }, v.prototype.append = function(e3, t3) {
              return this.addSource({ content: new g(e3), separator: t3 && t3.separator || "" }), this;
            }, v.prototype.clone = function() {
              var e3 = new v({ intro: this.intro, separator: this.separator });
              return this.sources.forEach(function(t3) {
                e3.addSource({ filename: t3.filename, content: t3.content.clone(), separator: t3.separator });
              }), e3;
            }, v.prototype.generateDecodedMap = function(e3) {
              var t3 = this;
              e3 === void 0 && (e3 = {});
              var r3 = [];
              this.sources.forEach(function(e4) {
                Object.keys(e4.content.storedNames).forEach(function(e5) {
                  ~r3.indexOf(e5) || r3.push(e5);
                });
              });
              var n2 = new h3(e3.hires);
              return this.intro && n2.advance(this.intro), this.sources.forEach(function(e4, s3) {
                s3 > 0 && n2.advance(t3.separator);
                var i2 = e4.filename ? t3.uniqueSourceIndexByFilename[e4.filename] : -1, o2 = e4.content, a2 = d(o2.original);
                o2.intro && n2.advance(o2.intro), o2.firstChunk.eachNext(function(t4) {
                  var s4 = a2(t4.start);
                  t4.intro.length && n2.advance(t4.intro), e4.filename ? t4.edited ? n2.addEdit(i2, t4.content, s4, t4.storeName ? r3.indexOf(t4.original) : -1) : n2.addUneditedChunk(i2, t4, o2.original, s4, o2.sourcemapLocations) : n2.advance(t4.content), t4.outro.length && n2.advance(t4.outro);
                }), o2.outro && n2.advance(o2.outro);
              }), { file: e3.file ? e3.file.split(/[/\\]/).pop() : null, sources: this.uniqueSources.map(function(t4) {
                return e3.file ? u(e3.file, t4.filename) : t4.filename;
              }), sourcesContent: this.uniqueSources.map(function(t4) {
                return e3.includeContent ? t4.content : null;
              }), names: r3, mappings: n2.raw };
            }, v.prototype.generateMap = function(e3) {
              return new l(this.generateDecodedMap(e3));
            }, v.prototype.getIndentString = function() {
              var e3 = {};
              return this.sources.forEach(function(t3) {
                var r3 = t3.content.indentStr;
                r3 !== null && (e3[r3] || (e3[r3] = 0), e3[r3] += 1);
              }), Object.keys(e3).sort(function(t3, r3) {
                return e3[t3] - e3[r3];
              })[0] || "	";
            }, v.prototype.indent = function(e3) {
              var t3 = this;
              if (arguments.length || (e3 = this.getIndentString()), e3 === "")
                return this;
              var r3 = !this.intro || this.intro.slice(-1) === "\n";
              return this.sources.forEach(function(n2, s3) {
                var i2 = n2.separator !== void 0 ? n2.separator : t3.separator, o2 = r3 || s3 > 0 && /\r?\n$/.test(i2);
                n2.content.indent(e3, { exclude: n2.indentExclusionRanges, indentStart: o2 }), r3 = n2.content.lastChar() === "\n";
              }), this.intro && (this.intro = e3 + this.intro.replace(/^[^\n]/gm, function(t4, r4) {
                return r4 > 0 ? e3 + t4 : t4;
              })), this;
            }, v.prototype.prepend = function(e3) {
              return this.intro = e3 + this.intro, this;
            }, v.prototype.toString = function() {
              var e3 = this, t3 = this.sources.map(function(t4, r3) {
                var n2 = t4.separator !== void 0 ? t4.separator : e3.separator;
                return (r3 > 0 ? n2 : "") + t4.content.toString();
              }).join("");
              return this.intro + t3;
            }, v.prototype.isEmpty = function() {
              return !(this.intro.length && this.intro.trim() || this.sources.some(function(e3) {
                return !e3.content.isEmpty();
              }));
            }, v.prototype.length = function() {
              return this.sources.reduce(function(e3, t3) {
                return e3 + t3.content.length();
              }, this.intro.length);
            }, v.prototype.trimLines = function() {
              return this.trim("[\\r\\n]");
            }, v.prototype.trim = function(e3) {
              return this.trimStart(e3).trimEnd(e3);
            }, v.prototype.trimStart = function(e3) {
              var t3 = new RegExp("^" + (e3 || "\\s") + "+");
              if (this.intro = this.intro.replace(t3, ""), !this.intro) {
                var r3, n2 = 0;
                do {
                  if (!(r3 = this.sources[n2++]))
                    break;
                } while (!r3.content.trimStartAborted(e3));
              }
              return this;
            }, v.prototype.trimEnd = function(e3) {
              var t3, r3 = new RegExp((e3 || "\\s") + "+$"), n2 = this.sources.length - 1;
              do {
                if (!(t3 = this.sources[n2--])) {
                  this.intro = this.intro.replace(r3, "");
                  break;
                }
              } while (!t3.content.trimEndAborted(e3));
              return this;
            }, g.Bundle = v, g.SourceMap = l, g.default = g, e2.exports = g;
          }, (e2, t2, r2) => {
            var n, s2 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, i = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, o = "a-z\\xdf-\\xf6\\xf8-\\xff", a = "A-Z\\xc0-\\xd6\\xd8-\\xde", l = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", c = "[" + l + "]", u = "[\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0]", p2 = "\\d+", f = "[" + o + "]", d = "[^\\ud800-\\udfff" + l + p2 + "\\u2700-\\u27bf" + o + a + "]", h3 = "\\ud83c[\\udffb-\\udfff]", m = "[^\\ud800-\\udfff]", y = "(?:\\ud83c[\\udde6-\\uddff]){2}", g = "[\\ud800-\\udbff][\\udc00-\\udfff]", b = "[" + a + "]", v = "(?:" + f + "|" + d + ")", E = "(?:" + b + "|" + d + ")", x = "(?:['\u2019](?:d|ll|m|re|s|t|ve))?", S = "(?:['\u2019](?:D|LL|M|RE|S|T|VE))?", T = "(?:" + u + "|" + h3 + ")?", w = "[\\ufe0e\\ufe0f]?", P = w + T + "(?:\\u200d(?:" + [m, y, g].join("|") + ")" + w + T + ")*", A = "(?:" + ["[\\u2700-\\u27bf]", y, g].join("|") + ")" + P, O = "(?:" + [m + u + "?", u, y, g, "[\\ud800-\\udfff]"].join("|") + ")", C = RegExp("['\u2019]", "g"), I = RegExp(u, "g"), k2 = RegExp(h3 + "(?=" + h3 + ")|" + O + P, "g"), N = RegExp([b + "?" + f + "+" + x + "(?=" + [c, b, "$"].join("|") + ")", E + "+" + S + "(?=" + [c, b + v, "$"].join("|") + ")", b + "?" + v + "+" + x, b + "+" + S, p2, A].join("|"), "g"), _ = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe23\\u20d0-\\u20f0\\ufe0e\\ufe0f]"), j = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, D = typeof r2.g == "object" && r2.g && r2.g.Object === Object && r2.g, L = typeof self == "object" && self && self.Object === Object && self, M = D || L || Function("return this")(), B = (n = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "ss" }, function(e3) {
              return n == null ? void 0 : n[e3];
            });
            function R(e3) {
              return _.test(e3);
            }
            var F = Object.prototype.toString, U = M.Symbol, $ = U ? U.prototype : void 0, q = $ ? $.toString : void 0;
            function V(e3) {
              return e3 == null ? "" : function(e4) {
                if (typeof e4 == "string")
                  return e4;
                if (function(e5) {
                  return typeof e5 == "symbol" || function(e6) {
                    return !!e6 && typeof e6 == "object";
                  }(e5) && F.call(e5) == "[object Symbol]";
                }(e4))
                  return q ? q.call(e4) : "";
                var t3 = e4 + "";
                return t3 == "0" && 1 / e4 == -1 / 0 ? "-0" : t3;
              }(e3);
            }
            var W, K = (W = function(e3, t3, r3) {
              return t3 = t3.toLowerCase(), e3 + (r3 ? G(V(t3).toLowerCase()) : t3);
            }, function(e3) {
              return function(e4, t3, r3, n2) {
                for (var s3 = -1, i2 = e4 ? e4.length : 0; ++s3 < i2; )
                  r3 = t3(r3, e4[s3], s3, e4);
                return r3;
              }(function(e4, t3, r3) {
                return e4 = V(e4), (t3 = t3) === void 0 ? function(e5) {
                  return j.test(e5);
                }(e4) ? function(e5) {
                  return e5.match(N) || [];
                }(e4) : function(e5) {
                  return e5.match(s2) || [];
                }(e4) : e4.match(t3) || [];
              }(function(e4) {
                return (e4 = V(e4)) && e4.replace(i, B).replace(I, "");
              }(e3).replace(C, "")), W, "");
            }), G = ("toUpperCase", function(e3) {
              var t3, r3, n2, s3, i2 = R(e3 = V(e3)) ? function(e4) {
                return R(e4) ? function(e5) {
                  return e5.match(k2) || [];
                }(e4) : function(e5) {
                  return e5.split("");
                }(e4);
              }(e3) : void 0, o2 = i2 ? i2[0] : e3.charAt(0), a2 = i2 ? (t3 = i2, r3 = 1, s3 = t3.length, n2 = n2 === void 0 ? s3 : n2, !r3 && n2 >= s3 ? t3 : function(e4, t4, r4) {
                var n3 = -1, s4 = e4.length;
                t4 < 0 && (t4 = -t4 > s4 ? 0 : s4 + t4), (r4 = r4 > s4 ? s4 : r4) < 0 && (r4 += s4), s4 = t4 > r4 ? 0 : r4 - t4 >>> 0, t4 >>>= 0;
                for (var i3 = Array(s4); ++n3 < s4; )
                  i3[n3] = e4[n3 + t4];
                return i3;
              }(t3, r3, n2)).join("") : e3.slice(1);
              return o2.toUpperCase() + a2;
            });
            e2.exports = K;
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7), s2 = r2(520).interpolateName, i = r2(8);
            e2.exports = function(e3, t3) {
              var r3 = (t3 = t3 || {}) && typeof t3.context == "string" ? t3.context : n.cwd(), o = t3 && typeof t3.hashPrefix == "string" ? t3.hashPrefix : "";
              return function(t4, n2) {
                var a = e3.replace(/\[local\]/gi, t4), l = { resourcePath: n2 }, c = { content: o + i.relative(r3, n2).replace(/\\/g, "/") + "+" + t4, context: r3 };
                return s2(l, a, c).replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
              };
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n, s2 = (n = r2(521)) && n.__esModule ? n : { default: n };
            const i = /^:import\((.+)\)$/;
            t2.default = class {
              constructor(e3, t3) {
                this.pathFetcher = e3, this.plugin = this.plugin.bind(this), this.exportTokens = {}, this.translations = {}, this.trace = t3;
              }
              plugin() {
                const e3 = this;
                return { postcssPlugin: "css-modules-parser", OnceExit: (t3) => Promise.all(e3.fetchAllImports(t3)).then(() => e3.linkImportedSymbols(t3)).then(() => e3.extractExports(t3)) };
              }
              fetchAllImports(e3) {
                let t3 = [];
                return e3.each((r3) => {
                  r3.type == "rule" && r3.selector.match(i) && t3.push(this.fetchImport(r3, e3.source.input.from, t3.length));
                }), t3;
              }
              linkImportedSymbols(e3) {
                (0, s2.default)(e3, this.translations);
              }
              extractExports(e3) {
                e3.each((e4) => {
                  e4.type == "rule" && e4.selector == ":export" && this.handleExport(e4);
                });
              }
              handleExport(e3) {
                e3.each((e4) => {
                  e4.type == "decl" && (Object.keys(this.translations).forEach((t3) => {
                    e4.value = e4.value.replace(t3, this.translations[t3]);
                  }), this.exportTokens[e4.prop] = e4.value);
                }), e3.remove();
              }
              fetchImport(e3, t3, r3) {
                let n2 = e3.selector.match(i)[1], s3 = this.trace + String.fromCharCode(r3);
                return this.pathFetcher(n2, t3, s3).then((t4) => {
                  e3.each((e4) => {
                    e4.type == "decl" && (this.translations[e4.prop] = t4[e4.value]);
                  }), e3.remove();
                }, (e4) => {
                });
              }
            };
          }, (e2) => {
            "use strict";
            e2.exports = function(e3) {
              for (var t2 = 5381, r2 = e3.length; r2; )
                t2 = 33 * t2 ^ e3.charCodeAt(--r2);
              return t2 >>> 0;
            };
          }, (e2, t2, r2) => {
            "use strict";
            const n = r2(96), s2 = r2(335), { extractICSS: i } = r2(340), o = (e3) => e3.type === "combinator" && e3.value === " ";
            function a(e3) {
              const t3 = [];
              return e3.forEach((e4) => {
                Array.isArray(e4) ? a(e4).forEach((e5) => {
                  t3.push(e5);
                }) : e4 && t3.push(e4);
              }), t3.length > 0 && o(t3[t3.length - 1]) && t3.pop(), t3;
            }
            function l(e3, t3) {
              switch (e3.type) {
                case "word":
                  t3.localizeNextItem && (t3.localAliasMap.has(e3.value) || (e3.value = ":local(" + e3.value + ")", t3.localizeNextItem = false));
                  break;
                case "function":
                  t3.options && t3.options.rewriteUrl && e3.value.toLowerCase() === "url" && e3.nodes.map((e4) => {
                    if (e4.type !== "string" && e4.type !== "word")
                      return;
                    let r3 = t3.options.rewriteUrl(t3.global, e4.value);
                    switch (e4.type) {
                      case "string":
                        e4.quote === "'" && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'")), e4.quote === '"' && (r3 = r3.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"'));
                        break;
                      case "word":
                        r3 = r3.replace(/("|'|\)|\\)/g, "\\$1");
                    }
                    e4.value = r3;
                  });
              }
              return e3;
            }
            function c(e3, t3, r3) {
              const n2 = s2(t3.value);
              n2.walk((t4, n3, s3) => {
                const i2 = { options: r3.options, global: r3.global, localizeNextItem: e3 && !r3.global, localAliasMap: r3.localAliasMap };
                s3[n3] = l(t4, i2);
              }), t3.value = n2.toString();
            }
            function u(e3, t3) {
              if (!/animation$/i.test(e3.prop))
                return /animation(-name)?$/i.test(e3.prop) ? c(true, e3, t3) : /url\(/i.test(e3.value) ? c(false, e3, t3) : void 0;
              {
                const r3 = /^-?[_a-z][_a-z0-9-]*$/i, n2 = { $alternate: 1, "$alternate-reverse": 1, $backwards: 1, $both: 1, $ease: 1, "$ease-in": 1, "$ease-in-out": 1, "$ease-out": 1, $forwards: 1, $infinite: 1, $linear: 1, $none: 1 / 0, $normal: 1, $paused: 1, $reverse: 1, $running: 1, "$step-end": 1, "$step-start": 1, $initial: 1 / 0, $inherit: 1 / 0, $unset: 1 / 0 }, i2 = false;
                let o2 = {}, a2 = null;
                const c4 = s2(e3.value).walk((e4) => {
                  e4.type === "div" && (o2 = {}), e4.type === "function" && e4.value.toLowerCase() === "steps" && (a2 = e4);
                  const s3 = e4.type !== "word" || (c5 = e4, (u2 = a2) && u2.nodes.some((e5) => e5.sourceIndex === c5.sourceIndex)) ? null : e4.value.toLowerCase();
                  var c5, u2;
                  let p2 = false;
                  return !i2 && s3 && r3.test(s3) && ("$" + s3 in n2 ? (o2["$" + s3] = "$" + s3 in o2 ? o2["$" + s3] + 1 : 0, p2 = o2["$" + s3] >= n2["$" + s3]) : p2 = true), l(e4, { options: t3.options, global: t3.global, localizeNextItem: p2 && !t3.global, localAliasMap: t3.localAliasMap });
                });
                e3.value = c4.toString();
              }
            }
            e2.exports = (e3 = {}) => {
              if (e3 && e3.mode && e3.mode !== "global" && e3.mode !== "local" && e3.mode !== "pure")
                throw new Error('options.mode must be either "global", "local" or "pure" (default "local")');
              const t3 = e3 && e3.mode === "pure", r3 = e3 && e3.mode === "global";
              return { postcssPlugin: "postcss-modules-local-by-default", prepare() {
                const s3 = new Map();
                return { Once(l2) {
                  const { icssImports: c4 } = i(l2, false);
                  Object.keys(c4).forEach((e4) => {
                    Object.keys(c4[e4]).forEach((t4) => {
                      s3.set(t4, c4[e4][t4]);
                    });
                  }), l2.walkAtRules((n2) => {
                    if (/keyframes$/i.test(n2.name)) {
                      const i2 = /^\s*:global\s*\((.+)\)\s*$/.exec(n2.params), o2 = /^\s*:local\s*\((.+)\)\s*$/.exec(n2.params);
                      let a2 = r3;
                      if (i2) {
                        if (t3)
                          throw n2.error("@keyframes :global(...) is not allowed in pure mode");
                        n2.params = i2[1], a2 = true;
                      } else
                        o2 ? (n2.params = o2[0], a2 = false) : r3 || n2.params && !s3.has(n2.params) && (n2.params = ":local(" + n2.params + ")");
                      n2.walkDecls((t4) => {
                        u(t4, { localAliasMap: s3, options: e3, global: a2 });
                      });
                    } else
                      n2.nodes && n2.nodes.forEach((t4) => {
                        t4.type === "decl" && u(t4, { localAliasMap: s3, options: e3, global: r3 });
                      });
                  }), l2.walkRules((r4) => {
                    if (r4.parent && r4.parent.type === "atrule" && /keyframes$/i.test(r4.parent.name))
                      return;
                    const i2 = function(e4, t4, r5) {
                      const s4 = (e5, t5) => {
                        if (t5.ignoreNextSpacing && !o(e5))
                          throw new Error("Missing whitespace after " + t5.ignoreNextSpacing);
                        if (t5.enforceNoSpacing && o(e5))
                          throw new Error("Missing whitespace before " + t5.enforceNoSpacing);
                        let i4;
                        switch (e5.type) {
                          case "root": {
                            let r6;
                            t5.hasPureGlobals = false, i4 = e5.nodes.map((n2) => {
                              const i5 = { global: t5.global, lastWasSpacing: true, hasLocals: false, explicit: false };
                              if (n2 = s4(n2, i5), r6 === void 0)
                                r6 = i5.global;
                              else if (r6 !== i5.global)
                                throw new Error('Inconsistent rule global/local result in rule "' + e5 + '" (multiple selectors must result in the same mode for the rule)');
                              return i5.hasLocals || (t5.hasPureGlobals = true), n2;
                            }), t5.global = r6, e5.nodes = a(i4);
                            break;
                          }
                          case "selector":
                            i4 = e5.map((e6) => s4(e6, t5)), (e5 = e5.clone()).nodes = a(i4);
                            break;
                          case "combinator":
                            if (o(e5))
                              return t5.ignoreNextSpacing ? (t5.ignoreNextSpacing = false, t5.lastWasSpacing = false, t5.enforceNoSpacing = false, null) : (t5.lastWasSpacing = true, e5);
                            break;
                          case "pseudo": {
                            let r6;
                            const o2 = !!e5.length, l3 = e5.value === ":local" || e5.value === ":global";
                            if (e5.value === ":import" || e5.value === ":export")
                              t5.hasLocals = true;
                            else {
                              if (o2) {
                                if (l3) {
                                  if (e5.nodes.length === 0)
                                    throw new Error(`${e5.value}() can't be empty`);
                                  if (t5.inside)
                                    throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                                  if (r6 = { global: e5.value === ":global", inside: e5.value, hasLocals: false, explicit: true }, i4 = e5.map((e6) => s4(e6, r6)).reduce((e6, t6) => e6.concat(t6.nodes), []), i4.length) {
                                    const { before: t6, after: r7 } = e5.spaces, n2 = i4[0], s5 = i4[i4.length - 1];
                                    n2.spaces = { before: t6, after: n2.spaces.after }, s5.spaces = { before: s5.spaces.before, after: r7 };
                                  }
                                  e5 = i4;
                                  break;
                                }
                                r6 = { global: t5.global, inside: t5.inside, lastWasSpacing: true, hasLocals: false, explicit: t5.explicit }, i4 = e5.map((e6) => s4(e6, r6)), (e5 = e5.clone()).nodes = a(i4), r6.hasLocals && (t5.hasLocals = true);
                                break;
                              }
                              if (l3) {
                                if (t5.inside)
                                  throw new Error(`A ${e5.value} is not allowed inside of a ${t5.inside}(...)`);
                                const r7 = !!e5.spaces.before;
                                return t5.ignoreNextSpacing = !!t5.lastWasSpacing && e5.value, t5.enforceNoSpacing = !t5.lastWasSpacing && e5.value, t5.global = e5.value === ":global", t5.explicit = true, r7 ? n.combinator({ value: " " }) : null;
                              }
                            }
                            break;
                          }
                          case "id":
                          case "class": {
                            if (!e5.value)
                              throw new Error("Invalid class or id selector syntax");
                            if (t5.global)
                              break;
                            const s5 = r5.has(e5.value), i5 = s5 && t5.explicit;
                            if (!s5 || i5) {
                              const r6 = e5.clone();
                              r6.spaces = { before: "", after: "" }, e5 = n.pseudo({ value: ":local", nodes: [r6], spaces: e5.spaces }), t5.hasLocals = true;
                            }
                            break;
                          }
                        }
                        return t5.lastWasSpacing = false, t5.ignoreNextSpacing = false, t5.enforceNoSpacing = false, e5;
                      }, i3 = { global: t4 === "global", hasPureGlobals: false };
                      return i3.selector = n((e5) => {
                        s4(e5, i3);
                      }).processSync(e4, { updateSelector: false, lossless: true }), i3;
                    }(r4, e3.mode, s3);
                    if (i2.options = e3, i2.localAliasMap = s3, t3 && i2.hasPureGlobals)
                      throw r4.error('Selector "' + r4.selector + '" is not pure (pure selectors must contain at least one local class or id)');
                    r4.selector = i2.selector, r4.nodes && r4.nodes.forEach((e4) => u(e4, i2));
                  });
                } };
              } };
            }, e2.exports.postcss = true;
          }, (e2, t2, r2) => {
            var n = r2(336), s2 = r2(337), i = r2(338);
            function o(e3) {
              return this instanceof o ? (this.nodes = n(e3), this) : new o(e3);
            }
            o.prototype.toString = function() {
              return Array.isArray(this.nodes) ? i(this.nodes) : "";
            }, o.prototype.walk = function(e3, t3) {
              return s2(this.nodes, e3, t3), this;
            }, o.unit = r2(339), o.walk = s2, o.stringify = i, e2.exports = o;
          }, (e2) => {
            var t2 = "(".charCodeAt(0), r2 = ")".charCodeAt(0), n = "'".charCodeAt(0), s2 = '"'.charCodeAt(0), i = "\\".charCodeAt(0), o = "/".charCodeAt(0), a = ",".charCodeAt(0), l = ":".charCodeAt(0), c = "*".charCodeAt(0), u = "u".charCodeAt(0), p2 = "U".charCodeAt(0), f = "+".charCodeAt(0), d = /^[a-f0-9?-]+$/i;
            e2.exports = function(e3) {
              for (var h3, m, y, g, b, v, E, x, S, T = [], w = e3, P = 0, A = w.charCodeAt(P), O = w.length, C = [{ nodes: T }], I = 0, k2 = "", N = "", _ = ""; P < O; )
                if (A <= 32) {
                  h3 = P;
                  do {
                    h3 += 1, A = w.charCodeAt(h3);
                  } while (A <= 32);
                  g = w.slice(P, h3), y = T[T.length - 1], A === r2 && I ? _ = g : y && y.type === "div" ? y.after = g : A === a || A === l || A === o && w.charCodeAt(h3 + 1) !== c && (!S || S && S.type === "function" && S.value !== "calc") ? N = g : T.push({ type: "space", sourceIndex: P, value: g }), P = h3;
                } else if (A === n || A === s2) {
                  h3 = P, g = { type: "string", sourceIndex: P, quote: m = A === n ? "'" : '"' };
                  do {
                    if (b = false, ~(h3 = w.indexOf(m, h3 + 1)))
                      for (v = h3; w.charCodeAt(v - 1) === i; )
                        v -= 1, b = !b;
                    else
                      h3 = (w += m).length - 1, g.unclosed = true;
                  } while (b);
                  g.value = w.slice(P + 1, h3), T.push(g), P = h3 + 1, A = w.charCodeAt(P);
                } else if (A === o && w.charCodeAt(P + 1) === c)
                  g = { type: "comment", sourceIndex: P }, (h3 = w.indexOf("*/", P)) === -1 && (g.unclosed = true, h3 = w.length), g.value = w.slice(P + 2, h3), T.push(g), P = h3 + 2, A = w.charCodeAt(P);
                else if (A !== o && A !== c || !S || S.type !== "function" || S.value !== "calc")
                  if (A === o || A === a || A === l)
                    g = w[P], T.push({ type: "div", sourceIndex: P - N.length, value: g, before: N, after: "" }), N = "", P += 1, A = w.charCodeAt(P);
                  else if (t2 === A) {
                    h3 = P;
                    do {
                      h3 += 1, A = w.charCodeAt(h3);
                    } while (A <= 32);
                    if (x = P, g = { type: "function", sourceIndex: P - k2.length, value: k2, before: w.slice(x + 1, h3) }, P = h3, k2 === "url" && A !== n && A !== s2) {
                      h3 -= 1;
                      do {
                        if (b = false, ~(h3 = w.indexOf(")", h3 + 1)))
                          for (v = h3; w.charCodeAt(v - 1) === i; )
                            v -= 1, b = !b;
                        else
                          h3 = (w += ")").length - 1, g.unclosed = true;
                      } while (b);
                      E = h3;
                      do {
                        E -= 1, A = w.charCodeAt(E);
                      } while (A <= 32);
                      x < E ? (g.nodes = P !== E + 1 ? [{ type: "word", sourceIndex: P, value: w.slice(P, E + 1) }] : [], g.unclosed && E + 1 !== h3 ? (g.after = "", g.nodes.push({ type: "space", sourceIndex: E + 1, value: w.slice(E + 1, h3) })) : g.after = w.slice(E + 1, h3)) : (g.after = "", g.nodes = []), P = h3 + 1, A = w.charCodeAt(P), T.push(g);
                    } else
                      I += 1, g.after = "", T.push(g), C.push(g), T = g.nodes = [], S = g;
                    k2 = "";
                  } else if (r2 === A && I)
                    P += 1, A = w.charCodeAt(P), S.after = _, _ = "", I -= 1, C.pop(), T = (S = C[I]).nodes;
                  else {
                    h3 = P;
                    do {
                      A === i && (h3 += 1), h3 += 1, A = w.charCodeAt(h3);
                    } while (h3 < O && !(A <= 32 || A === n || A === s2 || A === a || A === l || A === o || A === t2 || A === c && S && S.type === "function" && S.value === "calc" || A === o && S.type === "function" && S.value === "calc" || A === r2 && I));
                    g = w.slice(P, h3), t2 === A ? k2 = g : u !== g.charCodeAt(0) && p2 !== g.charCodeAt(0) || f !== g.charCodeAt(1) || !d.test(g.slice(2)) ? T.push({ type: "word", sourceIndex: P, value: g }) : T.push({ type: "unicode-range", sourceIndex: P, value: g }), P = h3;
                  }
                else
                  g = w[P], T.push({ type: "word", sourceIndex: P - N.length, value: g }), P += 1, A = w.charCodeAt(P);
              for (P = C.length - 1; P; P -= 1)
                C[P].unclosed = true;
              return C[0].nodes;
            };
          }, (e2) => {
            e2.exports = function e3(t2, r2, n) {
              var s2, i, o, a;
              for (s2 = 0, i = t2.length; s2 < i; s2 += 1)
                o = t2[s2], n || (a = r2(o, s2, t2)), a !== false && o.type === "function" && Array.isArray(o.nodes) && e3(o.nodes, r2, n), n && r2(o, s2, t2);
            };
          }, (e2) => {
            function t2(e3, t3) {
              var n, s2, i = e3.type, o = e3.value;
              return t3 && (s2 = t3(e3)) !== void 0 ? s2 : i === "word" || i === "space" ? o : i === "string" ? (n = e3.quote || "") + o + (e3.unclosed ? "" : n) : i === "comment" ? "/*" + o + (e3.unclosed ? "" : "*/") : i === "div" ? (e3.before || "") + o + (e3.after || "") : Array.isArray(e3.nodes) ? (n = r2(e3.nodes, t3), i !== "function" ? n : o + "(" + (e3.before || "") + n + (e3.after || "") + (e3.unclosed ? "" : ")")) : o;
            }
            function r2(e3, r3) {
              var n, s2;
              if (Array.isArray(e3)) {
                for (n = "", s2 = e3.length - 1; ~s2; s2 -= 1)
                  n = t2(e3[s2], r3) + n;
                return n;
              }
              return t2(e3, r3);
            }
            e2.exports = r2;
          }, (e2) => {
            var t2 = "-".charCodeAt(0), r2 = "+".charCodeAt(0), n = ".".charCodeAt(0), s2 = "e".charCodeAt(0), i = "E".charCodeAt(0);
            e2.exports = function(e3) {
              var o, a, l, c = 0, u = e3.length;
              if (u === 0 || !function(e4) {
                var s3, i2 = e4.charCodeAt(0);
                if (i2 === r2 || i2 === t2) {
                  if ((s3 = e4.charCodeAt(1)) >= 48 && s3 <= 57)
                    return true;
                  var o2 = e4.charCodeAt(2);
                  return s3 === n && o2 >= 48 && o2 <= 57;
                }
                return i2 === n ? (s3 = e4.charCodeAt(1)) >= 48 && s3 <= 57 : i2 >= 48 && i2 <= 57;
              }(e3))
                return false;
              for ((o = e3.charCodeAt(c)) !== r2 && o !== t2 || c++; c < u && !((o = e3.charCodeAt(c)) < 48 || o > 57); )
                c += 1;
              if (o = e3.charCodeAt(c), a = e3.charCodeAt(c + 1), o === n && a >= 48 && a <= 57)
                for (c += 2; c < u && !((o = e3.charCodeAt(c)) < 48 || o > 57); )
                  c += 1;
              if (o = e3.charCodeAt(c), a = e3.charCodeAt(c + 1), l = e3.charCodeAt(c + 2), (o === s2 || o === i) && (a >= 48 && a <= 57 || (a === r2 || a === t2) && l >= 48 && l <= 57))
                for (c += a === r2 || a === t2 ? 3 : 2; c < u && !((o = e3.charCodeAt(c)) < 48 || o > 57); )
                  c += 1;
              return { number: e3.slice(0, c), unit: e3.slice(c) };
            };
          }, (e2, t2, r2) => {
            const n = r2(164), s2 = r2(341), i = r2(342), o = r2(343);
            e2.exports = { replaceValueSymbols: n, replaceSymbols: s2, extractICSS: i, createICSSRules: o };
          }, (e2, t2, r2) => {
            const n = r2(164);
            e2.exports = (e3, t3) => {
              e3.walk((e4) => {
                e4.type === "decl" && e4.value ? e4.value = n(e4.value.toString(), t3) : e4.type === "rule" && e4.selector ? e4.selector = n(e4.selector.toString(), t3) : e4.type === "atrule" && e4.params && (e4.params = n(e4.params.toString(), t3));
              });
            };
          }, (e2) => {
            const t2 = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/, r2 = /^("[^"]*"|'[^']*'|[^"']+)$/, n = (e3) => {
              const t3 = {};
              return e3.walkDecls((e4) => {
                const r3 = e4.raws.before ? e4.raws.before.trim() : "";
                t3[r3 + e4.prop] = e4.value;
              }), t3;
            };
            e2.exports = (e3, s2 = true, i = "auto") => {
              const o = {}, a = {};
              function l(e4, t3) {
                const r3 = t3.replace(/'|"/g, "");
                o[r3] = Object.assign(o[r3] || {}, n(e4)), s2 && e4.remove();
              }
              function c(e4) {
                Object.assign(a, n(e4)), s2 && e4.remove();
              }
              return e3.each((e4) => {
                if (e4.type === "rule" && i !== "at-rule") {
                  if (e4.selector.slice(0, 7) === ":import") {
                    const r3 = t2.exec(e4.selector);
                    r3 && l(e4, r3[1]);
                  }
                  e4.selector === ":export" && c(e4);
                }
                if (e4.type === "atrule" && i !== "rule") {
                  if (e4.name === "icss-import") {
                    const t3 = r2.exec(e4.params);
                    t3 && l(e4, t3[1]);
                  }
                  e4.name === "icss-export" && c(e4);
                }
              }), { icssImports: o, icssExports: a };
            };
          }, (e2) => {
            const t2 = (e3, t3, r3 = "rule") => Object.keys(e3).map((n) => {
              const s2 = e3[n], i = Object.keys(s2).map((e4) => t3.decl({ prop: e4, value: s2[e4], raws: { before: "\n  " } })), o = i.length > 0, a = r3 === "rule" ? t3.rule({ selector: `:import('${n}')`, raws: { after: o ? "\n" : "" } }) : t3.atRule({ name: "icss-import", params: `'${n}'`, raws: { after: o ? "\n" : "" } });
              return o && a.append(i), a;
            }), r2 = (e3, t3, r3 = "rule") => {
              const n = Object.keys(e3).map((r4) => t3.decl({ prop: r4, value: e3[r4], raws: { before: "\n  " } }));
              if (n.length === 0)
                return [];
              const s2 = r3 === "rule" ? t3.rule({ selector: ":export", raws: { after: "\n" } }) : t3.atRule({ name: "icss-export", raws: { after: "\n" } });
              return s2.append(n), [s2];
            };
            e2.exports = (e3, n, s2, i) => [...t2(e3, s2, i), ...r2(n, s2, i)];
          }, (e2, t2, r2) => {
            const n = r2(345), s2 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/, i = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
            function o(e3, t3, r3, n2) {
              const s3 = t3 + "_siblings", i2 = t3 + "_" + e3;
              if (n2[i2] !== 1) {
                Array.isArray(n2[s3]) || (n2[s3] = []);
                const t4 = n2[s3];
                Array.isArray(r3[e3]) ? r3[e3] = r3[e3].concat(t4) : r3[e3] = t4.slice(), n2[i2] = 1, t4.push(e3);
              }
            }
            e2.exports = (e3 = {}) => {
              let t3 = 0;
              const r3 = typeof e3.createImportedName != "function" ? (e4) => `i__imported_${e4.replace(/\W/g, "_")}_${t3++}` : e3.createImportedName, a = e3.failOnWrongOrder;
              return { postcssPlugin: "postcss-modules-extract-imports", prepare() {
                const e4 = {}, t4 = {}, l = {}, c = {}, u = {};
                return { Once(p2, f) {
                  p2.walkRules((r4) => {
                    const n2 = i.exec(r4.selector);
                    if (n2) {
                      const [, s3, i2] = n2, a2 = s3 || i2;
                      o(a2, "root", e4, t4), l[a2] = r4;
                    }
                  }), p2.walkDecls(/^composes$/, (n2) => {
                    const i2 = n2.value.match(s2);
                    if (!i2)
                      return;
                    let a2, [, l2, p3, f2, d2] = i2;
                    if (d2)
                      a2 = l2.split(/\s+/).map((e5) => `global(${e5})`);
                    else {
                      const s3 = p3 || f2;
                      let i3 = n2.parent, d3 = "";
                      for (; i3.type !== "root"; )
                        d3 = i3.parent.index(i3) + "_" + d3, i3 = i3.parent;
                      const { selector: h4 } = n2.parent;
                      o(s3, `_${d3}${h4}`, e4, t4), c[s3] = n2, u[s3] = u[s3] || {}, a2 = l2.split(/\s+/).map((e5) => (u[s3][e5] || (u[s3][e5] = r3(e5, s3)), u[s3][e5]));
                    }
                    n2.value = a2.join(" ");
                  });
                  const d = n(e4, a);
                  if (d instanceof Error) {
                    const e5 = d.nodes.find((e6) => c.hasOwnProperty(e6));
                    throw c[e5].error("Failed to resolve order of composed modules " + d.nodes.map((e6) => "`" + e6 + "`").join(", ") + ".", { plugin: "postcss-modules-extract-imports", word: "composes" });
                  }
                  let h3;
                  d.forEach((e5) => {
                    const t5 = u[e5];
                    let r4 = l[e5];
                    !r4 && t5 && (r4 = f.rule({ selector: `:import("${e5}")`, raws: { after: "\n" } }), h3 ? p2.insertAfter(h3, r4) : p2.prepend(r4)), h3 = r4, t5 && Object.keys(t5).forEach((e6) => {
                      r4.append(f.decl({ value: e6, prop: t5[e6], raws: { before: "\n  " } }));
                    });
                  });
                } };
              } };
            }, e2.exports.postcss = true;
          }, (e2) => {
            function t2(e3, r2, n, s2, i) {
              if (n[e3] === 2)
                return;
              if (n[e3] === 1)
                return i ? function(e4, t3) {
                  const r3 = new Error("Nondeterministic import's order"), n2 = t3[e4].find((r4) => t3[r4].indexOf(e4) > -1);
                  return r3.nodes = [e4, n2], r3;
                }(e3, r2) : void 0;
              n[e3] = 1;
              const o = r2[e3], a = o.length;
              for (let e4 = 0; e4 < a; ++e4) {
                const a2 = t2(o[e4], r2, n, s2, i);
                if (a2 instanceof Error)
                  return a2;
              }
              n[e3] = 2, s2.push(e3);
            }
            e2.exports = function(e3, r2) {
              const n = [], s2 = {}, i = Object.keys(e3), o = i.length;
              for (let a = 0; a < o; ++a) {
                const o2 = t2(i[a], e3, s2, n, r2);
                if (o2 instanceof Error)
                  return o2;
              }
              return n;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(536), i = r2(93);
            function o(e3, t3) {
              let r3, n2 = 1;
              do {
                r3 = e3._generateUid("", n2), n2++;
              } while (t3.has(r3));
              return r3;
            }
            var a = (0, n.declare)(({ types: e3, template: t3, assertVersion: r3 }) => (r3("^7.12.0"), { name: "proposal-class-static-block", inherits: s2.default, pre() {
              (0, i.enableFeature)(this.file, i.FEATURES.staticBlocks, false);
            }, visitor: { ClassBody(r4) {
              const { scope: n2 } = r4, s3 = new Set(), i2 = r4.get("body");
              for (const e4 of i2)
                e4.isPrivate() && s3.add(e4.get("key.id").node.name);
              for (const r5 of i2) {
                if (!r5.isStaticBlock())
                  continue;
                const i3 = o(n2, s3);
                s3.add(i3);
                const a2 = e3.privateName(e3.identifier(i3));
                r5.replaceWith(e3.classPrivateProperty(a2, t3.expression.ast`(() => { ${r5.node.body} })()`, [], true));
              }
            } } }));
            t2.default = a;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = e3.node || e3;
              (({ leadingComments: e4 }) => !!e4 && e4.some((e5) => /[@#]__PURE__/.test(e5.value)))(t3) || n.addComment(t3, "leading", "#__PURE__");
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(541), i = r2(93), o = r2(347), a = (0, n.declare)(({ assertVersion: e3, types: t3, template: r3 }, { loose: n2 }) => {
              e3(7);
              const a2 = new WeakMap();
              function l(e4, r4, n3 = false) {
                e4.node.value ? n3 ? e4.get("value").insertBefore(r4) : e4.get("value").insertAfter(r4) : e4.set("value", t3.unaryExpression("void", r4));
              }
              function c(e4, r4) {
                let n3, s3;
                for (const t4 of e4.get("body.body")) {
                  if ((t4.isClassProperty() || t4.isClassPrivateProperty()) && !t4.node.static) {
                    n3 = t4;
                    break;
                  }
                  !s3 && t4.isClassMethod({ kind: "constructor" }) && (s3 = t4);
                }
                n3 ? l(n3, r4, true) : (0, i.injectInitialization)(e4, s3, [t3.expressionStatement(r4)]);
              }
              function u(e4, n3, s3, i2 = "", l2) {
                let c4 = a2.get(s3.node);
                if (!c4) {
                  c4 = n3.scope.generateUidIdentifier(`${i2 || ""} brandCheck`), a2.set(s3.node, c4), l2(s3, r3.expression.ast`${t3.cloneNode(c4)}.add(this)`);
                  const e5 = t3.newExpression(t3.identifier("WeakSet"), []);
                  (0, o.default)(e5), n3.insertBefore(r3.ast`var ${c4} = ${e5}`);
                }
                return t3.cloneNode(c4);
              }
              return new WeakMap(), { name: "proposal-private-property-in-object", inherits: s2.default, pre() {
                (0, i.enableFeature)(this.file, i.FEATURES.privateIn, n2);
              }, visitor: { BinaryExpression(e4) {
                const { node: n3 } = e4;
                if (n3.operator !== "in")
                  return;
                if (!t3.isPrivateName(n3.left))
                  return;
                const { name: s3 } = n3.left.id;
                let i2;
                const o2 = e4.findParent((e5) => !!e5.isClass() && (i2 = e5.get("body.body").find(({ node: e6 }) => t3.isPrivate(e6) && e6.key.id.name === s3), !!i2));
                if (o2.parentPath.scope.path.isPattern())
                  o2.replaceWith(r3.ast`(() => ${o2.node})()`);
                else if (i2.isMethod())
                  if (i2.node.static)
                    o2.node.id ? function(e5, t4, r4) {
                      for (; r4 !== t4; )
                        r4.hasOwnBinding(e5) && r4.rename(e5), r4 = r4.parent;
                    }(o2.node.id.name, o2.scope, e4.scope) : o2.set("id", e4.scope.generateUidIdentifier("class")), e4.replaceWith(r3.expression.ast`
                ${t3.cloneNode(o2.node.id)} === ${e4.node.right}
              `);
                  else {
                    var a3;
                    const t4 = u(0, o2, o2, (a3 = o2.node.id) == null ? void 0 : a3.name, c);
                    e4.replaceWith(r3.expression.ast`${t4}.has(${e4.node.right})`);
                  }
                else {
                  const t4 = u(0, o2, i2, i2.node.key.id.name, l);
                  e4.replaceWith(r3.expression.ast`${t4}.has(${e4.node.right})`);
                }
              } } };
            });
            t2.default = a;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(93), i = (0, n.declare)((e3, t3) => (e3.assertVersion(7), (0, s2.createClassFeaturePlugin)({ name: "proposal-class-properties", api: e3, feature: s2.FEATURES.fields, loose: t3.loose, manipulateOptions(e4, t4) {
              t4.plugins.push("classProperties", "classPrivateProperties");
            } })));
            t2.default = i;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(93), i = (0, n.declare)((e3, t3) => (e3.assertVersion(7), (0, s2.createClassFeaturePlugin)({ name: "proposal-private-methods", api: e3, feature: s2.FEATURES.privateMethods, loose: t3.loose, manipulateOptions(e4, t4) {
              t4.plugins.push("classPrivateMethods");
            } })));
            t2.default = i;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(542), i = r2(9), o = (0, n.declare)((e3) => (e3.assertVersion(7), { name: "proposal-logical-assignment-operators", inherits: s2.default, visitor: { AssignmentExpression(e4) {
              const { node: t3, scope: r3 } = e4, { operator: n2, left: s3, right: o2 } = t3, a = n2.slice(0, -1);
              if (!i.types.LOGICAL_OPERATORS.includes(a))
                return;
              const l = i.types.cloneNode(s3);
              if (i.types.isMemberExpression(s3)) {
                const { object: e5, property: t4, computed: n3 } = s3, o3 = r3.maybeGenerateMemoised(e5);
                if (o3 && (s3.object = o3, l.object = i.types.assignmentExpression("=", i.types.cloneNode(o3), e5)), n3) {
                  const e6 = r3.maybeGenerateMemoised(t4);
                  e6 && (s3.property = e6, l.property = i.types.assignmentExpression("=", i.types.cloneNode(e6), t4));
                }
              }
              e4.replaceWith(i.types.logicalExpression(a, l, i.types.assignmentExpression("=", s3, o2)));
            } } }));
            t2.default = o;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(543), i = r2(9), o = (0, n.declare)((e3, { loose: t3 = false }) => {
              var r3;
              e3.assertVersion(7);
              const n2 = (r3 = e3.assumption("noDocumentAll")) != null ? r3 : t3;
              return { name: "proposal-nullish-coalescing-operator", inherits: s2.default, visitor: { LogicalExpression(e4) {
                const { node: t4, scope: r4 } = e4;
                if (t4.operator !== "??")
                  return;
                let s3, o2;
                if (r4.isStatic(t4.left))
                  s3 = t4.left, o2 = i.types.cloneNode(t4.left);
                else {
                  if (r4.path.isPattern())
                    return void e4.replaceWith(i.template.ast`(() => ${e4.node})()`);
                  s3 = r4.generateUidIdentifierBasedOnNode(t4.left), r4.push({ id: i.types.cloneNode(s3) }), o2 = i.types.assignmentExpression("=", s3, t4.left);
                }
                e4.replaceWith(i.types.conditionalExpression(n2 ? i.types.binaryExpression("!=", o2, i.types.nullLiteral()) : i.types.logicalExpression("&&", i.types.binaryExpression("!==", o2, i.types.nullLiteral()), i.types.binaryExpression("!==", i.types.cloneNode(s3), r4.buildUndefinedNode())), i.types.cloneNode(s3), t4.right));
              } } };
            });
            t2.default = o;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = r2(4), s2 = r2(544), i = r2(9), o = r2(545);
            function a(e3) {
              return e3 && typeof e3 == "object" && "default" in e3 ? e3 : { default: e3 };
            }
            var l = a(s2);
            function c(e3) {
              const t3 = u(e3), { node: r3, parentPath: n2 } = t3;
              if (n2.isLogicalExpression()) {
                const { operator: e4, right: t4 } = n2.node;
                if (e4 === "&&" || e4 === "||" || e4 === "??" && r3 === t4)
                  return c(n2);
              }
              if (n2.isSequenceExpression()) {
                const { expressions: e4 } = n2.node;
                return e4[e4.length - 1] !== r3 || c(n2);
              }
              return n2.isConditional({ test: r3 }) || n2.isUnaryExpression({ operator: "!" }) || n2.isLoop({ test: r3 });
            }
            function u(e3) {
              let t3 = e3;
              return e3.findParent((e4) => {
                if (!o.isTransparentExprWrapper(e4))
                  return true;
                t3 = e4;
              }), t3;
            }
            const { ast: p2 } = i.template.expression;
            function f(e3) {
              return e3 = o.skipTransparentExprWrappers(e3), i.types.isIdentifier(e3) || i.types.isSuper(e3) || i.types.isMemberExpression(e3) && !e3.computed && f(e3.object);
            }
            function d(e3, { pureGetters: t3, noDocumentAll: r3 }) {
              const { scope: n2 } = e3, s3 = u(e3), { parentPath: a2 } = s3, l2 = c(s3);
              let d2 = false;
              const h4 = a2.isCallExpression({ callee: s3.node }) && e3.isOptionalMemberExpression(), m = [];
              let y = e3;
              if (n2.path.isPattern() && function(e4) {
                let t4 = e4;
                const { scope: r4 } = e4;
                for (; t4.isOptionalMemberExpression() || t4.isOptionalCallExpression(); ) {
                  const { node: e5 } = t4, n3 = t4.isOptionalMemberExpression() ? "object" : "callee", s4 = o.skipTransparentExprWrappers(t4.get(n3));
                  if (e5.optional)
                    return !r4.isStatic(s4.node);
                  t4 = s4;
                }
              }(y))
                return void e3.replaceWith(i.template.ast`(() => ${e3.node})()`);
              for (; y.isOptionalMemberExpression() || y.isOptionalCallExpression(); ) {
                const { node: e4 } = y;
                e4.optional && m.push(e4), y.isOptionalMemberExpression() ? (y.node.type = "MemberExpression", y = o.skipTransparentExprWrappers(y.get("object"))) : y.isOptionalCallExpression() && (y.node.type = "CallExpression", y = o.skipTransparentExprWrappers(y.get("callee")));
              }
              let g = e3;
              a2.isUnaryExpression({ operator: "delete" }) && (g = a2, d2 = true);
              for (let e4 = m.length - 1; e4 >= 0; e4--) {
                const s4 = m[e4], a3 = i.types.isCallExpression(s4), c4 = a3 ? "callee" : "object", u2 = s4[c4];
                let y2, v, E = u2;
                for (; o.isTransparentExprWrapper(E); )
                  E = E.expression;
                if (a3 && i.types.isIdentifier(E, { name: "eval" }) ? (v = y2 = E, s4[c4] = i.types.sequenceExpression([i.types.numericLiteral(0), y2])) : t3 && a3 && f(E) ? v = y2 = u2 : (y2 = n2.maybeGenerateMemoised(E), y2 ? (v = i.types.assignmentExpression("=", i.types.cloneNode(y2), u2), s4[c4] = y2) : v = y2 = u2), a3 && i.types.isMemberExpression(E))
                  if (t3 && f(E))
                    s4.callee = u2;
                  else {
                    const { object: e5 } = E;
                    let t4 = n2.maybeGenerateMemoised(e5);
                    t4 ? E.object = i.types.assignmentExpression("=", t4, e5) : t4 = i.types.isSuper(e5) ? i.types.thisExpression() : e5, s4.arguments.unshift(i.types.cloneNode(t4)), s4.callee = i.types.memberExpression(s4.callee, i.types.identifier("call"));
                  }
                let x = g.node;
                if (e4 === 0 && h4) {
                  var b;
                  const e5 = o.skipTransparentExprWrappers(g.get("object")).node;
                  let r4;
                  t3 && f(e5) || (r4 = n2.maybeGenerateMemoised(e5), r4 && (x.object = i.types.assignmentExpression("=", r4, e5))), x = i.types.callExpression(i.types.memberExpression(x, i.types.identifier("bind")), [i.types.cloneNode((b = r4) != null ? b : e5)]);
                }
                if (l2) {
                  const e5 = r3 ? p2`${i.types.cloneNode(v)} != null` : p2`
            ${i.types.cloneNode(v)} !== null && ${i.types.cloneNode(y2)} !== void 0`;
                  g.replaceWith(i.types.logicalExpression("&&", e5, x)), g = o.skipTransparentExprWrappers(g.get("right"));
                } else {
                  const e5 = r3 ? p2`${i.types.cloneNode(v)} == null` : p2`
            ${i.types.cloneNode(v)} === null || ${i.types.cloneNode(y2)} === void 0`, t4 = d2 ? p2`true` : p2`void 0`;
                  g.replaceWith(i.types.conditionalExpression(e5, t4, x)), g = o.skipTransparentExprWrappers(g.get("alternate"));
                }
              }
            }
            var h3 = n.declare((e3, t3) => {
              var r3, n2;
              e3.assertVersion(7);
              const { loose: s3 = false } = t3, i2 = (r3 = e3.assumption("noDocumentAll")) != null ? r3 : s3, o2 = (n2 = e3.assumption("pureGetters")) != null ? n2 : s3;
              return { name: "proposal-optional-chaining", inherits: l.default.default, visitor: { "OptionalCallExpression|OptionalMemberExpression"(e4) {
                d(e4, { noDocumentAll: i2, pureGetters: o2 });
              } } };
            });
            t2.default = h3, t2.transform = d;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(4), s2 = r2(546), i = r2(9), o = (0, n.declare)((e3) => (e3.assertVersion(7), { name: "proposal-export-namespace-from", inherits: s2.default, visitor: { ExportNamedDeclaration(e4) {
              var t3;
              const { node: r3, scope: n2 } = e4, { specifiers: s3 } = r3, o2 = i.types.isExportDefaultSpecifier(s3[0]) ? 1 : 0;
              if (!i.types.isExportNamespaceSpecifier(s3[o2]))
                return;
              const a = [];
              o2 === 1 && a.push(i.types.exportNamedDeclaration(null, [s3.shift()], r3.source));
              const l = s3.shift(), { exported: c } = l, u = n2.generateUidIdentifier((t3 = c.name) != null ? t3 : c.value);
              a.push(i.types.importDeclaration([i.types.importNamespaceSpecifier(u)], i.types.cloneNode(r3.source)), i.types.exportNamedDeclaration(null, [i.types.exportSpecifier(i.types.cloneNode(u), c)])), r3.specifiers.length >= 1 && a.push(r3);
              const [p2] = e4.replaceWithMultiple(a);
              e4.scope.registerDeclaration(p2);
            } } }));
            t2.default = o;
          }, (e2, t2, r2) => {
            "use strict";
            if (r2(356), r2(357), !("sticky" in r2.g.RegExp.prototype)) {
              let n = function(t4, r3) {
                const n2 = r3 != null ? r3.indexOf("y") : -1, s2 = new e3(t4, n2 === -1 ? r3 : r3.slice(0, n2) + r3.slice(n2 + 1) + (r3.indexOf("g") === -1 ? "g" : ""));
                return s2._sticky = n2 !== -1, s2;
              };
              const e3 = r2.g.RegExp, t3 = e3.prototype.exec;
              e3.prototype.exec = function(e4) {
                const r3 = this.lastIndex, n2 = t3.call(this, e4);
                return this._sticky && n2 != null && this.lastIndex - n2[0].length !== r3 ? (this.lastIndex = 0, null) : n2;
              }, e3.prototype.test = function(e4) {
                return !!this.exec(e4);
              }, n.prototype = e3.prototype, r2.g.RegExp = n;
            }
            for (let e3 of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"])
              r2.g[e3] && !(Symbol.toStringTag in r2.g[e3].prototype) && Object.defineProperty(r2.g[e3].prototype, Symbol.toStringTag, { value: e3 });
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(179), s2 = r2(2), i = r2(16), o = r2(123), a = r2(124), l = r2(192), c = r2(193), u = r2(194), p2 = r2(118), f = r2(195), d = n.aTypedArray, h3 = n.exportTypedArrayMethod, m = s2.Uint16Array, y = m && m.prototype.sort, g = !!y && !i(function() {
              var e3 = new m(2);
              e3.sort(null), e3.sort({});
            }), b = !!y && !i(function() {
              if (p2)
                return p2 < 74;
              if (c)
                return c < 67;
              if (u)
                return true;
              if (f)
                return f < 602;
              var e3, t3, r3 = new m(516), n2 = Array(516);
              for (e3 = 0; e3 < 516; e3++)
                t3 = e3 % 4, r3[e3] = 515 - e3, n2[e3] = e3 - 2 * t3 + 3;
              for (r3.sort(function(e4, t4) {
                return (e4 / 4 | 0) - (t4 / 4 | 0);
              }), e3 = 0; e3 < 516; e3++)
                if (r3[e3] !== n2[e3])
                  return true;
            });
            h3("sort", function(e3) {
              var t3 = this;
              if (e3 !== void 0 && o(e3), b)
                return y.call(t3, e3);
              d(t3);
              var r3, n2 = a(t3.length), s3 = Array(n2);
              for (r3 = 0; r3 < n2; r3++)
                s3[r3] = t3[r3];
              for (s3 = l(t3, function(e4) {
                return function(t4, r4) {
                  return e4 !== void 0 ? +e4(t4, r4) || 0 : r4 != r4 ? -1 : t4 != t4 ? 1 : t4 === 0 && r4 === 0 ? 1 / t4 > 0 && 1 / r4 < 0 ? 1 : -1 : t4 > r4;
                };
              }(e3)), r3 = 0; r3 < n2; r3++)
                t3[r3] = s3[r3];
              return t3;
            }, !b || g);
          }, (e2, t2, r2) => {
            var n = r2(196), s2 = r2(2), i = r2(206);
            n({ global: true, bind: true, enumerable: true, forced: !s2.setImmediate || !s2.clearImmediate }, { setImmediate: i.set, clearImmediate: i.clear });
          }, (e2, t2) => {
            "use strict";
            var r2 = {}.propertyIsEnumerable, n = Object.getOwnPropertyDescriptor, s2 = n && !r2.call({ 1: 2 }, 1);
            t2.f = s2 ? function(e3) {
              var t3 = n(this, e3);
              return !!t3 && t3.enumerable;
            } : r2;
          }, (e2, t2, r2) => {
            var n = r2(201), s2 = r2(204).concat("length", "prototype");
            t2.f = Object.getOwnPropertyNames || function(e3) {
              return n(e3, s2);
            };
          }, (e2, t2) => {
            t2.f = Object.getOwnPropertySymbols;
          }, (e2, t2, r2) => {
            "use strict";
            r2.r(t2), r2.d(t2, { buildTemplateProcessor: () => D, createCJSModule: () => A, loadModule: () => j, version: () => I, vueVersion: () => m.a });
            var n = r2(8), s2 = r2(9), i = r2(27), o = r2(39), a = r2(501), l = r2(313), c = r2(504), u = r2(83), p2 = r2(505), f = r2(314), d = r2(18), h3 = r2.n(d);
            const m = { a: "3.1.4" }, y = E(...Object.keys({ "proposal-class-static-block": r2(346), "proposal-private-property-in-object": r2(348), "proposal-class-properties": r2(349), "proposal-private-methods": r2(350), "proposal-logical-assignment-operators": r2(351), "proposal-nullish-coalescing-operator": r2(352), "proposal-optional-chaining": r2(353), "proposal-export-namespace-from": r2(354) })), g = true;
            function b(e3, t3, r3) {
              return t3 + "\n" + e3;
            }
            function v(e3, t3, r3, n2, s3) {
              if (!n2)
                return b(e3, t3);
              const i2 = { start: { line: n2, column: s3 } };
              return b((0, o.codeFrameColumns)(r3, i2, { message: e3 }), t3);
            }
            function E(...e3) {
              return e3.reduce((e4, t3) => e4.append(String(t3)), new l()).end().slice(0, 8);
            }
            async function x(e3, t3, r3) {
              let n2 = false;
              const s3 = { preventCache: () => n2 = true };
              if (!e3)
                return await r3(s3);
              const i2 = E(...t3), o2 = await e3.get(i2);
              if (o2)
                return JSON.parse(o2);
              const a2 = await r3(s3);
              return n2 || await e3.set(i2, JSON.stringify(a2)), a2;
            }
            class S {
              constructor(e3) {
                var t3, r3;
                r3 = void 0, (t3 = "promise") in this ? Object.defineProperty(this, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : this[t3] = r3, this.promise = e3;
              }
            }
            const T = { "proposal-class-static-block": r2(346), "proposal-private-property-in-object": r2(348), "proposal-class-properties": r2(349), "proposal-private-methods": r2(350), "proposal-logical-assignment-operators": r2(351), "proposal-nullish-coalescing-operator": r2(352), "proposal-optional-chaining": r2(353), "proposal-export-namespace-from": r2(354) };
            async function w(e3, t3, r3, n2, o2, l2) {
              let c4;
              try {
                c4 = (0, i.parse)(e3, { sourceType: t3 ? "module" : "script", sourceFilename: r3.toString(), plugins: [...n2 !== void 0 ? n2 : []] });
              } catch (t4) {
                throw l2 == null || l2("error", "parse script", v(t4.message, r3.toString(), e3, t4.loc.line, t4.loc.column + 1)), t4;
              }
              var u2;
              return u2 = c4, (0, s2.traverse)(u2, { CallExpression(e4) {
                s2.types.isImport(e4.node.callee) && e4.replaceWith(s2.types.callExpression(s2.types.identifier("import__"), e4.node.arguments));
              } }), [function(e4) {
                const t4 = [];
                return (0, s2.traverse)(e4, { ImportDeclaration(e5) {
                  t4.push(e5.node.source.value);
                }, CallExpression(e5) {
                  e5.node.callee.name === "require" && e5.node.arguments.length === 1 && s2.types.isStringLiteral(e5.node.arguments[0]) && t4.push(e5.node.arguments[0].value);
                } }), t4;
              }(c4), (await (0, s2.transformFromAstAsync)(c4, e3, { sourceMaps: false, plugins: [...t3 ? [a.a] : [], ...Object.values(T), ...o2 !== void 0 ? Object.values(o2) : []], babelrc: false, configFile: false, highlightCode: false, compact: true, comments: false })).code];
            }
            async function P(e3, t3) {
              const { moduleCache: r3, loadModule: n2, handleModule: s3 } = t3, { id: i2, path: o2, getContent: a2 } = t3.getResource(e3, t3);
              return i2 in r3 ? r3[i2] instanceof S ? await r3[i2].promise : r3[i2] : (r3[i2] = new S((async () => {
                if (n2) {
                  const e5 = await n2(i2, t3);
                  if (e5 !== void 0)
                    return r3[i2] = e5;
                }
                const { getContentData: e4, type: l2 } = await a2();
                let d2;
                if (s3 !== void 0 && (d2 = await s3(l2, e4, o2, t3)), d2 === void 0 && (d2 = await async function(e5, t4, r4, n3) {
                  switch (e5) {
                    case ".vue":
                      return async function(e6, t5, r5) {
                        const n4 = t5.toString(), s4 = {}, { delimiters: i3, moduleCache: o3, compiledCache: a3, getResource: l3, addStyle: d3, log: m2, additionalBabelParserPlugins: S2 = [], additionalBabelPlugins: T2 = {}, customBlockHandler: O2 } = r5, { descriptor: I2, errors: k3 } = (0, c.d)(e6, { filename: n4, sourceMap: false }), N2 = O2 !== void 0 ? await Promise.all(I2.customBlocks.map((e7) => O2(e7, t5, r5))) : [], _2 = E(n4, "0.8.4", y), j2 = `data-v-${_2}`, D2 = I2.styles.some((e7) => e7.scoped);
                        D2 && (s4.__scopeId = j2), I2.template && I2.template.lang && await P({ refPath: t5, relPath: I2.template.lang }, r5);
                        const L = I2.template ? { compiler: { ...p2, compile: (e7, t6) => f.compile(e7, { ...t6, sourceMap: false }) }, source: I2.template.src ? await (await l3({ refPath: t5, relPath: I2.template.src }, r5).getContent()).getContentData(false) : I2.template.content, filename: I2.filename, isProd: g, scoped: D2, id: j2, slotted: I2.slotted, compilerOptions: { delimiters: i3, scopeId: D2 ? j2 : void 0, mode: "module" }, preprocessLang: I2.template.lang, preprocessCustomRequire: (e7) => o3[e7] } : null;
                        if (I2.script || I2.scriptSetup) {
                          var M, B, R;
                          (M = I2.script) !== null && M !== void 0 && M.src && (I2.script.content = await (await l3({ refPath: t5, relPath: I2.script.src }, r5).getContent()).getContentData(false));
                          const [e7, i4] = await x(a3, [_2, (B = I2.script) === null || B === void 0 ? void 0 : B.content, (R = I2.scriptSetup) === null || R === void 0 ? void 0 : R.content, S2, Object.keys(T2)], async ({ preventCache: e8 }) => {
                            const t6 = (0, c.a)(I2, { isProd: g, id: j2, babelParserPlugins: S2, inlineTemplate: false, templateOptions: L });
                            return L !== null && (L.compilerOptions.bindingMetadata = t6.bindings), await w(t6.content, true, n4, [...S2, ...u.babelParserDefaultPlugins, "jsx"], { ...T2, jsx: h3() }, m2);
                          });
                          await C(t5, e7, r5), Object.assign(s4, (F = A(t5, i4, r5).exports, F && F.__esModule ? F : { default: F }).default);
                        }
                        var F;
                        if (I2.template !== null) {
                          const [i4, o4] = await x(a3, [_2, L.source], async ({ preventCache: t6 }) => {
                            const r6 = (0, c.c)(L);
                            if (r6.errors.length) {
                              t6();
                              for (const t7 of r6.errors)
                                typeof t7 == "object" ? t7.loc ? m2 == null || m2("error", "SFC template", v(t7.message, n4, e6, t7.loc.start.line + I2.template.loc.start.line - 1, t7.loc.start.column)) : m2 == null || m2("error", "SFC template", b(t7.message, n4)) : m2 == null || m2("error", "SFC template", b(t7, n4));
                            }
                            for (const e7 of r6.tips)
                              m2 == null || m2("info", "SFC template", e7);
                            return await w(r6.code, true, I2.filename, S2, T2, m2);
                          });
                          await C(t5, i4, r5), Object.assign(s4, A(t5, o4, r5).exports);
                        }
                        for (const n5 of I2.styles) {
                          n5.lang && await P({ refPath: t5, relPath: n5.lang }, r5);
                          const s5 = n5.src ? await (await l3({ refPath: t5, relPath: n5.src }, r5).getContent()).getContentData(false) : n5.content;
                          d3(await x(a3, [_2, s5], async ({ preventCache: r6 }) => {
                            const i4 = await (0, c.b)({ filename: I2.filename, source: s5, isProd: g, id: j2, scoped: n5.scoped, trim: true, preprocessLang: n5.lang, preprocessCustomRequire: (e7) => o3[e7] });
                            if (i4.errors.length) {
                              r6();
                              for (const r7 of i4.errors)
                                m2 == null || m2("error", "SFC style", v(r7.message, t5, e6, r7.line + n5.loc.start.line - 1, r7.column));
                            }
                            return i4.code;
                          }), n5.scoped ? j2 : void 0);
                        }
                        return O2 !== void 0 && await Promise.all(N2.map((e7) => e7 == null ? void 0 : e7(s4))), s4;
                      }(await t4(false), r4, n3);
                    case ".js":
                      return O(await t4(false), false, r4, n3);
                    case ".mjs":
                      return O(await t4(false), true, r4, n3);
                  }
                }(l2, e4, o2, t3)), d2 === void 0)
                  throw new TypeError(`Unable to handle ${l2} files (${o2})`);
                return r3[i2] = d2;
              })()), await r3[i2].promise);
            }
            function A(e3, t3, r3) {
              const { moduleCache: n2, pathResolve: s3, getResource: i2 } = r3, o2 = { exports: {} };
              return Function("exports", "require", "module", "__filename", "__dirname", "import__", t3).call(o2.exports, o2.exports, function(t4) {
                const { id: s4 } = i2({ refPath: e3, relPath: t4 }, r3);
                if (s4 in n2)
                  return n2[s4];
                throw new Error(`require(${JSON.stringify(s4)}) failed. module not found in moduleCache`);
              }, o2, e3, s3({ refPath: e3, relPath: "." }), async function(t4) {
                return await P({ refPath: e3, relPath: t4 }, r3);
              }), o2;
            }
            async function O(e3, t3, r3, n2) {
              const { compiledCache: s3, additionalBabelParserPlugins: i2, additionalBabelPlugins: o2, log: a2 } = n2, [l2, c4] = await x(s3, ["0.8.4", e3, r3], async () => await w(e3, t3, r3, i2, o2, a2));
              return await C(r3, l2, n2), A(r3, c4, n2).exports;
            }
            async function C(e3, t3, r3) {
              await Promise.all(t3.map((t4) => P({ refPath: e3, relPath: t4 }, r3)));
            }
            const I = "0.8.4";
            function k2(e3) {
              throw new ReferenceError(`${e3} is not defined`);
            }
            const N = ({ refPath: e3, relPath: t3 }) => {
              if (e3 === void 0)
                return t3;
              const r3 = t3.toString();
              return r3[0] !== "." ? t3 : n.posix.normalize(n.posix.join(n.posix.dirname(e3.toString()), r3));
            };
            function _(e3, t3) {
              const { pathResolve: r3, getFile: s3, log: i2 } = t3, o2 = r3(e3), a2 = o2.toString();
              return { id: a2, path: o2, getContent: async () => {
                var _a2;
                const e4 = await s3(o2);
                return typeof e4 == "string" || e4 instanceof ArrayBuffer ? { type: n.posix.extname(a2), getContentData: async (t4) => (e4 instanceof ArrayBuffer !== t4 && (i2 == null || i2("warn", `unexpected data type. ${t4 ? "binary" : "string"} is expected for "${o2}"`)), e4) } : { type: (_a2 = e4.type) != null ? _a2 : n.posix.extname(a2), getContentData: e4.getContentData };
              } };
            }
            async function j(e3, t3 = k2("options")) {
              const { moduleCache: r3 = k2("options.moduleCache"), getFile: n2 = k2("options.getFile()"), addStyle: s3 = k2("options.addStyle()"), pathResolve: i2 = N, getResource: o2 = _ } = t3;
              r3 instanceof Object && Object.setPrototypeOf(r3, null);
              const a2 = { moduleCache: r3, pathResolve: i2, getResource: o2, ...t3 };
              return await P({ refPath: void 0, relPath: e3 }, a2);
            }
            function D(e3) {
              return { render: (t3, r3, n2) => {
                try {
                  const s3 = e3(t3, r3);
                  typeof s3 == "string" ? n2(null, s3) : (s3.then((e4) => {
                    n2(null, e4);
                  }), s3.catch((e4) => {
                    n2(e4, null);
                  }));
                } catch (e4) {
                  n2(e4, null);
                }
              } };
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(19), s2 = r2(0);
            t2.default = class {
              constructor(e3, t3, r3, n2) {
                this.queue = null, this.priorityQueue = null, this.parentPath = n2, this.scope = e3, this.state = r3, this.opts = t3;
              }
              shouldVisit(e3) {
                const t3 = this.opts;
                if (t3.enter || t3.exit)
                  return true;
                if (t3[e3.type])
                  return true;
                const r3 = s2.VISITOR_KEYS[e3.type];
                if (r3 == null || !r3.length)
                  return false;
                for (const t4 of r3)
                  if (e3[t4])
                    return true;
                return false;
              }
              create(e3, t3, r3, s3) {
                return n.default.get({ parentPath: this.parentPath, parent: e3, container: t3, key: r3, listKey: s3 });
              }
              maybeQueue(e3, t3) {
                this.queue && (t3 ? this.queue.push(e3) : this.priorityQueue.push(e3));
              }
              visitMultiple(e3, t3, r3) {
                if (e3.length === 0)
                  return false;
                const n2 = [];
                for (let s3 = 0; s3 < e3.length; s3++) {
                  const i = e3[s3];
                  i && this.shouldVisit(i) && n2.push(this.create(t3, e3, s3, r3));
                }
                return this.visitQueue(n2);
              }
              visitSingle(e3, t3) {
                return !!this.shouldVisit(e3[t3]) && this.visitQueue([this.create(e3, e3, t3)]);
              }
              visitQueue(e3) {
                this.queue = e3, this.priorityQueue = [];
                const t3 = new WeakSet();
                let r3 = false;
                for (const n2 of e3) {
                  if (n2.resync(), n2.contexts.length !== 0 && n2.contexts[n2.contexts.length - 1] === this || n2.pushContext(this), n2.key === null)
                    continue;
                  const { node: s3 } = n2;
                  if (!t3.has(s3)) {
                    if (s3 && t3.add(s3), n2.visit()) {
                      r3 = true;
                      break;
                    }
                    if (this.priorityQueue.length && (r3 = this.visitQueue(this.priorityQueue), this.priorityQueue = [], this.queue = e3, r3))
                      break;
                  }
                }
                for (const t4 of e3)
                  t4.popContext();
                return this.queue = null, r3;
              }
              visit(e3, t3) {
                const r3 = e3[t3];
                return !!r3 && (Array.isArray(r3) ? this.visitMultiple(r3, e3, t3) : this.visitSingle(e3, t3));
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(213).default)("React.Component");
            t2.default = n;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return !!e3 && /^[a-z]/.test(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = [];
              for (let r3 = 0; r3 < e3.children.length; r3++) {
                let i = e3.children[r3];
                (0, n.isJSXText)(i) ? (0, s2.default)(i, t3) : ((0, n.isJSXExpressionContainer)(i) && (i = i.expression), (0, n.isJSXEmptyExpression)(i) || t3.push(i));
              }
              return t3;
            };
            var n = r2(1), s2 = r2(366);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = e3.value.split(/\r\n|\n|\r/);
              let s2 = 0;
              for (let e4 = 0; e4 < r3.length; e4++)
                r3[e4].match(/[^ \t]/) && (s2 = e4);
              let i = "";
              for (let e4 = 0; e4 < r3.length; e4++) {
                const t4 = r3[e4], n2 = e4 === 0, o = e4 === r3.length - 1, a = e4 === s2;
                let l = t4.replace(/\t/g, " ");
                n2 || (l = l.replace(/^[ ]+/, "")), o || (l = l.replace(/[ ]+$/, "")), l && (a || (l += " "), i += l);
              }
              i && t3.push((0, n.stringLiteral)(i));
            };
            var n = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, ...t3) {
              const r3 = n.BUILDER_KEYS[e3], i = t3.length;
              if (i > r3.length)
                throw new Error(`${e3}: Too many arguments passed. Received ${i} but can receive no more than ${r3.length}`);
              const o = { type: e3 };
              let a = 0;
              r3.forEach((r4) => {
                const s3 = n.NODE_FIELDS[e3][r4];
                let l;
                a < i && (l = t3[a]), l === void 0 && (l = Array.isArray(s3.default) ? [] : s3.default), o[r4] = l, a++;
              });
              for (const e4 of Object.keys(o))
                (0, s2.default)(o, e4, o[e4]);
              return o;
            };
            var n = r2(11), s2 = r2(130);
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.isIdentifierStart = c, t2.isIdentifierChar = u, t2.isIdentifierName = function(e3) {
              let t3 = true;
              for (let r3 = 0; r3 < e3.length; r3++) {
                let n2 = e3.charCodeAt(r3);
                if ((64512 & n2) == 55296 && r3 + 1 < e3.length) {
                  const t4 = e3.charCodeAt(++r3);
                  (64512 & t4) == 56320 && (n2 = 65536 + ((1023 & n2) << 10) + (1023 & t4));
                }
                if (t3) {
                  if (t3 = false, !c(n2))
                    return false;
                } else if (!u(n2))
                  return false;
              }
              return !t3;
            };
            let r2 = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", n = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
            const s2 = new RegExp("[" + r2 + "]"), i = new RegExp("[" + r2 + n + "]");
            r2 = n = null;
            const o = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], a = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
            function l(e3, t3) {
              let r3 = 65536;
              for (let n2 = 0, s3 = t3.length; n2 < s3; n2 += 2) {
                if (r3 += t3[n2], r3 > e3)
                  return false;
                if (r3 += t3[n2 + 1], r3 >= e3)
                  return true;
              }
              return false;
            }
            function c(e3) {
              return e3 < 65 ? e3 === 36 : e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && s2.test(String.fromCharCode(e3)) : l(e3, o)));
            }
            function u(e3) {
              return e3 < 48 ? e3 === 36 : e3 < 58 || !(e3 < 65) && (e3 <= 90 || (e3 < 97 ? e3 === 95 : e3 <= 122 || (e3 <= 65535 ? e3 >= 170 && i.test(String.fromCharCode(e3)) : l(e3, o) || l(e3, a))));
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.isReservedWord = i, t2.isStrictReservedWord = o, t2.isStrictBindOnlyReservedWord = a, t2.isStrictBindReservedWord = function(e3, t3) {
              return o(e3, t3) || a(e3);
            }, t2.isKeyword = function(e3) {
              return r2.has(e3);
            };
            const r2 = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"]), n = new Set(["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"]), s2 = new Set(["eval", "arguments"]);
            function i(e3, t3) {
              return t3 && e3 === "await" || e3 === "enum";
            }
            function o(e3, t3) {
              return i(e3, t3) || n.has(e3);
            }
            function a(e3) {
              return s2.has(e3);
            }
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(20);
            const s2 = (e3, t3 = "TypeParameterDeclaration") => {
              (0, n.default)(e3, { builder: ["id", "typeParameters", "extends", "body"], visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)(t3), extends: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")), mixins: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")), implements: (0, n.validateOptional)((0, n.arrayOfType)("ClassImplements")), body: (0, n.validateType)("ObjectTypeAnnotation") } });
            };
            (0, n.default)("AnyTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("ArrayTypeAnnotation", { visitor: ["elementType"], aliases: ["Flow", "FlowType"], fields: { elementType: (0, n.validateType)("FlowType") } }), (0, n.default)("BooleanTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("BooleanLiteralTypeAnnotation", { builder: ["value"], aliases: ["Flow", "FlowType"], fields: { value: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("NullLiteralTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("ClassImplements", { visitor: ["id", "typeParameters"], aliases: ["Flow"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation") } }), s2("DeclareClass"), (0, n.default)("DeclareFunction", { visitor: ["id"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), predicate: (0, n.validateOptionalType)("DeclaredPredicate") } }), s2("DeclareInterface"), (0, n.default)("DeclareModule", { builder: ["id", "body", "kind"], visitor: ["id", "body"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)(["Identifier", "StringLiteral"]), body: (0, n.validateType)("BlockStatement"), kind: (0, n.validateOptional)((0, n.assertOneOf)("CommonJS", "ES")) } }), (0, n.default)("DeclareModuleExports", { visitor: ["typeAnnotation"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { typeAnnotation: (0, n.validateType)("TypeAnnotation") } }), (0, n.default)("DeclareTypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"), right: (0, n.validateType)("FlowType") } }), (0, n.default)("DeclareOpaqueType", { visitor: ["id", "typeParameters", "supertype"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n.validateOptionalType)("FlowType") } }), (0, n.default)("DeclareVariable", { visitor: ["id"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier") } }), (0, n.default)("DeclareExportDeclaration", { visitor: ["declaration", "specifiers", "source"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { declaration: (0, n.validateOptionalType)("Flow"), specifiers: (0, n.validateOptional)((0, n.arrayOfType)(["ExportSpecifier", "ExportNamespaceSpecifier"])), source: (0, n.validateOptionalType)("StringLiteral"), default: (0, n.validateOptional)((0, n.assertValueType)("boolean")) } }), (0, n.default)("DeclareExportAllDeclaration", { visitor: ["source"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { source: (0, n.validateType)("StringLiteral"), exportKind: (0, n.validateOptional)((0, n.assertOneOf)("type", "value")) } }), (0, n.default)("DeclaredPredicate", { visitor: ["value"], aliases: ["Flow", "FlowPredicate"], fields: { value: (0, n.validateType)("Flow") } }), (0, n.default)("ExistsTypeAnnotation", { aliases: ["Flow", "FlowType"] }), (0, n.default)("FunctionTypeAnnotation", { visitor: ["typeParameters", "params", "rest", "returnType"], aliases: ["Flow", "FlowType"], fields: { typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"), params: (0, n.validate)((0, n.arrayOfType)("FunctionTypeParam")), rest: (0, n.validateOptionalType)("FunctionTypeParam"), this: (0, n.validateOptionalType)("FunctionTypeParam"), returnType: (0, n.validateType)("FlowType") } }), (0, n.default)("FunctionTypeParam", { visitor: ["name", "typeAnnotation"], aliases: ["Flow"], fields: { name: (0, n.validateOptionalType)("Identifier"), typeAnnotation: (0, n.validateType)("FlowType"), optional: (0, n.validateOptional)((0, n.assertValueType)("boolean")) } }), (0, n.default)("GenericTypeAnnotation", { visitor: ["id", "typeParameters"], aliases: ["Flow", "FlowType"], fields: { id: (0, n.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation") } }), (0, n.default)("InferredPredicate", { aliases: ["Flow", "FlowPredicate"] }), (0, n.default)("InterfaceExtends", { visitor: ["id", "typeParameters"], aliases: ["Flow"], fields: { id: (0, n.validateType)(["Identifier", "QualifiedTypeIdentifier"]), typeParameters: (0, n.validateOptionalType)("TypeParameterInstantiation") } }), s2("InterfaceDeclaration"), (0, n.default)("InterfaceTypeAnnotation", { visitor: ["extends", "body"], aliases: ["Flow", "FlowType"], fields: { extends: (0, n.validateOptional)((0, n.arrayOfType)("InterfaceExtends")), body: (0, n.validateType)("ObjectTypeAnnotation") } }), (0, n.default)("IntersectionTypeAnnotation", { visitor: ["types"], aliases: ["Flow", "FlowType"], fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) } }), (0, n.default)("MixedTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("EmptyTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("NullableTypeAnnotation", { visitor: ["typeAnnotation"], aliases: ["Flow", "FlowType"], fields: { typeAnnotation: (0, n.validateType)("FlowType") } }), (0, n.default)("NumberLiteralTypeAnnotation", { builder: ["value"], aliases: ["Flow", "FlowType"], fields: { value: (0, n.validate)((0, n.assertValueType)("number")) } }), (0, n.default)("NumberTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("ObjectTypeAnnotation", { visitor: ["properties", "indexers", "callProperties", "internalSlots"], aliases: ["Flow", "FlowType"], builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"], fields: { properties: (0, n.validate)((0, n.arrayOfType)(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])), indexers: (0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeIndexer")), callProperties: (0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeCallProperty")), internalSlots: (0, n.validateOptional)((0, n.arrayOfType)("ObjectTypeInternalSlot")), exact: { validate: (0, n.assertValueType)("boolean"), default: false }, inexact: (0, n.validateOptional)((0, n.assertValueType)("boolean")) } }), (0, n.default)("ObjectTypeInternalSlot", { visitor: ["id", "value", "optional", "static", "method"], aliases: ["Flow", "UserWhitespacable"], fields: { id: (0, n.validateType)("Identifier"), value: (0, n.validateType)("FlowType"), optional: (0, n.validate)((0, n.assertValueType)("boolean")), static: (0, n.validate)((0, n.assertValueType)("boolean")), method: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("ObjectTypeCallProperty", { visitor: ["value"], aliases: ["Flow", "UserWhitespacable"], fields: { value: (0, n.validateType)("FlowType"), static: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("ObjectTypeIndexer", { visitor: ["id", "key", "value", "variance"], aliases: ["Flow", "UserWhitespacable"], fields: { id: (0, n.validateOptionalType)("Identifier"), key: (0, n.validateType)("FlowType"), value: (0, n.validateType)("FlowType"), static: (0, n.validate)((0, n.assertValueType)("boolean")), variance: (0, n.validateOptionalType)("Variance") } }), (0, n.default)("ObjectTypeProperty", { visitor: ["key", "value", "variance"], aliases: ["Flow", "UserWhitespacable"], fields: { key: (0, n.validateType)(["Identifier", "StringLiteral"]), value: (0, n.validateType)("FlowType"), kind: (0, n.validate)((0, n.assertOneOf)("init", "get", "set")), static: (0, n.validate)((0, n.assertValueType)("boolean")), proto: (0, n.validate)((0, n.assertValueType)("boolean")), optional: (0, n.validate)((0, n.assertValueType)("boolean")), variance: (0, n.validateOptionalType)("Variance"), method: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("ObjectTypeSpreadProperty", { visitor: ["argument"], aliases: ["Flow", "UserWhitespacable"], fields: { argument: (0, n.validateType)("FlowType") } }), (0, n.default)("OpaqueType", { visitor: ["id", "typeParameters", "supertype", "impltype"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"), supertype: (0, n.validateOptionalType)("FlowType"), impltype: (0, n.validateType)("FlowType") } }), (0, n.default)("QualifiedTypeIdentifier", { visitor: ["id", "qualification"], aliases: ["Flow"], fields: { id: (0, n.validateType)("Identifier"), qualification: (0, n.validateType)(["Identifier", "QualifiedTypeIdentifier"]) } }), (0, n.default)("StringLiteralTypeAnnotation", { builder: ["value"], aliases: ["Flow", "FlowType"], fields: { value: (0, n.validate)((0, n.assertValueType)("string")) } }), (0, n.default)("StringTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("SymbolTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("ThisTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("TupleTypeAnnotation", { visitor: ["types"], aliases: ["Flow", "FlowType"], fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) } }), (0, n.default)("TypeofTypeAnnotation", { visitor: ["argument"], aliases: ["Flow", "FlowType"], fields: { argument: (0, n.validateType)("FlowType") } }), (0, n.default)("TypeAlias", { visitor: ["id", "typeParameters", "right"], aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"], fields: { id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TypeParameterDeclaration"), right: (0, n.validateType)("FlowType") } }), (0, n.default)("TypeAnnotation", { aliases: ["Flow"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("FlowType") } }), (0, n.default)("TypeCastExpression", { visitor: ["expression", "typeAnnotation"], aliases: ["Flow", "ExpressionWrapper", "Expression"], fields: { expression: (0, n.validateType)("Expression"), typeAnnotation: (0, n.validateType)("TypeAnnotation") } }), (0, n.default)("TypeParameter", { aliases: ["Flow"], visitor: ["bound", "default", "variance"], fields: { name: (0, n.validate)((0, n.assertValueType)("string")), bound: (0, n.validateOptionalType)("TypeAnnotation"), default: (0, n.validateOptionalType)("FlowType"), variance: (0, n.validateOptionalType)("Variance") } }), (0, n.default)("TypeParameterDeclaration", { aliases: ["Flow"], visitor: ["params"], fields: { params: (0, n.validate)((0, n.arrayOfType)("TypeParameter")) } }), (0, n.default)("TypeParameterInstantiation", { aliases: ["Flow"], visitor: ["params"], fields: { params: (0, n.validate)((0, n.arrayOfType)("FlowType")) } }), (0, n.default)("UnionTypeAnnotation", { visitor: ["types"], aliases: ["Flow", "FlowType"], fields: { types: (0, n.validate)((0, n.arrayOfType)("FlowType")) } }), (0, n.default)("Variance", { aliases: ["Flow"], builder: ["kind"], fields: { kind: (0, n.validate)((0, n.assertOneOf)("minus", "plus")) } }), (0, n.default)("VoidTypeAnnotation", { aliases: ["Flow", "FlowType", "FlowBaseAnnotation"] }), (0, n.default)("EnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { id: (0, n.validateType)("Identifier"), body: (0, n.validateType)(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"]) } }), (0, n.default)("EnumBooleanBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n.validate)((0, n.assertValueType)("boolean")), members: (0, n.validateArrayOfType)("EnumBooleanMember"), hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("EnumNumberBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n.validate)((0, n.assertValueType)("boolean")), members: (0, n.validateArrayOfType)("EnumNumberMember"), hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("EnumStringBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { explicitType: (0, n.validate)((0, n.assertValueType)("boolean")), members: (0, n.validateArrayOfType)(["EnumStringMember", "EnumDefaultedMember"]), hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("EnumSymbolBody", { aliases: ["EnumBody"], visitor: ["members"], fields: { members: (0, n.validateArrayOfType)("EnumDefaultedMember"), hasUnknownMembers: (0, n.validate)((0, n.assertValueType)("boolean")) } }), (0, n.default)("EnumBooleanMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n.validateType)("Identifier"), init: (0, n.validateType)("BooleanLiteral") } }), (0, n.default)("EnumNumberMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n.validateType)("Identifier"), init: (0, n.validateType)("NumericLiteral") } }), (0, n.default)("EnumStringMember", { aliases: ["EnumMember"], visitor: ["id", "init"], fields: { id: (0, n.validateType)("Identifier"), init: (0, n.validateType)("StringLiteral") } }), (0, n.default)("EnumDefaultedMember", { aliases: ["EnumMember"], visitor: ["id"], fields: { id: (0, n.validateType)("Identifier") } }), (0, n.default)("IndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["Flow", "FlowType"], fields: { objectType: (0, n.validateType)("FlowType"), indexType: (0, n.validateType)("FlowType") } }), (0, n.default)("OptionalIndexedAccessType", { visitor: ["objectType", "indexType"], aliases: ["Flow", "FlowType"], fields: { objectType: (0, n.validateType)("FlowType"), indexType: (0, n.validateType)("FlowType"), optional: (0, n.validate)((0, n.assertValueType)("boolean")) } });
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(20);
            (0, n.default)("JSXAttribute", { visitor: ["name", "value"], aliases: ["JSX", "Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXNamespacedName") }, value: { optional: true, validate: (0, n.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer") } } }), (0, n.default)("JSXClosingElement", { visitor: ["name"], aliases: ["JSX", "Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") } } }), (0, n.default)("JSXElement", { builder: ["openingElement", "closingElement", "children", "selfClosing"], visitor: ["openingElement", "children", "closingElement"], aliases: ["JSX", "Immutable", "Expression"], fields: { openingElement: { validate: (0, n.assertNodeType)("JSXOpeningElement") }, closingElement: { optional: true, validate: (0, n.assertNodeType)("JSXClosingElement") }, children: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) }, selfClosing: { validate: (0, n.assertValueType)("boolean"), optional: true } } }), (0, n.default)("JSXEmptyExpression", { aliases: ["JSX"] }), (0, n.default)("JSXExpressionContainer", { visitor: ["expression"], aliases: ["JSX", "Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression", "JSXEmptyExpression") } } }), (0, n.default)("JSXSpreadChild", { visitor: ["expression"], aliases: ["JSX", "Immutable"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("JSXIdentifier", { builder: ["name"], aliases: ["JSX"], fields: { name: { validate: (0, n.assertValueType)("string") } } }), (0, n.default)("JSXMemberExpression", { visitor: ["object", "property"], aliases: ["JSX"], fields: { object: { validate: (0, n.assertNodeType)("JSXMemberExpression", "JSXIdentifier") }, property: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), (0, n.default)("JSXNamespacedName", { visitor: ["namespace", "name"], aliases: ["JSX"], fields: { namespace: { validate: (0, n.assertNodeType)("JSXIdentifier") }, name: { validate: (0, n.assertNodeType)("JSXIdentifier") } } }), (0, n.default)("JSXOpeningElement", { builder: ["name", "attributes", "selfClosing"], visitor: ["name", "attributes"], aliases: ["JSX", "Immutable"], fields: { name: { validate: (0, n.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName") }, selfClosing: { default: false }, attributes: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXAttribute", "JSXSpreadAttribute"))) }, typeParameters: { validate: (0, n.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"), optional: true } } }), (0, n.default)("JSXSpreadAttribute", { visitor: ["argument"], aliases: ["JSX"], fields: { argument: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("JSXText", { aliases: ["JSX", "Immutable"], builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } } }), (0, n.default)("JSXFragment", { builder: ["openingFragment", "closingFragment", "children"], visitor: ["openingFragment", "children", "closingFragment"], aliases: ["JSX", "Immutable", "Expression"], fields: { openingFragment: { validate: (0, n.assertNodeType)("JSXOpeningFragment") }, closingFragment: { validate: (0, n.assertNodeType)("JSXClosingFragment") }, children: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment"))) } } }), (0, n.default)("JSXOpeningFragment", { aliases: ["JSX", "Immutable"] }), (0, n.default)("JSXClosingFragment", { aliases: ["JSX", "Immutable"] });
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(20), s2 = r2(217);
            (0, n.default)("Noop", { visitor: [] }), (0, n.default)("Placeholder", { visitor: [], builder: ["expectedNode", "name"], fields: { name: { validate: (0, n.assertNodeType)("Identifier") }, expectedNode: { validate: (0, n.assertOneOf)(...s2.PLACEHOLDERS) } } }), (0, n.default)("V8IntrinsicIdentifier", { builder: ["name"], fields: { name: { validate: (0, n.assertValueType)("string") } } });
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(20), s2 = r2(128);
            (0, n.default)("ArgumentPlaceholder", {}), (0, n.default)("BindExpression", { visitor: ["object", "callee"], aliases: ["Expression"], fields: { object: { validate: Object.assign(() => {
            }, { oneOfNodeTypes: ["Expression"] }) }, callee: { validate: Object.assign(() => {
            }, { oneOfNodeTypes: ["Expression"] }) } } }), (0, n.default)("ClassProperty", { visitor: ["key", "value", "typeAnnotation", "decorators"], builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"], aliases: ["Property"], fields: Object.assign({}, s2.classMethodOrPropertyCommon, { value: { validate: (0, n.assertNodeType)("Expression"), optional: true }, definite: { validate: (0, n.assertValueType)("boolean"), optional: true }, typeAnnotation: { validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))), optional: true }, readonly: { validate: (0, n.assertValueType)("boolean"), optional: true }, declare: { validate: (0, n.assertValueType)("boolean"), optional: true } }) }), (0, n.default)("PipelineTopicExpression", { builder: ["expression"], visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("PipelineBareFunction", { builder: ["callee"], visitor: ["callee"], fields: { callee: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("PipelinePrimaryTopicReference", { aliases: ["Expression"] }), (0, n.default)("ClassPrivateProperty", { visitor: ["key", "value", "decorators"], builder: ["key", "value", "decorators", "static"], aliases: ["Property", "Private"], fields: { key: { validate: (0, n.assertNodeType)("PrivateName") }, value: { validate: (0, n.assertNodeType)("Expression"), optional: true }, typeAnnotation: { validate: (0, n.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"), optional: true }, decorators: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Decorator"))), optional: true } } }), (0, n.default)("ClassPrivateMethod", { builder: ["kind", "key", "params", "body", "static"], visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"], aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"], fields: Object.assign({}, s2.classMethodOrDeclareMethodCommon, s2.functionTypeAnnotationCommon, { key: { validate: (0, n.assertNodeType)("PrivateName") }, body: { validate: (0, n.assertNodeType)("BlockStatement") } }) }), (0, n.default)("ImportAttribute", { visitor: ["key", "value"], fields: { key: { validate: (0, n.assertNodeType)("Identifier", "StringLiteral") }, value: { validate: (0, n.assertNodeType)("StringLiteral") } } }), (0, n.default)("Decorator", { visitor: ["expression"], fields: { expression: { validate: (0, n.assertNodeType)("Expression") } } }), (0, n.default)("DoExpression", { visitor: ["body"], builder: ["body", "async"], aliases: ["Expression"], fields: { body: { validate: (0, n.assertNodeType)("BlockStatement") }, async: { validate: (0, n.assertValueType)("boolean"), default: false } } }), (0, n.default)("ExportDefaultSpecifier", { visitor: ["exported"], aliases: ["ModuleSpecifier"], fields: { exported: { validate: (0, n.assertNodeType)("Identifier") } } }), (0, n.default)("PrivateName", { visitor: ["id"], aliases: ["Private"], fields: { id: { validate: (0, n.assertNodeType)("Identifier") } } }), (0, n.default)("RecordExpression", { visitor: ["properties"], aliases: ["Expression"], fields: { properties: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("ObjectProperty", "SpreadElement"))) } } }), (0, n.default)("TupleExpression", { fields: { elements: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Expression", "SpreadElement"))), default: [] } }, visitor: ["elements"], aliases: ["Expression"] }), (0, n.default)("DecimalLiteral", { builder: ["value"], fields: { value: { validate: (0, n.assertValueType)("string") } }, aliases: ["Expression", "Pureish", "Literal", "Immutable"] }), (0, n.default)("StaticBlock", { visitor: ["body"], fields: { body: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("Statement"))) } }, aliases: ["Scopable", "BlockParent"] }), (0, n.default)("ModuleExpression", { visitor: ["body"], fields: { body: { validate: (0, n.assertNodeType)("Program") } }, aliases: ["Expression"] });
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(20), s2 = r2(128);
            const i = (0, n.assertValueType)("boolean"), o = { returnType: { validate: (0, n.assertNodeType)("TSTypeAnnotation", "Noop"), optional: true }, typeParameters: { validate: (0, n.assertNodeType)("TSTypeParameterDeclaration", "Noop"), optional: true } };
            (0, n.default)("TSParameterProperty", { aliases: ["LVal"], visitor: ["parameter"], fields: { accessibility: { validate: (0, n.assertOneOf)("public", "private", "protected"), optional: true }, readonly: { validate: (0, n.assertValueType)("boolean"), optional: true }, parameter: { validate: (0, n.assertNodeType)("Identifier", "AssignmentPattern") } } }), (0, n.default)("TSDeclareFunction", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "params", "returnType"], fields: Object.assign({}, s2.functionDeclarationCommon, o) }), (0, n.default)("TSDeclareMethod", { visitor: ["decorators", "key", "typeParameters", "params", "returnType"], fields: Object.assign({}, s2.classMethodOrDeclareMethodCommon, o) }), (0, n.default)("TSQualifiedName", { aliases: ["TSEntityName"], visitor: ["left", "right"], fields: { left: (0, n.validateType)("TSEntityName"), right: (0, n.validateType)("Identifier") } });
            const a = { typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), parameters: (0, n.validateArrayOfType)(["Identifier", "RestElement"]), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") }, l = { aliases: ["TSTypeElement"], visitor: ["typeParameters", "parameters", "typeAnnotation"], fields: a };
            (0, n.default)("TSCallSignatureDeclaration", l), (0, n.default)("TSConstructSignatureDeclaration", l);
            const c = { key: (0, n.validateType)("Expression"), computed: (0, n.validate)(i), optional: (0, n.validateOptional)(i) };
            (0, n.default)("TSPropertySignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeAnnotation", "initializer"], fields: Object.assign({}, c, { readonly: (0, n.validateOptional)(i), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), initializer: (0, n.validateOptionalType)("Expression") }) }), (0, n.default)("TSMethodSignature", { aliases: ["TSTypeElement"], visitor: ["key", "typeParameters", "parameters", "typeAnnotation"], fields: Object.assign({}, a, c, { kind: { validate: (0, n.assertOneOf)("method", "get", "set") } }) }), (0, n.default)("TSIndexSignature", { aliases: ["TSTypeElement"], visitor: ["parameters", "typeAnnotation"], fields: { readonly: (0, n.validateOptional)(i), static: (0, n.validateOptional)(i), parameters: (0, n.validateArrayOfType)("Identifier"), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation") } });
            const u = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
            for (const e3 of u)
              (0, n.default)(e3, { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
            (0, n.default)("TSThisType", { aliases: ["TSType", "TSBaseType"], visitor: [], fields: {} });
            const p2 = { aliases: ["TSType"], visitor: ["typeParameters", "parameters", "typeAnnotation"] };
            (0, n.default)("TSFunctionType", Object.assign({}, p2, { fields: a })), (0, n.default)("TSConstructorType", Object.assign({}, p2, { fields: Object.assign({}, a, { abstract: (0, n.validateOptional)(i) }) })), (0, n.default)("TSTypeReference", { aliases: ["TSType"], visitor: ["typeName", "typeParameters"], fields: { typeName: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), (0, n.default)("TSTypePredicate", { aliases: ["TSType"], visitor: ["parameterName", "typeAnnotation"], builder: ["parameterName", "typeAnnotation", "asserts"], fields: { parameterName: (0, n.validateType)(["Identifier", "TSThisType"]), typeAnnotation: (0, n.validateOptionalType)("TSTypeAnnotation"), asserts: (0, n.validateOptional)(i) } }), (0, n.default)("TSTypeQuery", { aliases: ["TSType"], visitor: ["exprName"], fields: { exprName: (0, n.validateType)(["TSEntityName", "TSImportType"]) } }), (0, n.default)("TSTypeLiteral", { aliases: ["TSType"], visitor: ["members"], fields: { members: (0, n.validateArrayOfType)("TSTypeElement") } }), (0, n.default)("TSArrayType", { aliases: ["TSType"], visitor: ["elementType"], fields: { elementType: (0, n.validateType)("TSType") } }), (0, n.default)("TSTupleType", { aliases: ["TSType"], visitor: ["elementTypes"], fields: { elementTypes: (0, n.validateArrayOfType)(["TSType", "TSNamedTupleMember"]) } }), (0, n.default)("TSOptionalType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSRestType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSNamedTupleMember", { visitor: ["label", "elementType"], builder: ["label", "elementType", "optional"], fields: { label: (0, n.validateType)("Identifier"), optional: { validate: i, default: false }, elementType: (0, n.validateType)("TSType") } });
            const f = { aliases: ["TSType"], visitor: ["types"], fields: { types: (0, n.validateArrayOfType)("TSType") } };
            (0, n.default)("TSUnionType", f), (0, n.default)("TSIntersectionType", f), (0, n.default)("TSConditionalType", { aliases: ["TSType"], visitor: ["checkType", "extendsType", "trueType", "falseType"], fields: { checkType: (0, n.validateType)("TSType"), extendsType: (0, n.validateType)("TSType"), trueType: (0, n.validateType)("TSType"), falseType: (0, n.validateType)("TSType") } }), (0, n.default)("TSInferType", { aliases: ["TSType"], visitor: ["typeParameter"], fields: { typeParameter: (0, n.validateType)("TSTypeParameter") } }), (0, n.default)("TSParenthesizedType", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSTypeOperator", { aliases: ["TSType"], visitor: ["typeAnnotation"], fields: { operator: (0, n.validate)((0, n.assertValueType)("string")), typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSIndexedAccessType", { aliases: ["TSType"], visitor: ["objectType", "indexType"], fields: { objectType: (0, n.validateType)("TSType"), indexType: (0, n.validateType)("TSType") } }), (0, n.default)("TSMappedType", { aliases: ["TSType"], visitor: ["typeParameter", "typeAnnotation", "nameType"], fields: { readonly: (0, n.validateOptional)(i), typeParameter: (0, n.validateType)("TSTypeParameter"), optional: (0, n.validateOptional)(i), typeAnnotation: (0, n.validateOptionalType)("TSType"), nameType: (0, n.validateOptionalType)("TSType") } }), (0, n.default)("TSLiteralType", { aliases: ["TSType", "TSBaseType"], visitor: ["literal"], fields: { literal: (0, n.validateType)(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"]) } }), (0, n.default)("TSExpressionWithTypeArguments", { aliases: ["TSType"], visitor: ["expression", "typeParameters"], fields: { expression: (0, n.validateType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), (0, n.default)("TSInterfaceDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "extends", "body"], fields: { declare: (0, n.validateOptional)(i), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), extends: (0, n.validateOptional)((0, n.arrayOfType)("TSExpressionWithTypeArguments")), body: (0, n.validateType)("TSInterfaceBody") } }), (0, n.default)("TSInterfaceBody", { visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("TSTypeElement") } }), (0, n.default)("TSTypeAliasDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "typeParameters", "typeAnnotation"], fields: { declare: (0, n.validateOptional)(i), id: (0, n.validateType)("Identifier"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterDeclaration"), typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSAsExpression", { aliases: ["Expression"], visitor: ["expression", "typeAnnotation"], fields: { expression: (0, n.validateType)("Expression"), typeAnnotation: (0, n.validateType)("TSType") } }), (0, n.default)("TSTypeAssertion", { aliases: ["Expression"], visitor: ["typeAnnotation", "expression"], fields: { typeAnnotation: (0, n.validateType)("TSType"), expression: (0, n.validateType)("Expression") } }), (0, n.default)("TSEnumDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "members"], fields: { declare: (0, n.validateOptional)(i), const: (0, n.validateOptional)(i), id: (0, n.validateType)("Identifier"), members: (0, n.validateArrayOfType)("TSEnumMember"), initializer: (0, n.validateOptionalType)("Expression") } }), (0, n.default)("TSEnumMember", { visitor: ["id", "initializer"], fields: { id: (0, n.validateType)(["Identifier", "StringLiteral"]), initializer: (0, n.validateOptionalType)("Expression") } }), (0, n.default)("TSModuleDeclaration", { aliases: ["Statement", "Declaration"], visitor: ["id", "body"], fields: { declare: (0, n.validateOptional)(i), global: (0, n.validateOptional)(i), id: (0, n.validateType)(["Identifier", "StringLiteral"]), body: (0, n.validateType)(["TSModuleBlock", "TSModuleDeclaration"]) } }), (0, n.default)("TSModuleBlock", { aliases: ["Scopable", "Block", "BlockParent"], visitor: ["body"], fields: { body: (0, n.validateArrayOfType)("Statement") } }), (0, n.default)("TSImportType", { aliases: ["TSType"], visitor: ["argument", "qualifier", "typeParameters"], fields: { argument: (0, n.validateType)("StringLiteral"), qualifier: (0, n.validateOptionalType)("TSEntityName"), typeParameters: (0, n.validateOptionalType)("TSTypeParameterInstantiation") } }), (0, n.default)("TSImportEqualsDeclaration", { aliases: ["Statement"], visitor: ["id", "moduleReference"], fields: { isExport: (0, n.validate)(i), id: (0, n.validateType)("Identifier"), moduleReference: (0, n.validateType)(["TSEntityName", "TSExternalModuleReference"]) } }), (0, n.default)("TSExternalModuleReference", { visitor: ["expression"], fields: { expression: (0, n.validateType)("StringLiteral") } }), (0, n.default)("TSNonNullExpression", { aliases: ["Expression"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), (0, n.default)("TSExportAssignment", { aliases: ["Statement"], visitor: ["expression"], fields: { expression: (0, n.validateType)("Expression") } }), (0, n.default)("TSNamespaceExportDeclaration", { aliases: ["Statement"], visitor: ["id"], fields: { id: (0, n.validateType)("Identifier") } }), (0, n.default)("TSTypeAnnotation", { visitor: ["typeAnnotation"], fields: { typeAnnotation: { validate: (0, n.assertNodeType)("TSType") } } }), (0, n.default)("TSTypeParameterInstantiation", { visitor: ["params"], fields: { params: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSType"))) } } }), (0, n.default)("TSTypeParameterDeclaration", { visitor: ["params"], fields: { params: { validate: (0, n.chain)((0, n.assertValueType)("array"), (0, n.assertEach)((0, n.assertNodeType)("TSTypeParameter"))) } } }), (0, n.default)("TSTypeParameter", { builder: ["constraint", "default", "name"], visitor: ["constraint", "default"], fields: { name: { validate: (0, n.assertValueType)("string") }, constraint: { validate: (0, n.assertNodeType)("TSType"), optional: true }, default: { validate: (0, n.assertNodeType)("TSType"), optional: true } } });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              if (!(0, n.default)(e3)) {
                var t3;
                const r3 = (t3 = e3 == null ? void 0 : e3.type) != null ? t3 : JSON.stringify(e3);
                throw new TypeError(`Not a valid node of type "${r3}"`);
              }
            };
            var n = r2(218);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.assertArrayExpression = function(e3, t3) {
              s2("ArrayExpression", e3, t3);
            }, t2.assertAssignmentExpression = function(e3, t3) {
              s2("AssignmentExpression", e3, t3);
            }, t2.assertBinaryExpression = function(e3, t3) {
              s2("BinaryExpression", e3, t3);
            }, t2.assertInterpreterDirective = function(e3, t3) {
              s2("InterpreterDirective", e3, t3);
            }, t2.assertDirective = function(e3, t3) {
              s2("Directive", e3, t3);
            }, t2.assertDirectiveLiteral = function(e3, t3) {
              s2("DirectiveLiteral", e3, t3);
            }, t2.assertBlockStatement = function(e3, t3) {
              s2("BlockStatement", e3, t3);
            }, t2.assertBreakStatement = function(e3, t3) {
              s2("BreakStatement", e3, t3);
            }, t2.assertCallExpression = function(e3, t3) {
              s2("CallExpression", e3, t3);
            }, t2.assertCatchClause = function(e3, t3) {
              s2("CatchClause", e3, t3);
            }, t2.assertConditionalExpression = function(e3, t3) {
              s2("ConditionalExpression", e3, t3);
            }, t2.assertContinueStatement = function(e3, t3) {
              s2("ContinueStatement", e3, t3);
            }, t2.assertDebuggerStatement = function(e3, t3) {
              s2("DebuggerStatement", e3, t3);
            }, t2.assertDoWhileStatement = function(e3, t3) {
              s2("DoWhileStatement", e3, t3);
            }, t2.assertEmptyStatement = function(e3, t3) {
              s2("EmptyStatement", e3, t3);
            }, t2.assertExpressionStatement = function(e3, t3) {
              s2("ExpressionStatement", e3, t3);
            }, t2.assertFile = function(e3, t3) {
              s2("File", e3, t3);
            }, t2.assertForInStatement = function(e3, t3) {
              s2("ForInStatement", e3, t3);
            }, t2.assertForStatement = function(e3, t3) {
              s2("ForStatement", e3, t3);
            }, t2.assertFunctionDeclaration = function(e3, t3) {
              s2("FunctionDeclaration", e3, t3);
            }, t2.assertFunctionExpression = function(e3, t3) {
              s2("FunctionExpression", e3, t3);
            }, t2.assertIdentifier = function(e3, t3) {
              s2("Identifier", e3, t3);
            }, t2.assertIfStatement = function(e3, t3) {
              s2("IfStatement", e3, t3);
            }, t2.assertLabeledStatement = function(e3, t3) {
              s2("LabeledStatement", e3, t3);
            }, t2.assertStringLiteral = function(e3, t3) {
              s2("StringLiteral", e3, t3);
            }, t2.assertNumericLiteral = function(e3, t3) {
              s2("NumericLiteral", e3, t3);
            }, t2.assertNullLiteral = function(e3, t3) {
              s2("NullLiteral", e3, t3);
            }, t2.assertBooleanLiteral = function(e3, t3) {
              s2("BooleanLiteral", e3, t3);
            }, t2.assertRegExpLiteral = function(e3, t3) {
              s2("RegExpLiteral", e3, t3);
            }, t2.assertLogicalExpression = function(e3, t3) {
              s2("LogicalExpression", e3, t3);
            }, t2.assertMemberExpression = function(e3, t3) {
              s2("MemberExpression", e3, t3);
            }, t2.assertNewExpression = function(e3, t3) {
              s2("NewExpression", e3, t3);
            }, t2.assertProgram = function(e3, t3) {
              s2("Program", e3, t3);
            }, t2.assertObjectExpression = function(e3, t3) {
              s2("ObjectExpression", e3, t3);
            }, t2.assertObjectMethod = function(e3, t3) {
              s2("ObjectMethod", e3, t3);
            }, t2.assertObjectProperty = function(e3, t3) {
              s2("ObjectProperty", e3, t3);
            }, t2.assertRestElement = function(e3, t3) {
              s2("RestElement", e3, t3);
            }, t2.assertReturnStatement = function(e3, t3) {
              s2("ReturnStatement", e3, t3);
            }, t2.assertSequenceExpression = function(e3, t3) {
              s2("SequenceExpression", e3, t3);
            }, t2.assertParenthesizedExpression = function(e3, t3) {
              s2("ParenthesizedExpression", e3, t3);
            }, t2.assertSwitchCase = function(e3, t3) {
              s2("SwitchCase", e3, t3);
            }, t2.assertSwitchStatement = function(e3, t3) {
              s2("SwitchStatement", e3, t3);
            }, t2.assertThisExpression = function(e3, t3) {
              s2("ThisExpression", e3, t3);
            }, t2.assertThrowStatement = function(e3, t3) {
              s2("ThrowStatement", e3, t3);
            }, t2.assertTryStatement = function(e3, t3) {
              s2("TryStatement", e3, t3);
            }, t2.assertUnaryExpression = function(e3, t3) {
              s2("UnaryExpression", e3, t3);
            }, t2.assertUpdateExpression = function(e3, t3) {
              s2("UpdateExpression", e3, t3);
            }, t2.assertVariableDeclaration = function(e3, t3) {
              s2("VariableDeclaration", e3, t3);
            }, t2.assertVariableDeclarator = function(e3, t3) {
              s2("VariableDeclarator", e3, t3);
            }, t2.assertWhileStatement = function(e3, t3) {
              s2("WhileStatement", e3, t3);
            }, t2.assertWithStatement = function(e3, t3) {
              s2("WithStatement", e3, t3);
            }, t2.assertAssignmentPattern = function(e3, t3) {
              s2("AssignmentPattern", e3, t3);
            }, t2.assertArrayPattern = function(e3, t3) {
              s2("ArrayPattern", e3, t3);
            }, t2.assertArrowFunctionExpression = function(e3, t3) {
              s2("ArrowFunctionExpression", e3, t3);
            }, t2.assertClassBody = function(e3, t3) {
              s2("ClassBody", e3, t3);
            }, t2.assertClassExpression = function(e3, t3) {
              s2("ClassExpression", e3, t3);
            }, t2.assertClassDeclaration = function(e3, t3) {
              s2("ClassDeclaration", e3, t3);
            }, t2.assertExportAllDeclaration = function(e3, t3) {
              s2("ExportAllDeclaration", e3, t3);
            }, t2.assertExportDefaultDeclaration = function(e3, t3) {
              s2("ExportDefaultDeclaration", e3, t3);
            }, t2.assertExportNamedDeclaration = function(e3, t3) {
              s2("ExportNamedDeclaration", e3, t3);
            }, t2.assertExportSpecifier = function(e3, t3) {
              s2("ExportSpecifier", e3, t3);
            }, t2.assertForOfStatement = function(e3, t3) {
              s2("ForOfStatement", e3, t3);
            }, t2.assertImportDeclaration = function(e3, t3) {
              s2("ImportDeclaration", e3, t3);
            }, t2.assertImportDefaultSpecifier = function(e3, t3) {
              s2("ImportDefaultSpecifier", e3, t3);
            }, t2.assertImportNamespaceSpecifier = function(e3, t3) {
              s2("ImportNamespaceSpecifier", e3, t3);
            }, t2.assertImportSpecifier = function(e3, t3) {
              s2("ImportSpecifier", e3, t3);
            }, t2.assertMetaProperty = function(e3, t3) {
              s2("MetaProperty", e3, t3);
            }, t2.assertClassMethod = function(e3, t3) {
              s2("ClassMethod", e3, t3);
            }, t2.assertObjectPattern = function(e3, t3) {
              s2("ObjectPattern", e3, t3);
            }, t2.assertSpreadElement = function(e3, t3) {
              s2("SpreadElement", e3, t3);
            }, t2.assertSuper = function(e3, t3) {
              s2("Super", e3, t3);
            }, t2.assertTaggedTemplateExpression = function(e3, t3) {
              s2("TaggedTemplateExpression", e3, t3);
            }, t2.assertTemplateElement = function(e3, t3) {
              s2("TemplateElement", e3, t3);
            }, t2.assertTemplateLiteral = function(e3, t3) {
              s2("TemplateLiteral", e3, t3);
            }, t2.assertYieldExpression = function(e3, t3) {
              s2("YieldExpression", e3, t3);
            }, t2.assertAwaitExpression = function(e3, t3) {
              s2("AwaitExpression", e3, t3);
            }, t2.assertImport = function(e3, t3) {
              s2("Import", e3, t3);
            }, t2.assertBigIntLiteral = function(e3, t3) {
              s2("BigIntLiteral", e3, t3);
            }, t2.assertExportNamespaceSpecifier = function(e3, t3) {
              s2("ExportNamespaceSpecifier", e3, t3);
            }, t2.assertOptionalMemberExpression = function(e3, t3) {
              s2("OptionalMemberExpression", e3, t3);
            }, t2.assertOptionalCallExpression = function(e3, t3) {
              s2("OptionalCallExpression", e3, t3);
            }, t2.assertAnyTypeAnnotation = function(e3, t3) {
              s2("AnyTypeAnnotation", e3, t3);
            }, t2.assertArrayTypeAnnotation = function(e3, t3) {
              s2("ArrayTypeAnnotation", e3, t3);
            }, t2.assertBooleanTypeAnnotation = function(e3, t3) {
              s2("BooleanTypeAnnotation", e3, t3);
            }, t2.assertBooleanLiteralTypeAnnotation = function(e3, t3) {
              s2("BooleanLiteralTypeAnnotation", e3, t3);
            }, t2.assertNullLiteralTypeAnnotation = function(e3, t3) {
              s2("NullLiteralTypeAnnotation", e3, t3);
            }, t2.assertClassImplements = function(e3, t3) {
              s2("ClassImplements", e3, t3);
            }, t2.assertDeclareClass = function(e3, t3) {
              s2("DeclareClass", e3, t3);
            }, t2.assertDeclareFunction = function(e3, t3) {
              s2("DeclareFunction", e3, t3);
            }, t2.assertDeclareInterface = function(e3, t3) {
              s2("DeclareInterface", e3, t3);
            }, t2.assertDeclareModule = function(e3, t3) {
              s2("DeclareModule", e3, t3);
            }, t2.assertDeclareModuleExports = function(e3, t3) {
              s2("DeclareModuleExports", e3, t3);
            }, t2.assertDeclareTypeAlias = function(e3, t3) {
              s2("DeclareTypeAlias", e3, t3);
            }, t2.assertDeclareOpaqueType = function(e3, t3) {
              s2("DeclareOpaqueType", e3, t3);
            }, t2.assertDeclareVariable = function(e3, t3) {
              s2("DeclareVariable", e3, t3);
            }, t2.assertDeclareExportDeclaration = function(e3, t3) {
              s2("DeclareExportDeclaration", e3, t3);
            }, t2.assertDeclareExportAllDeclaration = function(e3, t3) {
              s2("DeclareExportAllDeclaration", e3, t3);
            }, t2.assertDeclaredPredicate = function(e3, t3) {
              s2("DeclaredPredicate", e3, t3);
            }, t2.assertExistsTypeAnnotation = function(e3, t3) {
              s2("ExistsTypeAnnotation", e3, t3);
            }, t2.assertFunctionTypeAnnotation = function(e3, t3) {
              s2("FunctionTypeAnnotation", e3, t3);
            }, t2.assertFunctionTypeParam = function(e3, t3) {
              s2("FunctionTypeParam", e3, t3);
            }, t2.assertGenericTypeAnnotation = function(e3, t3) {
              s2("GenericTypeAnnotation", e3, t3);
            }, t2.assertInferredPredicate = function(e3, t3) {
              s2("InferredPredicate", e3, t3);
            }, t2.assertInterfaceExtends = function(e3, t3) {
              s2("InterfaceExtends", e3, t3);
            }, t2.assertInterfaceDeclaration = function(e3, t3) {
              s2("InterfaceDeclaration", e3, t3);
            }, t2.assertInterfaceTypeAnnotation = function(e3, t3) {
              s2("InterfaceTypeAnnotation", e3, t3);
            }, t2.assertIntersectionTypeAnnotation = function(e3, t3) {
              s2("IntersectionTypeAnnotation", e3, t3);
            }, t2.assertMixedTypeAnnotation = function(e3, t3) {
              s2("MixedTypeAnnotation", e3, t3);
            }, t2.assertEmptyTypeAnnotation = function(e3, t3) {
              s2("EmptyTypeAnnotation", e3, t3);
            }, t2.assertNullableTypeAnnotation = function(e3, t3) {
              s2("NullableTypeAnnotation", e3, t3);
            }, t2.assertNumberLiteralTypeAnnotation = function(e3, t3) {
              s2("NumberLiteralTypeAnnotation", e3, t3);
            }, t2.assertNumberTypeAnnotation = function(e3, t3) {
              s2("NumberTypeAnnotation", e3, t3);
            }, t2.assertObjectTypeAnnotation = function(e3, t3) {
              s2("ObjectTypeAnnotation", e3, t3);
            }, t2.assertObjectTypeInternalSlot = function(e3, t3) {
              s2("ObjectTypeInternalSlot", e3, t3);
            }, t2.assertObjectTypeCallProperty = function(e3, t3) {
              s2("ObjectTypeCallProperty", e3, t3);
            }, t2.assertObjectTypeIndexer = function(e3, t3) {
              s2("ObjectTypeIndexer", e3, t3);
            }, t2.assertObjectTypeProperty = function(e3, t3) {
              s2("ObjectTypeProperty", e3, t3);
            }, t2.assertObjectTypeSpreadProperty = function(e3, t3) {
              s2("ObjectTypeSpreadProperty", e3, t3);
            }, t2.assertOpaqueType = function(e3, t3) {
              s2("OpaqueType", e3, t3);
            }, t2.assertQualifiedTypeIdentifier = function(e3, t3) {
              s2("QualifiedTypeIdentifier", e3, t3);
            }, t2.assertStringLiteralTypeAnnotation = function(e3, t3) {
              s2("StringLiteralTypeAnnotation", e3, t3);
            }, t2.assertStringTypeAnnotation = function(e3, t3) {
              s2("StringTypeAnnotation", e3, t3);
            }, t2.assertSymbolTypeAnnotation = function(e3, t3) {
              s2("SymbolTypeAnnotation", e3, t3);
            }, t2.assertThisTypeAnnotation = function(e3, t3) {
              s2("ThisTypeAnnotation", e3, t3);
            }, t2.assertTupleTypeAnnotation = function(e3, t3) {
              s2("TupleTypeAnnotation", e3, t3);
            }, t2.assertTypeofTypeAnnotation = function(e3, t3) {
              s2("TypeofTypeAnnotation", e3, t3);
            }, t2.assertTypeAlias = function(e3, t3) {
              s2("TypeAlias", e3, t3);
            }, t2.assertTypeAnnotation = function(e3, t3) {
              s2("TypeAnnotation", e3, t3);
            }, t2.assertTypeCastExpression = function(e3, t3) {
              s2("TypeCastExpression", e3, t3);
            }, t2.assertTypeParameter = function(e3, t3) {
              s2("TypeParameter", e3, t3);
            }, t2.assertTypeParameterDeclaration = function(e3, t3) {
              s2("TypeParameterDeclaration", e3, t3);
            }, t2.assertTypeParameterInstantiation = function(e3, t3) {
              s2("TypeParameterInstantiation", e3, t3);
            }, t2.assertUnionTypeAnnotation = function(e3, t3) {
              s2("UnionTypeAnnotation", e3, t3);
            }, t2.assertVariance = function(e3, t3) {
              s2("Variance", e3, t3);
            }, t2.assertVoidTypeAnnotation = function(e3, t3) {
              s2("VoidTypeAnnotation", e3, t3);
            }, t2.assertEnumDeclaration = function(e3, t3) {
              s2("EnumDeclaration", e3, t3);
            }, t2.assertEnumBooleanBody = function(e3, t3) {
              s2("EnumBooleanBody", e3, t3);
            }, t2.assertEnumNumberBody = function(e3, t3) {
              s2("EnumNumberBody", e3, t3);
            }, t2.assertEnumStringBody = function(e3, t3) {
              s2("EnumStringBody", e3, t3);
            }, t2.assertEnumSymbolBody = function(e3, t3) {
              s2("EnumSymbolBody", e3, t3);
            }, t2.assertEnumBooleanMember = function(e3, t3) {
              s2("EnumBooleanMember", e3, t3);
            }, t2.assertEnumNumberMember = function(e3, t3) {
              s2("EnumNumberMember", e3, t3);
            }, t2.assertEnumStringMember = function(e3, t3) {
              s2("EnumStringMember", e3, t3);
            }, t2.assertEnumDefaultedMember = function(e3, t3) {
              s2("EnumDefaultedMember", e3, t3);
            }, t2.assertIndexedAccessType = function(e3, t3) {
              s2("IndexedAccessType", e3, t3);
            }, t2.assertOptionalIndexedAccessType = function(e3, t3) {
              s2("OptionalIndexedAccessType", e3, t3);
            }, t2.assertJSXAttribute = function(e3, t3) {
              s2("JSXAttribute", e3, t3);
            }, t2.assertJSXClosingElement = function(e3, t3) {
              s2("JSXClosingElement", e3, t3);
            }, t2.assertJSXElement = function(e3, t3) {
              s2("JSXElement", e3, t3);
            }, t2.assertJSXEmptyExpression = function(e3, t3) {
              s2("JSXEmptyExpression", e3, t3);
            }, t2.assertJSXExpressionContainer = function(e3, t3) {
              s2("JSXExpressionContainer", e3, t3);
            }, t2.assertJSXSpreadChild = function(e3, t3) {
              s2("JSXSpreadChild", e3, t3);
            }, t2.assertJSXIdentifier = function(e3, t3) {
              s2("JSXIdentifier", e3, t3);
            }, t2.assertJSXMemberExpression = function(e3, t3) {
              s2("JSXMemberExpression", e3, t3);
            }, t2.assertJSXNamespacedName = function(e3, t3) {
              s2("JSXNamespacedName", e3, t3);
            }, t2.assertJSXOpeningElement = function(e3, t3) {
              s2("JSXOpeningElement", e3, t3);
            }, t2.assertJSXSpreadAttribute = function(e3, t3) {
              s2("JSXSpreadAttribute", e3, t3);
            }, t2.assertJSXText = function(e3, t3) {
              s2("JSXText", e3, t3);
            }, t2.assertJSXFragment = function(e3, t3) {
              s2("JSXFragment", e3, t3);
            }, t2.assertJSXOpeningFragment = function(e3, t3) {
              s2("JSXOpeningFragment", e3, t3);
            }, t2.assertJSXClosingFragment = function(e3, t3) {
              s2("JSXClosingFragment", e3, t3);
            }, t2.assertNoop = function(e3, t3) {
              s2("Noop", e3, t3);
            }, t2.assertPlaceholder = function(e3, t3) {
              s2("Placeholder", e3, t3);
            }, t2.assertV8IntrinsicIdentifier = function(e3, t3) {
              s2("V8IntrinsicIdentifier", e3, t3);
            }, t2.assertArgumentPlaceholder = function(e3, t3) {
              s2("ArgumentPlaceholder", e3, t3);
            }, t2.assertBindExpression = function(e3, t3) {
              s2("BindExpression", e3, t3);
            }, t2.assertClassProperty = function(e3, t3) {
              s2("ClassProperty", e3, t3);
            }, t2.assertPipelineTopicExpression = function(e3, t3) {
              s2("PipelineTopicExpression", e3, t3);
            }, t2.assertPipelineBareFunction = function(e3, t3) {
              s2("PipelineBareFunction", e3, t3);
            }, t2.assertPipelinePrimaryTopicReference = function(e3, t3) {
              s2("PipelinePrimaryTopicReference", e3, t3);
            }, t2.assertClassPrivateProperty = function(e3, t3) {
              s2("ClassPrivateProperty", e3, t3);
            }, t2.assertClassPrivateMethod = function(e3, t3) {
              s2("ClassPrivateMethod", e3, t3);
            }, t2.assertImportAttribute = function(e3, t3) {
              s2("ImportAttribute", e3, t3);
            }, t2.assertDecorator = function(e3, t3) {
              s2("Decorator", e3, t3);
            }, t2.assertDoExpression = function(e3, t3) {
              s2("DoExpression", e3, t3);
            }, t2.assertExportDefaultSpecifier = function(e3, t3) {
              s2("ExportDefaultSpecifier", e3, t3);
            }, t2.assertPrivateName = function(e3, t3) {
              s2("PrivateName", e3, t3);
            }, t2.assertRecordExpression = function(e3, t3) {
              s2("RecordExpression", e3, t3);
            }, t2.assertTupleExpression = function(e3, t3) {
              s2("TupleExpression", e3, t3);
            }, t2.assertDecimalLiteral = function(e3, t3) {
              s2("DecimalLiteral", e3, t3);
            }, t2.assertStaticBlock = function(e3, t3) {
              s2("StaticBlock", e3, t3);
            }, t2.assertModuleExpression = function(e3, t3) {
              s2("ModuleExpression", e3, t3);
            }, t2.assertTSParameterProperty = function(e3, t3) {
              s2("TSParameterProperty", e3, t3);
            }, t2.assertTSDeclareFunction = function(e3, t3) {
              s2("TSDeclareFunction", e3, t3);
            }, t2.assertTSDeclareMethod = function(e3, t3) {
              s2("TSDeclareMethod", e3, t3);
            }, t2.assertTSQualifiedName = function(e3, t3) {
              s2("TSQualifiedName", e3, t3);
            }, t2.assertTSCallSignatureDeclaration = function(e3, t3) {
              s2("TSCallSignatureDeclaration", e3, t3);
            }, t2.assertTSConstructSignatureDeclaration = function(e3, t3) {
              s2("TSConstructSignatureDeclaration", e3, t3);
            }, t2.assertTSPropertySignature = function(e3, t3) {
              s2("TSPropertySignature", e3, t3);
            }, t2.assertTSMethodSignature = function(e3, t3) {
              s2("TSMethodSignature", e3, t3);
            }, t2.assertTSIndexSignature = function(e3, t3) {
              s2("TSIndexSignature", e3, t3);
            }, t2.assertTSAnyKeyword = function(e3, t3) {
              s2("TSAnyKeyword", e3, t3);
            }, t2.assertTSBooleanKeyword = function(e3, t3) {
              s2("TSBooleanKeyword", e3, t3);
            }, t2.assertTSBigIntKeyword = function(e3, t3) {
              s2("TSBigIntKeyword", e3, t3);
            }, t2.assertTSIntrinsicKeyword = function(e3, t3) {
              s2("TSIntrinsicKeyword", e3, t3);
            }, t2.assertTSNeverKeyword = function(e3, t3) {
              s2("TSNeverKeyword", e3, t3);
            }, t2.assertTSNullKeyword = function(e3, t3) {
              s2("TSNullKeyword", e3, t3);
            }, t2.assertTSNumberKeyword = function(e3, t3) {
              s2("TSNumberKeyword", e3, t3);
            }, t2.assertTSObjectKeyword = function(e3, t3) {
              s2("TSObjectKeyword", e3, t3);
            }, t2.assertTSStringKeyword = function(e3, t3) {
              s2("TSStringKeyword", e3, t3);
            }, t2.assertTSSymbolKeyword = function(e3, t3) {
              s2("TSSymbolKeyword", e3, t3);
            }, t2.assertTSUndefinedKeyword = function(e3, t3) {
              s2("TSUndefinedKeyword", e3, t3);
            }, t2.assertTSUnknownKeyword = function(e3, t3) {
              s2("TSUnknownKeyword", e3, t3);
            }, t2.assertTSVoidKeyword = function(e3, t3) {
              s2("TSVoidKeyword", e3, t3);
            }, t2.assertTSThisType = function(e3, t3) {
              s2("TSThisType", e3, t3);
            }, t2.assertTSFunctionType = function(e3, t3) {
              s2("TSFunctionType", e3, t3);
            }, t2.assertTSConstructorType = function(e3, t3) {
              s2("TSConstructorType", e3, t3);
            }, t2.assertTSTypeReference = function(e3, t3) {
              s2("TSTypeReference", e3, t3);
            }, t2.assertTSTypePredicate = function(e3, t3) {
              s2("TSTypePredicate", e3, t3);
            }, t2.assertTSTypeQuery = function(e3, t3) {
              s2("TSTypeQuery", e3, t3);
            }, t2.assertTSTypeLiteral = function(e3, t3) {
              s2("TSTypeLiteral", e3, t3);
            }, t2.assertTSArrayType = function(e3, t3) {
              s2("TSArrayType", e3, t3);
            }, t2.assertTSTupleType = function(e3, t3) {
              s2("TSTupleType", e3, t3);
            }, t2.assertTSOptionalType = function(e3, t3) {
              s2("TSOptionalType", e3, t3);
            }, t2.assertTSRestType = function(e3, t3) {
              s2("TSRestType", e3, t3);
            }, t2.assertTSNamedTupleMember = function(e3, t3) {
              s2("TSNamedTupleMember", e3, t3);
            }, t2.assertTSUnionType = function(e3, t3) {
              s2("TSUnionType", e3, t3);
            }, t2.assertTSIntersectionType = function(e3, t3) {
              s2("TSIntersectionType", e3, t3);
            }, t2.assertTSConditionalType = function(e3, t3) {
              s2("TSConditionalType", e3, t3);
            }, t2.assertTSInferType = function(e3, t3) {
              s2("TSInferType", e3, t3);
            }, t2.assertTSParenthesizedType = function(e3, t3) {
              s2("TSParenthesizedType", e3, t3);
            }, t2.assertTSTypeOperator = function(e3, t3) {
              s2("TSTypeOperator", e3, t3);
            }, t2.assertTSIndexedAccessType = function(e3, t3) {
              s2("TSIndexedAccessType", e3, t3);
            }, t2.assertTSMappedType = function(e3, t3) {
              s2("TSMappedType", e3, t3);
            }, t2.assertTSLiteralType = function(e3, t3) {
              s2("TSLiteralType", e3, t3);
            }, t2.assertTSExpressionWithTypeArguments = function(e3, t3) {
              s2("TSExpressionWithTypeArguments", e3, t3);
            }, t2.assertTSInterfaceDeclaration = function(e3, t3) {
              s2("TSInterfaceDeclaration", e3, t3);
            }, t2.assertTSInterfaceBody = function(e3, t3) {
              s2("TSInterfaceBody", e3, t3);
            }, t2.assertTSTypeAliasDeclaration = function(e3, t3) {
              s2("TSTypeAliasDeclaration", e3, t3);
            }, t2.assertTSAsExpression = function(e3, t3) {
              s2("TSAsExpression", e3, t3);
            }, t2.assertTSTypeAssertion = function(e3, t3) {
              s2("TSTypeAssertion", e3, t3);
            }, t2.assertTSEnumDeclaration = function(e3, t3) {
              s2("TSEnumDeclaration", e3, t3);
            }, t2.assertTSEnumMember = function(e3, t3) {
              s2("TSEnumMember", e3, t3);
            }, t2.assertTSModuleDeclaration = function(e3, t3) {
              s2("TSModuleDeclaration", e3, t3);
            }, t2.assertTSModuleBlock = function(e3, t3) {
              s2("TSModuleBlock", e3, t3);
            }, t2.assertTSImportType = function(e3, t3) {
              s2("TSImportType", e3, t3);
            }, t2.assertTSImportEqualsDeclaration = function(e3, t3) {
              s2("TSImportEqualsDeclaration", e3, t3);
            }, t2.assertTSExternalModuleReference = function(e3, t3) {
              s2("TSExternalModuleReference", e3, t3);
            }, t2.assertTSNonNullExpression = function(e3, t3) {
              s2("TSNonNullExpression", e3, t3);
            }, t2.assertTSExportAssignment = function(e3, t3) {
              s2("TSExportAssignment", e3, t3);
            }, t2.assertTSNamespaceExportDeclaration = function(e3, t3) {
              s2("TSNamespaceExportDeclaration", e3, t3);
            }, t2.assertTSTypeAnnotation = function(e3, t3) {
              s2("TSTypeAnnotation", e3, t3);
            }, t2.assertTSTypeParameterInstantiation = function(e3, t3) {
              s2("TSTypeParameterInstantiation", e3, t3);
            }, t2.assertTSTypeParameterDeclaration = function(e3, t3) {
              s2("TSTypeParameterDeclaration", e3, t3);
            }, t2.assertTSTypeParameter = function(e3, t3) {
              s2("TSTypeParameter", e3, t3);
            }, t2.assertExpression = function(e3, t3) {
              s2("Expression", e3, t3);
            }, t2.assertBinary = function(e3, t3) {
              s2("Binary", e3, t3);
            }, t2.assertScopable = function(e3, t3) {
              s2("Scopable", e3, t3);
            }, t2.assertBlockParent = function(e3, t3) {
              s2("BlockParent", e3, t3);
            }, t2.assertBlock = function(e3, t3) {
              s2("Block", e3, t3);
            }, t2.assertStatement = function(e3, t3) {
              s2("Statement", e3, t3);
            }, t2.assertTerminatorless = function(e3, t3) {
              s2("Terminatorless", e3, t3);
            }, t2.assertCompletionStatement = function(e3, t3) {
              s2("CompletionStatement", e3, t3);
            }, t2.assertConditional = function(e3, t3) {
              s2("Conditional", e3, t3);
            }, t2.assertLoop = function(e3, t3) {
              s2("Loop", e3, t3);
            }, t2.assertWhile = function(e3, t3) {
              s2("While", e3, t3);
            }, t2.assertExpressionWrapper = function(e3, t3) {
              s2("ExpressionWrapper", e3, t3);
            }, t2.assertFor = function(e3, t3) {
              s2("For", e3, t3);
            }, t2.assertForXStatement = function(e3, t3) {
              s2("ForXStatement", e3, t3);
            }, t2.assertFunction = function(e3, t3) {
              s2("Function", e3, t3);
            }, t2.assertFunctionParent = function(e3, t3) {
              s2("FunctionParent", e3, t3);
            }, t2.assertPureish = function(e3, t3) {
              s2("Pureish", e3, t3);
            }, t2.assertDeclaration = function(e3, t3) {
              s2("Declaration", e3, t3);
            }, t2.assertPatternLike = function(e3, t3) {
              s2("PatternLike", e3, t3);
            }, t2.assertLVal = function(e3, t3) {
              s2("LVal", e3, t3);
            }, t2.assertTSEntityName = function(e3, t3) {
              s2("TSEntityName", e3, t3);
            }, t2.assertLiteral = function(e3, t3) {
              s2("Literal", e3, t3);
            }, t2.assertImmutable = function(e3, t3) {
              s2("Immutable", e3, t3);
            }, t2.assertUserWhitespacable = function(e3, t3) {
              s2("UserWhitespacable", e3, t3);
            }, t2.assertMethod = function(e3, t3) {
              s2("Method", e3, t3);
            }, t2.assertObjectMember = function(e3, t3) {
              s2("ObjectMember", e3, t3);
            }, t2.assertProperty = function(e3, t3) {
              s2("Property", e3, t3);
            }, t2.assertUnaryLike = function(e3, t3) {
              s2("UnaryLike", e3, t3);
            }, t2.assertPattern = function(e3, t3) {
              s2("Pattern", e3, t3);
            }, t2.assertClass = function(e3, t3) {
              s2("Class", e3, t3);
            }, t2.assertModuleDeclaration = function(e3, t3) {
              s2("ModuleDeclaration", e3, t3);
            }, t2.assertExportDeclaration = function(e3, t3) {
              s2("ExportDeclaration", e3, t3);
            }, t2.assertModuleSpecifier = function(e3, t3) {
              s2("ModuleSpecifier", e3, t3);
            }, t2.assertFlow = function(e3, t3) {
              s2("Flow", e3, t3);
            }, t2.assertFlowType = function(e3, t3) {
              s2("FlowType", e3, t3);
            }, t2.assertFlowBaseAnnotation = function(e3, t3) {
              s2("FlowBaseAnnotation", e3, t3);
            }, t2.assertFlowDeclaration = function(e3, t3) {
              s2("FlowDeclaration", e3, t3);
            }, t2.assertFlowPredicate = function(e3, t3) {
              s2("FlowPredicate", e3, t3);
            }, t2.assertEnumBody = function(e3, t3) {
              s2("EnumBody", e3, t3);
            }, t2.assertEnumMember = function(e3, t3) {
              s2("EnumMember", e3, t3);
            }, t2.assertJSX = function(e3, t3) {
              s2("JSX", e3, t3);
            }, t2.assertPrivate = function(e3, t3) {
              s2("Private", e3, t3);
            }, t2.assertTSTypeElement = function(e3, t3) {
              s2("TSTypeElement", e3, t3);
            }, t2.assertTSType = function(e3, t3) {
              s2("TSType", e3, t3);
            }, t2.assertTSBaseType = function(e3, t3) {
              s2("TSBaseType", e3, t3);
            }, t2.assertNumberLiteral = function(e3, t3) {
              s2("NumberLiteral", e3, t3);
            }, t2.assertRegexLiteral = function(e3, t3) {
              s2("RegexLiteral", e3, t3);
            }, t2.assertRestProperty = function(e3, t3) {
              s2("RestProperty", e3, t3);
            }, t2.assertSpreadProperty = function(e3, t3) {
              s2("SpreadProperty", e3, t3);
            };
            var n = r2(62);
            function s2(e3, t3, r3) {
              if (!(0, n.default)(e3, t3, r3))
                throw new Error(`Expected type "${e3}" with option ${JSON.stringify(r3)}, but instead got "${t3.type}".`);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              if (e3 === "string")
                return (0, n.stringTypeAnnotation)();
              if (e3 === "number")
                return (0, n.numberTypeAnnotation)();
              if (e3 === "undefined")
                return (0, n.voidTypeAnnotation)();
              if (e3 === "boolean")
                return (0, n.booleanTypeAnnotation)();
              if (e3 === "function")
                return (0, n.genericTypeAnnotation)((0, n.identifier)("Function"));
              if (e3 === "object")
                return (0, n.genericTypeAnnotation)((0, n.identifier)("Object"));
              if (e3 === "symbol")
                return (0, n.genericTypeAnnotation)((0, n.identifier)("Symbol"));
              if (e3 === "bigint")
                return (0, n.anyTypeAnnotation)();
              throw new Error("Invalid typeof value: " + e3);
            };
            var n = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = (0, s2.default)(e3);
              return t3.length === 1 ? t3[0] : (0, n.unionTypeAnnotation)(t3);
            };
            var n = r2(6), s2 = r2(219);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = e3.map((e4) => e4.typeAnnotation), r3 = (0, s2.default)(t3);
              return r3.length === 1 ? r3[0] : (0, n.tsUnionType)(r3);
            };
            var n = r2(6), s2 = r2(380);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = {}, r3 = {}, s2 = [], i = [];
              for (let t4 = 0; t4 < e3.length; t4++) {
                const o = e3[t4];
                if (o && !(i.indexOf(o) >= 0)) {
                  if ((0, n.isTSAnyKeyword)(o))
                    return [o];
                  (0, n.isTSBaseType)(o) ? r3[o.type] = o : (0, n.isTSUnionType)(o) ? s2.indexOf(o.types) < 0 && (e3 = e3.concat(o.types), s2.push(o.types)) : i.push(o);
                }
              }
              for (const e4 of Object.keys(r3))
                i.push(r3[e4]);
              for (const e4 of Object.keys(t3))
                i.push(t3[e4]);
              return i;
            };
            var n = r2(1);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), Object.defineProperty(t2, "ArrayExpression", { enumerable: true, get: function() {
              return n.arrayExpression;
            } }), Object.defineProperty(t2, "AssignmentExpression", { enumerable: true, get: function() {
              return n.assignmentExpression;
            } }), Object.defineProperty(t2, "BinaryExpression", { enumerable: true, get: function() {
              return n.binaryExpression;
            } }), Object.defineProperty(t2, "InterpreterDirective", { enumerable: true, get: function() {
              return n.interpreterDirective;
            } }), Object.defineProperty(t2, "Directive", { enumerable: true, get: function() {
              return n.directive;
            } }), Object.defineProperty(t2, "DirectiveLiteral", { enumerable: true, get: function() {
              return n.directiveLiteral;
            } }), Object.defineProperty(t2, "BlockStatement", { enumerable: true, get: function() {
              return n.blockStatement;
            } }), Object.defineProperty(t2, "BreakStatement", { enumerable: true, get: function() {
              return n.breakStatement;
            } }), Object.defineProperty(t2, "CallExpression", { enumerable: true, get: function() {
              return n.callExpression;
            } }), Object.defineProperty(t2, "CatchClause", { enumerable: true, get: function() {
              return n.catchClause;
            } }), Object.defineProperty(t2, "ConditionalExpression", { enumerable: true, get: function() {
              return n.conditionalExpression;
            } }), Object.defineProperty(t2, "ContinueStatement", { enumerable: true, get: function() {
              return n.continueStatement;
            } }), Object.defineProperty(t2, "DebuggerStatement", { enumerable: true, get: function() {
              return n.debuggerStatement;
            } }), Object.defineProperty(t2, "DoWhileStatement", { enumerable: true, get: function() {
              return n.doWhileStatement;
            } }), Object.defineProperty(t2, "EmptyStatement", { enumerable: true, get: function() {
              return n.emptyStatement;
            } }), Object.defineProperty(t2, "ExpressionStatement", { enumerable: true, get: function() {
              return n.expressionStatement;
            } }), Object.defineProperty(t2, "File", { enumerable: true, get: function() {
              return n.file;
            } }), Object.defineProperty(t2, "ForInStatement", { enumerable: true, get: function() {
              return n.forInStatement;
            } }), Object.defineProperty(t2, "ForStatement", { enumerable: true, get: function() {
              return n.forStatement;
            } }), Object.defineProperty(t2, "FunctionDeclaration", { enumerable: true, get: function() {
              return n.functionDeclaration;
            } }), Object.defineProperty(t2, "FunctionExpression", { enumerable: true, get: function() {
              return n.functionExpression;
            } }), Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
              return n.identifier;
            } }), Object.defineProperty(t2, "IfStatement", { enumerable: true, get: function() {
              return n.ifStatement;
            } }), Object.defineProperty(t2, "LabeledStatement", { enumerable: true, get: function() {
              return n.labeledStatement;
            } }), Object.defineProperty(t2, "StringLiteral", { enumerable: true, get: function() {
              return n.stringLiteral;
            } }), Object.defineProperty(t2, "NumericLiteral", { enumerable: true, get: function() {
              return n.numericLiteral;
            } }), Object.defineProperty(t2, "NullLiteral", { enumerable: true, get: function() {
              return n.nullLiteral;
            } }), Object.defineProperty(t2, "BooleanLiteral", { enumerable: true, get: function() {
              return n.booleanLiteral;
            } }), Object.defineProperty(t2, "RegExpLiteral", { enumerable: true, get: function() {
              return n.regExpLiteral;
            } }), Object.defineProperty(t2, "LogicalExpression", { enumerable: true, get: function() {
              return n.logicalExpression;
            } }), Object.defineProperty(t2, "MemberExpression", { enumerable: true, get: function() {
              return n.memberExpression;
            } }), Object.defineProperty(t2, "NewExpression", { enumerable: true, get: function() {
              return n.newExpression;
            } }), Object.defineProperty(t2, "Program", { enumerable: true, get: function() {
              return n.program;
            } }), Object.defineProperty(t2, "ObjectExpression", { enumerable: true, get: function() {
              return n.objectExpression;
            } }), Object.defineProperty(t2, "ObjectMethod", { enumerable: true, get: function() {
              return n.objectMethod;
            } }), Object.defineProperty(t2, "ObjectProperty", { enumerable: true, get: function() {
              return n.objectProperty;
            } }), Object.defineProperty(t2, "RestElement", { enumerable: true, get: function() {
              return n.restElement;
            } }), Object.defineProperty(t2, "ReturnStatement", { enumerable: true, get: function() {
              return n.returnStatement;
            } }), Object.defineProperty(t2, "SequenceExpression", { enumerable: true, get: function() {
              return n.sequenceExpression;
            } }), Object.defineProperty(t2, "ParenthesizedExpression", { enumerable: true, get: function() {
              return n.parenthesizedExpression;
            } }), Object.defineProperty(t2, "SwitchCase", { enumerable: true, get: function() {
              return n.switchCase;
            } }), Object.defineProperty(t2, "SwitchStatement", { enumerable: true, get: function() {
              return n.switchStatement;
            } }), Object.defineProperty(t2, "ThisExpression", { enumerable: true, get: function() {
              return n.thisExpression;
            } }), Object.defineProperty(t2, "ThrowStatement", { enumerable: true, get: function() {
              return n.throwStatement;
            } }), Object.defineProperty(t2, "TryStatement", { enumerable: true, get: function() {
              return n.tryStatement;
            } }), Object.defineProperty(t2, "UnaryExpression", { enumerable: true, get: function() {
              return n.unaryExpression;
            } }), Object.defineProperty(t2, "UpdateExpression", { enumerable: true, get: function() {
              return n.updateExpression;
            } }), Object.defineProperty(t2, "VariableDeclaration", { enumerable: true, get: function() {
              return n.variableDeclaration;
            } }), Object.defineProperty(t2, "VariableDeclarator", { enumerable: true, get: function() {
              return n.variableDeclarator;
            } }), Object.defineProperty(t2, "WhileStatement", { enumerable: true, get: function() {
              return n.whileStatement;
            } }), Object.defineProperty(t2, "WithStatement", { enumerable: true, get: function() {
              return n.withStatement;
            } }), Object.defineProperty(t2, "AssignmentPattern", { enumerable: true, get: function() {
              return n.assignmentPattern;
            } }), Object.defineProperty(t2, "ArrayPattern", { enumerable: true, get: function() {
              return n.arrayPattern;
            } }), Object.defineProperty(t2, "ArrowFunctionExpression", { enumerable: true, get: function() {
              return n.arrowFunctionExpression;
            } }), Object.defineProperty(t2, "ClassBody", { enumerable: true, get: function() {
              return n.classBody;
            } }), Object.defineProperty(t2, "ClassExpression", { enumerable: true, get: function() {
              return n.classExpression;
            } }), Object.defineProperty(t2, "ClassDeclaration", { enumerable: true, get: function() {
              return n.classDeclaration;
            } }), Object.defineProperty(t2, "ExportAllDeclaration", { enumerable: true, get: function() {
              return n.exportAllDeclaration;
            } }), Object.defineProperty(t2, "ExportDefaultDeclaration", { enumerable: true, get: function() {
              return n.exportDefaultDeclaration;
            } }), Object.defineProperty(t2, "ExportNamedDeclaration", { enumerable: true, get: function() {
              return n.exportNamedDeclaration;
            } }), Object.defineProperty(t2, "ExportSpecifier", { enumerable: true, get: function() {
              return n.exportSpecifier;
            } }), Object.defineProperty(t2, "ForOfStatement", { enumerable: true, get: function() {
              return n.forOfStatement;
            } }), Object.defineProperty(t2, "ImportDeclaration", { enumerable: true, get: function() {
              return n.importDeclaration;
            } }), Object.defineProperty(t2, "ImportDefaultSpecifier", { enumerable: true, get: function() {
              return n.importDefaultSpecifier;
            } }), Object.defineProperty(t2, "ImportNamespaceSpecifier", { enumerable: true, get: function() {
              return n.importNamespaceSpecifier;
            } }), Object.defineProperty(t2, "ImportSpecifier", { enumerable: true, get: function() {
              return n.importSpecifier;
            } }), Object.defineProperty(t2, "MetaProperty", { enumerable: true, get: function() {
              return n.metaProperty;
            } }), Object.defineProperty(t2, "ClassMethod", { enumerable: true, get: function() {
              return n.classMethod;
            } }), Object.defineProperty(t2, "ObjectPattern", { enumerable: true, get: function() {
              return n.objectPattern;
            } }), Object.defineProperty(t2, "SpreadElement", { enumerable: true, get: function() {
              return n.spreadElement;
            } }), Object.defineProperty(t2, "Super", { enumerable: true, get: function() {
              return n.super;
            } }), Object.defineProperty(t2, "TaggedTemplateExpression", { enumerable: true, get: function() {
              return n.taggedTemplateExpression;
            } }), Object.defineProperty(t2, "TemplateElement", { enumerable: true, get: function() {
              return n.templateElement;
            } }), Object.defineProperty(t2, "TemplateLiteral", { enumerable: true, get: function() {
              return n.templateLiteral;
            } }), Object.defineProperty(t2, "YieldExpression", { enumerable: true, get: function() {
              return n.yieldExpression;
            } }), Object.defineProperty(t2, "AwaitExpression", { enumerable: true, get: function() {
              return n.awaitExpression;
            } }), Object.defineProperty(t2, "Import", { enumerable: true, get: function() {
              return n.import;
            } }), Object.defineProperty(t2, "BigIntLiteral", { enumerable: true, get: function() {
              return n.bigIntLiteral;
            } }), Object.defineProperty(t2, "ExportNamespaceSpecifier", { enumerable: true, get: function() {
              return n.exportNamespaceSpecifier;
            } }), Object.defineProperty(t2, "OptionalMemberExpression", { enumerable: true, get: function() {
              return n.optionalMemberExpression;
            } }), Object.defineProperty(t2, "OptionalCallExpression", { enumerable: true, get: function() {
              return n.optionalCallExpression;
            } }), Object.defineProperty(t2, "AnyTypeAnnotation", { enumerable: true, get: function() {
              return n.anyTypeAnnotation;
            } }), Object.defineProperty(t2, "ArrayTypeAnnotation", { enumerable: true, get: function() {
              return n.arrayTypeAnnotation;
            } }), Object.defineProperty(t2, "BooleanTypeAnnotation", { enumerable: true, get: function() {
              return n.booleanTypeAnnotation;
            } }), Object.defineProperty(t2, "BooleanLiteralTypeAnnotation", { enumerable: true, get: function() {
              return n.booleanLiteralTypeAnnotation;
            } }), Object.defineProperty(t2, "NullLiteralTypeAnnotation", { enumerable: true, get: function() {
              return n.nullLiteralTypeAnnotation;
            } }), Object.defineProperty(t2, "ClassImplements", { enumerable: true, get: function() {
              return n.classImplements;
            } }), Object.defineProperty(t2, "DeclareClass", { enumerable: true, get: function() {
              return n.declareClass;
            } }), Object.defineProperty(t2, "DeclareFunction", { enumerable: true, get: function() {
              return n.declareFunction;
            } }), Object.defineProperty(t2, "DeclareInterface", { enumerable: true, get: function() {
              return n.declareInterface;
            } }), Object.defineProperty(t2, "DeclareModule", { enumerable: true, get: function() {
              return n.declareModule;
            } }), Object.defineProperty(t2, "DeclareModuleExports", { enumerable: true, get: function() {
              return n.declareModuleExports;
            } }), Object.defineProperty(t2, "DeclareTypeAlias", { enumerable: true, get: function() {
              return n.declareTypeAlias;
            } }), Object.defineProperty(t2, "DeclareOpaqueType", { enumerable: true, get: function() {
              return n.declareOpaqueType;
            } }), Object.defineProperty(t2, "DeclareVariable", { enumerable: true, get: function() {
              return n.declareVariable;
            } }), Object.defineProperty(t2, "DeclareExportDeclaration", { enumerable: true, get: function() {
              return n.declareExportDeclaration;
            } }), Object.defineProperty(t2, "DeclareExportAllDeclaration", { enumerable: true, get: function() {
              return n.declareExportAllDeclaration;
            } }), Object.defineProperty(t2, "DeclaredPredicate", { enumerable: true, get: function() {
              return n.declaredPredicate;
            } }), Object.defineProperty(t2, "ExistsTypeAnnotation", { enumerable: true, get: function() {
              return n.existsTypeAnnotation;
            } }), Object.defineProperty(t2, "FunctionTypeAnnotation", { enumerable: true, get: function() {
              return n.functionTypeAnnotation;
            } }), Object.defineProperty(t2, "FunctionTypeParam", { enumerable: true, get: function() {
              return n.functionTypeParam;
            } }), Object.defineProperty(t2, "GenericTypeAnnotation", { enumerable: true, get: function() {
              return n.genericTypeAnnotation;
            } }), Object.defineProperty(t2, "InferredPredicate", { enumerable: true, get: function() {
              return n.inferredPredicate;
            } }), Object.defineProperty(t2, "InterfaceExtends", { enumerable: true, get: function() {
              return n.interfaceExtends;
            } }), Object.defineProperty(t2, "InterfaceDeclaration", { enumerable: true, get: function() {
              return n.interfaceDeclaration;
            } }), Object.defineProperty(t2, "InterfaceTypeAnnotation", { enumerable: true, get: function() {
              return n.interfaceTypeAnnotation;
            } }), Object.defineProperty(t2, "IntersectionTypeAnnotation", { enumerable: true, get: function() {
              return n.intersectionTypeAnnotation;
            } }), Object.defineProperty(t2, "MixedTypeAnnotation", { enumerable: true, get: function() {
              return n.mixedTypeAnnotation;
            } }), Object.defineProperty(t2, "EmptyTypeAnnotation", { enumerable: true, get: function() {
              return n.emptyTypeAnnotation;
            } }), Object.defineProperty(t2, "NullableTypeAnnotation", { enumerable: true, get: function() {
              return n.nullableTypeAnnotation;
            } }), Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
              return n.numberLiteralTypeAnnotation;
            } }), Object.defineProperty(t2, "NumberTypeAnnotation", { enumerable: true, get: function() {
              return n.numberTypeAnnotation;
            } }), Object.defineProperty(t2, "ObjectTypeAnnotation", { enumerable: true, get: function() {
              return n.objectTypeAnnotation;
            } }), Object.defineProperty(t2, "ObjectTypeInternalSlot", { enumerable: true, get: function() {
              return n.objectTypeInternalSlot;
            } }), Object.defineProperty(t2, "ObjectTypeCallProperty", { enumerable: true, get: function() {
              return n.objectTypeCallProperty;
            } }), Object.defineProperty(t2, "ObjectTypeIndexer", { enumerable: true, get: function() {
              return n.objectTypeIndexer;
            } }), Object.defineProperty(t2, "ObjectTypeProperty", { enumerable: true, get: function() {
              return n.objectTypeProperty;
            } }), Object.defineProperty(t2, "ObjectTypeSpreadProperty", { enumerable: true, get: function() {
              return n.objectTypeSpreadProperty;
            } }), Object.defineProperty(t2, "OpaqueType", { enumerable: true, get: function() {
              return n.opaqueType;
            } }), Object.defineProperty(t2, "QualifiedTypeIdentifier", { enumerable: true, get: function() {
              return n.qualifiedTypeIdentifier;
            } }), Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
              return n.stringLiteralTypeAnnotation;
            } }), Object.defineProperty(t2, "StringTypeAnnotation", { enumerable: true, get: function() {
              return n.stringTypeAnnotation;
            } }), Object.defineProperty(t2, "SymbolTypeAnnotation", { enumerable: true, get: function() {
              return n.symbolTypeAnnotation;
            } }), Object.defineProperty(t2, "ThisTypeAnnotation", { enumerable: true, get: function() {
              return n.thisTypeAnnotation;
            } }), Object.defineProperty(t2, "TupleTypeAnnotation", { enumerable: true, get: function() {
              return n.tupleTypeAnnotation;
            } }), Object.defineProperty(t2, "TypeofTypeAnnotation", { enumerable: true, get: function() {
              return n.typeofTypeAnnotation;
            } }), Object.defineProperty(t2, "TypeAlias", { enumerable: true, get: function() {
              return n.typeAlias;
            } }), Object.defineProperty(t2, "TypeAnnotation", { enumerable: true, get: function() {
              return n.typeAnnotation;
            } }), Object.defineProperty(t2, "TypeCastExpression", { enumerable: true, get: function() {
              return n.typeCastExpression;
            } }), Object.defineProperty(t2, "TypeParameter", { enumerable: true, get: function() {
              return n.typeParameter;
            } }), Object.defineProperty(t2, "TypeParameterDeclaration", { enumerable: true, get: function() {
              return n.typeParameterDeclaration;
            } }), Object.defineProperty(t2, "TypeParameterInstantiation", { enumerable: true, get: function() {
              return n.typeParameterInstantiation;
            } }), Object.defineProperty(t2, "UnionTypeAnnotation", { enumerable: true, get: function() {
              return n.unionTypeAnnotation;
            } }), Object.defineProperty(t2, "Variance", { enumerable: true, get: function() {
              return n.variance;
            } }), Object.defineProperty(t2, "VoidTypeAnnotation", { enumerable: true, get: function() {
              return n.voidTypeAnnotation;
            } }), Object.defineProperty(t2, "EnumDeclaration", { enumerable: true, get: function() {
              return n.enumDeclaration;
            } }), Object.defineProperty(t2, "EnumBooleanBody", { enumerable: true, get: function() {
              return n.enumBooleanBody;
            } }), Object.defineProperty(t2, "EnumNumberBody", { enumerable: true, get: function() {
              return n.enumNumberBody;
            } }), Object.defineProperty(t2, "EnumStringBody", { enumerable: true, get: function() {
              return n.enumStringBody;
            } }), Object.defineProperty(t2, "EnumSymbolBody", { enumerable: true, get: function() {
              return n.enumSymbolBody;
            } }), Object.defineProperty(t2, "EnumBooleanMember", { enumerable: true, get: function() {
              return n.enumBooleanMember;
            } }), Object.defineProperty(t2, "EnumNumberMember", { enumerable: true, get: function() {
              return n.enumNumberMember;
            } }), Object.defineProperty(t2, "EnumStringMember", { enumerable: true, get: function() {
              return n.enumStringMember;
            } }), Object.defineProperty(t2, "EnumDefaultedMember", { enumerable: true, get: function() {
              return n.enumDefaultedMember;
            } }), Object.defineProperty(t2, "IndexedAccessType", { enumerable: true, get: function() {
              return n.indexedAccessType;
            } }), Object.defineProperty(t2, "OptionalIndexedAccessType", { enumerable: true, get: function() {
              return n.optionalIndexedAccessType;
            } }), Object.defineProperty(t2, "JSXAttribute", { enumerable: true, get: function() {
              return n.jsxAttribute;
            } }), Object.defineProperty(t2, "JSXClosingElement", { enumerable: true, get: function() {
              return n.jsxClosingElement;
            } }), Object.defineProperty(t2, "JSXElement", { enumerable: true, get: function() {
              return n.jsxElement;
            } }), Object.defineProperty(t2, "JSXEmptyExpression", { enumerable: true, get: function() {
              return n.jsxEmptyExpression;
            } }), Object.defineProperty(t2, "JSXExpressionContainer", { enumerable: true, get: function() {
              return n.jsxExpressionContainer;
            } }), Object.defineProperty(t2, "JSXSpreadChild", { enumerable: true, get: function() {
              return n.jsxSpreadChild;
            } }), Object.defineProperty(t2, "JSXIdentifier", { enumerable: true, get: function() {
              return n.jsxIdentifier;
            } }), Object.defineProperty(t2, "JSXMemberExpression", { enumerable: true, get: function() {
              return n.jsxMemberExpression;
            } }), Object.defineProperty(t2, "JSXNamespacedName", { enumerable: true, get: function() {
              return n.jsxNamespacedName;
            } }), Object.defineProperty(t2, "JSXOpeningElement", { enumerable: true, get: function() {
              return n.jsxOpeningElement;
            } }), Object.defineProperty(t2, "JSXSpreadAttribute", { enumerable: true, get: function() {
              return n.jsxSpreadAttribute;
            } }), Object.defineProperty(t2, "JSXText", { enumerable: true, get: function() {
              return n.jsxText;
            } }), Object.defineProperty(t2, "JSXFragment", { enumerable: true, get: function() {
              return n.jsxFragment;
            } }), Object.defineProperty(t2, "JSXOpeningFragment", { enumerable: true, get: function() {
              return n.jsxOpeningFragment;
            } }), Object.defineProperty(t2, "JSXClosingFragment", { enumerable: true, get: function() {
              return n.jsxClosingFragment;
            } }), Object.defineProperty(t2, "Noop", { enumerable: true, get: function() {
              return n.noop;
            } }), Object.defineProperty(t2, "Placeholder", { enumerable: true, get: function() {
              return n.placeholder;
            } }), Object.defineProperty(t2, "V8IntrinsicIdentifier", { enumerable: true, get: function() {
              return n.v8IntrinsicIdentifier;
            } }), Object.defineProperty(t2, "ArgumentPlaceholder", { enumerable: true, get: function() {
              return n.argumentPlaceholder;
            } }), Object.defineProperty(t2, "BindExpression", { enumerable: true, get: function() {
              return n.bindExpression;
            } }), Object.defineProperty(t2, "ClassProperty", { enumerable: true, get: function() {
              return n.classProperty;
            } }), Object.defineProperty(t2, "PipelineTopicExpression", { enumerable: true, get: function() {
              return n.pipelineTopicExpression;
            } }), Object.defineProperty(t2, "PipelineBareFunction", { enumerable: true, get: function() {
              return n.pipelineBareFunction;
            } }), Object.defineProperty(t2, "PipelinePrimaryTopicReference", { enumerable: true, get: function() {
              return n.pipelinePrimaryTopicReference;
            } }), Object.defineProperty(t2, "ClassPrivateProperty", { enumerable: true, get: function() {
              return n.classPrivateProperty;
            } }), Object.defineProperty(t2, "ClassPrivateMethod", { enumerable: true, get: function() {
              return n.classPrivateMethod;
            } }), Object.defineProperty(t2, "ImportAttribute", { enumerable: true, get: function() {
              return n.importAttribute;
            } }), Object.defineProperty(t2, "Decorator", { enumerable: true, get: function() {
              return n.decorator;
            } }), Object.defineProperty(t2, "DoExpression", { enumerable: true, get: function() {
              return n.doExpression;
            } }), Object.defineProperty(t2, "ExportDefaultSpecifier", { enumerable: true, get: function() {
              return n.exportDefaultSpecifier;
            } }), Object.defineProperty(t2, "PrivateName", { enumerable: true, get: function() {
              return n.privateName;
            } }), Object.defineProperty(t2, "RecordExpression", { enumerable: true, get: function() {
              return n.recordExpression;
            } }), Object.defineProperty(t2, "TupleExpression", { enumerable: true, get: function() {
              return n.tupleExpression;
            } }), Object.defineProperty(t2, "DecimalLiteral", { enumerable: true, get: function() {
              return n.decimalLiteral;
            } }), Object.defineProperty(t2, "StaticBlock", { enumerable: true, get: function() {
              return n.staticBlock;
            } }), Object.defineProperty(t2, "ModuleExpression", { enumerable: true, get: function() {
              return n.moduleExpression;
            } }), Object.defineProperty(t2, "TSParameterProperty", { enumerable: true, get: function() {
              return n.tsParameterProperty;
            } }), Object.defineProperty(t2, "TSDeclareFunction", { enumerable: true, get: function() {
              return n.tsDeclareFunction;
            } }), Object.defineProperty(t2, "TSDeclareMethod", { enumerable: true, get: function() {
              return n.tsDeclareMethod;
            } }), Object.defineProperty(t2, "TSQualifiedName", { enumerable: true, get: function() {
              return n.tsQualifiedName;
            } }), Object.defineProperty(t2, "TSCallSignatureDeclaration", { enumerable: true, get: function() {
              return n.tsCallSignatureDeclaration;
            } }), Object.defineProperty(t2, "TSConstructSignatureDeclaration", { enumerable: true, get: function() {
              return n.tsConstructSignatureDeclaration;
            } }), Object.defineProperty(t2, "TSPropertySignature", { enumerable: true, get: function() {
              return n.tsPropertySignature;
            } }), Object.defineProperty(t2, "TSMethodSignature", { enumerable: true, get: function() {
              return n.tsMethodSignature;
            } }), Object.defineProperty(t2, "TSIndexSignature", { enumerable: true, get: function() {
              return n.tsIndexSignature;
            } }), Object.defineProperty(t2, "TSAnyKeyword", { enumerable: true, get: function() {
              return n.tsAnyKeyword;
            } }), Object.defineProperty(t2, "TSBooleanKeyword", { enumerable: true, get: function() {
              return n.tsBooleanKeyword;
            } }), Object.defineProperty(t2, "TSBigIntKeyword", { enumerable: true, get: function() {
              return n.tsBigIntKeyword;
            } }), Object.defineProperty(t2, "TSIntrinsicKeyword", { enumerable: true, get: function() {
              return n.tsIntrinsicKeyword;
            } }), Object.defineProperty(t2, "TSNeverKeyword", { enumerable: true, get: function() {
              return n.tsNeverKeyword;
            } }), Object.defineProperty(t2, "TSNullKeyword", { enumerable: true, get: function() {
              return n.tsNullKeyword;
            } }), Object.defineProperty(t2, "TSNumberKeyword", { enumerable: true, get: function() {
              return n.tsNumberKeyword;
            } }), Object.defineProperty(t2, "TSObjectKeyword", { enumerable: true, get: function() {
              return n.tsObjectKeyword;
            } }), Object.defineProperty(t2, "TSStringKeyword", { enumerable: true, get: function() {
              return n.tsStringKeyword;
            } }), Object.defineProperty(t2, "TSSymbolKeyword", { enumerable: true, get: function() {
              return n.tsSymbolKeyword;
            } }), Object.defineProperty(t2, "TSUndefinedKeyword", { enumerable: true, get: function() {
              return n.tsUndefinedKeyword;
            } }), Object.defineProperty(t2, "TSUnknownKeyword", { enumerable: true, get: function() {
              return n.tsUnknownKeyword;
            } }), Object.defineProperty(t2, "TSVoidKeyword", { enumerable: true, get: function() {
              return n.tsVoidKeyword;
            } }), Object.defineProperty(t2, "TSThisType", { enumerable: true, get: function() {
              return n.tsThisType;
            } }), Object.defineProperty(t2, "TSFunctionType", { enumerable: true, get: function() {
              return n.tsFunctionType;
            } }), Object.defineProperty(t2, "TSConstructorType", { enumerable: true, get: function() {
              return n.tsConstructorType;
            } }), Object.defineProperty(t2, "TSTypeReference", { enumerable: true, get: function() {
              return n.tsTypeReference;
            } }), Object.defineProperty(t2, "TSTypePredicate", { enumerable: true, get: function() {
              return n.tsTypePredicate;
            } }), Object.defineProperty(t2, "TSTypeQuery", { enumerable: true, get: function() {
              return n.tsTypeQuery;
            } }), Object.defineProperty(t2, "TSTypeLiteral", { enumerable: true, get: function() {
              return n.tsTypeLiteral;
            } }), Object.defineProperty(t2, "TSArrayType", { enumerable: true, get: function() {
              return n.tsArrayType;
            } }), Object.defineProperty(t2, "TSTupleType", { enumerable: true, get: function() {
              return n.tsTupleType;
            } }), Object.defineProperty(t2, "TSOptionalType", { enumerable: true, get: function() {
              return n.tsOptionalType;
            } }), Object.defineProperty(t2, "TSRestType", { enumerable: true, get: function() {
              return n.tsRestType;
            } }), Object.defineProperty(t2, "TSNamedTupleMember", { enumerable: true, get: function() {
              return n.tsNamedTupleMember;
            } }), Object.defineProperty(t2, "TSUnionType", { enumerable: true, get: function() {
              return n.tsUnionType;
            } }), Object.defineProperty(t2, "TSIntersectionType", { enumerable: true, get: function() {
              return n.tsIntersectionType;
            } }), Object.defineProperty(t2, "TSConditionalType", { enumerable: true, get: function() {
              return n.tsConditionalType;
            } }), Object.defineProperty(t2, "TSInferType", { enumerable: true, get: function() {
              return n.tsInferType;
            } }), Object.defineProperty(t2, "TSParenthesizedType", { enumerable: true, get: function() {
              return n.tsParenthesizedType;
            } }), Object.defineProperty(t2, "TSTypeOperator", { enumerable: true, get: function() {
              return n.tsTypeOperator;
            } }), Object.defineProperty(t2, "TSIndexedAccessType", { enumerable: true, get: function() {
              return n.tsIndexedAccessType;
            } }), Object.defineProperty(t2, "TSMappedType", { enumerable: true, get: function() {
              return n.tsMappedType;
            } }), Object.defineProperty(t2, "TSLiteralType", { enumerable: true, get: function() {
              return n.tsLiteralType;
            } }), Object.defineProperty(t2, "TSExpressionWithTypeArguments", { enumerable: true, get: function() {
              return n.tsExpressionWithTypeArguments;
            } }), Object.defineProperty(t2, "TSInterfaceDeclaration", { enumerable: true, get: function() {
              return n.tsInterfaceDeclaration;
            } }), Object.defineProperty(t2, "TSInterfaceBody", { enumerable: true, get: function() {
              return n.tsInterfaceBody;
            } }), Object.defineProperty(t2, "TSTypeAliasDeclaration", { enumerable: true, get: function() {
              return n.tsTypeAliasDeclaration;
            } }), Object.defineProperty(t2, "TSAsExpression", { enumerable: true, get: function() {
              return n.tsAsExpression;
            } }), Object.defineProperty(t2, "TSTypeAssertion", { enumerable: true, get: function() {
              return n.tsTypeAssertion;
            } }), Object.defineProperty(t2, "TSEnumDeclaration", { enumerable: true, get: function() {
              return n.tsEnumDeclaration;
            } }), Object.defineProperty(t2, "TSEnumMember", { enumerable: true, get: function() {
              return n.tsEnumMember;
            } }), Object.defineProperty(t2, "TSModuleDeclaration", { enumerable: true, get: function() {
              return n.tsModuleDeclaration;
            } }), Object.defineProperty(t2, "TSModuleBlock", { enumerable: true, get: function() {
              return n.tsModuleBlock;
            } }), Object.defineProperty(t2, "TSImportType", { enumerable: true, get: function() {
              return n.tsImportType;
            } }), Object.defineProperty(t2, "TSImportEqualsDeclaration", { enumerable: true, get: function() {
              return n.tsImportEqualsDeclaration;
            } }), Object.defineProperty(t2, "TSExternalModuleReference", { enumerable: true, get: function() {
              return n.tsExternalModuleReference;
            } }), Object.defineProperty(t2, "TSNonNullExpression", { enumerable: true, get: function() {
              return n.tsNonNullExpression;
            } }), Object.defineProperty(t2, "TSExportAssignment", { enumerable: true, get: function() {
              return n.tsExportAssignment;
            } }), Object.defineProperty(t2, "TSNamespaceExportDeclaration", { enumerable: true, get: function() {
              return n.tsNamespaceExportDeclaration;
            } }), Object.defineProperty(t2, "TSTypeAnnotation", { enumerable: true, get: function() {
              return n.tsTypeAnnotation;
            } }), Object.defineProperty(t2, "TSTypeParameterInstantiation", { enumerable: true, get: function() {
              return n.tsTypeParameterInstantiation;
            } }), Object.defineProperty(t2, "TSTypeParameterDeclaration", { enumerable: true, get: function() {
              return n.tsTypeParameterDeclaration;
            } }), Object.defineProperty(t2, "TSTypeParameter", { enumerable: true, get: function() {
              return n.tsTypeParameter;
            } }), Object.defineProperty(t2, "NumberLiteral", { enumerable: true, get: function() {
              return n.numberLiteral;
            } }), Object.defineProperty(t2, "RegexLiteral", { enumerable: true, get: function() {
              return n.regexLiteral;
            } }), Object.defineProperty(t2, "RestProperty", { enumerable: true, get: function() {
              return n.restProperty;
            } }), Object.defineProperty(t2, "SpreadProperty", { enumerable: true, get: function() {
              return n.spreadProperty;
            } });
            var n = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.default)(e3, false);
            };
            var n = r2(26);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.default)(e3);
            };
            var n = r2(26);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.default)(e3, true, true);
            };
            var n = r2(26);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.default)(e3, false, true);
            };
            var n = r2(26);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3, s2) {
              return (0, n.default)(e3, t3, [{ type: s2 ? "CommentLine" : "CommentBlock", value: r3 }]);
            };
            var n = r2(220);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return n.COMMENT_KEYS.forEach((t3) => {
                e3[t3] = null;
              }), e3;
            };
            var n = r2(25);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TSBASETYPE_TYPES = t2.TSTYPE_TYPES = t2.TSTYPEELEMENT_TYPES = t2.PRIVATE_TYPES = t2.JSX_TYPES = t2.ENUMMEMBER_TYPES = t2.ENUMBODY_TYPES = t2.FLOWPREDICATE_TYPES = t2.FLOWDECLARATION_TYPES = t2.FLOWBASEANNOTATION_TYPES = t2.FLOWTYPE_TYPES = t2.FLOW_TYPES = t2.MODULESPECIFIER_TYPES = t2.EXPORTDECLARATION_TYPES = t2.MODULEDECLARATION_TYPES = t2.CLASS_TYPES = t2.PATTERN_TYPES = t2.UNARYLIKE_TYPES = t2.PROPERTY_TYPES = t2.OBJECTMEMBER_TYPES = t2.METHOD_TYPES = t2.USERWHITESPACABLE_TYPES = t2.IMMUTABLE_TYPES = t2.LITERAL_TYPES = t2.TSENTITYNAME_TYPES = t2.LVAL_TYPES = t2.PATTERNLIKE_TYPES = t2.DECLARATION_TYPES = t2.PUREISH_TYPES = t2.FUNCTIONPARENT_TYPES = t2.FUNCTION_TYPES = t2.FORXSTATEMENT_TYPES = t2.FOR_TYPES = t2.EXPRESSIONWRAPPER_TYPES = t2.WHILE_TYPES = t2.LOOP_TYPES = t2.CONDITIONAL_TYPES = t2.COMPLETIONSTATEMENT_TYPES = t2.TERMINATORLESS_TYPES = t2.STATEMENT_TYPES = t2.BLOCK_TYPES = t2.BLOCKPARENT_TYPES = t2.SCOPABLE_TYPES = t2.BINARY_TYPES = t2.EXPRESSION_TYPES = void 0;
            var n = r2(11);
            const s2 = n.FLIPPED_ALIAS_KEYS.Expression;
            t2.EXPRESSION_TYPES = s2;
            const i = n.FLIPPED_ALIAS_KEYS.Binary;
            t2.BINARY_TYPES = i;
            const o = n.FLIPPED_ALIAS_KEYS.Scopable;
            t2.SCOPABLE_TYPES = o;
            const a = n.FLIPPED_ALIAS_KEYS.BlockParent;
            t2.BLOCKPARENT_TYPES = a;
            const l = n.FLIPPED_ALIAS_KEYS.Block;
            t2.BLOCK_TYPES = l;
            const c = n.FLIPPED_ALIAS_KEYS.Statement;
            t2.STATEMENT_TYPES = c;
            const u = n.FLIPPED_ALIAS_KEYS.Terminatorless;
            t2.TERMINATORLESS_TYPES = u;
            const p2 = n.FLIPPED_ALIAS_KEYS.CompletionStatement;
            t2.COMPLETIONSTATEMENT_TYPES = p2;
            const f = n.FLIPPED_ALIAS_KEYS.Conditional;
            t2.CONDITIONAL_TYPES = f;
            const d = n.FLIPPED_ALIAS_KEYS.Loop;
            t2.LOOP_TYPES = d;
            const h3 = n.FLIPPED_ALIAS_KEYS.While;
            t2.WHILE_TYPES = h3;
            const m = n.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
            t2.EXPRESSIONWRAPPER_TYPES = m;
            const y = n.FLIPPED_ALIAS_KEYS.For;
            t2.FOR_TYPES = y;
            const g = n.FLIPPED_ALIAS_KEYS.ForXStatement;
            t2.FORXSTATEMENT_TYPES = g;
            const b = n.FLIPPED_ALIAS_KEYS.Function;
            t2.FUNCTION_TYPES = b;
            const v = n.FLIPPED_ALIAS_KEYS.FunctionParent;
            t2.FUNCTIONPARENT_TYPES = v;
            const E = n.FLIPPED_ALIAS_KEYS.Pureish;
            t2.PUREISH_TYPES = E;
            const x = n.FLIPPED_ALIAS_KEYS.Declaration;
            t2.DECLARATION_TYPES = x;
            const S = n.FLIPPED_ALIAS_KEYS.PatternLike;
            t2.PATTERNLIKE_TYPES = S;
            const T = n.FLIPPED_ALIAS_KEYS.LVal;
            t2.LVAL_TYPES = T;
            const w = n.FLIPPED_ALIAS_KEYS.TSEntityName;
            t2.TSENTITYNAME_TYPES = w;
            const P = n.FLIPPED_ALIAS_KEYS.Literal;
            t2.LITERAL_TYPES = P;
            const A = n.FLIPPED_ALIAS_KEYS.Immutable;
            t2.IMMUTABLE_TYPES = A;
            const O = n.FLIPPED_ALIAS_KEYS.UserWhitespacable;
            t2.USERWHITESPACABLE_TYPES = O;
            const C = n.FLIPPED_ALIAS_KEYS.Method;
            t2.METHOD_TYPES = C;
            const I = n.FLIPPED_ALIAS_KEYS.ObjectMember;
            t2.OBJECTMEMBER_TYPES = I;
            const k2 = n.FLIPPED_ALIAS_KEYS.Property;
            t2.PROPERTY_TYPES = k2;
            const N = n.FLIPPED_ALIAS_KEYS.UnaryLike;
            t2.UNARYLIKE_TYPES = N;
            const _ = n.FLIPPED_ALIAS_KEYS.Pattern;
            t2.PATTERN_TYPES = _;
            const j = n.FLIPPED_ALIAS_KEYS.Class;
            t2.CLASS_TYPES = j;
            const D = n.FLIPPED_ALIAS_KEYS.ModuleDeclaration;
            t2.MODULEDECLARATION_TYPES = D;
            const L = n.FLIPPED_ALIAS_KEYS.ExportDeclaration;
            t2.EXPORTDECLARATION_TYPES = L;
            const M = n.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
            t2.MODULESPECIFIER_TYPES = M;
            const B = n.FLIPPED_ALIAS_KEYS.Flow;
            t2.FLOW_TYPES = B;
            const R = n.FLIPPED_ALIAS_KEYS.FlowType;
            t2.FLOWTYPE_TYPES = R;
            const F = n.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
            t2.FLOWBASEANNOTATION_TYPES = F;
            const U = n.FLIPPED_ALIAS_KEYS.FlowDeclaration;
            t2.FLOWDECLARATION_TYPES = U;
            const $ = n.FLIPPED_ALIAS_KEYS.FlowPredicate;
            t2.FLOWPREDICATE_TYPES = $;
            const q = n.FLIPPED_ALIAS_KEYS.EnumBody;
            t2.ENUMBODY_TYPES = q;
            const V = n.FLIPPED_ALIAS_KEYS.EnumMember;
            t2.ENUMMEMBER_TYPES = V;
            const W = n.FLIPPED_ALIAS_KEYS.JSX;
            t2.JSX_TYPES = W;
            const K = n.FLIPPED_ALIAS_KEYS.Private;
            t2.PRIVATE_TYPES = K;
            const G = n.FLIPPED_ALIAS_KEYS.TSTypeElement;
            t2.TSTYPEELEMENT_TYPES = G;
            const H = n.FLIPPED_ALIAS_KEYS.TSType;
            t2.TSTYPE_TYPES = H;
            const J = n.FLIPPED_ALIAS_KEYS.TSBaseType;
            t2.TSBASETYPE_TYPES = J;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = "body") {
              return e3[t3] = (0, n.default)(e3[t3], e3);
            };
            var n = r2(225);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (e3 = (0, n.default)(e3)) !== "eval" && e3 !== "arguments" || (e3 = "_" + e3), e3;
            };
            var n = r2(226);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = e3.key || e3.property) {
              return !e3.computed && (0, n.isIdentifier)(t3) && (t3 = (0, s2.stringLiteral)(t3.name)), t3;
            };
            var n = r2(1), s2 = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(1);
            t2.default = function(e3) {
              if ((0, n.isExpressionStatement)(e3) && (e3 = e3.expression), (0, n.isExpression)(e3))
                return e3;
              if ((0, n.isClass)(e3) ? e3.type = "ClassExpression" : (0, n.isFunction)(e3) && (e3.type = "FunctionExpression"), !(0, n.isExpression)(e3))
                throw new Error(`cannot turn ${e3.type} to an expression`);
              return e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = o;
            var n = r2(1), s2 = r2(26), i = r2(227);
            function o(e3, t3 = e3.key) {
              let r3;
              return e3.kind === "method" ? o.increment() + "" : (r3 = (0, n.isIdentifier)(t3) ? t3.name : (0, n.isStringLiteral)(t3) ? JSON.stringify(t3.value) : JSON.stringify((0, i.default)((0, s2.default)(t3))), e3.computed && (r3 = `[${r3}]`), e3.static && (r3 = `static:${r3}`), r3);
            }
            o.uid = 0, o.increment = function() {
              return o.uid >= Number.MAX_SAFE_INTEGER ? o.uid = 0 : o.uid++;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              if (e3 == null || !e3.length)
                return;
              const r3 = [], s2 = (0, n.default)(e3, t3, r3);
              if (s2) {
                for (const e4 of r3)
                  t3.push(e4);
                return s2;
              }
            };
            var n = r2(395);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3, a) {
              const l = [];
              let c = true;
              for (const u of t3)
                if ((0, s2.isEmptyStatement)(u) || (c = false), (0, s2.isExpression)(u))
                  l.push(u);
                else if ((0, s2.isExpressionStatement)(u))
                  l.push(u.expression);
                else if ((0, s2.isVariableDeclaration)(u)) {
                  if (u.kind !== "var")
                    return;
                  for (const e4 of u.declarations) {
                    const t4 = (0, n.default)(e4);
                    for (const e5 of Object.keys(t4))
                      a.push({ kind: u.kind, id: (0, o.default)(t4[e5]) });
                    e4.init && l.push((0, i.assignmentExpression)("=", e4.id, e4.init));
                  }
                  c = true;
                } else if ((0, s2.isIfStatement)(u)) {
                  const t4 = u.consequent ? e3([u.consequent], r3, a) : r3.buildUndefinedNode(), n2 = u.alternate ? e3([u.alternate], r3, a) : r3.buildUndefinedNode();
                  if (!t4 || !n2)
                    return;
                  l.push((0, i.conditionalExpression)(u.test, t4, n2));
                } else if ((0, s2.isBlockStatement)(u)) {
                  const t4 = e3(u.body, r3, a);
                  if (!t4)
                    return;
                  l.push(t4);
                } else {
                  if (!(0, s2.isEmptyStatement)(u))
                    return;
                  t3.indexOf(u) === 0 && (c = true);
                }
              return c && l.push(r3.buildUndefinedNode()), l.length === 1 ? l[0] : (0, i.sequenceExpression)(l);
            };
            var n = r2(64), s2 = r2(1), i = r2(6), o = r2(26);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(1), s2 = r2(6);
            t2.default = function(e3, t3) {
              if ((0, n.isStatement)(e3))
                return e3;
              let r3, i = false;
              if ((0, n.isClass)(e3))
                i = true, r3 = "ClassDeclaration";
              else if ((0, n.isFunction)(e3))
                i = true, r3 = "FunctionDeclaration";
              else if ((0, n.isAssignmentExpression)(e3))
                return (0, s2.expressionStatement)(e3);
              if (i && !e3.id && (r3 = false), !r3) {
                if (t3)
                  return false;
                throw new Error(`cannot turn ${e3.type} to a statement`);
              }
              return e3.type = r3, e3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(38), s2 = r2(6);
            t2.default = function e3(t3) {
              if (t3 === void 0)
                return (0, s2.identifier)("undefined");
              if (t3 === true || t3 === false)
                return (0, s2.booleanLiteral)(t3);
              if (t3 === null)
                return (0, s2.nullLiteral)();
              if (typeof t3 == "string")
                return (0, s2.stringLiteral)(t3);
              if (typeof t3 == "number") {
                let e4;
                if (Number.isFinite(t3))
                  e4 = (0, s2.numericLiteral)(Math.abs(t3));
                else {
                  let r3;
                  r3 = Number.isNaN(t3) ? (0, s2.numericLiteral)(0) : (0, s2.numericLiteral)(1), e4 = (0, s2.binaryExpression)("/", r3, (0, s2.numericLiteral)(0));
                }
                return (t3 < 0 || Object.is(t3, -0)) && (e4 = (0, s2.unaryExpression)("-", e4)), e4;
              }
              if (function(e4) {
                return i(e4) === "[object RegExp]";
              }(t3)) {
                const e4 = t3.source, r3 = t3.toString().match(/\/([a-z]+|)$/)[1];
                return (0, s2.regExpLiteral)(e4, r3);
              }
              if (Array.isArray(t3))
                return (0, s2.arrayExpression)(t3.map(e3));
              if (function(e4) {
                if (typeof e4 != "object" || e4 === null || Object.prototype.toString.call(e4) !== "[object Object]")
                  return false;
                const t4 = Object.getPrototypeOf(e4);
                return t4 === null || Object.getPrototypeOf(t4) === null;
              }(t3)) {
                const r3 = [];
                for (const i2 of Object.keys(t3)) {
                  let o;
                  o = (0, n.default)(i2) ? (0, s2.identifier)(i2) : (0, s2.stringLiteral)(i2), r3.push((0, s2.objectProperty)(o, e3(t3[i2])));
                }
                return (0, s2.objectExpression)(r3);
              }
              throw new Error("don't know how to turn this value into a node");
            };
            const i = Function.call.bind(Object.prototype.toString);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3 = false) {
              return e3.object = (0, n.memberExpression)(e3.object, e3.property, e3.computed), e3.property = t3, e3.computed = !!r3, e3;
            };
            var n = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              if (!e3 || !t3)
                return e3;
              for (const r3 of n.INHERIT_KEYS.optional)
                e3[r3] == null && (e3[r3] = t3[r3]);
              for (const r3 of Object.keys(t3))
                r3[0] === "_" && r3 !== "__clone" && (e3[r3] = t3[r3]);
              for (const r3 of n.INHERIT_KEYS.force)
                e3[r3] = t3[r3];
              return (0, s2.default)(e3, t3), e3;
            };
            var n = r2(25), s2 = r2(223);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              return e3.object = (0, n.memberExpression)(t3, e3.object), e3;
            };
            var n = r2(6);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(64);
            t2.default = function(e3, t3) {
              return (0, n.default)(e3, t3, true);
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              typeof t3 == "function" && (t3 = { enter: t3 });
              const { enter: n2, exit: i } = t3;
              s2(e3, n2, i, r3, []);
            };
            var n = r2(11);
            function s2(e3, t3, r3, i, o) {
              const a = n.VISITOR_KEYS[e3.type];
              if (a) {
                t3 && t3(e3, o, i);
                for (const n2 of a) {
                  const a2 = e3[n2];
                  if (Array.isArray(a2))
                    for (let l = 0; l < a2.length; l++) {
                      const c = a2[l];
                      c && (o.push({ node: e3, key: n2, index: l }), s2(c, t3, r3, i, o), o.pop());
                    }
                  else
                    a2 && (o.push({ node: e3, key: n2 }), s2(a2, t3, r3, i, o), o.pop());
                }
                r3 && r3(e3, o, i);
              }
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              if (r3 && e3.type === "Identifier" && t3.type === "ObjectProperty" && r3.type === "ObjectExpression")
                return false;
              const s2 = n.default.keys[t3.type];
              if (s2)
                for (let r4 = 0; r4 < s2.length; r4++) {
                  const n2 = t3[s2[r4]];
                  if (Array.isArray(n2)) {
                    if (n2.indexOf(e3) >= 0)
                      return true;
                  } else if (n2 === e3)
                    return true;
                }
              return false;
            };
            var n = r2(64);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.isFunctionDeclaration)(e3) || (0, n.isClassDeclaration)(e3) || (0, s2.default)(e3);
            };
            var n = r2(1), s2 = r2(230);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return !!(0, n.default)(e3.type, "Immutable") || !!(0, s2.isIdentifier)(e3) && e3.name === "undefined";
            };
            var n = r2(129), s2 = r2(1);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
              if (typeof t3 != "object" || typeof r3 != "object" || t3 == null || r3 == null)
                return t3 === r3;
              if (t3.type !== r3.type)
                return false;
              const s2 = Object.keys(n.NODE_FIELDS[t3.type] || t3.type), i = n.VISITOR_KEYS[t3.type];
              for (const n2 of s2) {
                if (typeof t3[n2] != typeof r3[n2])
                  return false;
                if (t3[n2] != null || r3[n2] != null) {
                  if (t3[n2] == null || r3[n2] == null)
                    return false;
                  if (Array.isArray(t3[n2])) {
                    if (!Array.isArray(r3[n2]))
                      return false;
                    if (t3[n2].length !== r3[n2].length)
                      return false;
                    for (let s3 = 0; s3 < t3[n2].length; s3++)
                      if (!e3(t3[n2][s3], r3[n2][s3]))
                        return false;
                  } else if (typeof t3[n2] != "object" || i != null && i.includes(n2)) {
                    if (!e3(t3[n2], r3[n2]))
                      return false;
                  } else
                    for (const e4 of Object.keys(t3[n2]))
                      if (t3[n2][e4] !== r3[n2][e4])
                        return false;
                }
              }
              return true;
            };
            var n = r2(11);
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r2) {
              switch (t3.type) {
                case "MemberExpression":
                case "JSXMemberExpression":
                case "OptionalMemberExpression":
                  return t3.property === e3 ? !!t3.computed : t3.object === e3;
                case "VariableDeclarator":
                  return t3.init === e3;
                case "ArrowFunctionExpression":
                  return t3.body === e3;
                case "PrivateName":
                  return false;
                case "ClassMethod":
                case "ClassPrivateMethod":
                case "ObjectMethod":
                  if (t3.params.includes(e3))
                    return false;
                case "ObjectProperty":
                case "ClassProperty":
                case "ClassPrivateProperty":
                  return t3.key === e3 ? !!t3.computed : t3.value !== e3 || !r2 || r2.type !== "ObjectPattern";
                case "ClassDeclaration":
                case "ClassExpression":
                  return t3.superClass === e3;
                case "AssignmentExpression":
                case "AssignmentPattern":
                  return t3.right === e3;
                case "LabeledStatement":
                case "CatchClause":
                case "RestElement":
                  return false;
                case "BreakStatement":
                case "ContinueStatement":
                  return false;
                case "FunctionDeclaration":
                case "FunctionExpression":
                  return false;
                case "ExportNamespaceSpecifier":
                case "ExportDefaultSpecifier":
                  return false;
                case "ExportSpecifier":
                  return (r2 == null || !r2.source) && t3.local === e3;
                case "ImportDefaultSpecifier":
                case "ImportNamespaceSpecifier":
                case "ImportSpecifier":
                case "JSXAttribute":
                  return false;
                case "ObjectPattern":
                case "ArrayPattern":
                case "MetaProperty":
                  return false;
                case "ObjectTypeProperty":
                  return t3.key !== e3;
                case "TSEnumMember":
                  return t3.id !== e3;
                case "TSPropertySignature":
                  return t3.key !== e3 || !!t3.computed;
              }
              return true;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              return (!(0, n.isBlockStatement)(e3) || !(0, n.isFunction)(t3) && !(0, n.isCatchClause)(t3)) && (!(!(0, n.isPattern)(e3) || !(0, n.isFunction)(t3) && !(0, n.isCatchClause)(t3)) || (0, n.isScopable)(e3));
            };
            var n = r2(1);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.isImportDefaultSpecifier)(e3) || (0, n.isIdentifier)(e3.imported || e3.exported, { name: "default" });
            };
            var n = r2(1);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.default)(e3) && !s2.has(e3);
            };
            var n = r2(38);
            const s2 = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return (0, n.isVariableDeclaration)(e3, { kind: "var" }) && !e3[s2.BLOCK_SCOPED_SYMBOL];
            };
            var n = r2(1), s2 = r2(25);
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, r2(232);
            var n = r2(132), s2 = r2(0);
            const i = { ReferencedIdentifier({ node: e3 }, t3) {
              e3.name === t3.oldName && (e3.name = t3.newName);
            }, Scope(e3, t3) {
              e3.scope.bindingIdentifierEquals(t3.oldName, t3.binding.identifier) || function(e4) {
                if (!e4.isMethod() || !e4.node.computed)
                  return void e4.skip();
                const t4 = s2.VISITOR_KEYS[e4.type];
                for (const r3 of t4)
                  r3 !== "key" && e4.skipKey(r3);
              }(e3);
            }, "AssignmentExpression|Declaration|VariableDeclarator"(e3, t3) {
              if (e3.isVariableDeclaration())
                return;
              const r3 = e3.getOuterBindingIdentifiers();
              for (const e4 in r3)
                e4 === t3.oldName && (r3[e4].name = t3.newName);
            } };
            t2.default = class {
              constructor(e3, t3, r3) {
                this.newName = r3, this.oldName = t3, this.binding = e3;
              }
              maybeConvertFromExportDeclaration(e3) {
                const t3 = e3.parentPath;
                t3.isExportDeclaration() && (t3.isExportDefaultDeclaration() && !t3.get("declaration").node.id || (0, n.default)(t3));
              }
              maybeConvertFromClassFunctionDeclaration(e3) {
              }
              maybeConvertFromClassFunctionExpression(e3) {
              }
              rename(e3) {
                const { binding: t3, oldName: r3, newName: n2 } = this, { scope: s3, path: o } = t3, a = o.find((e4) => e4.isDeclaration() || e4.isFunctionExpression() || e4.isClassExpression());
                a && a.getOuterBindingIdentifiers()[r3] === t3.identifier && this.maybeConvertFromExportDeclaration(a);
                const l = e3 || s3.block;
                (l == null ? void 0 : l.type) === "SwitchStatement" ? l.cases.forEach((e4) => {
                  s3.traverse(e4, i, this);
                }) : s3.traverse(l, i, this), e3 || (s3.removeOwnBinding(r3), s3.bindings[n2] = t3, this.binding.identifier.name = n2), a && (this.maybeConvertFromClassFunctionDeclaration(a), this.maybeConvertFromClassFunctionExpression(a));
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            e2.exports = r2(415);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('{"builtin":{"Array":false,"ArrayBuffer":false,"Atomics":false,"BigInt":false,"BigInt64Array":false,"BigUint64Array":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"globalThis":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es5":{"Array":false,"Boolean":false,"constructor":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"propertyIsEnumerable":false,"RangeError":false,"ReferenceError":false,"RegExp":false,"String":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false},"es2015":{"Array":false,"ArrayBuffer":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"es2017":{"Array":false,"ArrayBuffer":false,"Atomics":false,"Boolean":false,"constructor":false,"DataView":false,"Date":false,"decodeURI":false,"decodeURIComponent":false,"encodeURI":false,"encodeURIComponent":false,"Error":false,"escape":false,"eval":false,"EvalError":false,"Float32Array":false,"Float64Array":false,"Function":false,"hasOwnProperty":false,"Infinity":false,"Int16Array":false,"Int32Array":false,"Int8Array":false,"isFinite":false,"isNaN":false,"isPrototypeOf":false,"JSON":false,"Map":false,"Math":false,"NaN":false,"Number":false,"Object":false,"parseFloat":false,"parseInt":false,"Promise":false,"propertyIsEnumerable":false,"Proxy":false,"RangeError":false,"ReferenceError":false,"Reflect":false,"RegExp":false,"Set":false,"SharedArrayBuffer":false,"String":false,"Symbol":false,"SyntaxError":false,"toLocaleString":false,"toString":false,"TypeError":false,"Uint16Array":false,"Uint32Array":false,"Uint8Array":false,"Uint8ClampedArray":false,"undefined":false,"unescape":false,"URIError":false,"valueOf":false,"WeakMap":false,"WeakSet":false},"browser":{"AbortController":false,"AbortSignal":false,"addEventListener":false,"alert":false,"AnalyserNode":false,"Animation":false,"AnimationEffectReadOnly":false,"AnimationEffectTiming":false,"AnimationEffectTimingReadOnly":false,"AnimationEvent":false,"AnimationPlaybackEvent":false,"AnimationTimeline":false,"applicationCache":false,"ApplicationCache":false,"ApplicationCacheErrorEvent":false,"atob":false,"Attr":false,"Audio":false,"AudioBuffer":false,"AudioBufferSourceNode":false,"AudioContext":false,"AudioDestinationNode":false,"AudioListener":false,"AudioNode":false,"AudioParam":false,"AudioProcessingEvent":false,"AudioScheduledSourceNode":false,"AudioWorkletGlobalScope ":false,"AudioWorkletNode":false,"AudioWorkletProcessor":false,"BarProp":false,"BaseAudioContext":false,"BatteryManager":false,"BeforeUnloadEvent":false,"BiquadFilterNode":false,"Blob":false,"BlobEvent":false,"blur":false,"BroadcastChannel":false,"btoa":false,"BudgetService":false,"ByteLengthQueuingStrategy":false,"Cache":false,"caches":false,"CacheStorage":false,"cancelAnimationFrame":false,"cancelIdleCallback":false,"CanvasCaptureMediaStreamTrack":false,"CanvasGradient":false,"CanvasPattern":false,"CanvasRenderingContext2D":false,"ChannelMergerNode":false,"ChannelSplitterNode":false,"CharacterData":false,"clearInterval":false,"clearTimeout":false,"clientInformation":false,"ClipboardEvent":false,"close":false,"closed":false,"CloseEvent":false,"Comment":false,"CompositionEvent":false,"confirm":false,"console":false,"ConstantSourceNode":false,"ConvolverNode":false,"CountQueuingStrategy":false,"createImageBitmap":false,"Credential":false,"CredentialsContainer":false,"crypto":false,"Crypto":false,"CryptoKey":false,"CSS":false,"CSSConditionRule":false,"CSSFontFaceRule":false,"CSSGroupingRule":false,"CSSImportRule":false,"CSSKeyframeRule":false,"CSSKeyframesRule":false,"CSSMediaRule":false,"CSSNamespaceRule":false,"CSSPageRule":false,"CSSRule":false,"CSSRuleList":false,"CSSStyleDeclaration":false,"CSSStyleRule":false,"CSSStyleSheet":false,"CSSSupportsRule":false,"CustomElementRegistry":false,"customElements":false,"CustomEvent":false,"DataTransfer":false,"DataTransferItem":false,"DataTransferItemList":false,"defaultstatus":false,"defaultStatus":false,"DelayNode":false,"DeviceMotionEvent":false,"DeviceOrientationEvent":false,"devicePixelRatio":false,"dispatchEvent":false,"document":false,"Document":false,"DocumentFragment":false,"DocumentType":false,"DOMError":false,"DOMException":false,"DOMImplementation":false,"DOMMatrix":false,"DOMMatrixReadOnly":false,"DOMParser":false,"DOMPoint":false,"DOMPointReadOnly":false,"DOMQuad":false,"DOMRect":false,"DOMRectReadOnly":false,"DOMStringList":false,"DOMStringMap":false,"DOMTokenList":false,"DragEvent":false,"DynamicsCompressorNode":false,"Element":false,"ErrorEvent":false,"event":false,"Event":false,"EventSource":false,"EventTarget":false,"external":false,"fetch":false,"File":false,"FileList":false,"FileReader":false,"find":false,"focus":false,"FocusEvent":false,"FontFace":false,"FontFaceSetLoadEvent":false,"FormData":false,"frameElement":false,"frames":false,"GainNode":false,"Gamepad":false,"GamepadButton":false,"GamepadEvent":false,"getComputedStyle":false,"getSelection":false,"HashChangeEvent":false,"Headers":false,"history":false,"History":false,"HTMLAllCollection":false,"HTMLAnchorElement":false,"HTMLAreaElement":false,"HTMLAudioElement":false,"HTMLBaseElement":false,"HTMLBodyElement":false,"HTMLBRElement":false,"HTMLButtonElement":false,"HTMLCanvasElement":false,"HTMLCollection":false,"HTMLContentElement":false,"HTMLDataElement":false,"HTMLDataListElement":false,"HTMLDetailsElement":false,"HTMLDialogElement":false,"HTMLDirectoryElement":false,"HTMLDivElement":false,"HTMLDListElement":false,"HTMLDocument":false,"HTMLElement":false,"HTMLEmbedElement":false,"HTMLFieldSetElement":false,"HTMLFontElement":false,"HTMLFormControlsCollection":false,"HTMLFormElement":false,"HTMLFrameElement":false,"HTMLFrameSetElement":false,"HTMLHeadElement":false,"HTMLHeadingElement":false,"HTMLHRElement":false,"HTMLHtmlElement":false,"HTMLIFrameElement":false,"HTMLImageElement":false,"HTMLInputElement":false,"HTMLLabelElement":false,"HTMLLegendElement":false,"HTMLLIElement":false,"HTMLLinkElement":false,"HTMLMapElement":false,"HTMLMarqueeElement":false,"HTMLMediaElement":false,"HTMLMenuElement":false,"HTMLMetaElement":false,"HTMLMeterElement":false,"HTMLModElement":false,"HTMLObjectElement":false,"HTMLOListElement":false,"HTMLOptGroupElement":false,"HTMLOptionElement":false,"HTMLOptionsCollection":false,"HTMLOutputElement":false,"HTMLParagraphElement":false,"HTMLParamElement":false,"HTMLPictureElement":false,"HTMLPreElement":false,"HTMLProgressElement":false,"HTMLQuoteElement":false,"HTMLScriptElement":false,"HTMLSelectElement":false,"HTMLShadowElement":false,"HTMLSlotElement":false,"HTMLSourceElement":false,"HTMLSpanElement":false,"HTMLStyleElement":false,"HTMLTableCaptionElement":false,"HTMLTableCellElement":false,"HTMLTableColElement":false,"HTMLTableElement":false,"HTMLTableRowElement":false,"HTMLTableSectionElement":false,"HTMLTemplateElement":false,"HTMLTextAreaElement":false,"HTMLTimeElement":false,"HTMLTitleElement":false,"HTMLTrackElement":false,"HTMLUListElement":false,"HTMLUnknownElement":false,"HTMLVideoElement":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"IdleDeadline":false,"IIRFilterNode":false,"Image":false,"ImageBitmap":false,"ImageBitmapRenderingContext":false,"ImageCapture":false,"ImageData":false,"indexedDB":false,"innerHeight":false,"innerWidth":false,"InputEvent":false,"IntersectionObserver":false,"IntersectionObserverEntry":false,"Intl":false,"isSecureContext":false,"KeyboardEvent":false,"KeyframeEffect":false,"KeyframeEffectReadOnly":false,"length":false,"localStorage":false,"location":true,"Location":false,"locationbar":false,"matchMedia":false,"MediaDeviceInfo":false,"MediaDevices":false,"MediaElementAudioSourceNode":false,"MediaEncryptedEvent":false,"MediaError":false,"MediaKeyMessageEvent":false,"MediaKeySession":false,"MediaKeyStatusMap":false,"MediaKeySystemAccess":false,"MediaList":false,"MediaQueryList":false,"MediaQueryListEvent":false,"MediaRecorder":false,"MediaSettingsRange":false,"MediaSource":false,"MediaStream":false,"MediaStreamAudioDestinationNode":false,"MediaStreamAudioSourceNode":false,"MediaStreamEvent":false,"MediaStreamTrack":false,"MediaStreamTrackEvent":false,"menubar":false,"MessageChannel":false,"MessageEvent":false,"MessagePort":false,"MIDIAccess":false,"MIDIConnectionEvent":false,"MIDIInput":false,"MIDIInputMap":false,"MIDIMessageEvent":false,"MIDIOutput":false,"MIDIOutputMap":false,"MIDIPort":false,"MimeType":false,"MimeTypeArray":false,"MouseEvent":false,"moveBy":false,"moveTo":false,"MutationEvent":false,"MutationObserver":false,"MutationRecord":false,"name":false,"NamedNodeMap":false,"NavigationPreloadManager":false,"navigator":false,"Navigator":false,"NetworkInformation":false,"Node":false,"NodeFilter":false,"NodeIterator":false,"NodeList":false,"Notification":false,"OfflineAudioCompletionEvent":false,"OfflineAudioContext":false,"offscreenBuffering":false,"OffscreenCanvas":true,"onabort":true,"onafterprint":true,"onanimationend":true,"onanimationiteration":true,"onanimationstart":true,"onappinstalled":true,"onauxclick":true,"onbeforeinstallprompt":true,"onbeforeprint":true,"onbeforeunload":true,"onblur":true,"oncancel":true,"oncanplay":true,"oncanplaythrough":true,"onchange":true,"onclick":true,"onclose":true,"oncontextmenu":true,"oncuechange":true,"ondblclick":true,"ondevicemotion":true,"ondeviceorientation":true,"ondeviceorientationabsolute":true,"ondrag":true,"ondragend":true,"ondragenter":true,"ondragleave":true,"ondragover":true,"ondragstart":true,"ondrop":true,"ondurationchange":true,"onemptied":true,"onended":true,"onerror":true,"onfocus":true,"ongotpointercapture":true,"onhashchange":true,"oninput":true,"oninvalid":true,"onkeydown":true,"onkeypress":true,"onkeyup":true,"onlanguagechange":true,"onload":true,"onloadeddata":true,"onloadedmetadata":true,"onloadstart":true,"onlostpointercapture":true,"onmessage":true,"onmessageerror":true,"onmousedown":true,"onmouseenter":true,"onmouseleave":true,"onmousemove":true,"onmouseout":true,"onmouseover":true,"onmouseup":true,"onmousewheel":true,"onoffline":true,"ononline":true,"onpagehide":true,"onpageshow":true,"onpause":true,"onplay":true,"onplaying":true,"onpointercancel":true,"onpointerdown":true,"onpointerenter":true,"onpointerleave":true,"onpointermove":true,"onpointerout":true,"onpointerover":true,"onpointerup":true,"onpopstate":true,"onprogress":true,"onratechange":true,"onrejectionhandled":true,"onreset":true,"onresize":true,"onscroll":true,"onsearch":true,"onseeked":true,"onseeking":true,"onselect":true,"onstalled":true,"onstorage":true,"onsubmit":true,"onsuspend":true,"ontimeupdate":true,"ontoggle":true,"ontransitionend":true,"onunhandledrejection":true,"onunload":true,"onvolumechange":true,"onwaiting":true,"onwheel":true,"open":false,"openDatabase":false,"opener":false,"Option":false,"origin":false,"OscillatorNode":false,"outerHeight":false,"outerWidth":false,"PageTransitionEvent":false,"pageXOffset":false,"pageYOffset":false,"PannerNode":false,"parent":false,"Path2D":false,"PaymentAddress":false,"PaymentRequest":false,"PaymentRequestUpdateEvent":false,"PaymentResponse":false,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceLongTaskTiming":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceNavigationTiming":false,"PerformanceObserver":false,"PerformanceObserverEntryList":false,"PerformancePaintTiming":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"PeriodicWave":false,"Permissions":false,"PermissionStatus":false,"personalbar":false,"PhotoCapabilities":false,"Plugin":false,"PluginArray":false,"PointerEvent":false,"PopStateEvent":false,"postMessage":false,"Presentation":false,"PresentationAvailability":false,"PresentationConnection":false,"PresentationConnectionAvailableEvent":false,"PresentationConnectionCloseEvent":false,"PresentationConnectionList":false,"PresentationReceiver":false,"PresentationRequest":false,"print":false,"ProcessingInstruction":false,"ProgressEvent":false,"PromiseRejectionEvent":false,"prompt":false,"PushManager":false,"PushSubscription":false,"PushSubscriptionOptions":false,"queueMicrotask":false,"RadioNodeList":false,"Range":false,"ReadableStream":false,"registerProcessor":false,"RemotePlayback":false,"removeEventListener":false,"Request":false,"requestAnimationFrame":false,"requestIdleCallback":false,"resizeBy":false,"ResizeObserver":false,"ResizeObserverEntry":false,"resizeTo":false,"Response":false,"RTCCertificate":false,"RTCDataChannel":false,"RTCDataChannelEvent":false,"RTCDtlsTransport":false,"RTCIceCandidate":false,"RTCIceGatherer":false,"RTCIceTransport":false,"RTCPeerConnection":false,"RTCPeerConnectionIceEvent":false,"RTCRtpContributingSource":false,"RTCRtpReceiver":false,"RTCRtpSender":false,"RTCSctpTransport":false,"RTCSessionDescription":false,"RTCStatsReport":false,"RTCTrackEvent":false,"screen":false,"Screen":false,"screenLeft":false,"ScreenOrientation":false,"screenTop":false,"screenX":false,"screenY":false,"ScriptProcessorNode":false,"scroll":false,"scrollbars":false,"scrollBy":false,"scrollTo":false,"scrollX":false,"scrollY":false,"SecurityPolicyViolationEvent":false,"Selection":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerRegistration":false,"sessionStorage":false,"setInterval":false,"setTimeout":false,"ShadowRoot":false,"SharedWorker":false,"SourceBuffer":false,"SourceBufferList":false,"speechSynthesis":false,"SpeechSynthesisEvent":false,"SpeechSynthesisUtterance":false,"StaticRange":false,"status":false,"statusbar":false,"StereoPannerNode":false,"stop":false,"Storage":false,"StorageEvent":false,"StorageManager":false,"styleMedia":false,"StyleSheet":false,"StyleSheetList":false,"SubtleCrypto":false,"SVGAElement":false,"SVGAngle":false,"SVGAnimatedAngle":false,"SVGAnimatedBoolean":false,"SVGAnimatedEnumeration":false,"SVGAnimatedInteger":false,"SVGAnimatedLength":false,"SVGAnimatedLengthList":false,"SVGAnimatedNumber":false,"SVGAnimatedNumberList":false,"SVGAnimatedPreserveAspectRatio":false,"SVGAnimatedRect":false,"SVGAnimatedString":false,"SVGAnimatedTransformList":false,"SVGAnimateElement":false,"SVGAnimateMotionElement":false,"SVGAnimateTransformElement":false,"SVGAnimationElement":false,"SVGCircleElement":false,"SVGClipPathElement":false,"SVGComponentTransferFunctionElement":false,"SVGDefsElement":false,"SVGDescElement":false,"SVGDiscardElement":false,"SVGElement":false,"SVGEllipseElement":false,"SVGFEBlendElement":false,"SVGFEColorMatrixElement":false,"SVGFEComponentTransferElement":false,"SVGFECompositeElement":false,"SVGFEConvolveMatrixElement":false,"SVGFEDiffuseLightingElement":false,"SVGFEDisplacementMapElement":false,"SVGFEDistantLightElement":false,"SVGFEDropShadowElement":false,"SVGFEFloodElement":false,"SVGFEFuncAElement":false,"SVGFEFuncBElement":false,"SVGFEFuncGElement":false,"SVGFEFuncRElement":false,"SVGFEGaussianBlurElement":false,"SVGFEImageElement":false,"SVGFEMergeElement":false,"SVGFEMergeNodeElement":false,"SVGFEMorphologyElement":false,"SVGFEOffsetElement":false,"SVGFEPointLightElement":false,"SVGFESpecularLightingElement":false,"SVGFESpotLightElement":false,"SVGFETileElement":false,"SVGFETurbulenceElement":false,"SVGFilterElement":false,"SVGForeignObjectElement":false,"SVGGElement":false,"SVGGeometryElement":false,"SVGGradientElement":false,"SVGGraphicsElement":false,"SVGImageElement":false,"SVGLength":false,"SVGLengthList":false,"SVGLinearGradientElement":false,"SVGLineElement":false,"SVGMarkerElement":false,"SVGMaskElement":false,"SVGMatrix":false,"SVGMetadataElement":false,"SVGMPathElement":false,"SVGNumber":false,"SVGNumberList":false,"SVGPathElement":false,"SVGPatternElement":false,"SVGPoint":false,"SVGPointList":false,"SVGPolygonElement":false,"SVGPolylineElement":false,"SVGPreserveAspectRatio":false,"SVGRadialGradientElement":false,"SVGRect":false,"SVGRectElement":false,"SVGScriptElement":false,"SVGSetElement":false,"SVGStopElement":false,"SVGStringList":false,"SVGStyleElement":false,"SVGSVGElement":false,"SVGSwitchElement":false,"SVGSymbolElement":false,"SVGTextContentElement":false,"SVGTextElement":false,"SVGTextPathElement":false,"SVGTextPositioningElement":false,"SVGTitleElement":false,"SVGTransform":false,"SVGTransformList":false,"SVGTSpanElement":false,"SVGUnitTypes":false,"SVGUseElement":false,"SVGViewElement":false,"TaskAttributionTiming":false,"Text":false,"TextDecoder":false,"TextEncoder":false,"TextEvent":false,"TextMetrics":false,"TextTrack":false,"TextTrackCue":false,"TextTrackCueList":false,"TextTrackList":false,"TimeRanges":false,"toolbar":false,"top":false,"Touch":false,"TouchEvent":false,"TouchList":false,"TrackEvent":false,"TransitionEvent":false,"TreeWalker":false,"UIEvent":false,"URL":false,"URLSearchParams":false,"ValidityState":false,"visualViewport":false,"VisualViewport":false,"VTTCue":false,"WaveShaperNode":false,"WebAssembly":false,"WebGL2RenderingContext":false,"WebGLActiveInfo":false,"WebGLBuffer":false,"WebGLContextEvent":false,"WebGLFramebuffer":false,"WebGLProgram":false,"WebGLQuery":false,"WebGLRenderbuffer":false,"WebGLRenderingContext":false,"WebGLSampler":false,"WebGLShader":false,"WebGLShaderPrecisionFormat":false,"WebGLSync":false,"WebGLTexture":false,"WebGLTransformFeedback":false,"WebGLUniformLocation":false,"WebGLVertexArrayObject":false,"WebSocket":false,"WheelEvent":false,"window":false,"Window":false,"Worker":false,"WritableStream":false,"XMLDocument":false,"XMLHttpRequest":false,"XMLHttpRequestEventTarget":false,"XMLHttpRequestUpload":false,"XMLSerializer":false,"XPathEvaluator":false,"XPathExpression":false,"XPathResult":false,"XSLTProcessor":false},"worker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"clearInterval":false,"clearTimeout":false,"close":true,"console":false,"fetch":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":true,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onlanguagechange":true,"onmessage":true,"onoffline":true,"ononline":true,"onrejectionhandled":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"removeEventListener":false,"Request":false,"Response":false,"self":true,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"node":{"__dirname":false,"__filename":false,"Buffer":false,"clearImmediate":false,"clearInterval":false,"clearTimeout":false,"console":false,"exports":true,"global":false,"Intl":false,"module":false,"process":false,"queueMicrotask":false,"require":false,"setImmediate":false,"setInterval":false,"setTimeout":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false},"commonjs":{"exports":true,"global":false,"module":false,"require":false},"amd":{"define":false,"require":false},"mocha":{"after":false,"afterEach":false,"before":false,"beforeEach":false,"context":false,"describe":false,"it":false,"mocha":false,"run":false,"setup":false,"specify":false,"suite":false,"suiteSetup":false,"suiteTeardown":false,"teardown":false,"test":false,"xcontext":false,"xdescribe":false,"xit":false,"xspecify":false},"jasmine":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fail":false,"fdescribe":false,"fit":false,"it":false,"jasmine":false,"pending":false,"runs":false,"spyOn":false,"spyOnProperty":false,"waits":false,"waitsFor":false,"xdescribe":false,"xit":false},"jest":{"afterAll":false,"afterEach":false,"beforeAll":false,"beforeEach":false,"describe":false,"expect":false,"fdescribe":false,"fit":false,"it":false,"jest":false,"pit":false,"require":false,"test":false,"xdescribe":false,"xit":false,"xtest":false},"qunit":{"asyncTest":false,"deepEqual":false,"equal":false,"expect":false,"module":false,"notDeepEqual":false,"notEqual":false,"notOk":false,"notPropEqual":false,"notStrictEqual":false,"ok":false,"propEqual":false,"QUnit":false,"raises":false,"start":false,"stop":false,"strictEqual":false,"test":false,"throws":false},"phantomjs":{"console":true,"exports":true,"phantom":true,"require":true,"WebPage":true},"couch":{"emit":false,"exports":false,"getRow":false,"log":false,"module":false,"provides":false,"require":false,"respond":false,"send":false,"start":false,"sum":false},"rhino":{"defineClass":false,"deserialize":false,"gc":false,"help":false,"importClass":false,"importPackage":false,"java":false,"load":false,"loadClass":false,"Packages":false,"print":false,"quit":false,"readFile":false,"readUrl":false,"runCommand":false,"seal":false,"serialize":false,"spawn":false,"sync":false,"toint32":false,"version":false},"nashorn":{"__DIR__":false,"__FILE__":false,"__LINE__":false,"com":false,"edu":false,"exit":false,"java":false,"Java":false,"javafx":false,"JavaImporter":false,"javax":false,"JSAdapter":false,"load":false,"loadWithNewGlobal":false,"org":false,"Packages":false,"print":false,"quit":false},"wsh":{"ActiveXObject":true,"Enumerator":true,"GetObject":true,"ScriptEngine":true,"ScriptEngineBuildVersion":true,"ScriptEngineMajorVersion":true,"ScriptEngineMinorVersion":true,"VBArray":true,"WScript":true,"WSH":true,"XDomainRequest":true},"jquery":{"$":false,"jQuery":false},"yui":{"YAHOO":false,"YAHOO_config":false,"YUI":false,"YUI_config":false},"shelljs":{"cat":false,"cd":false,"chmod":false,"config":false,"cp":false,"dirs":false,"echo":false,"env":false,"error":false,"exec":false,"exit":false,"find":false,"grep":false,"ln":false,"ls":false,"mkdir":false,"mv":false,"popd":false,"pushd":false,"pwd":false,"rm":false,"sed":false,"set":false,"target":false,"tempdir":false,"test":false,"touch":false,"which":false},"prototypejs":{"$":false,"$$":false,"$A":false,"$break":false,"$continue":false,"$F":false,"$H":false,"$R":false,"$w":false,"Abstract":false,"Ajax":false,"Autocompleter":false,"Builder":false,"Class":false,"Control":false,"Draggable":false,"Draggables":false,"Droppables":false,"Effect":false,"Element":false,"Enumerable":false,"Event":false,"Field":false,"Form":false,"Hash":false,"Insertion":false,"ObjectRange":false,"PeriodicalExecuter":false,"Position":false,"Prototype":false,"Scriptaculous":false,"Selector":false,"Sortable":false,"SortableObserver":false,"Sound":false,"Template":false,"Toggle":false,"Try":false},"meteor":{"_":false,"$":false,"Accounts":false,"AccountsClient":false,"AccountsCommon":false,"AccountsServer":false,"App":false,"Assets":false,"Blaze":false,"check":false,"Cordova":false,"DDP":false,"DDPRateLimiter":false,"DDPServer":false,"Deps":false,"EJSON":false,"Email":false,"HTTP":false,"Log":false,"Match":false,"Meteor":false,"Mongo":false,"MongoInternals":false,"Npm":false,"Package":false,"Plugin":false,"process":false,"Random":false,"ReactiveDict":false,"ReactiveVar":false,"Router":false,"ServiceConfiguration":false,"Session":false,"share":false,"Spacebars":false,"Template":false,"Tinytest":false,"Tracker":false,"UI":false,"Utils":false,"WebApp":false,"WebAppInternals":false},"mongo":{"_isWindows":false,"_rand":false,"BulkWriteResult":false,"cat":false,"cd":false,"connect":false,"db":false,"getHostName":false,"getMemInfo":false,"hostname":false,"ISODate":false,"listFiles":false,"load":false,"ls":false,"md5sumFile":false,"mkdir":false,"Mongo":false,"NumberInt":false,"NumberLong":false,"ObjectId":false,"PlanCache":false,"print":false,"printjson":false,"pwd":false,"quit":false,"removeFile":false,"rs":false,"sh":false,"UUID":false,"version":false,"WriteResult":false},"applescript":{"$":false,"Application":false,"Automation":false,"console":false,"delay":false,"Library":false,"ObjC":false,"ObjectSpecifier":false,"Path":false,"Progress":false,"Ref":false},"serviceworker":{"addEventListener":false,"applicationCache":false,"atob":false,"Blob":false,"BroadcastChannel":false,"btoa":false,"Cache":false,"caches":false,"CacheStorage":false,"clearInterval":false,"clearTimeout":false,"Client":false,"clients":false,"Clients":false,"close":true,"console":false,"ExtendableEvent":false,"ExtendableMessageEvent":false,"fetch":false,"FetchEvent":false,"FileReaderSync":false,"FormData":false,"Headers":false,"IDBCursor":false,"IDBCursorWithValue":false,"IDBDatabase":false,"IDBFactory":false,"IDBIndex":false,"IDBKeyRange":false,"IDBObjectStore":false,"IDBOpenDBRequest":false,"IDBRequest":false,"IDBTransaction":false,"IDBVersionChangeEvent":false,"ImageData":false,"importScripts":false,"indexedDB":false,"location":false,"MessageChannel":false,"MessagePort":false,"name":false,"navigator":false,"Notification":false,"onclose":true,"onconnect":true,"onerror":true,"onfetch":true,"oninstall":true,"onlanguagechange":true,"onmessage":true,"onmessageerror":true,"onnotificationclick":true,"onnotificationclose":true,"onoffline":true,"ononline":true,"onpush":true,"onpushsubscriptionchange":true,"onrejectionhandled":true,"onsync":true,"onunhandledrejection":true,"performance":false,"Performance":false,"PerformanceEntry":false,"PerformanceMark":false,"PerformanceMeasure":false,"PerformanceNavigation":false,"PerformanceResourceTiming":false,"PerformanceTiming":false,"postMessage":true,"Promise":false,"queueMicrotask":false,"registration":false,"removeEventListener":false,"Request":false,"Response":false,"self":false,"ServiceWorker":false,"ServiceWorkerContainer":false,"ServiceWorkerGlobalScope":false,"ServiceWorkerMessageEvent":false,"ServiceWorkerRegistration":false,"setInterval":false,"setTimeout":false,"skipWaiting":false,"TextDecoder":false,"TextEncoder":false,"URL":false,"URLSearchParams":false,"WebSocket":false,"WindowClient":false,"Worker":false,"WorkerGlobalScope":false,"XMLHttpRequest":false},"atomtest":{"advanceClock":false,"fakeClearInterval":false,"fakeClearTimeout":false,"fakeSetInterval":false,"fakeSetTimeout":false,"resetTimeouts":false,"waitsForPromise":false},"embertest":{"andThen":false,"click":false,"currentPath":false,"currentRouteName":false,"currentURL":false,"fillIn":false,"find":false,"findAll":false,"findWithAssert":false,"keyEvent":false,"pauseTest":false,"resumeTest":false,"triggerEvent":false,"visit":false,"wait":false},"protractor":{"$":false,"$$":false,"browser":false,"by":false,"By":false,"DartObject":false,"element":false,"protractor":false},"shared-node-browser":{"clearInterval":false,"clearTimeout":false,"console":false,"setInterval":false,"setTimeout":false,"URL":false,"URLSearchParams":false},"webextensions":{"browser":false,"chrome":false,"opr":false},"greasemonkey":{"cloneInto":false,"createObjectIn":false,"exportFunction":false,"GM":false,"GM_addStyle":false,"GM_deleteValue":false,"GM_getResourceText":false,"GM_getResourceURL":false,"GM_getValue":false,"GM_info":false,"GM_listValues":false,"GM_log":false,"GM_openInTab":false,"GM_registerMenuCommand":false,"GM_setClipboard":false,"GM_setValue":false,"GM_xmlhttpRequest":false,"unsafeWindow":false},"devtools":{"$":false,"$_":false,"$$":false,"$0":false,"$1":false,"$2":false,"$3":false,"$4":false,"$x":false,"chrome":false,"clear":false,"copy":false,"debug":false,"dir":false,"dirxml":false,"getEventListeners":false,"inspect":false,"keys":false,"monitor":false,"monitorEvents":false,"profile":false,"profileEnd":false,"queryObjects":false,"table":false,"undebug":false,"unmonitor":false,"unmonitorEvents":false,"values":false}}');
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(417);
            t2.default = class {
              constructor(e3, t3) {
                this._cachedMap = void 0, this._code = void 0, this._opts = void 0, this._rawMappings = void 0, this._lastGenLine = void 0, this._lastSourceLine = void 0, this._lastSourceColumn = void 0, this._cachedMap = null, this._code = t3, this._opts = e3, this._rawMappings = [];
              }
              get() {
                if (!this._cachedMap) {
                  const e3 = this._cachedMap = new n.SourceMapGenerator({ sourceRoot: this._opts.sourceRoot }), t3 = this._code;
                  typeof t3 == "string" ? e3.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), t3) : typeof t3 == "object" && Object.keys(t3).forEach((r3) => {
                    e3.setSourceContent(r3.replace(/\\/g, "/"), t3[r3]);
                  }), this._rawMappings.forEach((t4) => e3.addMapping(t4), e3);
                }
                return this._cachedMap.toJSON();
              }
              getRawMappings() {
                return this._rawMappings.slice();
              }
              mark(e3, t3, r3, n2, s2, i, o) {
                this._lastGenLine !== e3 && r3 === null || (o || this._lastGenLine !== e3 || this._lastSourceLine !== r3 || this._lastSourceColumn !== n2) && (this._cachedMap = null, this._lastGenLine = e3, this._lastSourceLine = r3, this._lastSourceColumn = n2, this._rawMappings.push({ name: s2 || void 0, generated: { line: e3, column: t3 }, source: r3 == null ? void 0 : (i || this._opts.sourceFileName).replace(/\\/g, "/"), original: r3 == null ? void 0 : { line: r3, column: n2 } }));
              }
            };
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(419), s2 = r2(233), i = r2(0), o = r2(165);
            const a = /e/i, l = /\.0+$/, c = /^0[box]/, u = /^\s*[@#]__PURE__\s*$/;
            class p2 {
              constructor(e3, t3) {
                this.inForStatementInitCounter = 0, this._printStack = [], this._indent = 0, this._insideAux = false, this._parenPushNewlineState = null, this._noLineTerminator = false, this._printAuxAfterOnNextUserNode = false, this._printedComments = new WeakSet(), this._endsWithInteger = false, this._endsWithWord = false, this.format = e3, this._buf = new n.default(t3);
              }
              generate(e3) {
                return this.print(e3), this._maybeAddAuxComment(), this._buf.get();
              }
              indent() {
                this.format.compact || this.format.concise || this._indent++;
              }
              dedent() {
                this.format.compact || this.format.concise || this._indent--;
              }
              semicolon(e3 = false) {
                this._maybeAddAuxComment(), this._append(";", !e3);
              }
              rightBrace() {
                this.format.minified && this._buf.removeLastSemicolon(), this.token("}");
              }
              space(e3 = false) {
                this.format.compact || (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || e3) && this._space();
              }
              word(e3) {
                (this._endsWithWord || this.endsWith("/") && e3.indexOf("/") === 0) && this._space(), this._maybeAddAuxComment(), this._append(e3), this._endsWithWord = true;
              }
              number(e3) {
                this.word(e3), this._endsWithInteger = Number.isInteger(+e3) && !c.test(e3) && !a.test(e3) && !l.test(e3) && e3[e3.length - 1] !== ".";
              }
              token(e3) {
                (e3 === "--" && this.endsWith("!") || e3[0] === "+" && this.endsWith("+") || e3[0] === "-" && this.endsWith("-") || e3[0] === "." && this._endsWithInteger) && this._space(), this._maybeAddAuxComment(), this._append(e3);
              }
              newline(e3) {
                if (!this.format.retainLines && !this.format.compact) {
                  if (this.format.concise)
                    this.space();
                  else if (!(this.endsWith("\n\n") || (typeof e3 != "number" && (e3 = 1), e3 = Math.min(2, e3), (this.endsWith("{\n") || this.endsWith(":\n")) && e3--, e3 <= 0)))
                    for (let t3 = 0; t3 < e3; t3++)
                      this._newline();
                }
              }
              endsWith(e3) {
                return this._buf.endsWith(e3);
              }
              removeTrailingNewline() {
                this._buf.removeTrailingNewline();
              }
              exactSource(e3, t3) {
                this._catchUp("start", e3), this._buf.exactSource(e3, t3);
              }
              source(e3, t3) {
                this._catchUp(e3, t3), this._buf.source(e3, t3);
              }
              withSource(e3, t3, r3) {
                this._catchUp(e3, t3), this._buf.withSource(e3, t3, r3);
              }
              _space() {
                this._append(" ", true);
              }
              _newline() {
                this._append("\n", true);
              }
              _append(e3, t3 = false) {
                this._maybeAddParen(e3), this._maybeIndent(e3), t3 ? this._buf.queue(e3) : this._buf.append(e3), this._endsWithWord = false, this._endsWithInteger = false;
              }
              _maybeIndent(e3) {
                this._indent && this.endsWith("\n") && e3[0] !== "\n" && this._buf.queue(this._getIndent());
              }
              _maybeAddParen(e3) {
                const t3 = this._parenPushNewlineState;
                if (!t3)
                  return;
                let r3;
                for (r3 = 0; r3 < e3.length && e3[r3] === " "; r3++)
                  continue;
                if (r3 === e3.length)
                  return;
                const n2 = e3[r3];
                if (n2 !== "\n") {
                  if (n2 !== "/" || r3 + 1 === e3.length)
                    return void (this._parenPushNewlineState = null);
                  const t4 = e3[r3 + 1];
                  if (t4 === "*") {
                    if (u.test(e3.slice(r3 + 2, e3.length - 2)))
                      return;
                  } else if (t4 !== "/")
                    return void (this._parenPushNewlineState = null);
                }
                this.token("("), this.indent(), t3.printed = true;
              }
              _catchUp(e3, t3) {
                if (!this.format.retainLines)
                  return;
                const r3 = t3 ? t3[e3] : null;
                if ((r3 == null ? void 0 : r3.line) != null) {
                  const e4 = r3.line - this._buf.getCurrentLine();
                  for (let t4 = 0; t4 < e4; t4++)
                    this._newline();
                }
              }
              _getIndent() {
                return this.format.indent.style.repeat(this._indent);
              }
              startTerminatorless(e3 = false) {
                return e3 ? (this._noLineTerminator = true, null) : this._parenPushNewlineState = { printed: false };
              }
              endTerminatorless(e3) {
                this._noLineTerminator = false, e3 != null && e3.printed && (this.dedent(), this.newline(), this.token(")"));
              }
              print(e3, t3) {
                if (!e3)
                  return;
                const r3 = this.format.concise;
                e3._compact && (this.format.concise = true);
                const n2 = this[e3.type];
                if (!n2)
                  throw new ReferenceError(`unknown node of type ${JSON.stringify(e3.type)} with constructor ${JSON.stringify(e3 == null ? void 0 : e3.constructor.name)}`);
                this._printStack.push(e3);
                const o2 = this._insideAux;
                this._insideAux = !e3.loc, this._maybeAddAuxComment(this._insideAux && !o2);
                let a2 = s2.needsParens(e3, t3, this._printStack);
                this.format.retainFunctionParens && e3.type === "FunctionExpression" && e3.extra && e3.extra.parenthesized && (a2 = true), a2 && this.token("("), this._printLeadingComments(e3);
                const l2 = i.isProgram(e3) || i.isFile(e3) ? null : e3.loc;
                this.withSource("start", l2, () => {
                  n2.call(this, e3, t3);
                }), this._printTrailingComments(e3), a2 && this.token(")"), this._printStack.pop(), this.format.concise = r3, this._insideAux = o2;
              }
              _maybeAddAuxComment(e3) {
                e3 && this._printAuxBeforeComment(), this._insideAux || this._printAuxAfterComment();
              }
              _printAuxBeforeComment() {
                if (this._printAuxAfterOnNextUserNode)
                  return;
                this._printAuxAfterOnNextUserNode = true;
                const e3 = this.format.auxiliaryCommentBefore;
                e3 && this._printComment({ type: "CommentBlock", value: e3 });
              }
              _printAuxAfterComment() {
                if (!this._printAuxAfterOnNextUserNode)
                  return;
                this._printAuxAfterOnNextUserNode = false;
                const e3 = this.format.auxiliaryCommentAfter;
                e3 && this._printComment({ type: "CommentBlock", value: e3 });
              }
              getPossibleRaw(e3) {
                const t3 = e3.extra;
                if (t3 && t3.raw != null && t3.rawValue != null && e3.value === t3.rawValue)
                  return t3.raw;
              }
              printJoin(e3, t3, r3 = {}) {
                if (e3 == null || !e3.length)
                  return;
                r3.indent && this.indent();
                const n2 = { addNewlines: r3.addNewlines };
                for (let s3 = 0; s3 < e3.length; s3++) {
                  const i2 = e3[s3];
                  i2 && (r3.statement && this._printNewline(true, i2, t3, n2), this.print(i2, t3), r3.iterator && r3.iterator(i2, s3), r3.separator && s3 < e3.length - 1 && r3.separator.call(this), r3.statement && this._printNewline(false, i2, t3, n2));
                }
                r3.indent && this.dedent();
              }
              printAndIndentOnComments(e3, t3) {
                const r3 = e3.leadingComments && e3.leadingComments.length > 0;
                r3 && this.indent(), this.print(e3, t3), r3 && this.dedent();
              }
              printBlock(e3) {
                const t3 = e3.body;
                i.isEmptyStatement(t3) || this.space(), this.print(t3, e3);
              }
              _printTrailingComments(e3) {
                this._printComments(this._getComments(false, e3));
              }
              _printLeadingComments(e3) {
                this._printComments(this._getComments(true, e3), true);
              }
              printInnerComments(e3, t3 = true) {
                var r3;
                (r3 = e3.innerComments) != null && r3.length && (t3 && this.indent(), this._printComments(e3.innerComments), t3 && this.dedent());
              }
              printSequence(e3, t3, r3 = {}) {
                return r3.statement = true, this.printJoin(e3, t3, r3);
              }
              printList(e3, t3, r3 = {}) {
                return r3.separator == null && (r3.separator = d), this.printJoin(e3, t3, r3);
              }
              _printNewline(e3, t3, r3, n2) {
                if (this.format.retainLines || this.format.compact)
                  return;
                if (this.format.concise)
                  return void this.space();
                let i2 = 0;
                this._buf.hasContent() && (e3 || i2++, n2.addNewlines && (i2 += n2.addNewlines(e3, t3) || 0), (e3 ? s2.needsWhitespaceBefore : s2.needsWhitespaceAfter)(t3, r3) && i2++), this.newline(i2);
              }
              _getComments(e3, t3) {
                return t3 && (e3 ? t3.leadingComments : t3.trailingComments) || [];
              }
              _printComment(e3, t3) {
                if (!this.format.shouldPrintComment(e3.value))
                  return;
                if (e3.ignore)
                  return;
                if (this._printedComments.has(e3))
                  return;
                this._printedComments.add(e3);
                const r3 = e3.type === "CommentBlock", n2 = r3 && !t3 && !this._noLineTerminator;
                n2 && this._buf.hasContent() && this.newline(1), this.endsWith("[") || this.endsWith("{") || this.space();
                let s3 = r3 || this._noLineTerminator ? `/*${e3.value}*/` : `//${e3.value}
`;
                if (r3 && this.format.indent.adjustMultilineComment) {
                  var i2;
                  const t4 = (i2 = e3.loc) == null ? void 0 : i2.start.column;
                  if (t4) {
                    const e4 = new RegExp("\\n\\s{1," + t4 + "}", "g");
                    s3 = s3.replace(e4, "\n");
                  }
                  const r4 = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
                  s3 = s3.replace(/\n(?!$)/g, `
${" ".repeat(r4)}`);
                }
                this.endsWith("/") && this._space(), this.withSource("start", e3.loc, () => {
                  this._append(s3);
                }), n2 && this.newline(1);
              }
              _printComments(e3, t3) {
                if (e3 != null && e3.length)
                  if (t3 && e3.length === 1 && u.test(e3[0].value))
                    this._printComment(e3[0], this._buf.hasContent() && !this.endsWith("\n"));
                  else
                    for (const t4 of e3)
                      this._printComment(t4);
              }
              printAssertions(e3) {
                var t3;
                (t3 = e3.assertions) != null && t3.length && (this.space(), this.word("assert"), this.space(), this.token("{"), this.space(), this.printList(e3.assertions, e3), this.space(), this.token("}"));
              }
            }
            Object.assign(p2.prototype, o), p2.prototype.Noop = function() {
            };
            var f = p2;
            function d() {
              this.token(","), this.space();
            }
            t2.default = f;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            const r2 = /^[ \t]+$/;
            t2.default = class {
              constructor(e3) {
                this._map = null, this._buf = [], this._last = "", this._queue = [], this._position = { line: 1, column: 0 }, this._sourcePosition = { identifierName: null, line: null, column: null, filename: null }, this._disallowedPop = null, this._map = e3;
              }
              get() {
                this._flush();
                const e3 = this._map, t3 = { code: this._buf.join("").trimRight(), map: null, rawMappings: e3 == null ? void 0 : e3.getRawMappings() };
                return e3 && Object.defineProperty(t3, "map", { configurable: true, enumerable: true, get() {
                  return this.map = e3.get();
                }, set(e4) {
                  Object.defineProperty(this, "map", { value: e4, writable: true });
                } }), t3;
              }
              append(e3) {
                this._flush();
                const { line: t3, column: r3, filename: n, identifierName: s2, force: i } = this._sourcePosition;
                this._append(e3, t3, r3, s2, n, i);
              }
              queue(e3) {
                if (e3 === "\n")
                  for (; this._queue.length > 0 && r2.test(this._queue[0][0]); )
                    this._queue.shift();
                const { line: t3, column: n, filename: s2, identifierName: i, force: o } = this._sourcePosition;
                this._queue.unshift([e3, t3, n, i, s2, o]);
              }
              _flush() {
                let e3;
                for (; e3 = this._queue.pop(); )
                  this._append(...e3);
              }
              _append(e3, t3, r3, n, s2, i) {
                this._buf.push(e3), this._last = e3[e3.length - 1];
                let o = e3.indexOf("\n"), a = 0;
                for (o !== 0 && this._mark(t3, r3, n, s2, i); o !== -1; )
                  this._position.line++, this._position.column = 0, a = o + 1, a < e3.length && this._mark(++t3, 0, n, s2, i), o = e3.indexOf("\n", a);
                this._position.column += e3.length - a;
              }
              _mark(e3, t3, r3, n, s2) {
                var i;
                (i = this._map) == null || i.mark(this._position.line, this._position.column, e3, t3, r3, n, s2);
              }
              removeTrailingNewline() {
                this._queue.length > 0 && this._queue[0][0] === "\n" && this._queue.shift();
              }
              removeLastSemicolon() {
                this._queue.length > 0 && this._queue[0][0] === ";" && this._queue.shift();
              }
              endsWith(e3) {
                if (e3.length === 1) {
                  let t4;
                  if (this._queue.length > 0) {
                    const e4 = this._queue[0][0];
                    t4 = e4[e4.length - 1];
                  } else
                    t4 = this._last;
                  return t4 === e3;
                }
                const t3 = this._last + this._queue.reduce((e4, t4) => t4[0] + e4, "");
                return e3.length <= t3.length && t3.slice(-e3.length) === e3;
              }
              hasContent() {
                return this._queue.length > 0 || !!this._last;
              }
              exactSource(e3, t3) {
                this.source("start", e3, true), t3(), this.source("end", e3), this._disallowPop("start", e3);
              }
              source(e3, t3, r3) {
                e3 && !t3 || this._normalizePosition(e3, t3, this._sourcePosition, r3);
              }
              withSource(e3, t3, r3) {
                if (!this._map)
                  return r3();
                const n = this._sourcePosition.line, s2 = this._sourcePosition.column, i = this._sourcePosition.filename, o = this._sourcePosition.identifierName;
                this.source(e3, t3), r3(), this._sourcePosition.force && this._sourcePosition.line === n && this._sourcePosition.column === s2 && this._sourcePosition.filename === i || this._disallowedPop && this._disallowedPop.line === n && this._disallowedPop.column === s2 && this._disallowedPop.filename === i || (this._sourcePosition.line = n, this._sourcePosition.column = s2, this._sourcePosition.filename = i, this._sourcePosition.identifierName = o, this._sourcePosition.force = false, this._disallowedPop = null);
              }
              _disallowPop(e3, t3) {
                e3 && !t3 || (this._disallowedPop = this._normalizePosition(e3, t3));
              }
              _normalizePosition(e3, t3, r3, n) {
                const s2 = t3 ? t3[e3] : null;
                r3 === void 0 && (r3 = { identifierName: null, line: null, column: null, filename: null, force: false });
                const i = r3.line, o = r3.column, a = r3.filename;
                return r3.identifierName = e3 === "start" && (t3 == null ? void 0 : t3.identifierName) || null, r3.line = s2 == null ? void 0 : s2.line, r3.column = s2 == null ? void 0 : s2.column, r3.filename = t3 == null ? void 0 : t3.filename, (n || r3.line !== i || r3.column !== o || r3.filename !== a) && (r3.force = n), r3;
              }
              getCurrentColumn() {
                const e3 = this._queue.reduce((e4, t4) => t4[0] + e4, ""), t3 = e3.lastIndexOf("\n");
                return t3 === -1 ? this._position.column + e3.length : e3.length - 1 - t3;
              }
              getCurrentLine() {
                const e3 = this._queue.reduce((e4, t4) => t4[0] + e4, "");
                let t3 = 0;
                for (let r3 = 0; r3 < e3.length; r3++)
                  e3[r3] === "\n" && t3++;
                return this._position.line + t3;
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.list = t2.nodes = void 0;
            var n = r2(0);
            function s2(e3, t3 = {}) {
              return n.isMemberExpression(e3) || n.isOptionalMemberExpression(e3) ? (s2(e3.object, t3), e3.computed && s2(e3.property, t3)) : n.isBinary(e3) || n.isAssignmentExpression(e3) ? (s2(e3.left, t3), s2(e3.right, t3)) : n.isCallExpression(e3) || n.isOptionalCallExpression(e3) ? (t3.hasCall = true, s2(e3.callee, t3)) : n.isFunction(e3) ? t3.hasFunction = true : n.isIdentifier(e3) && (t3.hasHelper = t3.hasHelper || i(e3.callee)), t3;
            }
            function i(e3) {
              return n.isMemberExpression(e3) ? i(e3.object) || i(e3.property) : n.isIdentifier(e3) ? e3.name === "require" || e3.name[0] === "_" : n.isCallExpression(e3) ? i(e3.callee) : !(!n.isBinary(e3) && !n.isAssignmentExpression(e3)) && (n.isIdentifier(e3.left) && i(e3.left) || i(e3.right));
            }
            function o(e3) {
              return n.isLiteral(e3) || n.isObjectExpression(e3) || n.isArrayExpression(e3) || n.isIdentifier(e3) || n.isMemberExpression(e3);
            }
            const a = { AssignmentExpression(e3) {
              const t3 = s2(e3.right);
              if (t3.hasCall && t3.hasHelper || t3.hasFunction)
                return { before: t3.hasFunction, after: true };
            }, SwitchCase: (e3, t3) => ({ before: !!e3.consequent.length || t3.cases[0] === e3, after: !e3.consequent.length && t3.cases[t3.cases.length - 1] === e3 }), LogicalExpression(e3) {
              if (n.isFunction(e3.left) || n.isFunction(e3.right))
                return { after: true };
            }, Literal(e3) {
              if (n.isStringLiteral(e3) && e3.value === "use strict")
                return { after: true };
            }, CallExpression(e3) {
              if (n.isFunction(e3.callee) || i(e3))
                return { before: true, after: true };
            }, OptionalCallExpression(e3) {
              if (n.isFunction(e3.callee))
                return { before: true, after: true };
            }, VariableDeclaration(e3) {
              for (let t3 = 0; t3 < e3.declarations.length; t3++) {
                const r3 = e3.declarations[t3];
                let n2 = i(r3.id) && !o(r3.init);
                if (!n2) {
                  const e4 = s2(r3.init);
                  n2 = i(r3.init) && e4.hasCall || e4.hasFunction;
                }
                if (n2)
                  return { before: true, after: true };
              }
            }, IfStatement(e3) {
              if (n.isBlockStatement(e3.consequent))
                return { before: true, after: true };
            } };
            t2.nodes = a, a.ObjectProperty = a.ObjectTypeProperty = a.ObjectMethod = function(e3, t3) {
              if (t3.properties[0] === e3)
                return { before: true };
            }, a.ObjectTypeCallProperty = function(e3, t3) {
              var r3;
              if (t3.callProperties[0] === e3 && ((r3 = t3.properties) == null || !r3.length))
                return { before: true };
            }, a.ObjectTypeIndexer = function(e3, t3) {
              var r3, n2;
              if (!(t3.indexers[0] !== e3 || (r3 = t3.properties) != null && r3.length || (n2 = t3.callProperties) != null && n2.length))
                return { before: true };
            }, a.ObjectTypeInternalSlot = function(e3, t3) {
              var r3, n2, s3;
              if (!(t3.internalSlots[0] !== e3 || (r3 = t3.properties) != null && r3.length || (n2 = t3.callProperties) != null && n2.length || (s3 = t3.indexers) != null && s3.length))
                return { before: true };
            };
            t2.list = { VariableDeclaration: (e3) => e3.declarations.map((e4) => e4.init), ArrayExpression: (e3) => e3.elements, ObjectExpression: (e3) => e3.properties }, [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([e3, t3]) {
              typeof t3 == "boolean" && (t3 = { after: t3, before: t3 }), [e3].concat(n.FLIPPED_ALIAS_KEYS[e3] || []).forEach(function(e4) {
                a[e4] = function() {
                  return t3;
                };
              });
            });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.NullableTypeAnnotation = function(e3, t3) {
              return n.isArrayTypeAnnotation(t3);
            }, t2.FunctionTypeAnnotation = function(e3, t3, r3) {
              return n.isUnionTypeAnnotation(t3) || n.isIntersectionTypeAnnotation(t3) || n.isArrayTypeAnnotation(t3) || n.isTypeAnnotation(t3) && n.isArrowFunctionExpression(r3[r3.length - 3]);
            }, t2.UpdateExpression = function(e3, t3) {
              return o(e3, t3) || i(e3, t3);
            }, t2.ObjectExpression = function(e3, t3, r3) {
              return c(r3, { expressionStatement: true, arrowBody: true });
            }, t2.DoExpression = function(e3, t3, r3) {
              return !e3.async && c(r3, { expressionStatement: true });
            }, t2.Binary = function(e3, t3) {
              if (e3.operator === "**" && n.isBinaryExpression(t3, { operator: "**" }))
                return t3.left === e3;
              if (i(e3, t3))
                return true;
              if (o(e3, t3) || n.isUnaryLike(t3) || n.isAwaitExpression(t3))
                return true;
              if (n.isBinary(t3)) {
                const r3 = t3.operator, i2 = s2[r3], o2 = e3.operator, a2 = s2[o2];
                if (i2 === a2 && t3.right === e3 && !n.isLogicalExpression(t3) || i2 > a2)
                  return true;
              }
            }, t2.IntersectionTypeAnnotation = t2.UnionTypeAnnotation = function(e3, t3) {
              return n.isArrayTypeAnnotation(t3) || n.isNullableTypeAnnotation(t3) || n.isIntersectionTypeAnnotation(t3) || n.isUnionTypeAnnotation(t3);
            }, t2.OptionalIndexedAccessType = function(e3, t3) {
              return n.isIndexedAccessType(t3, { objectType: e3 });
            }, t2.TSAsExpression = function() {
              return true;
            }, t2.TSTypeAssertion = function() {
              return true;
            }, t2.TSIntersectionType = t2.TSUnionType = function(e3, t3) {
              return n.isTSArrayType(t3) || n.isTSOptionalType(t3) || n.isTSIntersectionType(t3) || n.isTSUnionType(t3) || n.isTSRestType(t3);
            }, t2.TSInferType = function(e3, t3) {
              return n.isTSArrayType(t3) || n.isTSOptionalType(t3);
            }, t2.BinaryExpression = function(e3, t3) {
              return e3.operator === "in" && (n.isVariableDeclarator(t3) || n.isFor(t3));
            }, t2.SequenceExpression = function(e3, t3) {
              return !(n.isForStatement(t3) || n.isThrowStatement(t3) || n.isReturnStatement(t3) || n.isIfStatement(t3) && t3.test === e3 || n.isWhileStatement(t3) && t3.test === e3 || n.isForInStatement(t3) && t3.right === e3 || n.isSwitchStatement(t3) && t3.discriminant === e3 || n.isExpressionStatement(t3) && t3.expression === e3);
            }, t2.AwaitExpression = t2.YieldExpression = function(e3, t3) {
              return n.isBinary(t3) || n.isUnaryLike(t3) || o(e3, t3) || n.isAwaitExpression(t3) && n.isYieldExpression(e3) || n.isConditionalExpression(t3) && e3 === t3.test || i(e3, t3);
            }, t2.ClassExpression = function(e3, t3, r3) {
              return c(r3, { expressionStatement: true, exportDefault: true });
            }, t2.UnaryLike = a, t2.FunctionExpression = function(e3, t3, r3) {
              return c(r3, { expressionStatement: true, exportDefault: true });
            }, t2.ArrowFunctionExpression = function(e3, t3) {
              return n.isExportDeclaration(t3) || l(e3, t3);
            }, t2.ConditionalExpression = l, t2.OptionalCallExpression = t2.OptionalMemberExpression = function(e3, t3) {
              return n.isCallExpression(t3, { callee: e3 }) || n.isMemberExpression(t3, { object: e3 });
            }, t2.AssignmentExpression = function(e3, t3) {
              return !!n.isObjectPattern(e3.left) || l(e3, t3);
            }, t2.LogicalExpression = function(e3, t3) {
              switch (e3.operator) {
                case "||":
                  return !!n.isLogicalExpression(t3) && (t3.operator === "??" || t3.operator === "&&");
                case "&&":
                  return n.isLogicalExpression(t3, { operator: "??" });
                case "??":
                  return n.isLogicalExpression(t3) && t3.operator !== "??";
              }
            }, t2.Identifier = function(e3, t3, r3) {
              if (e3.name === "let") {
                const s3 = n.isMemberExpression(t3, { object: e3, computed: true }) || n.isOptionalMemberExpression(t3, { object: e3, computed: true, optional: false });
                return c(r3, { expressionStatement: s3, forHead: s3, forInHead: s3, forOfHead: true });
              }
              return e3.name === "async" && n.isForOfStatement(t3) && e3 === t3.left;
            };
            var n = r2(0);
            const s2 = { "||": 0, "??": 0, "&&": 1, "|": 2, "^": 3, "&": 4, "==": 5, "===": 5, "!=": 5, "!==": 5, "<": 6, ">": 6, "<=": 6, ">=": 6, in: 6, instanceof: 6, ">>": 7, "<<": 7, ">>>": 7, "+": 8, "-": 8, "*": 9, "/": 9, "%": 9, "**": 10 }, i = (e3, t3) => (n.isClassDeclaration(t3) || n.isClassExpression(t3)) && t3.superClass === e3, o = (e3, t3) => (n.isMemberExpression(t3) || n.isOptionalMemberExpression(t3)) && t3.object === e3 || (n.isCallExpression(t3) || n.isOptionalCallExpression(t3) || n.isNewExpression(t3)) && t3.callee === e3 || n.isTaggedTemplateExpression(t3) && t3.tag === e3 || n.isTSNonNullExpression(t3);
            function a(e3, t3) {
              return o(e3, t3) || n.isBinaryExpression(t3, { operator: "**", left: e3 }) || i(e3, t3);
            }
            function l(e3, t3) {
              return !!(n.isUnaryLike(t3) || n.isBinary(t3) || n.isConditionalExpression(t3, { test: e3 }) || n.isAwaitExpression(t3) || n.isTSTypeAssertion(t3) || n.isTSAsExpression(t3)) || a(e3, t3);
            }
            function c(e3, { expressionStatement: t3 = false, arrowBody: r3 = false, exportDefault: s3 = false, forHead: i2 = false, forInHead: a2 = false, forOfHead: l2 = false }) {
              let c4 = e3.length - 1, u = e3[c4];
              c4--;
              let p2 = e3[c4];
              for (; c4 >= 0; ) {
                if (t3 && n.isExpressionStatement(p2, { expression: u }) || s3 && n.isExportDefaultDeclaration(p2, { declaration: u }) || r3 && n.isArrowFunctionExpression(p2, { body: u }) || i2 && n.isForStatement(p2, { init: u }) || a2 && n.isForInStatement(p2, { left: u }) || l2 && n.isForOfStatement(p2, { left: u }))
                  return true;
                if (!(o(u, p2) && !n.isNewExpression(p2) || n.isSequenceExpression(p2) && p2.expressions[0] === u || n.isConditional(p2, { test: u }) || n.isBinary(p2, { left: u }) || n.isAssignmentExpression(p2, { left: u })))
                  return false;
                u = p2, c4--, p2 = e3[c4];
              }
              return false;
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TaggedTemplateExpression = function(e3) {
              this.print(e3.tag, e3), this.print(e3.typeParameters, e3), this.print(e3.quasi, e3);
            }, t2.TemplateElement = function(e3, t3) {
              const r3 = t3.quasis[0] === e3, n = t3.quasis[t3.quasis.length - 1] === e3, s2 = (r3 ? "`" : "}") + e3.value.raw + (n ? "`" : "${");
              this.token(s2);
            }, t2.TemplateLiteral = function(e3) {
              const t3 = e3.quasis;
              for (let r3 = 0; r3 < t3.length; r3++)
                this.print(t3[r3], e3), r3 + 1 < t3.length && this.print(e3.expressions[r3], e3);
            }, r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.UnaryExpression = function(e3) {
              e3.operator === "void" || e3.operator === "delete" || e3.operator === "typeof" || e3.operator === "throw" ? (this.word(e3.operator), this.space()) : this.token(e3.operator), this.print(e3.argument, e3);
            }, t2.DoExpression = function(e3) {
              e3.async && (this.word("async"), this.space()), this.word("do"), this.space(), this.print(e3.body, e3);
            }, t2.ParenthesizedExpression = function(e3) {
              this.token("("), this.print(e3.expression, e3), this.token(")");
            }, t2.UpdateExpression = function(e3) {
              e3.prefix ? (this.token(e3.operator), this.print(e3.argument, e3)) : (this.startTerminatorless(true), this.print(e3.argument, e3), this.endTerminatorless(), this.token(e3.operator));
            }, t2.ConditionalExpression = function(e3) {
              this.print(e3.test, e3), this.space(), this.token("?"), this.space(), this.print(e3.consequent, e3), this.space(), this.token(":"), this.space(), this.print(e3.alternate, e3);
            }, t2.NewExpression = function(e3, t3) {
              this.word("new"), this.space(), this.print(e3.callee, e3), (!this.format.minified || e3.arguments.length !== 0 || e3.optional || n.isCallExpression(t3, { callee: e3 }) || n.isMemberExpression(t3) || n.isNewExpression(t3)) && (this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.token("("), this.printList(e3.arguments, e3), this.token(")"));
            }, t2.SequenceExpression = function(e3) {
              this.printList(e3.expressions, e3);
            }, t2.ThisExpression = function() {
              this.word("this");
            }, t2.Super = function() {
              this.word("super");
            }, t2.Decorator = function(e3) {
              this.token("@"), this.print(e3.expression, e3), this.newline();
            }, t2.OptionalMemberExpression = function(e3) {
              if (this.print(e3.object, e3), !e3.computed && n.isMemberExpression(e3.property))
                throw new TypeError("Got a MemberExpression for MemberExpression property");
              let t3 = e3.computed;
              n.isLiteral(e3.property) && typeof e3.property.value == "number" && (t3 = true), e3.optional && this.token("?."), t3 ? (this.token("["), this.print(e3.property, e3), this.token("]")) : (e3.optional || this.token("."), this.print(e3.property, e3));
            }, t2.OptionalCallExpression = function(e3) {
              this.print(e3.callee, e3), this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), e3.optional && this.token("?."), this.token("("), this.printList(e3.arguments, e3), this.token(")");
            }, t2.CallExpression = function(e3) {
              this.print(e3.callee, e3), this.print(e3.typeArguments, e3), this.print(e3.typeParameters, e3), this.token("("), this.printList(e3.arguments, e3), this.token(")");
            }, t2.Import = function() {
              this.word("import");
            }, t2.EmptyStatement = function() {
              this.semicolon(true);
            }, t2.ExpressionStatement = function(e3) {
              this.print(e3.expression, e3), this.semicolon();
            }, t2.AssignmentPattern = function(e3) {
              this.print(e3.left, e3), e3.left.optional && this.token("?"), this.print(e3.left.typeAnnotation, e3), this.space(), this.token("="), this.space(), this.print(e3.right, e3);
            }, t2.LogicalExpression = t2.BinaryExpression = t2.AssignmentExpression = function(e3, t3) {
              const r3 = this.inForStatementInitCounter && e3.operator === "in" && !s2.needsParens(e3, t3);
              r3 && this.token("("), this.print(e3.left, e3), this.space(), e3.operator === "in" || e3.operator === "instanceof" ? this.word(e3.operator) : this.token(e3.operator), this.space(), this.print(e3.right, e3), r3 && this.token(")");
            }, t2.BindExpression = function(e3) {
              this.print(e3.object, e3), this.token("::"), this.print(e3.callee, e3);
            }, t2.MemberExpression = function(e3) {
              if (this.print(e3.object, e3), !e3.computed && n.isMemberExpression(e3.property))
                throw new TypeError("Got a MemberExpression for MemberExpression property");
              let t3 = e3.computed;
              n.isLiteral(e3.property) && typeof e3.property.value == "number" && (t3 = true), t3 ? (this.token("["), this.print(e3.property, e3), this.token("]")) : (this.token("."), this.print(e3.property, e3));
            }, t2.MetaProperty = function(e3) {
              this.print(e3.meta, e3), this.token("."), this.print(e3.property, e3);
            }, t2.PrivateName = function(e3) {
              this.token("#"), this.print(e3.id, e3);
            }, t2.V8IntrinsicIdentifier = function(e3) {
              this.token("%"), this.word(e3.name);
            }, t2.ModuleExpression = function(e3) {
              this.word("module"), this.space(), this.token("{"), e3.body.body.length === 0 ? this.token("}") : (this.newline(), this.printSequence(e3.body.body, e3, { indent: true }), this.rightBrace());
            }, t2.AwaitExpression = t2.YieldExpression = void 0;
            var n = r2(0), s2 = r2(233);
            function i(e3) {
              return function(t3) {
                if (this.word(e3), t3.delegate && this.token("*"), t3.argument) {
                  this.space();
                  const e4 = this.startTerminatorless();
                  this.print(t3.argument, t3), this.endTerminatorless(e4);
                }
              };
            }
            const o = i("yield");
            t2.YieldExpression = o;
            const a = i("await");
            t2.AwaitExpression = a;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.WithStatement = function(e3) {
              this.word("with"), this.space(), this.token("("), this.print(e3.object, e3), this.token(")"), this.printBlock(e3);
            }, t2.IfStatement = function(e3) {
              this.word("if"), this.space(), this.token("("), this.print(e3.test, e3), this.token(")"), this.space();
              const t3 = e3.alternate && n.isIfStatement(s2(e3.consequent));
              t3 && (this.token("{"), this.newline(), this.indent()), this.printAndIndentOnComments(e3.consequent, e3), t3 && (this.dedent(), this.newline(), this.token("}")), e3.alternate && (this.endsWith("}") && this.space(), this.word("else"), this.space(), this.printAndIndentOnComments(e3.alternate, e3));
            }, t2.ForStatement = function(e3) {
              this.word("for"), this.space(), this.token("("), this.inForStatementInitCounter++, this.print(e3.init, e3), this.inForStatementInitCounter--, this.token(";"), e3.test && (this.space(), this.print(e3.test, e3)), this.token(";"), e3.update && (this.space(), this.print(e3.update, e3)), this.token(")"), this.printBlock(e3);
            }, t2.WhileStatement = function(e3) {
              this.word("while"), this.space(), this.token("("), this.print(e3.test, e3), this.token(")"), this.printBlock(e3);
            }, t2.DoWhileStatement = function(e3) {
              this.word("do"), this.space(), this.print(e3.body, e3), this.space(), this.word("while"), this.space(), this.token("("), this.print(e3.test, e3), this.token(")"), this.semicolon();
            }, t2.LabeledStatement = function(e3) {
              this.print(e3.label, e3), this.token(":"), this.space(), this.print(e3.body, e3);
            }, t2.TryStatement = function(e3) {
              this.word("try"), this.space(), this.print(e3.block, e3), this.space(), e3.handlers ? this.print(e3.handlers[0], e3) : this.print(e3.handler, e3), e3.finalizer && (this.space(), this.word("finally"), this.space(), this.print(e3.finalizer, e3));
            }, t2.CatchClause = function(e3) {
              this.word("catch"), this.space(), e3.param && (this.token("("), this.print(e3.param, e3), this.print(e3.param.typeAnnotation, e3), this.token(")"), this.space()), this.print(e3.body, e3);
            }, t2.SwitchStatement = function(e3) {
              this.word("switch"), this.space(), this.token("("), this.print(e3.discriminant, e3), this.token(")"), this.space(), this.token("{"), this.printSequence(e3.cases, e3, { indent: true, addNewlines(t3, r3) {
                if (!t3 && e3.cases[e3.cases.length - 1] === r3)
                  return -1;
              } }), this.token("}");
            }, t2.SwitchCase = function(e3) {
              e3.test ? (this.word("case"), this.space(), this.print(e3.test, e3), this.token(":")) : (this.word("default"), this.token(":")), e3.consequent.length && (this.newline(), this.printSequence(e3.consequent, e3, { indent: true }));
            }, t2.DebuggerStatement = function() {
              this.word("debugger"), this.semicolon();
            }, t2.VariableDeclaration = function(e3, t3) {
              e3.declare && (this.word("declare"), this.space()), this.word(e3.kind), this.space();
              let r3, s3 = false;
              if (!n.isFor(t3))
                for (const t4 of e3.declarations)
                  t4.init && (s3 = true);
              if (s3 && (r3 = e3.kind === "const" ? h3 : d), this.printList(e3.declarations, e3, { separator: r3 }), n.isFor(t3)) {
                if (n.isForStatement(t3)) {
                  if (t3.init === e3)
                    return;
                } else if (t3.left === e3)
                  return;
              }
              this.semicolon();
            }, t2.VariableDeclarator = function(e3) {
              this.print(e3.id, e3), e3.definite && this.token("!"), this.print(e3.id.typeAnnotation, e3), e3.init && (this.space(), this.token("="), this.space(), this.print(e3.init, e3));
            }, t2.ThrowStatement = t2.BreakStatement = t2.ReturnStatement = t2.ContinueStatement = t2.ForOfStatement = t2.ForInStatement = void 0;
            var n = r2(0);
            function s2(e3) {
              return n.isStatement(e3.body) ? s2(e3.body) : e3;
            }
            const i = function(e3) {
              return function(t3) {
                this.word("for"), this.space(), e3 === "of" && t3.await && (this.word("await"), this.space()), this.token("("), this.print(t3.left, t3), this.space(), this.word(e3), this.space(), this.print(t3.right, t3), this.token(")"), this.printBlock(t3);
              };
            }, o = i("in");
            t2.ForInStatement = o;
            const a = i("of");
            function l(e3, t3 = "label") {
              return function(r3) {
                this.word(e3);
                const n2 = r3[t3];
                if (n2) {
                  this.space();
                  const e4 = t3 == "label", s3 = this.startTerminatorless(e4);
                  this.print(n2, r3), this.endTerminatorless(s3);
                }
                this.semicolon();
              };
            }
            t2.ForOfStatement = a;
            const c = l("continue");
            t2.ContinueStatement = c;
            const u = l("return", "argument");
            t2.ReturnStatement = u;
            const p2 = l("break");
            t2.BreakStatement = p2;
            const f = l("throw", "argument");
            function d() {
              if (this.token(","), this.newline(), this.endsWith("\n"))
                for (let e3 = 0; e3 < 4; e3++)
                  this.space(true);
            }
            function h3() {
              if (this.token(","), this.newline(), this.endsWith("\n"))
                for (let e3 = 0; e3 < 6; e3++)
                  this.space(true);
            }
            t2.ThrowStatement = f;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.ClassExpression = t2.ClassDeclaration = function(e3, t3) {
              this.format.decoratorsBeforeExport && (n.isExportDefaultDeclaration(t3) || n.isExportNamedDeclaration(t3)) || this.printJoin(e3.decorators, e3), e3.declare && (this.word("declare"), this.space()), e3.abstract && (this.word("abstract"), this.space()), this.word("class"), e3.id && (this.space(), this.print(e3.id, e3)), this.print(e3.typeParameters, e3), e3.superClass && (this.space(), this.word("extends"), this.space(), this.print(e3.superClass, e3), this.print(e3.superTypeParameters, e3)), e3.implements && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)), this.space(), this.print(e3.body, e3);
            }, t2.ClassBody = function(e3) {
              this.token("{"), this.printInnerComments(e3), e3.body.length === 0 ? this.token("}") : (this.newline(), this.indent(), this.printSequence(e3.body, e3), this.dedent(), this.endsWith("\n") || this.newline(), this.rightBrace());
            }, t2.ClassProperty = function(e3) {
              this.printJoin(e3.decorators, e3), this.source("end", e3.key.loc), this.tsPrintClassMemberModifiers(e3, true), e3.computed ? (this.token("["), this.print(e3.key, e3), this.token("]")) : (this._variance(e3), this.print(e3.key, e3)), e3.optional && this.token("?"), e3.definite && this.token("!"), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.token("="), this.space(), this.print(e3.value, e3)), this.semicolon();
            }, t2.ClassPrivateProperty = function(e3) {
              this.printJoin(e3.decorators, e3), e3.static && (this.word("static"), this.space()), this.print(e3.key, e3), this.print(e3.typeAnnotation, e3), e3.value && (this.space(), this.token("="), this.space(), this.print(e3.value, e3)), this.semicolon();
            }, t2.ClassMethod = function(e3) {
              this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
            }, t2.ClassPrivateMethod = function(e3) {
              this._classMethodHead(e3), this.space(), this.print(e3.body, e3);
            }, t2._classMethodHead = function(e3) {
              this.printJoin(e3.decorators, e3), this.source("end", e3.key.loc), this.tsPrintClassMemberModifiers(e3, false), this._methodHead(e3);
            }, t2.StaticBlock = function(e3) {
              this.word("static"), this.space(), this.token("{"), e3.body.length === 0 ? this.token("}") : (this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.rightBrace());
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2._params = function(e3) {
              this.print(e3.typeParameters, e3), this.token("("), this._parameters(e3.params, e3), this.token(")"), this.print(e3.returnType, e3);
            }, t2._parameters = function(e3, t3) {
              for (let r3 = 0; r3 < e3.length; r3++)
                this._param(e3[r3], t3), r3 < e3.length - 1 && (this.token(","), this.space());
            }, t2._param = function(e3, t3) {
              this.printJoin(e3.decorators, e3), this.print(e3, t3), e3.optional && this.token("?"), this.print(e3.typeAnnotation, e3);
            }, t2._methodHead = function(e3) {
              const t3 = e3.kind, r3 = e3.key;
              t3 !== "get" && t3 !== "set" || (this.word(t3), this.space()), e3.async && (this._catchUp("start", r3.loc), this.word("async"), this.space()), t3 !== "method" && t3 !== "init" || e3.generator && this.token("*"), e3.computed ? (this.token("["), this.print(r3, e3), this.token("]")) : this.print(r3, e3), e3.optional && this.token("?"), this._params(e3);
            }, t2._predicate = function(e3) {
              e3.predicate && (e3.returnType || this.token(":"), this.space(), this.print(e3.predicate, e3));
            }, t2._functionHead = function(e3) {
              e3.async && (this.word("async"), this.space()), this.word("function"), e3.generator && this.token("*"), this.space(), e3.id && this.print(e3.id, e3), this._params(e3), this._predicate(e3);
            }, t2.FunctionDeclaration = t2.FunctionExpression = function(e3) {
              this._functionHead(e3), this.space(), this.print(e3.body, e3);
            }, t2.ArrowFunctionExpression = function(e3) {
              e3.async && (this.word("async"), this.space());
              const t3 = e3.params[0];
              this.format.retainLines || this.format.auxiliaryCommentBefore || this.format.auxiliaryCommentAfter || e3.params.length !== 1 || !n.isIdentifier(t3) || function(e4, t4) {
                var r3, n2;
                return !!(e4.typeParameters || e4.returnType || e4.predicate || t4.typeAnnotation || t4.optional || (r3 = t4.leadingComments) != null && r3.length || (n2 = t4.trailingComments) != null && n2.length);
              }(e3, t3) ? this._params(e3) : this.print(t3, e3), this._predicate(e3), this.space(), this.token("=>"), this.space(), this.print(e3.body, e3);
            };
            var n = r2(0);
          }, (e2, t2) => {
            "use strict";
            t2.byteLength = function(e3) {
              var t3 = l(e3), r3 = t3[0], n2 = t3[1];
              return 3 * (r3 + n2) / 4 - n2;
            }, t2.toByteArray = function(e3) {
              var t3, r3, i2 = l(e3), o2 = i2[0], a2 = i2[1], c4 = new s2(function(e4, t4, r4) {
                return 3 * (t4 + r4) / 4 - r4;
              }(0, o2, a2)), u = 0, p2 = a2 > 0 ? o2 - 4 : o2;
              for (r3 = 0; r3 < p2; r3 += 4)
                t3 = n[e3.charCodeAt(r3)] << 18 | n[e3.charCodeAt(r3 + 1)] << 12 | n[e3.charCodeAt(r3 + 2)] << 6 | n[e3.charCodeAt(r3 + 3)], c4[u++] = t3 >> 16 & 255, c4[u++] = t3 >> 8 & 255, c4[u++] = 255 & t3;
              return a2 === 2 && (t3 = n[e3.charCodeAt(r3)] << 2 | n[e3.charCodeAt(r3 + 1)] >> 4, c4[u++] = 255 & t3), a2 === 1 && (t3 = n[e3.charCodeAt(r3)] << 10 | n[e3.charCodeAt(r3 + 1)] << 4 | n[e3.charCodeAt(r3 + 2)] >> 2, c4[u++] = t3 >> 8 & 255, c4[u++] = 255 & t3), c4;
            }, t2.fromByteArray = function(e3) {
              for (var t3, n2 = e3.length, s3 = n2 % 3, i2 = [], o2 = 16383, a2 = 0, l2 = n2 - s3; a2 < l2; a2 += o2)
                i2.push(c(e3, a2, a2 + o2 > l2 ? l2 : a2 + o2));
              return s3 === 1 ? (t3 = e3[n2 - 1], i2.push(r2[t3 >> 2] + r2[t3 << 4 & 63] + "==")) : s3 === 2 && (t3 = (e3[n2 - 2] << 8) + e3[n2 - 1], i2.push(r2[t3 >> 10] + r2[t3 >> 4 & 63] + r2[t3 << 2 & 63] + "=")), i2.join("");
            };
            for (var r2 = [], n = [], s2 = typeof Uint8Array != "undefined" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = i.length; o < a; ++o)
              r2[o] = i[o], n[i.charCodeAt(o)] = o;
            function l(e3) {
              var t3 = e3.length;
              if (t3 % 4 > 0)
                throw new Error("Invalid string. Length must be a multiple of 4");
              var r3 = e3.indexOf("=");
              return r3 === -1 && (r3 = t3), [r3, r3 === t3 ? 0 : 4 - r3 % 4];
            }
            function c(e3, t3, n2) {
              for (var s3, i2, o2 = [], a2 = t3; a2 < n2; a2 += 3)
                s3 = (e3[a2] << 16 & 16711680) + (e3[a2 + 1] << 8 & 65280) + (255 & e3[a2 + 2]), o2.push(r2[(i2 = s3) >> 18 & 63] + r2[i2 >> 12 & 63] + r2[i2 >> 6 & 63] + r2[63 & i2]);
              return o2.join("");
            }
            n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
          }, (e2, t2) => {
            t2.read = function(e3, t3, r2, n, s2) {
              var i, o, a = 8 * s2 - n - 1, l = (1 << a) - 1, c = l >> 1, u = -7, p2 = r2 ? s2 - 1 : 0, f = r2 ? -1 : 1, d = e3[t3 + p2];
              for (p2 += f, i = d & (1 << -u) - 1, d >>= -u, u += a; u > 0; i = 256 * i + e3[t3 + p2], p2 += f, u -= 8)
                ;
              for (o = i & (1 << -u) - 1, i >>= -u, u += n; u > 0; o = 256 * o + e3[t3 + p2], p2 += f, u -= 8)
                ;
              if (i === 0)
                i = 1 - c;
              else {
                if (i === l)
                  return o ? NaN : 1 / 0 * (d ? -1 : 1);
                o += Math.pow(2, n), i -= c;
              }
              return (d ? -1 : 1) * o * Math.pow(2, i - n);
            }, t2.write = function(e3, t3, r2, n, s2, i) {
              var o, a, l, c = 8 * i - s2 - 1, u = (1 << c) - 1, p2 = u >> 1, f = s2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d = n ? 0 : i - 1, h3 = n ? 1 : -1, m = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
              for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (a = isNaN(t3) ? 1 : 0, o = u) : (o = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -o)) < 1 && (o--, l *= 2), (t3 += o + p2 >= 1 ? f / l : f * Math.pow(2, 1 - p2)) * l >= 2 && (o++, l /= 2), o + p2 >= u ? (a = 0, o = u) : o + p2 >= 1 ? (a = (t3 * l - 1) * Math.pow(2, s2), o += p2) : (a = t3 * Math.pow(2, p2 - 1) * Math.pow(2, s2), o = 0)); s2 >= 8; e3[r2 + d] = 255 & a, d += h3, a /= 256, s2 -= 8)
                ;
              for (o = o << s2 | a, c += s2; c > 0; e3[r2 + d] = 255 & o, d += h3, o /= 256, c -= 8)
                ;
              e3[r2 + d - h3] |= 128 * m;
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.AnyTypeAnnotation = function() {
              this.word("any");
            }, t2.ArrayTypeAnnotation = function(e3) {
              this.print(e3.elementType, e3), this.token("["), this.token("]");
            }, t2.BooleanTypeAnnotation = function() {
              this.word("boolean");
            }, t2.BooleanLiteralTypeAnnotation = function(e3) {
              this.word(e3.value ? "true" : "false");
            }, t2.NullLiteralTypeAnnotation = function() {
              this.word("null");
            }, t2.DeclareClass = function(e3, t3) {
              n.isDeclareExportDeclaration(t3) || (this.word("declare"), this.space()), this.word("class"), this.space(), this._interfaceish(e3);
            }, t2.DeclareFunction = function(e3, t3) {
              n.isDeclareExportDeclaration(t3) || (this.word("declare"), this.space()), this.word("function"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation.typeAnnotation, e3), e3.predicate && (this.space(), this.print(e3.predicate, e3)), this.semicolon();
            }, t2.InferredPredicate = function() {
              this.token("%"), this.word("checks");
            }, t2.DeclaredPredicate = function(e3) {
              this.token("%"), this.word("checks"), this.token("("), this.print(e3.value, e3), this.token(")");
            }, t2.DeclareInterface = function(e3) {
              this.word("declare"), this.space(), this.InterfaceDeclaration(e3);
            }, t2.DeclareModule = function(e3) {
              this.word("declare"), this.space(), this.word("module"), this.space(), this.print(e3.id, e3), this.space(), this.print(e3.body, e3);
            }, t2.DeclareModuleExports = function(e3) {
              this.word("declare"), this.space(), this.word("module"), this.token("."), this.word("exports"), this.print(e3.typeAnnotation, e3);
            }, t2.DeclareTypeAlias = function(e3) {
              this.word("declare"), this.space(), this.TypeAlias(e3);
            }, t2.DeclareOpaqueType = function(e3, t3) {
              n.isDeclareExportDeclaration(t3) || (this.word("declare"), this.space()), this.OpaqueType(e3);
            }, t2.DeclareVariable = function(e3, t3) {
              n.isDeclareExportDeclaration(t3) || (this.word("declare"), this.space()), this.word("var"), this.space(), this.print(e3.id, e3), this.print(e3.id.typeAnnotation, e3), this.semicolon();
            }, t2.DeclareExportDeclaration = function(e3) {
              this.word("declare"), this.space(), this.word("export"), this.space(), e3.default && (this.word("default"), this.space()), c.apply(this, arguments);
            }, t2.DeclareExportAllDeclaration = function() {
              this.word("declare"), this.space(), s2.ExportAllDeclaration.apply(this, arguments);
            }, t2.EnumDeclaration = function(e3) {
              const { id: t3, body: r3 } = e3;
              this.word("enum"), this.space(), this.print(t3, e3), this.print(r3, e3);
            }, t2.EnumBooleanBody = function(e3) {
              const { explicitType: t3 } = e3;
              o(this, "boolean", t3), a(this, e3);
            }, t2.EnumNumberBody = function(e3) {
              const { explicitType: t3 } = e3;
              o(this, "number", t3), a(this, e3);
            }, t2.EnumStringBody = function(e3) {
              const { explicitType: t3 } = e3;
              o(this, "string", t3), a(this, e3);
            }, t2.EnumSymbolBody = function(e3) {
              o(this, "symbol", true), a(this, e3);
            }, t2.EnumDefaultedMember = function(e3) {
              const { id: t3 } = e3;
              this.print(t3, e3), this.token(",");
            }, t2.EnumBooleanMember = function(e3) {
              l(this, e3);
            }, t2.EnumNumberMember = function(e3) {
              l(this, e3);
            }, t2.EnumStringMember = function(e3) {
              l(this, e3);
            }, t2.ExistsTypeAnnotation = function() {
              this.token("*");
            }, t2.FunctionTypeAnnotation = function(e3, t3) {
              this.print(e3.typeParameters, e3), this.token("("), e3.this && (this.word("this"), this.token(":"), this.space(), this.print(e3.this.typeAnnotation, e3), (e3.params.length || e3.rest) && (this.token(","), this.space())), this.printList(e3.params, e3), e3.rest && (e3.params.length && (this.token(","), this.space()), this.token("..."), this.print(e3.rest, e3)), this.token(")"), t3.type === "ObjectTypeCallProperty" || t3.type === "DeclareFunction" || t3.type === "ObjectTypeProperty" && t3.method ? this.token(":") : (this.space(), this.token("=>")), this.space(), this.print(e3.returnType, e3);
            }, t2.FunctionTypeParam = function(e3) {
              this.print(e3.name, e3), e3.optional && this.token("?"), e3.name && (this.token(":"), this.space()), this.print(e3.typeAnnotation, e3);
            }, t2.GenericTypeAnnotation = t2.ClassImplements = t2.InterfaceExtends = function(e3) {
              this.print(e3.id, e3), this.print(e3.typeParameters, e3);
            }, t2._interfaceish = function(e3) {
              var t3;
              this.print(e3.id, e3), this.print(e3.typeParameters, e3), (t3 = e3.extends) != null && t3.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), e3.mixins && e3.mixins.length && (this.space(), this.word("mixins"), this.space(), this.printList(e3.mixins, e3)), e3.implements && e3.implements.length && (this.space(), this.word("implements"), this.space(), this.printList(e3.implements, e3)), this.space(), this.print(e3.body, e3);
            }, t2._variance = function(e3) {
              e3.variance && (e3.variance.kind === "plus" ? this.token("+") : e3.variance.kind === "minus" && this.token("-"));
            }, t2.InterfaceDeclaration = function(e3) {
              this.word("interface"), this.space(), this._interfaceish(e3);
            }, t2.InterfaceTypeAnnotation = function(e3) {
              this.word("interface"), e3.extends && e3.extends.length && (this.space(), this.word("extends"), this.space(), this.printList(e3.extends, e3)), this.space(), this.print(e3.body, e3);
            }, t2.IntersectionTypeAnnotation = function(e3) {
              this.printJoin(e3.types, e3, { separator: u });
            }, t2.MixedTypeAnnotation = function() {
              this.word("mixed");
            }, t2.EmptyTypeAnnotation = function() {
              this.word("empty");
            }, t2.NullableTypeAnnotation = function(e3) {
              this.token("?"), this.print(e3.typeAnnotation, e3);
            }, t2.NumberTypeAnnotation = function() {
              this.word("number");
            }, t2.StringTypeAnnotation = function() {
              this.word("string");
            }, t2.ThisTypeAnnotation = function() {
              this.word("this");
            }, t2.TupleTypeAnnotation = function(e3) {
              this.token("["), this.printList(e3.types, e3), this.token("]");
            }, t2.TypeofTypeAnnotation = function(e3) {
              this.word("typeof"), this.space(), this.print(e3.argument, e3);
            }, t2.TypeAlias = function(e3) {
              this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), this.space(), this.token("="), this.space(), this.print(e3.right, e3), this.semicolon();
            }, t2.TypeAnnotation = function(e3) {
              this.token(":"), this.space(), e3.optional && this.token("?"), this.print(e3.typeAnnotation, e3);
            }, t2.TypeParameterDeclaration = t2.TypeParameterInstantiation = function(e3) {
              this.token("<"), this.printList(e3.params, e3, {}), this.token(">");
            }, t2.TypeParameter = function(e3) {
              this._variance(e3), this.word(e3.name), e3.bound && this.print(e3.bound, e3), e3.default && (this.space(), this.token("="), this.space(), this.print(e3.default, e3));
            }, t2.OpaqueType = function(e3) {
              this.word("opaque"), this.space(), this.word("type"), this.space(), this.print(e3.id, e3), this.print(e3.typeParameters, e3), e3.supertype && (this.token(":"), this.space(), this.print(e3.supertype, e3)), e3.impltype && (this.space(), this.token("="), this.space(), this.print(e3.impltype, e3)), this.semicolon();
            }, t2.ObjectTypeAnnotation = function(e3) {
              e3.exact ? this.token("{|") : this.token("{");
              const t3 = [...e3.properties, ...e3.callProperties || [], ...e3.indexers || [], ...e3.internalSlots || []];
              t3.length && (this.space(), this.printJoin(t3, e3, { addNewlines(e4) {
                if (e4 && !t3[0])
                  return 1;
              }, indent: true, statement: true, iterator: () => {
                (t3.length !== 1 || e3.inexact) && (this.token(","), this.space());
              } }), this.space()), e3.inexact && (this.indent(), this.token("..."), t3.length && this.newline(), this.dedent()), e3.exact ? this.token("|}") : this.token("}");
            }, t2.ObjectTypeInternalSlot = function(e3) {
              e3.static && (this.word("static"), this.space()), this.token("["), this.token("["), this.print(e3.id, e3), this.token("]"), this.token("]"), e3.optional && this.token("?"), e3.method || (this.token(":"), this.space()), this.print(e3.value, e3);
            }, t2.ObjectTypeCallProperty = function(e3) {
              e3.static && (this.word("static"), this.space()), this.print(e3.value, e3);
            }, t2.ObjectTypeIndexer = function(e3) {
              e3.static && (this.word("static"), this.space()), this._variance(e3), this.token("["), e3.id && (this.print(e3.id, e3), this.token(":"), this.space()), this.print(e3.key, e3), this.token("]"), this.token(":"), this.space(), this.print(e3.value, e3);
            }, t2.ObjectTypeProperty = function(e3) {
              e3.proto && (this.word("proto"), this.space()), e3.static && (this.word("static"), this.space()), e3.kind !== "get" && e3.kind !== "set" || (this.word(e3.kind), this.space()), this._variance(e3), this.print(e3.key, e3), e3.optional && this.token("?"), e3.method || (this.token(":"), this.space()), this.print(e3.value, e3);
            }, t2.ObjectTypeSpreadProperty = function(e3) {
              this.token("..."), this.print(e3.argument, e3);
            }, t2.QualifiedTypeIdentifier = function(e3) {
              this.print(e3.qualification, e3), this.token("."), this.print(e3.id, e3);
            }, t2.SymbolTypeAnnotation = function() {
              this.word("symbol");
            }, t2.UnionTypeAnnotation = function(e3) {
              this.printJoin(e3.types, e3, { separator: p2 });
            }, t2.TypeCastExpression = function(e3) {
              this.token("("), this.print(e3.expression, e3), this.print(e3.typeAnnotation, e3), this.token(")");
            }, t2.Variance = function(e3) {
              e3.kind === "plus" ? this.token("+") : this.token("-");
            }, t2.VoidTypeAnnotation = function() {
              this.word("void");
            }, t2.IndexedAccessType = function(e3) {
              this.print(e3.objectType, e3), this.token("["), this.print(e3.indexType, e3), this.token("]");
            }, t2.OptionalIndexedAccessType = function(e3) {
              this.print(e3.objectType, e3), e3.optional && this.token("?."), this.token("["), this.print(e3.indexType, e3), this.token("]");
            }, Object.defineProperty(t2, "NumberLiteralTypeAnnotation", { enumerable: true, get: function() {
              return i.NumericLiteral;
            } }), Object.defineProperty(t2, "StringLiteralTypeAnnotation", { enumerable: true, get: function() {
              return i.StringLiteral;
            } });
            var n = r2(0), s2 = r2(234), i = r2(235);
            function o(e3, t3, r3) {
              r3 && (e3.space(), e3.word("of"), e3.space(), e3.word(t3)), e3.space();
            }
            function a(e3, t3) {
              const { members: r3 } = t3;
              e3.token("{"), e3.indent(), e3.newline();
              for (const n2 of r3)
                e3.print(n2, t3), e3.newline();
              t3.hasUnknownMembers && (e3.token("..."), e3.newline()), e3.dedent(), e3.token("}");
            }
            function l(e3, t3) {
              const { id: r3, init: n2 } = t3;
              e3.print(r3, t3), e3.space(), e3.token("="), e3.space(), e3.print(n2, t3), e3.token(",");
            }
            function c(e3) {
              if (e3.declaration) {
                const t3 = e3.declaration;
                this.print(t3, e3), n.isStatement(t3) || this.semicolon();
              } else
                this.token("{"), e3.specifiers.length && (this.space(), this.printList(e3.specifiers, e3), this.space()), this.token("}"), e3.source && (this.space(), this.word("from"), this.space(), this.print(e3.source, e3)), this.semicolon();
            }
            function u() {
              this.space(), this.token("&"), this.space();
            }
            function p2() {
              this.space(), this.token("|"), this.space();
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.File = function(e3) {
              e3.program && this.print(e3.program.interpreter, e3), this.print(e3.program, e3);
            }, t2.Program = function(e3) {
              this.printInnerComments(e3, false), this.printSequence(e3.directives, e3), e3.directives && e3.directives.length && this.newline(), this.printSequence(e3.body, e3);
            }, t2.BlockStatement = function(e3) {
              var t3;
              this.token("{"), this.printInnerComments(e3);
              const r3 = (t3 = e3.directives) == null ? void 0 : t3.length;
              e3.body.length || r3 ? (this.newline(), this.printSequence(e3.directives, e3, { indent: true }), r3 && this.newline(), this.printSequence(e3.body, e3, { indent: true }), this.removeTrailingNewline(), this.source("end", e3.loc), this.endsWith("\n") || this.newline(), this.rightBrace()) : (this.source("end", e3.loc), this.token("}"));
            }, t2.Directive = function(e3) {
              this.print(e3.value, e3), this.semicolon();
            }, t2.DirectiveLiteral = function(e3) {
              const t3 = this.getPossibleRaw(e3);
              if (t3 != null)
                return void this.token(t3);
              const { value: r3 } = e3;
              if (s2.test(r3)) {
                if (n.test(r3))
                  throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
                this.token(`'${r3}'`);
              } else
                this.token(`"${r3}"`);
            }, t2.InterpreterDirective = function(e3) {
              this.token(`#!${e3.value}
`);
            }, t2.Placeholder = function(e3) {
              this.token("%%"), this.print(e3.name), this.token("%%"), e3.expectedNode === "Statement" && this.semicolon();
            }, r2(0);
            const n = /(?:^|[^\\])(?:\\\\)*'/, s2 = /(?:^|[^\\])(?:\\\\)*"/;
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              this.space();
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.JSXAttribute = function(e3) {
              this.print(e3.name, e3), e3.value && (this.token("="), this.print(e3.value, e3));
            }, t2.JSXIdentifier = function(e3) {
              this.word(e3.name);
            }, t2.JSXNamespacedName = function(e3) {
              this.print(e3.namespace, e3), this.token(":"), this.print(e3.name, e3);
            }, t2.JSXMemberExpression = function(e3) {
              this.print(e3.object, e3), this.token("."), this.print(e3.property, e3);
            }, t2.JSXSpreadAttribute = function(e3) {
              this.token("{"), this.token("..."), this.print(e3.argument, e3), this.token("}");
            }, t2.JSXExpressionContainer = function(e3) {
              this.token("{"), this.print(e3.expression, e3), this.token("}");
            }, t2.JSXSpreadChild = function(e3) {
              this.token("{"), this.token("..."), this.print(e3.expression, e3), this.token("}");
            }, t2.JSXText = function(e3) {
              const t3 = this.getPossibleRaw(e3);
              t3 != null ? this.token(t3) : this.token(e3.value);
            }, t2.JSXElement = function(e3) {
              const t3 = e3.openingElement;
              if (this.print(t3, e3), !t3.selfClosing) {
                this.indent();
                for (const t4 of e3.children)
                  this.print(t4, e3);
                this.dedent(), this.print(e3.closingElement, e3);
              }
            }, t2.JSXOpeningElement = function(e3) {
              this.token("<"), this.print(e3.name, e3), this.print(e3.typeParameters, e3), e3.attributes.length > 0 && (this.space(), this.printJoin(e3.attributes, e3, { separator: n })), e3.selfClosing ? (this.space(), this.token("/>")) : this.token(">");
            }, t2.JSXClosingElement = function(e3) {
              this.token("</"), this.print(e3.name, e3), this.token(">");
            }, t2.JSXEmptyExpression = function(e3) {
              this.printInnerComments(e3);
            }, t2.JSXFragment = function(e3) {
              this.print(e3.openingFragment, e3), this.indent();
              for (const t3 of e3.children)
                this.print(t3, e3);
              this.dedent(), this.print(e3.closingFragment, e3);
            }, t2.JSXOpeningFragment = function() {
              this.token("<"), this.token(">");
            }, t2.JSXClosingFragment = function() {
              this.token("</"), this.token(">");
            }, r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3, t3) {
              t3 !== true && e3.token(t3);
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TSTypeAnnotation = function(e3) {
              this.token(":"), this.space(), e3.optional && this.token("?"), this.print(e3.typeAnnotation, e3);
            }, t2.TSTypeParameterDeclaration = t2.TSTypeParameterInstantiation = function(e3) {
              this.token("<"), this.printList(e3.params, e3, {}), this.token(">");
            }, t2.TSTypeParameter = function(e3) {
              this.word(e3.name), e3.constraint && (this.space(), this.word("extends"), this.space(), this.print(e3.constraint, e3)), e3.default && (this.space(), this.token("="), this.space(), this.print(e3.default, e3));
            }, t2.TSParameterProperty = function(e3) {
              e3.accessibility && (this.word(e3.accessibility), this.space()), e3.readonly && (this.word("readonly"), this.space()), this._param(e3.parameter);
            }, t2.TSDeclareFunction = function(e3) {
              e3.declare && (this.word("declare"), this.space()), this._functionHead(e3), this.token(";");
            }, t2.TSDeclareMethod = function(e3) {
              this._classMethodHead(e3), this.token(";");
            }, t2.TSQualifiedName = function(e3) {
              this.print(e3.left, e3), this.token("."), this.print(e3.right, e3);
            }, t2.TSCallSignatureDeclaration = function(e3) {
              this.tsPrintSignatureDeclarationBase(e3), this.token(";");
            }, t2.TSConstructSignatureDeclaration = function(e3) {
              this.word("new"), this.space(), this.tsPrintSignatureDeclarationBase(e3), this.token(";");
            }, t2.TSPropertySignature = function(e3) {
              const { readonly: t3, initializer: r3 } = e3;
              t3 && (this.word("readonly"), this.space()), this.tsPrintPropertyOrMethodName(e3), this.print(e3.typeAnnotation, e3), r3 && (this.space(), this.token("="), this.space(), this.print(r3, e3)), this.token(";");
            }, t2.tsPrintPropertyOrMethodName = function(e3) {
              e3.computed && this.token("["), this.print(e3.key, e3), e3.computed && this.token("]"), e3.optional && this.token("?");
            }, t2.TSMethodSignature = function(e3) {
              const { kind: t3 } = e3;
              t3 !== "set" && t3 !== "get" || (this.word(t3), this.space()), this.tsPrintPropertyOrMethodName(e3), this.tsPrintSignatureDeclarationBase(e3), this.token(";");
            }, t2.TSIndexSignature = function(e3) {
              const { readonly: t3, static: r3 } = e3;
              r3 && (this.word("static"), this.space()), t3 && (this.word("readonly"), this.space()), this.token("["), this._parameters(e3.parameters, e3), this.token("]"), this.print(e3.typeAnnotation, e3), this.token(";");
            }, t2.TSAnyKeyword = function() {
              this.word("any");
            }, t2.TSBigIntKeyword = function() {
              this.word("bigint");
            }, t2.TSUnknownKeyword = function() {
              this.word("unknown");
            }, t2.TSNumberKeyword = function() {
              this.word("number");
            }, t2.TSObjectKeyword = function() {
              this.word("object");
            }, t2.TSBooleanKeyword = function() {
              this.word("boolean");
            }, t2.TSStringKeyword = function() {
              this.word("string");
            }, t2.TSSymbolKeyword = function() {
              this.word("symbol");
            }, t2.TSVoidKeyword = function() {
              this.word("void");
            }, t2.TSUndefinedKeyword = function() {
              this.word("undefined");
            }, t2.TSNullKeyword = function() {
              this.word("null");
            }, t2.TSNeverKeyword = function() {
              this.word("never");
            }, t2.TSIntrinsicKeyword = function() {
              this.word("intrinsic");
            }, t2.TSThisType = function() {
              this.word("this");
            }, t2.TSFunctionType = function(e3) {
              this.tsPrintFunctionOrConstructorType(e3);
            }, t2.TSConstructorType = function(e3) {
              e3.abstract && (this.word("abstract"), this.space()), this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e3);
            }, t2.tsPrintFunctionOrConstructorType = function(e3) {
              const { typeParameters: t3, parameters: r3 } = e3;
              this.print(t3, e3), this.token("("), this._parameters(r3, e3), this.token(")"), this.space(), this.token("=>"), this.space(), this.print(e3.typeAnnotation.typeAnnotation, e3);
            }, t2.TSTypeReference = function(e3) {
              this.print(e3.typeName, e3), this.print(e3.typeParameters, e3);
            }, t2.TSTypePredicate = function(e3) {
              e3.asserts && (this.word("asserts"), this.space()), this.print(e3.parameterName), e3.typeAnnotation && (this.space(), this.word("is"), this.space(), this.print(e3.typeAnnotation.typeAnnotation));
            }, t2.TSTypeQuery = function(e3) {
              this.word("typeof"), this.space(), this.print(e3.exprName);
            }, t2.TSTypeLiteral = function(e3) {
              this.tsPrintTypeLiteralOrInterfaceBody(e3.members, e3);
            }, t2.tsPrintTypeLiteralOrInterfaceBody = function(e3, t3) {
              this.tsPrintBraced(e3, t3);
            }, t2.tsPrintBraced = function(e3, t3) {
              if (this.token("{"), e3.length) {
                this.indent(), this.newline();
                for (const r3 of e3)
                  this.print(r3, t3), this.newline();
                this.dedent(), this.rightBrace();
              } else
                this.token("}");
            }, t2.TSArrayType = function(e3) {
              this.print(e3.elementType, e3), this.token("[]");
            }, t2.TSTupleType = function(e3) {
              this.token("["), this.printList(e3.elementTypes, e3), this.token("]");
            }, t2.TSOptionalType = function(e3) {
              this.print(e3.typeAnnotation, e3), this.token("?");
            }, t2.TSRestType = function(e3) {
              this.token("..."), this.print(e3.typeAnnotation, e3);
            }, t2.TSNamedTupleMember = function(e3) {
              this.print(e3.label, e3), e3.optional && this.token("?"), this.token(":"), this.space(), this.print(e3.elementType, e3);
            }, t2.TSUnionType = function(e3) {
              this.tsPrintUnionOrIntersectionType(e3, "|");
            }, t2.TSIntersectionType = function(e3) {
              this.tsPrintUnionOrIntersectionType(e3, "&");
            }, t2.tsPrintUnionOrIntersectionType = function(e3, t3) {
              this.printJoin(e3.types, e3, { separator() {
                this.space(), this.token(t3), this.space();
              } });
            }, t2.TSConditionalType = function(e3) {
              this.print(e3.checkType), this.space(), this.word("extends"), this.space(), this.print(e3.extendsType), this.space(), this.token("?"), this.space(), this.print(e3.trueType), this.space(), this.token(":"), this.space(), this.print(e3.falseType);
            }, t2.TSInferType = function(e3) {
              this.token("infer"), this.space(), this.print(e3.typeParameter);
            }, t2.TSParenthesizedType = function(e3) {
              this.token("("), this.print(e3.typeAnnotation, e3), this.token(")");
            }, t2.TSTypeOperator = function(e3) {
              this.word(e3.operator), this.space(), this.print(e3.typeAnnotation, e3);
            }, t2.TSIndexedAccessType = function(e3) {
              this.print(e3.objectType, e3), this.token("["), this.print(e3.indexType, e3), this.token("]");
            }, t2.TSMappedType = function(e3) {
              const { nameType: t3, optional: r3, readonly: s2, typeParameter: i } = e3;
              this.token("{"), this.space(), s2 && (n(this, s2), this.word("readonly"), this.space()), this.token("["), this.word(i.name), this.space(), this.word("in"), this.space(), this.print(i.constraint, i), t3 && (this.space(), this.word("as"), this.space(), this.print(t3, e3)), this.token("]"), r3 && (n(this, r3), this.token("?")), this.token(":"), this.space(), this.print(e3.typeAnnotation, e3), this.space(), this.token("}");
            }, t2.TSLiteralType = function(e3) {
              this.print(e3.literal, e3);
            }, t2.TSExpressionWithTypeArguments = function(e3) {
              this.print(e3.expression, e3), this.print(e3.typeParameters, e3);
            }, t2.TSInterfaceDeclaration = function(e3) {
              const { declare: t3, id: r3, typeParameters: n2, extends: s2, body: i } = e3;
              t3 && (this.word("declare"), this.space()), this.word("interface"), this.space(), this.print(r3, e3), this.print(n2, e3), s2 != null && s2.length && (this.space(), this.word("extends"), this.space(), this.printList(s2, e3)), this.space(), this.print(i, e3);
            }, t2.TSInterfaceBody = function(e3) {
              this.tsPrintTypeLiteralOrInterfaceBody(e3.body, e3);
            }, t2.TSTypeAliasDeclaration = function(e3) {
              const { declare: t3, id: r3, typeParameters: n2, typeAnnotation: s2 } = e3;
              t3 && (this.word("declare"), this.space()), this.word("type"), this.space(), this.print(r3, e3), this.print(n2, e3), this.space(), this.token("="), this.space(), this.print(s2, e3), this.token(";");
            }, t2.TSAsExpression = function(e3) {
              const { expression: t3, typeAnnotation: r3 } = e3;
              this.print(t3, e3), this.space(), this.word("as"), this.space(), this.print(r3, e3);
            }, t2.TSTypeAssertion = function(e3) {
              const { typeAnnotation: t3, expression: r3 } = e3;
              this.token("<"), this.print(t3, e3), this.token(">"), this.space(), this.print(r3, e3);
            }, t2.TSEnumDeclaration = function(e3) {
              const { declare: t3, const: r3, id: n2, members: s2 } = e3;
              t3 && (this.word("declare"), this.space()), r3 && (this.word("const"), this.space()), this.word("enum"), this.space(), this.print(n2, e3), this.space(), this.tsPrintBraced(s2, e3);
            }, t2.TSEnumMember = function(e3) {
              const { id: t3, initializer: r3 } = e3;
              this.print(t3, e3), r3 && (this.space(), this.token("="), this.space(), this.print(r3, e3)), this.token(",");
            }, t2.TSModuleDeclaration = function(e3) {
              const { declare: t3, id: r3 } = e3;
              if (t3 && (this.word("declare"), this.space()), e3.global || (this.word(r3.type === "Identifier" ? "namespace" : "module"), this.space()), this.print(r3, e3), !e3.body)
                return void this.token(";");
              let n2 = e3.body;
              for (; n2.type === "TSModuleDeclaration"; )
                this.token("."), this.print(n2.id, n2), n2 = n2.body;
              this.space(), this.print(n2, e3);
            }, t2.TSModuleBlock = function(e3) {
              this.tsPrintBraced(e3.body, e3);
            }, t2.TSImportType = function(e3) {
              const { argument: t3, qualifier: r3, typeParameters: n2 } = e3;
              this.word("import"), this.token("("), this.print(t3, e3), this.token(")"), r3 && (this.token("."), this.print(r3, e3)), n2 && this.print(n2, e3);
            }, t2.TSImportEqualsDeclaration = function(e3) {
              const { isExport: t3, id: r3, moduleReference: n2 } = e3;
              t3 && (this.word("export"), this.space()), this.word("import"), this.space(), this.print(r3, e3), this.space(), this.token("="), this.space(), this.print(n2, e3), this.token(";");
            }, t2.TSExternalModuleReference = function(e3) {
              this.token("require("), this.print(e3.expression, e3), this.token(")");
            }, t2.TSNonNullExpression = function(e3) {
              this.print(e3.expression, e3), this.token("!");
            }, t2.TSExportAssignment = function(e3) {
              this.word("export"), this.space(), this.token("="), this.space(), this.print(e3.expression, e3), this.token(";");
            }, t2.TSNamespaceExportDeclaration = function(e3) {
              this.word("export"), this.space(), this.word("as"), this.space(), this.word("namespace"), this.space(), this.print(e3.id, e3);
            }, t2.tsPrintSignatureDeclarationBase = function(e3) {
              const { typeParameters: t3, parameters: r3 } = e3;
              this.print(t3, e3), this.token("("), this._parameters(r3, e3), this.token(")"), this.print(e3.typeAnnotation, e3);
            }, t2.tsPrintClassMemberModifiers = function(e3, t3) {
              t3 && e3.declare && (this.word("declare"), this.space()), e3.accessibility && (this.word(e3.accessibility), this.space()), e3.static && (this.word("static"), this.space()), e3.override && (this.word("override"), this.space()), e3.abstract && (this.word("abstract"), this.space()), t3 && e3.readonly && (this.word("readonly"), this.space());
            }, r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.findParent = function(e3) {
              let t3 = this;
              for (; t3 = t3.parentPath; )
                if (e3(t3))
                  return t3;
              return null;
            }, t2.find = function(e3) {
              let t3 = this;
              do {
                if (e3(t3))
                  return t3;
              } while (t3 = t3.parentPath);
              return null;
            }, t2.getFunctionParent = function() {
              return this.findParent((e3) => e3.isFunction());
            }, t2.getStatementParent = function() {
              let e3 = this;
              do {
                if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement())
                  break;
                e3 = e3.parentPath;
              } while (e3);
              if (e3 && (e3.isProgram() || e3.isFile()))
                throw new Error("File/Program node, we can't possibly find a statement parent to this");
              return e3;
            }, t2.getEarliestCommonAncestorFrom = function(e3) {
              return this.getDeepestCommonAncestorFrom(e3, function(e4, t3, r3) {
                let s2;
                const i = n.VISITOR_KEYS[e4.type];
                for (const e5 of r3) {
                  const r4 = e5[t3 + 1];
                  s2 ? (r4.listKey && s2.listKey === r4.listKey && r4.key < s2.key || i.indexOf(s2.parentKey) > i.indexOf(r4.parentKey)) && (s2 = r4) : s2 = r4;
                }
                return s2;
              });
            }, t2.getDeepestCommonAncestorFrom = function(e3, t3) {
              if (!e3.length)
                return this;
              if (e3.length === 1)
                return e3[0];
              let r3, n2, s2 = 1 / 0;
              const i = e3.map((e4) => {
                const t4 = [];
                do {
                  t4.unshift(e4);
                } while ((e4 = e4.parentPath) && e4 !== this);
                return t4.length < s2 && (s2 = t4.length), t4;
              }), o = i[0];
              e:
                for (let e4 = 0; e4 < s2; e4++) {
                  const t4 = o[e4];
                  for (const r4 of i)
                    if (r4[e4] !== t4)
                      break e;
                  r3 = e4, n2 = t4;
                }
              if (n2)
                return t3 ? t3(n2, r3, i) : n2;
              throw new Error("Couldn't find intersection");
            }, t2.getAncestry = function() {
              let e3 = this;
              const t3 = [];
              do {
                t3.push(e3);
              } while (e3 = e3.parentPath);
              return t3;
            }, t2.isAncestor = function(e3) {
              return e3.isDescendant(this);
            }, t2.isDescendant = function(e3) {
              return !!this.findParent((t3) => t3 === e3);
            }, t2.inType = function(...e3) {
              let t3 = this;
              for (; t3; ) {
                for (const r3 of e3)
                  if (t3.node.type === r3)
                    return true;
                t3 = t3.parentPath;
              }
              return false;
            };
            var n = r2(0);
            r2(19);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.getTypeAnnotation = function() {
              if (this.typeAnnotation)
                return this.typeAnnotation;
              let e3 = this._getTypeAnnotation() || s2.anyTypeAnnotation();
              return s2.isTypeAnnotation(e3) && (e3 = e3.typeAnnotation), this.typeAnnotation = e3;
            }, t2._getTypeAnnotation = function() {
              const e3 = this.node;
              if (e3) {
                if (e3.typeAnnotation)
                  return e3.typeAnnotation;
                if (!i.has(e3)) {
                  i.add(e3);
                  try {
                    var t3;
                    let r3 = n[e3.type];
                    if (r3)
                      return r3.call(this, e3);
                    if (r3 = n[this.parentPath.type], (t3 = r3) != null && t3.validParent)
                      return this.parentPath.getTypeAnnotation();
                  } finally {
                    i.delete(e3);
                  }
                }
              } else if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
                const e4 = this.parentPath.parentPath, t4 = e4.parentPath;
                return e4.key === "left" && t4.isForInStatement() ? s2.stringTypeAnnotation() : e4.key === "left" && t4.isForOfStatement() ? s2.anyTypeAnnotation() : s2.voidTypeAnnotation();
              }
            }, t2.isBaseType = function(e3, t3) {
              return o(e3, this.getTypeAnnotation(), t3);
            }, t2.couldBeBaseType = function(e3) {
              const t3 = this.getTypeAnnotation();
              if (s2.isAnyTypeAnnotation(t3))
                return true;
              if (s2.isUnionTypeAnnotation(t3)) {
                for (const r3 of t3.types)
                  if (s2.isAnyTypeAnnotation(r3) || o(e3, r3, true))
                    return true;
                return false;
              }
              return o(e3, t3, true);
            }, t2.baseTypeStrictlyMatches = function(e3) {
              const t3 = this.getTypeAnnotation(), r3 = e3.getTypeAnnotation();
              return !(s2.isAnyTypeAnnotation(t3) || !s2.isFlowBaseAnnotation(t3)) && r3.type === t3.type;
            }, t2.isGenericType = function(e3) {
              const t3 = this.getTypeAnnotation();
              return s2.isGenericTypeAnnotation(t3) && s2.isIdentifier(t3.id, { name: e3 });
            };
            var n = r2(435), s2 = r2(0);
            const i = new WeakSet();
            function o(e3, t3, r3) {
              if (e3 === "string")
                return s2.isStringTypeAnnotation(t3);
              if (e3 === "number")
                return s2.isNumberTypeAnnotation(t3);
              if (e3 === "boolean")
                return s2.isBooleanTypeAnnotation(t3);
              if (e3 === "any")
                return s2.isAnyTypeAnnotation(t3);
              if (e3 === "mixed")
                return s2.isMixedTypeAnnotation(t3);
              if (e3 === "empty")
                return s2.isEmptyTypeAnnotation(t3);
              if (e3 === "void")
                return s2.isVoidTypeAnnotation(t3);
              if (r3)
                return false;
              throw new Error(`Unknown base type ${e3}`);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.VariableDeclarator = function() {
              var e3;
              if (!this.get("id").isIdentifier())
                return;
              const t3 = this.get("init");
              let r3 = t3.getTypeAnnotation();
              return ((e3 = r3) == null ? void 0 : e3.type) === "AnyTypeAnnotation" && t3.isCallExpression() && t3.get("callee").isIdentifier({ name: "Array" }) && !t3.scope.hasBinding("Array", true) && (r3 = o()), r3;
            }, t2.TypeCastExpression = i, t2.NewExpression = function(e3) {
              if (this.get("callee").isIdentifier())
                return n.genericTypeAnnotation(e3.callee);
            }, t2.TemplateLiteral = function() {
              return n.stringTypeAnnotation();
            }, t2.UnaryExpression = function(e3) {
              const t3 = e3.operator;
              return t3 === "void" ? n.voidTypeAnnotation() : n.NUMBER_UNARY_OPERATORS.indexOf(t3) >= 0 ? n.numberTypeAnnotation() : n.STRING_UNARY_OPERATORS.indexOf(t3) >= 0 ? n.stringTypeAnnotation() : n.BOOLEAN_UNARY_OPERATORS.indexOf(t3) >= 0 ? n.booleanTypeAnnotation() : void 0;
            }, t2.BinaryExpression = function(e3) {
              const t3 = e3.operator;
              if (n.NUMBER_BINARY_OPERATORS.indexOf(t3) >= 0)
                return n.numberTypeAnnotation();
              if (n.BOOLEAN_BINARY_OPERATORS.indexOf(t3) >= 0)
                return n.booleanTypeAnnotation();
              if (t3 === "+") {
                const e4 = this.get("right"), t4 = this.get("left");
                return t4.isBaseType("number") && e4.isBaseType("number") ? n.numberTypeAnnotation() : t4.isBaseType("string") || e4.isBaseType("string") ? n.stringTypeAnnotation() : n.unionTypeAnnotation([n.stringTypeAnnotation(), n.numberTypeAnnotation()]);
              }
            }, t2.LogicalExpression = function() {
              const e3 = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
              return n.isTSTypeAnnotation(e3[0]) && n.createTSUnionType ? n.createTSUnionType(e3) : n.createFlowUnionType ? n.createFlowUnionType(e3) : n.createUnionTypeAnnotation(e3);
            }, t2.ConditionalExpression = function() {
              const e3 = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
              return n.isTSTypeAnnotation(e3[0]) && n.createTSUnionType ? n.createTSUnionType(e3) : n.createFlowUnionType ? n.createFlowUnionType(e3) : n.createUnionTypeAnnotation(e3);
            }, t2.SequenceExpression = function() {
              return this.get("expressions").pop().getTypeAnnotation();
            }, t2.ParenthesizedExpression = function() {
              return this.get("expression").getTypeAnnotation();
            }, t2.AssignmentExpression = function() {
              return this.get("right").getTypeAnnotation();
            }, t2.UpdateExpression = function(e3) {
              const t3 = e3.operator;
              if (t3 === "++" || t3 === "--")
                return n.numberTypeAnnotation();
            }, t2.StringLiteral = function() {
              return n.stringTypeAnnotation();
            }, t2.NumericLiteral = function() {
              return n.numberTypeAnnotation();
            }, t2.BooleanLiteral = function() {
              return n.booleanTypeAnnotation();
            }, t2.NullLiteral = function() {
              return n.nullLiteralTypeAnnotation();
            }, t2.RegExpLiteral = function() {
              return n.genericTypeAnnotation(n.identifier("RegExp"));
            }, t2.ObjectExpression = function() {
              return n.genericTypeAnnotation(n.identifier("Object"));
            }, t2.ArrayExpression = o, t2.RestElement = a, t2.ClassDeclaration = t2.ClassExpression = t2.FunctionDeclaration = t2.ArrowFunctionExpression = t2.FunctionExpression = function() {
              return n.genericTypeAnnotation(n.identifier("Function"));
            }, t2.CallExpression = function() {
              const { callee: e3 } = this.node;
              return c(e3) ? n.arrayTypeAnnotation(n.stringTypeAnnotation()) : l(e3) || u(e3) ? n.arrayTypeAnnotation(n.anyTypeAnnotation()) : p2(e3) ? n.arrayTypeAnnotation(n.tupleTypeAnnotation([n.stringTypeAnnotation(), n.anyTypeAnnotation()])) : f(this.get("callee"));
            }, t2.TaggedTemplateExpression = function() {
              return f(this.get("tag"));
            }, Object.defineProperty(t2, "Identifier", { enumerable: true, get: function() {
              return s2.default;
            } });
            var n = r2(0), s2 = r2(436);
            function i(e3) {
              return e3.typeAnnotation;
            }
            function o() {
              return n.genericTypeAnnotation(n.identifier("Array"));
            }
            function a() {
              return o();
            }
            i.validParent = true, a.validParent = true;
            const l = n.buildMatchMemberExpression("Array.from"), c = n.buildMatchMemberExpression("Object.keys"), u = n.buildMatchMemberExpression("Object.values"), p2 = n.buildMatchMemberExpression("Object.entries");
            function f(e3) {
              if ((e3 = e3.resolve()).isFunction()) {
                if (e3.is("async"))
                  return e3.is("generator") ? n.genericTypeAnnotation(n.identifier("AsyncIterator")) : n.genericTypeAnnotation(n.identifier("Promise"));
                if (e3.node.returnType)
                  return e3.node.returnType;
              }
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              if (!this.isReferenced())
                return;
              const t3 = this.scope.getBinding(e3.name);
              return t3 ? t3.identifier.typeAnnotation ? t3.identifier.typeAnnotation : function(e4, t4, r3) {
                const i2 = [], a = [];
                let l = s2(e4, t4, a);
                const c = o(e4, t4, r3);
                if (c) {
                  const t5 = s2(e4, c.ifStatement);
                  l = l.filter((e5) => t5.indexOf(e5) < 0), i2.push(c.typeAnnotation);
                }
                if (l.length) {
                  l = l.concat(a);
                  for (const e5 of l)
                    i2.push(e5.getTypeAnnotation());
                }
                if (i2.length)
                  return n.isTSTypeAnnotation(i2[0]) && n.createTSUnionType ? n.createTSUnionType(i2) : n.createFlowUnionType ? n.createFlowUnionType(i2) : n.createUnionTypeAnnotation(i2);
              }(t3, this, e3.name) : e3.name === "undefined" ? n.voidTypeAnnotation() : e3.name === "NaN" || e3.name === "Infinity" ? n.numberTypeAnnotation() : void e3.name;
            };
            var n = r2(0);
            function s2(e3, t3, r3) {
              const n2 = e3.constantViolations.slice();
              return n2.unshift(e3.path), n2.filter((e4) => {
                const n3 = (e4 = e4.resolve())._guessExecutionStatusRelativeTo(t3);
                return r3 && n3 === "unknown" && r3.push(e4), n3 === "before";
              });
            }
            function i(e3, t3) {
              const r3 = t3.node.operator, s3 = t3.get("right").resolve(), i2 = t3.get("left").resolve();
              let o2, a, l;
              if (i2.isIdentifier({ name: e3 }) ? o2 = s3 : s3.isIdentifier({ name: e3 }) && (o2 = i2), o2)
                return r3 === "===" ? o2.getTypeAnnotation() : n.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(r3) >= 0 ? n.numberTypeAnnotation() : void 0;
              if (r3 !== "===" && r3 !== "==")
                return;
              if (i2.isUnaryExpression({ operator: "typeof" }) ? (a = i2, l = s3) : s3.isUnaryExpression({ operator: "typeof" }) && (a = s3, l = i2), !a)
                return;
              if (!a.get("argument").isIdentifier({ name: e3 }))
                return;
              if (l = l.resolve(), !l.isLiteral())
                return;
              const c = l.node.value;
              return typeof c == "string" ? n.createTypeAnnotationBasedOnTypeof(c) : void 0;
            }
            function o(e3, t3, r3) {
              const s3 = function(e4, t4, r4) {
                let n2;
                for (; n2 = t4.parentPath; ) {
                  if (n2.isIfStatement() || n2.isConditionalExpression()) {
                    if (t4.key === "test")
                      return;
                    return n2;
                  }
                  if (n2.isFunction() && n2.parentPath.scope.getBinding(r4) !== e4)
                    return;
                  t4 = n2;
                }
              }(e3, t3, r3);
              if (!s3)
                return;
              const a = [s3.get("test")], l = [];
              for (let e4 = 0; e4 < a.length; e4++) {
                const t4 = a[e4];
                if (t4.isLogicalExpression())
                  t4.node.operator === "&&" && (a.push(t4.get("left")), a.push(t4.get("right")));
                else if (t4.isBinaryExpression()) {
                  const e5 = i(r3, t4);
                  e5 && l.push(e5);
                }
              }
              return l.length ? n.isTSTypeAnnotation(l[0]) && n.createTSUnionType ? { typeAnnotation: n.createTSUnionType(l), ifStatement: s3 } : n.createFlowUnionType ? { typeAnnotation: n.createFlowUnionType(l), ifStatement: s3 } : { typeAnnotation: n.createUnionTypeAnnotation(l), ifStatement: s3 } : o(s3, r3);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.replaceWithMultiple = function(e3) {
              var t3;
              this.resync(), e3 = this._verifyNodeList(e3), l.inheritLeadingComments(e3[0], this.node), l.inheritTrailingComments(e3[e3.length - 1], this.node), (t3 = o.path.get(this.parent)) == null || t3.delete(this.node), this.node = this.container[this.key] = null;
              const r3 = this.insertAfter(e3);
              return this.node ? this.requeue() : this.remove(), r3;
            }, t2.replaceWithSourceString = function(e3) {
              this.resync();
              try {
                e3 = `(${e3})`, e3 = (0, a.parse)(e3);
              } catch (t3) {
                const r3 = t3.loc;
                throw r3 && (t3.message += " - make sure this is an expression.\n" + (0, n.codeFrameColumns)(e3, { start: { line: r3.line, column: r3.column + 1 } }), t3.code = "BABEL_REPLACE_SOURCE_ERROR"), t3;
              }
              return e3 = e3.program.body[0].expression, s2.default.removeProperties(e3), this.replaceWith(e3);
            }, t2.replaceWith = function(e3) {
              if (this.resync(), this.removed)
                throw new Error("You can't replace this node, we've already removed it");
              if (e3 instanceof i.default && (e3 = e3.node), !e3)
                throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
              if (this.node === e3)
                return [this];
              if (this.isProgram() && !l.isProgram(e3))
                throw new Error("You can only replace a Program root node with another Program node");
              if (Array.isArray(e3))
                throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
              if (typeof e3 == "string")
                throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
              let t3 = "";
              if (this.isNodeType("Statement") && l.isExpression(e3) && (this.canHaveVariableDeclarationOrExpression() || this.canSwapBetweenExpressionAndStatement(e3) || this.parentPath.isExportDefaultDeclaration() || (e3 = l.expressionStatement(e3), t3 = "expression")), this.isNodeType("Expression") && l.isStatement(e3) && !this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(e3))
                return this.replaceExpressionWithStatements([e3]);
              const r3 = this.node;
              return r3 && (l.inheritsComments(e3, r3), l.removeComments(r3)), this._replaceWith(e3), this.type = e3.type, this.setScope(), this.requeue(), [t3 ? this.get(t3) : this];
            }, t2._replaceWith = function(e3) {
              var t3;
              if (!this.container)
                throw new ReferenceError("Container is falsy");
              this.inList ? l.validate(this.parent, this.key, [e3]) : l.validate(this.parent, this.key, e3), this.debug(`Replace with ${e3 == null ? void 0 : e3.type}`), (t3 = o.path.get(this.parent)) == null || t3.set(e3, this).delete(this.node), this.node = this.container[this.key] = e3;
            }, t2.replaceExpressionWithStatements = function(e3) {
              this.resync();
              const t3 = l.toSequenceExpression(e3, this.scope);
              if (t3)
                return this.replaceWith(t3)[0].get("expressions");
              const r3 = this.getFunctionParent(), n2 = r3 == null ? void 0 : r3.is("async"), i2 = r3 == null ? void 0 : r3.is("generator"), o2 = l.arrowFunctionExpression([], l.blockStatement(e3));
              this.replaceWith(l.callExpression(o2, []));
              const a2 = this.get("callee");
              (0, c.default)(a2.get("body"), (e4) => {
                this.scope.push({ id: e4 });
              }, "var");
              const u = this.get("callee").getCompletionRecords();
              for (const e4 of u) {
                if (!e4.isExpressionStatement())
                  continue;
                const t4 = e4.findParent((e5) => e5.isLoop());
                if (t4) {
                  let r4 = t4.getData("expressionReplacementReturnUid");
                  r4 ? r4 = l.identifier(r4.name) : (r4 = a2.scope.generateDeclaredUidIdentifier("ret"), a2.get("body").pushContainer("body", l.returnStatement(l.cloneNode(r4))), t4.setData("expressionReplacementReturnUid", r4)), e4.get("expression").replaceWith(l.assignmentExpression("=", l.cloneNode(r4), e4.node.expression));
                } else
                  e4.replaceWith(l.returnStatement(e4.node.expression));
              }
              a2.arrowFunctionToExpression();
              const p2 = a2, f = n2 && s2.default.hasType(this.get("callee.body").node, "AwaitExpression", l.FUNCTION_TYPES), d = i2 && s2.default.hasType(this.get("callee.body").node, "YieldExpression", l.FUNCTION_TYPES);
              return f && (p2.set("async", true), d || this.replaceWith(l.awaitExpression(this.node))), d && (p2.set("generator", true), this.replaceWith(l.yieldExpression(this.node, true))), p2.get("body.body");
            }, t2.replaceInline = function(e3) {
              if (this.resync(), Array.isArray(e3)) {
                if (Array.isArray(this.container)) {
                  e3 = this._verifyNodeList(e3);
                  const t3 = this._containerInsertAfter(e3);
                  return this.remove(), t3;
                }
                return this.replaceWithMultiple(e3);
              }
              return this.replaceWith(e3);
            };
            var n = r2(39), s2 = r2(10), i = r2(19), o = r2(34), a = r2(27), l = r2(0), c = r2(439);
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              return { grey: null, red: { bold: null } };
            }
            r2.r(t2), r2.d(t2, { getChalk: () => n });
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3 = "var") {
              e3.traverse(s2, { kind: r3, emit: t3 });
            };
            var n = r2(0);
            const s2 = { Scope(e3, t3) {
              t3.kind === "let" && e3.skip();
            }, FunctionParent(e3) {
              e3.skip();
            }, VariableDeclaration(e3, t3) {
              if (t3.kind && e3.node.kind !== t3.kind)
                return;
              const r3 = [], s3 = e3.get("declarations");
              let i;
              for (const e4 of s3) {
                i = e4.node.id, e4.node.init && r3.push(n.expressionStatement(n.assignmentExpression("=", e4.node.id, e4.node.init)));
                for (const r4 of Object.keys(e4.getBindingIdentifiers()))
                  t3.emit(n.identifier(r4), r4, e4.node.init !== null);
              }
              e3.parentPath.isFor({ left: e3.node }) ? e3.replaceWith(i) : e3.replaceWithMultiple(r3);
            } };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.evaluateTruthy = function() {
              const e3 = this.evaluate();
              if (e3.confident)
                return !!e3.value;
            }, t2.evaluate = function() {
              const e3 = { confident: true, deoptPath: null, seen: new Map() };
              let t3 = o(this, e3);
              return e3.confident || (t3 = void 0), { confident: e3.confident, deopt: e3.deoptPath, value: t3 };
            };
            const n = ["String", "Number", "Math"], s2 = ["random"];
            function i(e3, t3) {
              t3.confident && (t3.deoptPath = e3, t3.confident = false);
            }
            function o(e3, t3) {
              const { node: l } = e3, { seen: c } = t3;
              if (c.has(l)) {
                const r3 = c.get(l);
                return r3.resolved ? r3.value : void i(e3, t3);
              }
              {
                const u = { resolved: false };
                c.set(l, u);
                const p2 = function(e4, t4) {
                  if (t4.confident) {
                    if (e4.isSequenceExpression()) {
                      const r3 = e4.get("expressions");
                      return o(r3[r3.length - 1], t4);
                    }
                    if (e4.isStringLiteral() || e4.isNumericLiteral() || e4.isBooleanLiteral())
                      return e4.node.value;
                    if (e4.isNullLiteral())
                      return null;
                    if (e4.isTemplateLiteral())
                      return a(e4, e4.node.quasis, t4);
                    if (e4.isTaggedTemplateExpression() && e4.get("tag").isMemberExpression()) {
                      const r3 = e4.get("tag.object"), { node: { name: n2 } } = r3, s3 = e4.get("tag.property");
                      if (r3.isIdentifier() && n2 === "String" && !e4.scope.getBinding(n2) && s3.isIdentifier() && s3.node.name === "raw")
                        return a(e4, e4.node.quasi.quasis, t4, true);
                    }
                    if (e4.isConditionalExpression()) {
                      const r3 = o(e4.get("test"), t4);
                      if (!t4.confident)
                        return;
                      return o(r3 ? e4.get("consequent") : e4.get("alternate"), t4);
                    }
                    if (e4.isExpressionWrapper())
                      return o(e4.get("expression"), t4);
                    if (e4.isMemberExpression() && !e4.parentPath.isCallExpression({ callee: e4.node })) {
                      const t5 = e4.get("property"), r3 = e4.get("object");
                      if (r3.isLiteral() && t5.isIdentifier()) {
                        const e5 = r3.node.value, n2 = typeof e5;
                        if (n2 === "number" || n2 === "string")
                          return e5[t5.node.name];
                      }
                    }
                    if (e4.isReferencedIdentifier()) {
                      const r3 = e4.scope.getBinding(e4.node.name);
                      if (r3 && r3.constantViolations.length > 0)
                        return i(r3.path, t4);
                      if (r3 && e4.node.start < r3.path.node.end)
                        return i(r3.path, t4);
                      if (r3 != null && r3.hasValue)
                        return r3.value;
                      {
                        if (e4.node.name === "undefined")
                          return r3 ? i(r3.path, t4) : void 0;
                        if (e4.node.name === "Infinity")
                          return r3 ? i(r3.path, t4) : 1 / 0;
                        if (e4.node.name === "NaN")
                          return r3 ? i(r3.path, t4) : NaN;
                        const n2 = e4.resolve();
                        return n2 === e4 ? i(e4, t4) : o(n2, t4);
                      }
                    }
                    if (e4.isUnaryExpression({ prefix: true })) {
                      if (e4.node.operator === "void")
                        return;
                      const r3 = e4.get("argument");
                      if (e4.node.operator === "typeof" && (r3.isFunction() || r3.isClass()))
                        return "function";
                      const n2 = o(r3, t4);
                      if (!t4.confident)
                        return;
                      switch (e4.node.operator) {
                        case "!":
                          return !n2;
                        case "+":
                          return +n2;
                        case "-":
                          return -n2;
                        case "~":
                          return ~n2;
                        case "typeof":
                          return typeof n2;
                      }
                    }
                    if (e4.isArrayExpression()) {
                      const r3 = [], n2 = e4.get("elements");
                      for (const e5 of n2) {
                        const n3 = e5.evaluate();
                        if (!n3.confident)
                          return i(n3.deopt, t4);
                        r3.push(n3.value);
                      }
                      return r3;
                    }
                    if (e4.isObjectExpression()) {
                      const r3 = {}, n2 = e4.get("properties");
                      for (const e5 of n2) {
                        if (e5.isObjectMethod() || e5.isSpreadElement())
                          return i(e5, t4);
                        let n3 = e5.get("key");
                        if (e5.node.computed) {
                          if (n3 = n3.evaluate(), !n3.confident)
                            return i(n3.deopt, t4);
                          n3 = n3.value;
                        } else
                          n3 = n3.isIdentifier() ? n3.node.name : n3.node.value;
                        let s3 = e5.get("value").evaluate();
                        if (!s3.confident)
                          return i(s3.deopt, t4);
                        s3 = s3.value, r3[n3] = s3;
                      }
                      return r3;
                    }
                    if (e4.isLogicalExpression()) {
                      const r3 = t4.confident, n2 = o(e4.get("left"), t4), s3 = t4.confident;
                      t4.confident = r3;
                      const i2 = o(e4.get("right"), t4), a2 = t4.confident;
                      switch (e4.node.operator) {
                        case "||":
                          if (t4.confident = s3 && (!!n2 || a2), !t4.confident)
                            return;
                          return n2 || i2;
                        case "&&":
                          if (t4.confident = s3 && (!n2 || a2), !t4.confident)
                            return;
                          return n2 && i2;
                      }
                    }
                    if (e4.isBinaryExpression()) {
                      const r3 = o(e4.get("left"), t4);
                      if (!t4.confident)
                        return;
                      const n2 = o(e4.get("right"), t4);
                      if (!t4.confident)
                        return;
                      switch (e4.node.operator) {
                        case "-":
                          return r3 - n2;
                        case "+":
                          return r3 + n2;
                        case "/":
                          return r3 / n2;
                        case "*":
                          return r3 * n2;
                        case "%":
                          return r3 % n2;
                        case "**":
                          return Math.pow(r3, n2);
                        case "<":
                          return r3 < n2;
                        case ">":
                          return r3 > n2;
                        case "<=":
                          return r3 <= n2;
                        case ">=":
                          return r3 >= n2;
                        case "==":
                          return r3 == n2;
                        case "!=":
                          return r3 != n2;
                        case "===":
                          return r3 === n2;
                        case "!==":
                          return r3 !== n2;
                        case "|":
                          return r3 | n2;
                        case "&":
                          return r3 & n2;
                        case "^":
                          return r3 ^ n2;
                        case "<<":
                          return r3 << n2;
                        case ">>":
                          return r3 >> n2;
                        case ">>>":
                          return r3 >>> n2;
                      }
                    }
                    if (e4.isCallExpression()) {
                      const i2 = e4.get("callee");
                      let a2, l2;
                      if (i2.isIdentifier() && !e4.scope.getBinding(i2.node.name) && n.indexOf(i2.node.name) >= 0 && (l2 = r2.g[i2.node.name]), i2.isMemberExpression()) {
                        const e5 = i2.get("object"), t5 = i2.get("property");
                        if (e5.isIdentifier() && t5.isIdentifier() && n.indexOf(e5.node.name) >= 0 && s2.indexOf(t5.node.name) < 0 && (a2 = r2.g[e5.node.name], l2 = a2[t5.node.name]), e5.isLiteral() && t5.isIdentifier()) {
                          const r3 = typeof e5.node.value;
                          r3 !== "string" && r3 !== "number" || (a2 = e5.node.value, l2 = a2[t5.node.name]);
                        }
                      }
                      if (l2) {
                        const r3 = e4.get("arguments").map((e5) => o(e5, t4));
                        if (!t4.confident)
                          return;
                        return l2.apply(a2, r3);
                      }
                    }
                    i(e4, t4);
                  }
                }(e3, t3);
                return t3.confident && (u.resolved = true, u.value = p2), p2;
              }
            }
            function a(e3, t3, r3, n2 = false) {
              let s3 = "", i2 = 0;
              const a2 = e3.get("expressions");
              for (const e4 of t3) {
                if (!r3.confident)
                  break;
                s3 += n2 ? e4.value.raw : e4.value.cooked;
                const t4 = a2[i2++];
                t4 && (s3 += String(o(t4, r3)));
              }
              if (r3.confident)
                return s3;
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.toComputedKey = function() {
              let e3;
              if (this.isMemberExpression())
                e3 = this.node.property;
              else {
                if (!this.isProperty() && !this.isMethod())
                  throw new ReferenceError("todo");
                e3 = this.node.key;
              }
              return this.node.computed || n.isIdentifier(e3) && (e3 = n.stringLiteral(e3.name)), e3;
            }, t2.ensureBlock = function() {
              const e3 = this.get("body"), t3 = e3.node;
              if (Array.isArray(e3))
                throw new Error("Can't convert array path to a block statement");
              if (!t3)
                throw new Error("Can't convert node without a body");
              if (e3.isBlockStatement())
                return t3;
              const r3 = [];
              let s3, i2, o2 = "body";
              e3.isStatement() ? (i2 = "body", s3 = 0, r3.push(e3.node)) : (o2 += ".body.0", this.isFunction() ? (s3 = "argument", r3.push(n.returnStatement(e3.node))) : (s3 = "expression", r3.push(n.expressionStatement(e3.node)))), this.node.body = n.blockStatement(r3);
              const a2 = this.get(o2);
              return e3.setup(a2, i2 ? a2.node[i2] : a2.node, i2, s3), this.node;
            }, t2.arrowFunctionToShadowed = function() {
              this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
            }, t2.unwrapFunctionEnvironment = function() {
              if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration())
                throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
              i(this);
            }, t2.arrowFunctionToExpression = function({ allowInsertArrow: e3 = true, specCompliant: t3 = false, noNewArrows: r3 = !t3 } = {}) {
              if (!this.isArrowFunctionExpression())
                throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
              const o2 = i(this, r3, e3);
              if (this.ensureBlock(), this.node.type = "FunctionExpression", !r3) {
                const e4 = o2 ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");
                e4 && this.parentPath.scope.push({ id: e4, init: n.objectExpression([]) }), this.get("body").unshiftContainer("body", n.expressionStatement(n.callExpression(this.hub.addHelper("newArrowCheck"), [n.thisExpression(), e4 ? n.identifier(e4.name) : n.identifier(o2)]))), this.replaceWith(n.callExpression(n.memberExpression((0, s2.default)(this, true) || this.node, n.identifier("bind")), [e4 ? n.identifier(e4.name) : n.thisExpression()]));
              }
            };
            var n = r2(0), s2 = r2(134);
            function i(e3, t3 = true, r3 = true) {
              const s3 = e3.findParent((e4) => e4.isFunction() && !e4.isArrowFunctionExpression() || e4.isProgram() || e4.isClassProperty({ static: false })), i2 = (s3 == null ? void 0 : s3.node.kind) === "constructor";
              if (s3.isClassProperty())
                throw e3.buildCodeFrameError("Unable to transform arrow inside class property");
              const { thisPaths: l, argumentsPaths: c, newTargetPaths: u, superProps: p2, superCalls: f } = function(e4) {
                const t4 = [], r4 = [], n2 = [], s4 = [], i3 = [];
                return e4.traverse({ ClassProperty(e5) {
                  e5.skip();
                }, Function(e5) {
                  e5.isArrowFunctionExpression() || e5.skip();
                }, ThisExpression(e5) {
                  t4.push(e5);
                }, JSXIdentifier(e5) {
                  e5.node.name === "this" && (e5.parentPath.isJSXMemberExpression({ object: e5.node }) || e5.parentPath.isJSXOpeningElement({ name: e5.node })) && t4.push(e5);
                }, CallExpression(e5) {
                  e5.get("callee").isSuper() && i3.push(e5);
                }, MemberExpression(e5) {
                  e5.get("object").isSuper() && s4.push(e5);
                }, ReferencedIdentifier(e5) {
                  e5.node.name === "arguments" && r4.push(e5);
                }, MetaProperty(e5) {
                  e5.get("meta").isIdentifier({ name: "new" }) && e5.get("property").isIdentifier({ name: "target" }) && n2.push(e5);
                } }), { thisPaths: t4, argumentsPaths: r4, newTargetPaths: n2, superProps: s4, superCalls: i3 };
              }(e3);
              if (i2 && f.length > 0) {
                if (!r3)
                  throw f[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
                const e4 = [];
                s3.traverse({ Function(e5) {
                  e5.isArrowFunctionExpression() || e5.skip();
                }, ClassProperty(e5) {
                  e5.skip();
                }, CallExpression(t5) {
                  t5.get("callee").isSuper() && e4.push(t5);
                } });
                const t4 = function(e5) {
                  return a(e5, "supercall", () => {
                    const t5 = e5.scope.generateUidIdentifier("args");
                    return n.arrowFunctionExpression([n.restElement(t5)], n.callExpression(n.super(), [n.spreadElement(n.identifier(t5.name))]));
                  });
                }(s3);
                e4.forEach((e5) => {
                  const r4 = n.identifier(t4);
                  r4.loc = e5.node.callee.loc, e5.get("callee").replaceWith(r4);
                });
              }
              if (c.length > 0) {
                const e4 = a(s3, "arguments", () => n.identifier("arguments"));
                c.forEach((t4) => {
                  const r4 = n.identifier(e4);
                  r4.loc = t4.node.loc, t4.replaceWith(r4);
                });
              }
              if (u.length > 0) {
                const e4 = a(s3, "newtarget", () => n.metaProperty(n.identifier("new"), n.identifier("target")));
                u.forEach((t4) => {
                  const r4 = n.identifier(e4);
                  r4.loc = t4.node.loc, t4.replaceWith(r4);
                });
              }
              if (p2.length > 0) {
                if (!r3)
                  throw p2[0].buildCodeFrameError("Unable to handle nested super.prop usage");
                p2.reduce((e4, t4) => e4.concat(function(e5) {
                  if (e5.parentPath.isAssignmentExpression() && e5.parentPath.node.operator !== "=") {
                    const t5 = e5.parentPath, r4 = t5.node.operator.slice(0, -1), s4 = t5.node.right;
                    if (t5.node.operator = "=", e5.node.computed) {
                      const i3 = e5.scope.generateDeclaredUidIdentifier("tmp");
                      t5.get("left").replaceWith(n.memberExpression(e5.node.object, n.assignmentExpression("=", i3, e5.node.property), true)), t5.get("right").replaceWith(n.binaryExpression(r4, n.memberExpression(e5.node.object, n.identifier(i3.name), true), s4));
                    } else
                      t5.get("left").replaceWith(n.memberExpression(e5.node.object, e5.node.property)), t5.get("right").replaceWith(n.binaryExpression(r4, n.memberExpression(e5.node.object, n.identifier(e5.node.property.name)), s4));
                    return [t5.get("left"), t5.get("right").get("left")];
                  }
                  if (e5.parentPath.isUpdateExpression()) {
                    const t5 = e5.parentPath, r4 = e5.scope.generateDeclaredUidIdentifier("tmp"), s4 = e5.node.computed ? e5.scope.generateDeclaredUidIdentifier("prop") : null, i3 = [n.assignmentExpression("=", r4, n.memberExpression(e5.node.object, s4 ? n.assignmentExpression("=", s4, e5.node.property) : e5.node.property, e5.node.computed)), n.assignmentExpression("=", n.memberExpression(e5.node.object, s4 ? n.identifier(s4.name) : e5.node.property, e5.node.computed), n.binaryExpression("+", n.identifier(r4.name), n.numericLiteral(1)))];
                    return e5.parentPath.node.prefix || i3.push(n.identifier(r4.name)), t5.replaceWith(n.sequenceExpression(i3)), [t5.get("expressions.0.right"), t5.get("expressions.1.left")];
                  }
                  return [e5];
                }(t4)), []).forEach((e4) => {
                  const t4 = e4.node.computed ? "" : e4.get("property").node.name, r4 = e4.parentPath.isAssignmentExpression({ left: e4.node }), i3 = e4.parentPath.isCallExpression({ callee: e4.node }), o2 = function(e5, t5, r5) {
                    return a(e5, `superprop_${t5 ? "set" : "get"}:${r5 || ""}`, () => {
                      const s4 = [];
                      let i4;
                      if (r5)
                        i4 = n.memberExpression(n.super(), n.identifier(r5));
                      else {
                        const t6 = e5.scope.generateUidIdentifier("prop");
                        s4.unshift(t6), i4 = n.memberExpression(n.super(), n.identifier(t6.name), true);
                      }
                      if (t5) {
                        const t6 = e5.scope.generateUidIdentifier("value");
                        s4.push(t6), i4 = n.assignmentExpression("=", i4, n.identifier(t6.name));
                      }
                      return n.arrowFunctionExpression(s4, i4);
                    });
                  }(s3, r4, t4), c4 = [];
                  if (e4.node.computed && c4.push(e4.get("property").node), r4) {
                    const t5 = e4.parentPath.node.right;
                    c4.push(t5);
                  }
                  const u2 = n.callExpression(n.identifier(o2), c4);
                  i3 ? (e4.parentPath.unshiftContainer("arguments", n.thisExpression()), e4.replaceWith(n.memberExpression(u2, n.identifier("call"))), l.push(e4.parentPath.get("arguments.0"))) : r4 ? e4.parentPath.replaceWith(u2) : e4.replaceWith(u2);
                });
              }
              let d;
              return (l.length > 0 || !t3) && (d = function(e4, t4) {
                return a(e4, "this", (r4) => {
                  if (!t4 || !o(e4))
                    return n.thisExpression();
                  const s4 = new WeakSet();
                  e4.traverse({ Function(e5) {
                    e5.isArrowFunctionExpression() || e5.skip();
                  }, ClassProperty(e5) {
                    e5.skip();
                  }, CallExpression(e5) {
                    e5.get("callee").isSuper() && (s4.has(e5.node) || (s4.add(e5.node), e5.replaceWithMultiple([e5.node, n.assignmentExpression("=", n.identifier(r4), n.identifier("this"))])));
                  } });
                });
              }(s3, i2), (t3 || i2 && o(s3)) && (l.forEach((e4) => {
                const t4 = e4.isJSX() ? n.jsxIdentifier(d) : n.identifier(d);
                t4.loc = e4.node.loc, e4.replaceWith(t4);
              }), t3 || (d = null))), d;
            }
            function o(e3) {
              return e3.isClassMethod() && !!e3.parentPath.parentPath.node.superClass;
            }
            function a(e3, t3, r3) {
              const n2 = "binding:" + t3;
              let s3 = e3.getData(n2);
              if (!s3) {
                const i2 = e3.scope.generateUidIdentifier(t3);
                s3 = i2.name, e3.setData(n2, s3), e3.scope.push({ id: i2, init: r3(s3) });
              }
              return s3;
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              const t3 = e3.params;
              for (let e4 = 0; e4 < t3.length; e4++) {
                const r3 = t3[e4];
                if (n.isAssignmentPattern(r3) || n.isRestElement(r3))
                  return e4;
              }
              return t3.length;
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.program = t2.expression = t2.statement = t2.statements = t2.smart = void 0;
            var n = r2(0);
            function s2(e3) {
              return { code: (e4) => `/* @babel/template */;
${e4}`, validate: () => {
              }, unwrap: (t3) => e3(t3.program.body.slice(1)) };
            }
            const i = s2((e3) => e3.length > 1 ? e3 : e3[0]);
            t2.smart = i;
            const o = s2((e3) => e3);
            t2.statements = o;
            const a = s2((e3) => {
              if (e3.length === 0)
                throw new Error("Found nothing to return.");
              if (e3.length > 1)
                throw new Error("Found multiple statements but wanted one");
              return e3[0];
            });
            t2.statement = a;
            const l = { code: (e3) => `(
${e3}
)`, validate: (e3) => {
              if (e3.program.body.length > 1)
                throw new Error("Found multiple statements but wanted one");
              if (l.unwrap(e3).start === 0)
                throw new Error("Parse result included parens.");
            }, unwrap: ({ program: e3 }) => {
              const [t3] = e3.body;
              return n.assertExpressionStatement(t3), t3.expression;
            } };
            t2.expression = l, t2.program = { code: (e3) => e3, validate: () => {
            }, unwrap: (e3) => e3.program };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function e3(t3, r3) {
              const l = new WeakMap(), c = new WeakMap(), u = r3 || (0, n.validate)(null);
              return Object.assign((r4, ...o2) => {
                if (typeof r4 == "string") {
                  if (o2.length > 1)
                    throw new Error("Unexpected extra params.");
                  return a((0, s2.default)(t3, r4, (0, n.merge)(u, (0, n.validate)(o2[0]))));
                }
                if (Array.isArray(r4)) {
                  let e4 = l.get(r4);
                  return e4 || (e4 = (0, i.default)(t3, r4, u), l.set(r4, e4)), a(e4(o2));
                }
                if (typeof r4 == "object" && r4) {
                  if (o2.length > 0)
                    throw new Error("Unexpected extra params.");
                  return e3(t3, (0, n.merge)(u, (0, n.validate)(r4)));
                }
                throw new Error("Unexpected template param " + typeof r4);
              }, { ast: (e4, ...r4) => {
                if (typeof e4 == "string") {
                  if (r4.length > 1)
                    throw new Error("Unexpected extra params.");
                  return (0, s2.default)(t3, e4, (0, n.merge)((0, n.merge)(u, (0, n.validate)(r4[0])), o))();
                }
                if (Array.isArray(e4)) {
                  let s3 = c.get(e4);
                  return s3 || (s3 = (0, i.default)(t3, e4, (0, n.merge)(u, o)), c.set(e4, s3)), s3(r4)();
                }
                throw new Error("Unexpected template param " + typeof e4);
              } });
            };
            var n = r2(135), s2 = r2(445), i = r2(446);
            const o = (0, n.validate)({ placeholderPattern: false });
            function a(e3) {
              let t3 = "";
              try {
                throw new Error();
              } catch (e4) {
                e4.stack && (t3 = e4.stack.split("\n").slice(3).join("\n"));
              }
              return (r3) => {
                try {
                  return e3(r3);
                } catch (e4) {
                  throw e4.stack += `
    =============
${t3}`, e4;
                }
              };
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              let o;
              return t3 = e3.code(t3), (a) => {
                const l = (0, n.normalizeReplacements)(a);
                return o || (o = (0, s2.default)(e3, t3, r3)), e3.unwrap((0, i.default)(o, l));
              };
            };
            var n = r2(135), s2 = r2(237), i = r2(238);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              const { metadata: a, names: l } = function(e4, t4, r4) {
                let n2, i2, a2, l2 = "";
                do {
                  l2 += "$";
                  const c = o(t4, l2);
                  n2 = c.names, i2 = new Set(n2), a2 = (0, s2.default)(e4, e4.code(c.code), { parser: r4.parser, placeholderWhitelist: new Set(c.names.concat(r4.placeholderWhitelist ? Array.from(r4.placeholderWhitelist) : [])), placeholderPattern: r4.placeholderPattern, preserveComments: r4.preserveComments, syntacticPlaceholders: r4.syntacticPlaceholders });
                } while (a2.placeholders.some((e5) => e5.isDuplicate && i2.has(e5.name)));
                return { metadata: a2, names: n2 };
              }(e3, t3, r3);
              return (t4) => {
                const r4 = {};
                return t4.forEach((e4, t5) => {
                  r4[l[t5]] = e4;
                }), (t5) => {
                  const s3 = (0, n.normalizeReplacements)(t5);
                  return s3 && Object.keys(s3).forEach((e4) => {
                    if (Object.prototype.hasOwnProperty.call(r4, e4))
                      throw new Error("Unexpected replacement overlap.");
                  }), e3.unwrap((0, i.default)(a, s3 ? Object.assign(s3, r4) : r4));
                };
              };
            };
            var n = r2(135), s2 = r2(237), i = r2(238);
            function o(e3, t3) {
              const r3 = [];
              let n2 = e3[0];
              for (let s3 = 1; s3 < e3.length; s3++) {
                const i2 = `${t3}${s3 - 1}`;
                r3.push(i2), n2 += i2 + e3[s3];
              }
              return { names: r3, code: n2 };
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.matchesPattern = function(e3, t3) {
              return n.matchesPattern(this.node, e3, t3);
            }, t2.has = s2, t2.isStatic = function() {
              return this.scope.isStatic(this.node);
            }, t2.isnt = function(e3) {
              return !this.has(e3);
            }, t2.equals = function(e3, t3) {
              return this.node[e3] === t3;
            }, t2.isNodeType = function(e3) {
              return n.isType(this.type, e3);
            }, t2.canHaveVariableDeclarationOrExpression = function() {
              return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
            }, t2.canSwapBetweenExpressionAndStatement = function(e3) {
              return !(this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) && (this.isExpression() ? n.isBlockStatement(e3) : !!this.isBlockStatement() && n.isExpression(e3));
            }, t2.isCompletionRecord = function(e3) {
              let t3 = this, r3 = true;
              do {
                const n2 = t3.container;
                if (t3.isFunction() && !r3)
                  return !!e3;
                if (r3 = false, Array.isArray(n2) && t3.key !== n2.length - 1)
                  return false;
              } while ((t3 = t3.parentPath) && !t3.isProgram());
              return true;
            }, t2.isStatementOrBlock = function() {
              return !this.parentPath.isLabeledStatement() && !n.isBlockStatement(this.container) && n.STATEMENT_OR_BLOCK_KEYS.includes(this.key);
            }, t2.referencesImport = function(e3, t3) {
              if (!this.isReferencedIdentifier()) {
                if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? n.isStringLiteral(this.node.property, { value: t3 }) : this.node.property.name === t3)) {
                  const t4 = this.get("object");
                  return t4.isReferencedIdentifier() && t4.referencesImport(e3, "*");
                }
                return false;
              }
              const r3 = this.scope.getBinding(this.node.name);
              if (!r3 || r3.kind !== "module")
                return false;
              const s3 = r3.path, i2 = s3.parentPath;
              return !!i2.isImportDeclaration() && (i2.node.source.value === e3 && (!t3 || (!(!s3.isImportDefaultSpecifier() || t3 !== "default") || (!(!s3.isImportNamespaceSpecifier() || t3 !== "*") || !(!s3.isImportSpecifier() || !n.isIdentifier(s3.node.imported, { name: t3 }))))));
            }, t2.getSource = function() {
              const e3 = this.node;
              if (e3.end) {
                const t3 = this.hub.getCode();
                if (t3)
                  return t3.slice(e3.start, e3.end);
              }
              return "";
            }, t2.willIMaybeExecuteBefore = function(e3) {
              return this._guessExecutionStatusRelativeTo(e3) !== "after";
            }, t2._guessExecutionStatusRelativeTo = function(e3) {
              const t3 = { this: o(this), target: o(e3) };
              if (t3.target.node !== t3.this.node)
                return this._guessExecutionStatusRelativeToDifferentFunctions(t3.target);
              const r3 = { target: e3.getAncestry(), this: this.getAncestry() };
              if (r3.target.indexOf(this) >= 0)
                return "after";
              if (r3.this.indexOf(e3) >= 0)
                return "before";
              let s3;
              const i2 = { target: 0, this: 0 };
              for (; !s3 && i2.this < r3.this.length; ) {
                const e4 = r3.this[i2.this];
                i2.target = r3.target.indexOf(e4), i2.target >= 0 ? s3 = e4 : i2.this++;
              }
              if (!s3)
                throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
              if (l(r3.this, i2.this - 1) || l(r3.target, i2.target - 1))
                return "unknown";
              const a2 = { this: r3.this[i2.this - 1], target: r3.target[i2.target - 1] };
              if (a2.target.listKey && a2.this.listKey && a2.target.container === a2.this.container)
                return a2.target.key > a2.this.key ? "before" : "after";
              const c4 = n.VISITOR_KEYS[s3.type], u = c4.indexOf(a2.this.parentKey);
              return c4.indexOf(a2.target.parentKey) > u ? "before" : "after";
            }, t2._guessExecutionStatusRelativeToDifferentFunctions = function(e3) {
              if (!e3.isFunctionDeclaration() || e3.parentPath.isExportDeclaration())
                return "unknown";
              const t3 = e3.scope.getBinding(e3.node.id.name);
              if (!t3.references)
                return "before";
              const r3 = t3.referencePaths;
              let n2;
              for (const t4 of r3) {
                if (t4.find((t5) => t5.node === e3.node))
                  continue;
                if (t4.key !== "callee" || !t4.parentPath.isCallExpression())
                  return "unknown";
                if (c.has(t4.node))
                  continue;
                c.add(t4.node);
                const r4 = this._guessExecutionStatusRelativeTo(t4);
                if (c.delete(t4.node), n2 && n2 !== r4)
                  return "unknown";
                n2 = r4;
              }
              return n2;
            }, t2.resolve = function(e3, t3) {
              return this._resolve(e3, t3) || this;
            }, t2._resolve = function(e3, t3) {
              if (!(t3 && t3.indexOf(this) >= 0))
                if ((t3 = t3 || []).push(this), this.isVariableDeclarator()) {
                  if (this.get("id").isIdentifier())
                    return this.get("init").resolve(e3, t3);
                } else if (this.isReferencedIdentifier()) {
                  const r3 = this.scope.getBinding(this.node.name);
                  if (!r3)
                    return;
                  if (!r3.constant)
                    return;
                  if (r3.kind === "module")
                    return;
                  if (r3.path !== this) {
                    const n2 = r3.path.resolve(e3, t3);
                    if (this.find((e4) => e4.node === n2.node))
                      return;
                    return n2;
                  }
                } else {
                  if (this.isTypeCastExpression())
                    return this.get("expression").resolve(e3, t3);
                  if (e3 && this.isMemberExpression()) {
                    const r3 = this.toComputedKey();
                    if (!n.isLiteral(r3))
                      return;
                    const s3 = r3.value, i2 = this.get("object").resolve(e3, t3);
                    if (i2.isObjectExpression()) {
                      const r4 = i2.get("properties");
                      for (const n2 of r4) {
                        if (!n2.isProperty())
                          continue;
                        const r5 = n2.get("key");
                        let i3 = n2.isnt("computed") && r5.isIdentifier({ name: s3 });
                        if (i3 = i3 || r5.isLiteral({ value: s3 }), i3)
                          return n2.get("value").resolve(e3, t3);
                      }
                    } else if (i2.isArrayExpression() && !isNaN(+s3)) {
                      const r4 = i2.get("elements")[s3];
                      if (r4)
                        return r4.resolve(e3, t3);
                    }
                  }
                }
            }, t2.isConstantExpression = function() {
              if (this.isIdentifier()) {
                const e3 = this.scope.getBinding(this.node.name);
                return !!e3 && e3.constant;
              }
              return this.isLiteral() ? !this.isRegExpLiteral() && (!this.isTemplateLiteral() || this.get("expressions").every((e3) => e3.isConstantExpression())) : this.isUnaryExpression() ? this.node.operator === "void" && this.get("argument").isConstantExpression() : !!this.isBinaryExpression() && (this.get("left").isConstantExpression() && this.get("right").isConstantExpression());
            }, t2.isInStrictMode = function() {
              return !!(this.isProgram() ? this : this.parentPath).find((e3) => {
                if (e3.isProgram({ sourceType: "module" }))
                  return true;
                if (e3.isClass())
                  return true;
                if (!e3.isProgram() && !e3.isFunction())
                  return false;
                if (e3.isArrowFunctionExpression() && !e3.get("body").isBlockStatement())
                  return false;
                const t3 = e3.isFunction() ? e3.node.body : e3.node;
                for (const e4 of t3.directives)
                  if (e4.value.value === "use strict")
                    return true;
              });
            }, t2.is = void 0;
            var n = r2(0);
            function s2(e3) {
              const t3 = this.node && this.node[e3];
              return t3 && Array.isArray(t3) ? !!t3.length : !!t3;
            }
            const i = s2;
            function o(e3) {
              return (e3.scope.getFunctionParent() || e3.scope.getProgramParent()).path;
            }
            function a(e3, t3) {
              switch (e3) {
                case "LogicalExpression":
                  return t3 === "right";
                case "ConditionalExpression":
                case "IfStatement":
                  return t3 === "consequent" || t3 === "alternate";
                case "WhileStatement":
                case "DoWhileStatement":
                case "ForInStatement":
                case "ForOfStatement":
                  return t3 === "body";
                case "ForStatement":
                  return t3 === "body" || t3 === "update";
                case "SwitchStatement":
                  return t3 === "cases";
                case "TryStatement":
                  return t3 === "handler";
                case "AssignmentPattern":
                  return t3 === "right";
                case "OptionalMemberExpression":
                  return t3 === "property";
                case "OptionalCallExpression":
                  return t3 === "arguments";
                default:
                  return false;
              }
            }
            function l(e3, t3) {
              for (let r3 = 0; r3 < t3; r3++) {
                const t4 = e3[r3];
                if (a(t4.parent.type, t4.parentKey))
                  return true;
              }
              return false;
            }
            t2.is = i;
            const c = new WeakSet();
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.call = function(e3) {
              const t3 = this.opts;
              return this.debug(e3), !(!this.node || !this._call(t3[e3])) || !!this.node && this._call(t3[this.node.type] && t3[this.node.type][e3]);
            }, t2._call = function(e3) {
              if (!e3)
                return false;
              for (const t3 of e3) {
                if (!t3)
                  continue;
                const e4 = this.node;
                if (!e4)
                  return true;
                const r3 = t3.call(this.state, this, this.state);
                if (r3 && typeof r3 == "object" && typeof r3.then == "function")
                  throw new Error("You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
                if (r3)
                  throw new Error(`Unexpected return value from visitor method ${t3}`);
                if (this.node !== e4)
                  return true;
                if (this._traverseFlags > 0)
                  return true;
              }
              return false;
            }, t2.isBlacklisted = t2.isDenylisted = function() {
              var e3;
              const t3 = (e3 = this.opts.denylist) != null ? e3 : this.opts.blacklist;
              return t3 && t3.indexOf(this.node.type) > -1;
            }, t2.visit = function() {
              return !!this.node && (!this.isDenylisted() && ((!this.opts.shouldSkip || !this.opts.shouldSkip(this)) && (this.shouldSkip || this.call("enter") || this.shouldSkip ? (this.debug("Skip..."), this.shouldStop) : (this.debug("Recursing into..."), n.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys), this.call("exit"), this.shouldStop))));
            }, t2.skip = function() {
              this.shouldSkip = true;
            }, t2.skipKey = function(e3) {
              this.skipKeys == null && (this.skipKeys = {}), this.skipKeys[e3] = true;
            }, t2.stop = function() {
              this._traverseFlags |= s2.SHOULD_SKIP | s2.SHOULD_STOP;
            }, t2.setScope = function() {
              if (this.opts && this.opts.noScope)
                return;
              let e3, t3 = this.parentPath;
              for (this.key === "key" && t3.isMethod() && (t3 = t3.parentPath); t3 && !e3; ) {
                if (t3.opts && t3.opts.noScope)
                  return;
                e3 = t3.scope, t3 = t3.parentPath;
              }
              this.scope = this.getScope(e3), this.scope && this.scope.init();
            }, t2.setContext = function(e3) {
              return this.skipKeys != null && (this.skipKeys = {}), this._traverseFlags = 0, e3 && (this.context = e3, this.state = e3.state, this.opts = e3.opts), this.setScope(), this;
            }, t2.resync = function() {
              this.removed || (this._resyncParent(), this._resyncList(), this._resyncKey());
            }, t2._resyncParent = function() {
              this.parentPath && (this.parent = this.parentPath.node);
            }, t2._resyncKey = function() {
              if (this.container && this.node !== this.container[this.key]) {
                if (Array.isArray(this.container)) {
                  for (let e3 = 0; e3 < this.container.length; e3++)
                    if (this.container[e3] === this.node)
                      return this.setKey(e3);
                } else
                  for (const e3 of Object.keys(this.container))
                    if (this.container[e3] === this.node)
                      return this.setKey(e3);
                this.key = null;
              }
            }, t2._resyncList = function() {
              if (!this.parent || !this.inList)
                return;
              const e3 = this.parent[this.listKey];
              this.container !== e3 && (this.container = e3 || null);
            }, t2._resyncRemoved = function() {
              this.key != null && this.container && this.container[this.key] === this.node || this._markRemoved();
            }, t2.popContext = function() {
              this.contexts.pop(), this.contexts.length > 0 ? this.setContext(this.contexts[this.contexts.length - 1]) : this.setContext(void 0);
            }, t2.pushContext = function(e3) {
              this.contexts.push(e3), this.setContext(e3);
            }, t2.setup = function(e3, t3, r3, n2) {
              this.listKey = r3, this.container = t3, this.parentPath = e3 || this.parentPath, this.setKey(n2);
            }, t2.setKey = function(e3) {
              var t3;
              this.key = e3, this.node = this.container[this.key], this.type = (t3 = this.node) == null ? void 0 : t3.type;
            }, t2.requeue = function(e3 = this) {
              if (e3.removed)
                return;
              const t3 = this.contexts;
              for (const r3 of t3)
                r3.maybeQueue(e3);
            }, t2._getQueueContexts = function() {
              let e3 = this, t3 = this.contexts;
              for (; !t3.length && (e3 = e3.parentPath, e3); )
                t3 = e3.contexts;
              return t3;
            };
            var n = r2(10), s2 = r2(19);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.remove = function() {
              var e3;
              this._assertUnremoved(), this.resync(), (e3 = this.opts) != null && e3.noScope || this._removeFromScope(), this._callRemovalHooks() || (this.shareCommentsWithSiblings(), this._remove()), this._markRemoved();
            }, t2._removeFromScope = function() {
              const e3 = this.getBindingIdentifiers();
              Object.keys(e3).forEach((e4) => this.scope.removeBinding(e4));
            }, t2._callRemovalHooks = function() {
              for (const e3 of n.hooks)
                if (e3(this, this.parentPath))
                  return true;
            }, t2._remove = function() {
              Array.isArray(this.container) ? (this.container.splice(this.key, 1), this.updateSiblingKeys(this.key, -1)) : this._replaceWith(null);
            }, t2._markRemoved = function() {
              this._traverseFlags |= i.SHOULD_SKIP | i.REMOVED, this.parent && s2.path.get(this.parent).delete(this.node), this.node = null;
            }, t2._assertUnremoved = function() {
              if (this.removed)
                throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
            };
            var n = r2(450), s2 = r2(34), i = r2(19);
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.hooks = void 0, t2.hooks = [function(e3, t3) {
              if (e3.key === "test" && (t3.isWhile() || t3.isSwitchCase()) || e3.key === "declaration" && t3.isExportDeclaration() || e3.key === "body" && t3.isLabeledStatement() || e3.listKey === "declarations" && t3.isVariableDeclaration() && t3.node.declarations.length === 1 || e3.key === "expression" && t3.isExpressionStatement())
                return t3.remove(), true;
            }, function(e3, t3) {
              if (t3.isSequenceExpression() && t3.node.expressions.length === 1)
                return t3.replaceWith(t3.node.expressions[0]), true;
            }, function(e3, t3) {
              if (t3.isBinary())
                return e3.key === "left" ? t3.replaceWith(t3.node.right) : t3.replaceWith(t3.node.left), true;
            }, function(e3, t3) {
              if (t3.isIfStatement() && (e3.key === "consequent" || e3.key === "alternate") || e3.key === "body" && (t3.isLoop() || t3.isArrowFunctionExpression()))
                return e3.replaceWith({ type: "BlockStatement", body: [] }), true;
            }];
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.insertBefore = function(e3) {
              this._assertUnremoved();
              const t3 = this._verifyNodeList(e3), { parentPath: r3 } = this;
              if (r3.isExpressionStatement() || r3.isLabeledStatement() || r3.isExportNamedDeclaration() || r3.isExportDefaultDeclaration() && this.isDeclaration())
                return r3.insertBefore(t3);
              if (this.isNodeType("Expression") && !this.isJSXElement() || r3.isForStatement() && this.key === "init")
                return this.node && t3.push(this.node), this.replaceExpressionWithStatements(t3);
              if (Array.isArray(this.container))
                return this._containerInsertBefore(t3);
              if (this.isStatementOrBlock()) {
                const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || e4.expression != null);
                return this.replaceWith(o.blockStatement(r4 ? [e4] : [])), this.unshiftContainer("body", t3);
              }
              throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
            }, t2._containerInsert = function(e3, t3) {
              this.updateSiblingKeys(e3, t3.length);
              const r3 = [];
              this.container.splice(e3, 0, ...t3);
              for (let n3 = 0; n3 < t3.length; n3++) {
                const t4 = e3 + n3, s3 = this.getSibling(t4);
                r3.push(s3), this.context && this.context.queue && s3.pushContext(this.context);
              }
              const n2 = this._getQueueContexts();
              for (const e4 of r3) {
                e4.setScope(), e4.debug("Inserted.");
                for (const t4 of n2)
                  t4.maybeQueue(e4, true);
              }
              return r3;
            }, t2._containerInsertBefore = function(e3) {
              return this._containerInsert(this.key, e3);
            }, t2._containerInsertAfter = function(e3) {
              return this._containerInsert(this.key + 1, e3);
            }, t2.insertAfter = function(e3) {
              this._assertUnremoved();
              const t3 = this._verifyNodeList(e3), { parentPath: r3 } = this;
              if (r3.isExpressionStatement() || r3.isLabeledStatement() || r3.isExportNamedDeclaration() || r3.isExportDefaultDeclaration() && this.isDeclaration())
                return r3.insertAfter(t3.map((e4) => o.isExpression(e4) ? o.expressionStatement(e4) : e4));
              if (this.isNodeType("Expression") && !this.isJSXElement() && !r3.isJSXElement() || r3.isForStatement() && this.key === "init") {
                if (this.node) {
                  const e4 = this.node;
                  let { scope: n2 } = this;
                  if (n2.path.isPattern())
                    return o.assertExpression(e4), this.replaceWith(o.callExpression(o.arrowFunctionExpression([], e4), [])), this.get("callee.body").insertAfter(t3), [this];
                  r3.isMethod({ computed: true, key: e4 }) && (n2 = n2.parent);
                  const s3 = n2.generateDeclaredUidIdentifier();
                  t3.unshift(o.expressionStatement(o.assignmentExpression("=", o.cloneNode(s3), e4))), t3.push(o.expressionStatement(o.cloneNode(s3)));
                }
                return this.replaceExpressionWithStatements(t3);
              }
              if (Array.isArray(this.container))
                return this._containerInsertAfter(t3);
              if (this.isStatementOrBlock()) {
                const e4 = this.node, r4 = e4 && (!this.isExpressionStatement() || e4.expression != null);
                return this.replaceWith(o.blockStatement(r4 ? [e4] : [])), this.pushContainer("body", t3);
              }
              throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
            }, t2.updateSiblingKeys = function(e3, t3) {
              if (!this.parent)
                return;
              const r3 = n.path.get(this.parent);
              for (const [, n2] of r3)
                n2.key >= e3 && (n2.key += t3);
            }, t2._verifyNodeList = function(e3) {
              if (!e3)
                return [];
              Array.isArray(e3) || (e3 = [e3]);
              for (let t3 = 0; t3 < e3.length; t3++) {
                const r3 = e3[t3];
                let n2;
                if (r3 ? typeof r3 != "object" ? n2 = "contains a non-object node" : r3.type ? r3 instanceof i.default && (n2 = "has a NodePath when it expected a raw object") : n2 = "without a type" : n2 = "has falsy node", n2) {
                  const e4 = Array.isArray(r3) ? "array" : typeof r3;
                  throw new Error(`Node list ${n2} with the index of ${t3} and type of ${e4}`);
                }
              }
              return e3;
            }, t2.unshiftContainer = function(e3, t3) {
              return this._assertUnremoved(), t3 = this._verifyNodeList(t3), i.default.get({ parentPath: this, parent: this.node, container: this.node[e3], listKey: e3, key: 0 }).setContext(this.context)._containerInsertBefore(t3);
            }, t2.pushContainer = function(e3, t3) {
              this._assertUnremoved();
              const r3 = this._verifyNodeList(t3), n2 = this.node[e3];
              return i.default.get({ parentPath: this, parent: this.node, container: n2, listKey: e3, key: n2.length }).setContext(this.context).replaceWithMultiple(r3);
            }, t2.hoist = function(e3 = this.scope) {
              return new s2.default(this, e3).run();
            };
            var n = r2(34), s2 = r2(452), i = r2(19), o = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(0);
            const s2 = { ReferencedIdentifier(e3, t3) {
              if (e3.isJSXIdentifier() && n.react.isCompatTag(e3.node.name) && !e3.parentPath.isJSXMemberExpression())
                return;
              if (e3.node.name === "this") {
                let r4 = e3.scope;
                do {
                  if (r4.path.isFunction() && !r4.path.isArrowFunctionExpression())
                    break;
                } while (r4 = r4.parent);
                r4 && t3.breakOnScopePaths.push(r4.path);
              }
              const r3 = e3.scope.getBinding(e3.node.name);
              if (r3) {
                for (const n2 of r3.constantViolations)
                  if (n2.scope !== r3.path.scope)
                    return t3.mutableBinding = true, void e3.stop();
                r3 === t3.scope.getBinding(e3.node.name) && (t3.bindings[e3.node.name] = r3);
              }
            } };
            t2.default = class {
              constructor(e3, t3) {
                this.breakOnScopePaths = void 0, this.bindings = void 0, this.mutableBinding = void 0, this.scopes = void 0, this.scope = void 0, this.path = void 0, this.attachAfter = void 0, this.breakOnScopePaths = [], this.bindings = {}, this.mutableBinding = false, this.scopes = [], this.scope = t3, this.path = e3, this.attachAfter = false;
              }
              isCompatibleScope(e3) {
                for (const t3 of Object.keys(this.bindings)) {
                  const r3 = this.bindings[t3];
                  if (!e3.bindingIdentifierEquals(t3, r3.identifier))
                    return false;
                }
                return true;
              }
              getCompatibleScopes() {
                let e3 = this.path.scope;
                do {
                  if (!this.isCompatibleScope(e3))
                    break;
                  if (this.scopes.push(e3), this.breakOnScopePaths.indexOf(e3.path) >= 0)
                    break;
                } while (e3 = e3.parent);
              }
              getAttachmentPath() {
                let e3 = this._getAttachmentPath();
                if (!e3)
                  return;
                let t3 = e3.scope;
                if (t3.path === e3 && (t3 = e3.scope.parent), t3.path.isProgram() || t3.path.isFunction())
                  for (const r3 of Object.keys(this.bindings)) {
                    if (!t3.hasOwnBinding(r3))
                      continue;
                    const n2 = this.bindings[r3];
                    if (n2.kind !== "param" && n2.path.parentKey !== "params" && this.getAttachmentParentForPath(n2.path).key >= e3.key) {
                      this.attachAfter = true, e3 = n2.path;
                      for (const t4 of n2.constantViolations)
                        this.getAttachmentParentForPath(t4).key > e3.key && (e3 = t4);
                    }
                  }
                return e3;
              }
              _getAttachmentPath() {
                const e3 = this.scopes.pop();
                if (e3) {
                  if (e3.path.isFunction()) {
                    if (!this.hasOwnParamBindings(e3))
                      return this.getNextScopeAttachmentParent();
                    {
                      if (this.scope === e3)
                        return;
                      const t3 = e3.path.get("body").get("body");
                      for (let e4 = 0; e4 < t3.length; e4++)
                        if (!t3[e4].node._blockHoist)
                          return t3[e4];
                    }
                  } else if (e3.path.isProgram())
                    return this.getNextScopeAttachmentParent();
                }
              }
              getNextScopeAttachmentParent() {
                const e3 = this.scopes.pop();
                if (e3)
                  return this.getAttachmentParentForPath(e3.path);
              }
              getAttachmentParentForPath(e3) {
                do {
                  if (!e3.parentPath || Array.isArray(e3.container) && e3.isStatement())
                    return e3;
                } while (e3 = e3.parentPath);
              }
              hasOwnParamBindings(e3) {
                for (const t3 of Object.keys(this.bindings)) {
                  if (!e3.hasOwnBinding(t3))
                    continue;
                  const r3 = this.bindings[t3];
                  if (r3.kind === "param" && r3.constant)
                    return true;
                }
                return false;
              }
              run() {
                if (this.path.traverse(s2, this), this.mutableBinding)
                  return;
                this.getCompatibleScopes();
                const e3 = this.getAttachmentPath();
                if (!e3)
                  return;
                if (e3.getFunctionParent() === this.path.getFunctionParent())
                  return;
                let t3 = e3.scope.generateUidIdentifier("ref");
                const r3 = n.variableDeclarator(t3, this.path.node), i = this.attachAfter ? "insertAfter" : "insertBefore", [o] = e3[i]([e3.isVariableDeclarator() ? r3 : n.variableDeclaration("var", [r3])]), a = this.path.parentPath;
                return a.isJSXElement() && this.path.container === a.node.children && (t3 = n.jsxExpressionContainer(t3)), this.path.replaceWith(n.cloneNode(t3)), e3.isVariableDeclarator() ? o.get("init") : o.get("declarations.0.init");
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.getOpposite = function() {
              return this.key === "left" ? this.getSibling("right") : this.key === "right" ? this.getSibling("left") : null;
            }, t2.getCompletionRecords = function() {
              return c(this, { canHaveBreak: false, shouldPopulateBreak: false, inCaseClause: false }).map((e3) => e3.path);
            }, t2.getSibling = function(e3) {
              return n.default.get({ parentPath: this.parentPath, parent: this.parent, container: this.container, listKey: this.listKey, key: e3 }).setContext(this.context);
            }, t2.getPrevSibling = function() {
              return this.getSibling(this.key - 1);
            }, t2.getNextSibling = function() {
              return this.getSibling(this.key + 1);
            }, t2.getAllNextSiblings = function() {
              let e3 = this.key, t3 = this.getSibling(++e3);
              const r3 = [];
              for (; t3.node; )
                r3.push(t3), t3 = this.getSibling(++e3);
              return r3;
            }, t2.getAllPrevSiblings = function() {
              let e3 = this.key, t3 = this.getSibling(--e3);
              const r3 = [];
              for (; t3.node; )
                r3.push(t3), t3 = this.getSibling(--e3);
              return r3;
            }, t2.get = function(e3, t3 = true) {
              t3 === true && (t3 = this.context);
              const r3 = e3.split(".");
              return r3.length === 1 ? this._getKey(e3, t3) : this._getPattern(r3, t3);
            }, t2._getKey = function(e3, t3) {
              const r3 = this.node, s3 = r3[e3];
              return Array.isArray(s3) ? s3.map((i2, o2) => n.default.get({ listKey: e3, parentPath: this, parent: r3, container: s3, key: o2 }).setContext(t3)) : n.default.get({ parentPath: this, parent: r3, container: r3, key: e3 }).setContext(t3);
            }, t2._getPattern = function(e3, t3) {
              let r3 = this;
              for (const n2 of e3)
                r3 = n2 === "." ? r3.parentPath : Array.isArray(r3) ? r3[n2] : r3.get(n2, t3);
              return r3;
            }, t2.getBindingIdentifiers = function(e3) {
              return s2.getBindingIdentifiers(this.node, e3);
            }, t2.getOuterBindingIdentifiers = function(e3) {
              return s2.getOuterBindingIdentifiers(this.node, e3);
            }, t2.getBindingIdentifierPaths = function(e3 = false, t3 = false) {
              let r3 = [].concat(this);
              const n2 = Object.create(null);
              for (; r3.length; ) {
                const i2 = r3.shift();
                if (!i2)
                  continue;
                if (!i2.node)
                  continue;
                const o2 = s2.getBindingIdentifiers.keys[i2.node.type];
                if (i2.isIdentifier())
                  e3 ? (n2[i2.node.name] = n2[i2.node.name] || []).push(i2) : n2[i2.node.name] = i2;
                else if (i2.isExportDeclaration()) {
                  const e4 = i2.get("declaration");
                  e4.isDeclaration() && r3.push(e4);
                } else {
                  if (t3) {
                    if (i2.isFunctionDeclaration()) {
                      r3.push(i2.get("id"));
                      continue;
                    }
                    if (i2.isFunctionExpression())
                      continue;
                  }
                  if (o2)
                    for (let e4 = 0; e4 < o2.length; e4++) {
                      const t4 = o2[e4], n3 = i2.get(t4);
                      (Array.isArray(n3) || n3.node) && (r3 = r3.concat(n3));
                    }
                }
              }
              return n2;
            }, t2.getOuterBindingIdentifierPaths = function(e3) {
              return this.getBindingIdentifierPaths(e3, true);
            };
            var n = r2(19), s2 = r2(0);
            function i(e3, t3, r3) {
              return e3 ? t3.concat(c(e3, r3)) : t3;
            }
            function o(e3) {
              e3.forEach((e4) => {
                e4.type = 1;
              });
            }
            function a(e3, t3) {
              e3.forEach((e4) => {
                e4.path.isBreakStatement({ label: null }) && (t3 ? e4.path.replaceWith(s2.unaryExpression("void", s2.numericLiteral(0))) : e4.path.remove());
              });
            }
            function l(e3, t3) {
              let r3 = [];
              if (t3.canHaveBreak) {
                let n2 = [];
                for (let s3 = 0; s3 < e3.length; s3++) {
                  const i2 = e3[s3], l2 = Object.assign({}, t3, { inCaseClause: false });
                  i2.isBlockStatement() && (t3.inCaseClause || t3.shouldPopulateBreak) ? l2.shouldPopulateBreak = true : l2.shouldPopulateBreak = false;
                  const u = c(i2, l2);
                  if (u.length > 0 && u.every((e4) => e4.type === 1)) {
                    n2.length > 0 && u.every((e4) => e4.path.isBreakStatement({ label: null })) ? (o(n2), r3 = r3.concat(n2), n2.some((e4) => e4.path.isDeclaration()) && (r3 = r3.concat(u), a(u, true)), a(u, false)) : (r3 = r3.concat(u), t3.shouldPopulateBreak || a(u, true));
                    break;
                  }
                  s3 === e3.length - 1 ? r3 = r3.concat(u) : (r3 = r3.concat(u.filter((e4) => e4.type === 1)), n2 = u.filter((e4) => e4.type === 0));
                }
              } else
                e3.length && (r3 = r3.concat(c(e3[e3.length - 1], t3)));
              return r3;
            }
            function c(e3, t3) {
              let r3 = [];
              if (e3.isIfStatement())
                r3 = i(e3.get("consequent"), r3, t3), r3 = i(e3.get("alternate"), r3, t3);
              else if (e3.isDoExpression() || e3.isFor() || e3.isWhile() || e3.isLabeledStatement())
                r3 = i(e3.get("body"), r3, t3);
              else if (e3.isProgram() || e3.isBlockStatement())
                r3 = r3.concat(l(e3.get("body"), t3));
              else {
                if (e3.isFunction())
                  return c(e3.get("body"), t3);
                e3.isTryStatement() ? (r3 = i(e3.get("block"), r3, t3), r3 = i(e3.get("handler"), r3, t3)) : e3.isCatchClause() ? r3 = i(e3.get("body"), r3, t3) : e3.isSwitchStatement() ? r3 = function(e4, t4, r4) {
                  let n2 = [];
                  for (let s3 = 0; s3 < e4.length; s3++) {
                    const i2 = c(e4[s3], r4), o2 = [], a2 = [];
                    for (const e5 of i2)
                      e5.type === 0 && o2.push(e5), e5.type === 1 && a2.push(e5);
                    o2.length && (n2 = o2), t4 = t4.concat(a2);
                  }
                  return t4.concat(n2);
                }(e3.get("cases"), r3, t3) : e3.isSwitchCase() ? r3 = r3.concat(l(e3.get("consequent"), { canHaveBreak: true, shouldPopulateBreak: false, inCaseClause: true })) : e3.isBreakStatement() ? r3.push(function(e4) {
                  return { type: 1, path: e4 };
                }(e3)) : r3.push(function(e4) {
                  return { type: 0, path: e4 };
                }(e3));
              }
              return r3;
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.shareCommentsWithSiblings = function() {
              if (typeof this.key == "string")
                return;
              const e3 = this.node;
              if (!e3)
                return;
              const t3 = e3.trailingComments, r3 = e3.leadingComments;
              if (!t3 && !r3)
                return;
              const n2 = this.getSibling(this.key - 1), s2 = this.getSibling(this.key + 1), i = Boolean(n2.node), o = Boolean(s2.node);
              i && !o ? n2.addComments("trailing", t3) : o && !i && s2.addComments("leading", r3);
            }, t2.addComment = function(e3, t3, r3) {
              n.addComment(this.node, e3, t3, r3);
            }, t2.addComments = function(e3, t3) {
              n.addComments(this.node, e3, t3);
            };
            var n = r2(0);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.explode = i, t2.verify = o, t2.merge = function(e3, t3 = [], r3) {
              const n2 = {};
              for (let s3 = 0; s3 < e3.length; s3++) {
                const o2 = e3[s3], a2 = t3[s3];
                i(o2);
                for (const e4 of Object.keys(o2)) {
                  let t4 = o2[e4];
                  (a2 || r3) && (t4 = l(t4, a2, r3)), f(n2[e4] = n2[e4] || {}, t4);
                }
              }
              return n2;
            };
            var n = r2(212), s2 = r2(0);
            function i(e3) {
              if (e3._exploded)
                return e3;
              e3._exploded = true;
              for (const t3 of Object.keys(e3)) {
                if (p2(t3))
                  continue;
                const r3 = t3.split("|");
                if (r3.length === 1)
                  continue;
                const n2 = e3[t3];
                delete e3[t3];
                for (const t4 of r3)
                  e3[t4] = n2;
              }
              o(e3), delete e3.__esModule, function(e4) {
                for (const t3 of Object.keys(e4)) {
                  if (p2(t3))
                    continue;
                  const r3 = e4[t3];
                  typeof r3 == "function" && (e4[t3] = { enter: r3 });
                }
              }(e3), c(e3);
              for (const t3 of Object.keys(e3)) {
                if (p2(t3))
                  continue;
                const r3 = n[t3];
                if (!r3)
                  continue;
                const s3 = e3[t3];
                for (const e4 of Object.keys(s3))
                  s3[e4] = u(r3, s3[e4]);
                if (delete e3[t3], r3.types)
                  for (const t4 of r3.types)
                    e3[t4] ? f(e3[t4], s3) : e3[t4] = s3;
                else
                  f(e3, s3);
              }
              for (const t3 of Object.keys(e3)) {
                if (p2(t3))
                  continue;
                const r3 = e3[t3];
                let n2 = s2.FLIPPED_ALIAS_KEYS[t3];
                const i2 = s2.DEPRECATED_KEYS[t3];
                if (i2 && (n2 = [i2]), n2) {
                  delete e3[t3];
                  for (const t4 of n2) {
                    const n3 = e3[t4];
                    n3 ? f(n3, r3) : e3[t4] = Object.assign({}, r3);
                  }
                }
              }
              for (const t3 of Object.keys(e3))
                p2(t3) || c(e3[t3]);
              return e3;
            }
            function o(e3) {
              if (!e3._verified) {
                if (typeof e3 == "function")
                  throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
                for (const t3 of Object.keys(e3)) {
                  if (t3 !== "enter" && t3 !== "exit" || a(t3, e3[t3]), p2(t3))
                    continue;
                  if (s2.TYPES.indexOf(t3) < 0)
                    throw new Error(`You gave us a visitor for the node type ${t3} but it's not a valid type`);
                  const r3 = e3[t3];
                  if (typeof r3 == "object")
                    for (const e4 of Object.keys(r3)) {
                      if (e4 !== "enter" && e4 !== "exit")
                        throw new Error(`You passed \`traverse()\` a visitor object with the property ${t3} that has the invalid property ${e4}`);
                      a(`${t3}.${e4}`, r3[e4]);
                    }
                }
                e3._verified = true;
              }
            }
            function a(e3, t3) {
              const r3 = [].concat(t3);
              for (const t4 of r3)
                if (typeof t4 != "function")
                  throw new TypeError(`Non-function found defined in ${e3} with type ${typeof t4}`);
            }
            function l(e3, t3, r3) {
              const n2 = {};
              for (const s3 of Object.keys(e3)) {
                let i2 = e3[s3];
                Array.isArray(i2) && (i2 = i2.map(function(e4) {
                  let n3 = e4;
                  return t3 && (n3 = function(r4) {
                    return e4.call(t3, r4, t3);
                  }), r3 && (n3 = r3(t3.key, s3, n3)), n3 !== e4 && (n3.toString = () => e4.toString()), n3;
                }), n2[s3] = i2);
              }
              return n2;
            }
            function c(e3) {
              e3.enter && !Array.isArray(e3.enter) && (e3.enter = [e3.enter]), e3.exit && !Array.isArray(e3.exit) && (e3.exit = [e3.exit]);
            }
            function u(e3, t3) {
              const r3 = function(r4) {
                if (e3.checkPath(r4))
                  return t3.apply(this, arguments);
              };
              return r3.toString = () => t3.toString(), r3;
            }
            function p2(e3) {
              return e3[0] === "_" || e3 === "enter" || e3 === "exit" || e3 === "shouldSkip" || e3 === "denylist" || e3 === "noScope" || e3 === "skipKeys" || e3 === "blacklist";
            }
            function f(e3, t3) {
              for (const r3 of Object.keys(t3))
                e3[r3] = [].concat(e3[r3] || [], t3[r3]);
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = class {
              getCode() {
              }
              getScope() {
              }
              addHelper() {
                throw new Error("Helpers are not supported by the default hub.");
              }
              buildError(e3, t3, r2 = TypeError) {
                return new r2(t3);
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(21), s2 = r2(458);
            const i = Object.assign({ __proto__: null }, s2);
            var o = i;
            t2.default = o;
            const a = (e3) => (t3) => ({ minVersion: e3, ast: () => n.default.program.ast(t3) });
            i.asyncIterator = a("7.0.0-beta.0")`
  export default function _asyncIterator(iterable) {
    var method;
    if (typeof Symbol !== "undefined") {
      if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];
      if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];
    }
    if (method == null) method = iterable["@@asyncIterator"];
    if (method == null) method = iterable["@@iterator"]
    if (method == null) throw new TypeError("Object is not async iterable");
    return method.call(iterable);
  }
`, i.AwaitValue = a("7.0.0-beta.0")`
  export default function _AwaitValue(value) {
    this.wrapped = value;
  }
`, i.AsyncGenerator = a("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function AsyncGenerator(gen) {
    var front, back;

    function send(key, arg) {
      return new Promise(function (resolve, reject) {
        var request = {
          key: key,
          arg: arg,
          resolve: resolve,
          reject: reject,
          next: null,
        };

        if (back) {
          back = back.next = request;
        } else {
          front = back = request;
          resume(key, arg);
        }
      });
    }

    function resume(key, arg) {
      try {
        var result = gen[key](arg)
        var value = result.value;
        var wrappedAwait = value instanceof AwaitValue;

        Promise.resolve(wrappedAwait ? value.wrapped : value).then(
          function (arg) {
            if (wrappedAwait) {
              resume(key === "return" ? "return" : "next", arg);
              return
            }

            settle(result.done ? "return" : "normal", arg);
          },
          function (err) { resume("throw", err); });
      } catch (err) {
        settle("throw", err);
      }
    }

    function settle(type, value) {
      switch (type) {
        case "return":
          front.resolve({ value: value, done: true });
          break;
        case "throw":
          front.reject(value);
          break;
        default:
          front.resolve({ value: value, done: false });
          break;
      }

      front = front.next;
      if (front) {
        resume(front.key, front.arg);
      } else {
        back = null;
      }
    }

    this._invoke = send;

    // Hide "return" method if generator return is not supported
    if (typeof gen.return !== "function") {
      this.return = undefined;
    }
  }

  AsyncGenerator.prototype[typeof Symbol === "function" && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; };

  AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };
  AsyncGenerator.prototype.throw = function (arg) { return this._invoke("throw", arg); };
  AsyncGenerator.prototype.return = function (arg) { return this._invoke("return", arg); };
`, i.wrapAsyncGenerator = a("7.0.0-beta.0")`
  import AsyncGenerator from "AsyncGenerator";

  export default function _wrapAsyncGenerator(fn) {
    return function () {
      return new AsyncGenerator(fn.apply(this, arguments));
    };
  }
`, i.awaitAsyncGenerator = a("7.0.0-beta.0")`
  import AwaitValue from "AwaitValue";

  export default function _awaitAsyncGenerator(value) {
    return new AwaitValue(value);
  }
`, i.asyncGeneratorDelegate = a("7.0.0-beta.0")`
  export default function _asyncGeneratorDelegate(inner, awaitWrap) {
    var iter = {}, waiting = false;

    function pump(key, value) {
      waiting = true;
      value = new Promise(function (resolve) { resolve(inner[key](value)); });
      return { done: false, value: awaitWrap(value) };
    };

    iter[typeof Symbol !== "undefined" && Symbol.iterator || "@@iterator"] = function () { return this; };

    iter.next = function (value) {
      if (waiting) {
        waiting = false;
        return value;
      }
      return pump("next", value);
    };

    if (typeof inner.throw === "function") {
      iter.throw = function (value) {
        if (waiting) {
          waiting = false;
          throw value;
        }
        return pump("throw", value);
      };
    }

    if (typeof inner.return === "function") {
      iter.return = function (value) {
        if (waiting) {
          waiting = false;
          return value;
        }
        return pump("return", value);
      };
    }

    return iter;
  }
`, i.asyncToGenerator = a("7.0.0-beta.0")`
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  export default function _asyncToGenerator(fn) {
    return function () {
      var self = this, args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }
`, i.classCallCheck = a("7.0.0-beta.0")`
  export default function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
`, i.createClass = a("7.0.0-beta.0")`
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i ++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  export default function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
`, i.defineEnumerableProperties = a("7.0.0-beta.0")`
  export default function _defineEnumerableProperties(obj, descs) {
    for (var key in descs) {
      var desc = descs[key];
      desc.configurable = desc.enumerable = true;
      if ("value" in desc) desc.writable = true;
      Object.defineProperty(obj, key, desc);
    }

    // Symbols are not enumerated over by for-in loops. If native
    // Symbols are available, fetch all of the descs object's own
    // symbol properties and define them on our target object too.
    if (Object.getOwnPropertySymbols) {
      var objectSymbols = Object.getOwnPropertySymbols(descs);
      for (var i = 0; i < objectSymbols.length; i++) {
        var sym = objectSymbols[i];
        var desc = descs[sym];
        desc.configurable = desc.enumerable = true;
        if ("value" in desc) desc.writable = true;
        Object.defineProperty(obj, sym, desc);
      }
    }
    return obj;
  }
`, i.defaults = a("7.0.0-beta.0")`
  export default function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
`, i.defineProperty = a("7.0.0-beta.0")`
  export default function _defineProperty(obj, key, value) {
    // Shortcircuit the slow defineProperty path when possible.
    // We are trying to avoid issues where setters defined on the
    // prototype cause side effects under the fast path of simple
    // assignment. By checking for existence of the property with
    // the in operator, we can optimize most of this overhead away.
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
`, i.extends = a("7.0.0-beta.0")`
  export default function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };

    return _extends.apply(this, arguments);
  }
`, i.objectSpread = a("7.0.0-beta.0")`
  import defineProperty from "defineProperty";

  export default function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = (arguments[i] != null) ? Object(arguments[i]) : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
`, i.inherits = a("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }
`, i.inheritsLoose = a("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";

  export default function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    setPrototypeOf(subClass, superClass);
  }
`, i.getPrototypeOf = a("7.0.0-beta.0")`
  export default function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
    return _getPrototypeOf(o);
  }
`, i.setPrototypeOf = a("7.0.0-beta.0")`
  export default function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
`, i.isNativeReflectConstruct = a("7.9.0")`
  export default function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;

    // core-js@3
    if (Reflect.construct.sham) return false;

    // Proxy can't be polyfilled. Every browser implemented
    // proxies before or at the same time as Reflect.construct,
    // so if they support Proxy they also support Reflect.construct.
    if (typeof Proxy === "function") return true;

    // Since Reflect.construct can't be properly polyfilled, some
    // implementations (e.g. core-js@2) don't set the correct internal slots.
    // Those polyfills don't allow us to subclass built-ins, so we need to
    // use our fallback implementation.
    try {
      // If the internal slots aren't set, this throws an error similar to
      //   TypeError: this is not a Boolean object.

      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
      return true;
    } catch (e) {
      return false;
    }
  }
`, i.construct = a("7.0.0-beta.0")`
  import setPrototypeOf from "setPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";

  export default function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      // NOTE: If Parent !== Class, the correct __proto__ is set *after*
      //       calling the constructor.
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    // Avoid issues with Class being present but undefined when it wasn't
    // present in the original call.
    return _construct.apply(null, arguments);
  }
`, i.isNativeFunction = a("7.0.0-beta.0")`
  export default function _isNativeFunction(fn) {
    // Note: This function returns "true" for core-js functions.
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
`, i.wrapNativeSuper = a("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";
  import setPrototypeOf from "setPrototypeOf";
  import isNativeFunction from "isNativeFunction";
  import construct from "construct";

  export default function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return construct(Class, arguments, getPrototypeOf(this).constructor)
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true,
        }
      });

      return setPrototypeOf(Wrapper, Class);
    }

    return _wrapNativeSuper(Class)
  }
`, i.instanceof = a("7.0.0-beta.0")`
  export default function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
      return !!right[Symbol.hasInstance](left);
    } else {
      return left instanceof right;
    }
  }
`, i.interopRequireDefault = a("7.0.0-beta.0")`
  export default function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
`, i.interopRequireWildcard = a("7.14.0")`
  function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;

    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function (nodeInterop) {
      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
  }

  export default function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
      return obj;
    }

    if (obj === null || (typeof obj !== "object" && typeof obj !== "function")) {
      return { default: obj }
    }

    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }

    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
      if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor
          ? Object.getOwnPropertyDescriptor(obj, key)
          : null;
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
    newObj.default = obj;
    if (cache) {
      cache.set(obj, newObj);
    }
    return newObj;
  }
`, i.newArrowCheck = a("7.0.0-beta.0")`
  export default function _newArrowCheck(innerThis, boundThis) {
    if (innerThis !== boundThis) {
      throw new TypeError("Cannot instantiate an arrow function");
    }
  }
`, i.objectDestructuringEmpty = a("7.0.0-beta.0")`
  export default function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }
`, i.objectWithoutPropertiesLoose = a("7.0.0-beta.0")`
  export default function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};

    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }
`, i.objectWithoutProperties = a("7.0.0-beta.0")`
  import objectWithoutPropertiesLoose from "objectWithoutPropertiesLoose";

  export default function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = objectWithoutPropertiesLoose(source, excluded);
    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }
`, i.assertThisInitialized = a("7.0.0-beta.0")`
  export default function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
`, i.possibleConstructorReturn = a("7.0.0-beta.0")`
  import assertThisInitialized from "assertThisInitialized";

  export default function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }
    return assertThisInitialized(self);
  }
`, i.createSuper = a("7.9.0")`
  import getPrototypeOf from "getPrototypeOf";
  import isNativeReflectConstruct from "isNativeReflectConstruct";
  import possibleConstructorReturn from "possibleConstructorReturn";

  export default function _createSuper(Derived) {
    var hasNativeReflectConstruct = isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        // NOTE: This doesn't work if this.__proto__.constructor has been modified.
        var NewTarget = getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return possibleConstructorReturn(this, result);
    }
  }
 `, i.superPropBase = a("7.0.0-beta.0")`
  import getPrototypeOf from "getPrototypeOf";

  export default function _superPropBase(object, property) {
    // Yes, this throws if object is null to being with, that's on purpose.
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
`, i.get = a("7.0.0-beta.0")`
  import superPropBase from "superPropBase";

  export default function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);

        if (!base) return;

        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }
    return _get(target, property, receiver || target);
  }
`, i.set = a("7.0.0-beta.0")`
  import superPropBase from "superPropBase";
  import defineProperty from "defineProperty";

  function set(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set = Reflect.set;
    } else {
      set = function set(target, property, value, receiver) {
        var base = superPropBase(target, property);
        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);
          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            // Both getter and non-writable fall into this.
            return false;
          }
        }

        // Without a super that defines the property, spec boils down to
        // "define on receiver" for some reason.
        desc = Object.getOwnPropertyDescriptor(receiver, property);
        if (desc) {
          if (!desc.writable) {
            // Setter, getter, and non-writable fall into this.
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          // Avoid setters that may be defined on Sub's prototype, but not on
          // the instance.
          defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set(target, property, value, receiver);
  }

  export default function _set(target, property, value, receiver, isStrict) {
    var s = set(target, property, value, receiver || target);
    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }
`, i.taggedTemplateLiteral = a("7.0.0-beta.0")`
  export default function _taggedTemplateLiteral(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    return Object.freeze(Object.defineProperties(strings, {
        raw: { value: Object.freeze(raw) }
    }));
  }
`, i.taggedTemplateLiteralLoose = a("7.0.0-beta.0")`
  export default function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) { raw = strings.slice(0); }
    strings.raw = raw;
    return strings;
  }
`, i.readOnlyError = a("7.0.0-beta.0")`
  export default function _readOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is read-only");
  }
`, i.writeOnlyError = a("7.12.13")`
  export default function _writeOnlyError(name) {
    throw new TypeError("\\"" + name + "\\" is write-only");
  }
`, i.classNameTDZError = a("7.0.0-beta.0")`
  export default function _classNameTDZError(name) {
    throw new Error("Class \\"" + name + "\\" cannot be referenced in computed property keys.");
  }
`, i.temporalUndefined = a("7.0.0-beta.0")`
  // This function isn't mean to be called, but to be used as a reference.
  // We can't use a normal object because it isn't hoisted.
  export default function _temporalUndefined() {}
`, i.tdz = a("7.5.5")`
  export default function _tdzError(name) {
    throw new ReferenceError(name + " is not defined - temporal dead zone");
  }
`, i.temporalRef = a("7.0.0-beta.0")`
  import undef from "temporalUndefined";
  import err from "tdz";

  export default function _temporalRef(val, name) {
    return val === undef ? err(name) : val;
  }
`, i.slicedToArray = a("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimit from "iterableToArrayLimit";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArray(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimit(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i.slicedToArrayLoose = a("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArrayLimitLoose from "iterableToArrayLimitLoose";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _slicedToArrayLoose(arr, i) {
    return (
      arrayWithHoles(arr) ||
      iterableToArrayLimitLoose(arr, i) ||
      unsupportedIterableToArray(arr, i) ||
      nonIterableRest()
    );
  }
`, i.toArray = a("7.0.0-beta.0")`
  import arrayWithHoles from "arrayWithHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableRest from "nonIterableRest";

  export default function _toArray(arr) {
    return (
      arrayWithHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableRest()
    );
  }
`, i.toConsumableArray = a("7.0.0-beta.0")`
  import arrayWithoutHoles from "arrayWithoutHoles";
  import iterableToArray from "iterableToArray";
  import unsupportedIterableToArray from "unsupportedIterableToArray";
  import nonIterableSpread from "nonIterableSpread";

  export default function _toConsumableArray(arr) {
    return (
      arrayWithoutHoles(arr) ||
      iterableToArray(arr) ||
      unsupportedIterableToArray(arr) ||
      nonIterableSpread()
    );
  }
`, i.arrayWithoutHoles = a("7.0.0-beta.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
`, i.arrayWithHoles = a("7.0.0-beta.0")`
  export default function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
`, i.maybeArrayLike = a("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _maybeArrayLike(next, arr, i) {
    if (arr && !Array.isArray(arr) && typeof arr.length === "number") {
      var len = arr.length;
      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);
    }
    return next(arr, i);
  }
`, i.iterableToArray = a("7.0.0-beta.0")`
  export default function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
`, i.iterableToArrayLimit = a("7.0.0-beta.0")`
  export default function _iterableToArrayLimit(arr, i) {
    // this is an expanded form of \`for...of\` that properly supports abrupt completions of
    // iterators etc. variable names have been minimised to reduce the size of this massive
    // helper. sometimes spec compliance is annoying :(
    //
    // _n = _iteratorNormalCompletion
    // _d = _didIteratorError
    // _e = _iteratorError
    // _i = _iterator
    // _s = _step

    var _i = arr == null ? null : (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
`, i.iterableToArrayLimitLoose = a("7.0.0-beta.0")`
  export default function _iterableToArrayLimitLoose(arr, i) {
    var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]);
    if (_i == null) return;

    var _arr = [];
    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {
      _arr.push(_step.value);
      if (i && _arr.length === i) break;
    }
    return _arr;
  }
`, i.unsupportedIterableToArray = a("7.9.0")`
  import arrayLikeToArray from "arrayLikeToArray";

  export default function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return arrayLikeToArray(o, minLen);
  }
`, i.arrayLikeToArray = a("7.9.0")`
  export default function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
`, i.nonIterableSpread = a("7.0.0-beta.0")`
  export default function _nonIterableSpread() {
    throw new TypeError(
      "Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i.nonIterableRest = a("7.0.0-beta.0")`
  export default function _nonIterableRest() {
    throw new TypeError(
      "Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
`, i.createForOfIteratorHelper = a("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  // s: start (create the iterator)
  // n: next
  // e: error (called whenever something throws)
  // f: finish (always called at the end)

  export default function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      // Fallback for engines without symbol support
      if (
        Array.isArray(o) ||
        (it = unsupportedIterableToArray(o)) ||
        (allowArrayLike && o && typeof o.length === "number")
      ) {
        if (it) o = it;
        var i = 0;
        var F = function(){};
        return {
          s: F,
          n: function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          },
          e: function(e) { throw e; },
          f: F,
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true, didErr = false, err;

    return {
      s: function() {
        it = it.call(o);
      },
      n: function() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function(e) {
        didErr = true;
        err = e;
      },
      f: function() {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }
`, i.createForOfIteratorHelperLoose = a("7.9.0")`
  import unsupportedIterableToArray from "unsupportedIterableToArray";

  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (it) return (it = it.call(o)).next.bind(it);

    // Fallback for engines without symbol support
    if (
      Array.isArray(o) ||
      (it = unsupportedIterableToArray(o)) ||
      (allowArrayLike && o && typeof o.length === "number")
    ) {
      if (it) o = it;
      var i = 0;
      return function() {
        if (i >= o.length) return { done: true };
        return { done: false, value: o[i++] };
      }
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
`, i.skipFirstGeneratorNext = a("7.0.0-beta.0")`
  export default function _skipFirstGeneratorNext(fn) {
    return function () {
      var it = fn.apply(this, arguments);
      it.next();
      return it;
    }
  }
`, i.toPrimitive = a("7.1.5")`
  export default function _toPrimitive(
    input,
    hint /*: "default" | "string" | "number" | void */
  ) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
`, i.toPropertyKey = a("7.1.5")`
  import toPrimitive from "toPrimitive";

  export default function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
`, i.initializerWarningHelper = a("7.0.0-beta.0")`
    export default function _initializerWarningHelper(descriptor, context){
        throw new Error(
          'Decorating class property failed. Please ensure that ' +
          'proposal-class-properties is enabled and runs after the decorators transform.'
        );
    }
`, i.initializerDefineProperty = a("7.0.0-beta.0")`
    export default function _initializerDefineProperty(target, property, descriptor, context){
        if (!descriptor) return;

        Object.defineProperty(target, property, {
            enumerable: descriptor.enumerable,
            configurable: descriptor.configurable,
            writable: descriptor.writable,
            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,
        });
    }
`, i.applyDecoratedDescriptor = a("7.0.0-beta.0")`
    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){
        var desc = {};
        Object.keys(descriptor).forEach(function(key){
            desc[key] = descriptor[key];
        });
        desc.enumerable = !!desc.enumerable;
        desc.configurable = !!desc.configurable;
        if ('value' in desc || desc.initializer){
            desc.writable = true;
        }

        desc = decorators.slice().reverse().reduce(function(desc, decorator){
            return decorator(target, property, desc) || desc;
        }, desc);

        if (context && desc.initializer !== void 0){
            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
            desc.initializer = undefined;
        }

        if (desc.initializer === void 0){
            Object.defineProperty(target, property, desc);
            desc = null;
        }

        return desc;
    }
`, i.classPrivateFieldLooseKey = a("7.0.0-beta.0")`
  var id = 0;
  export default function _classPrivateFieldKey(name) {
    return "__private_" + (id++) + "_" + name;
  }
`, i.classPrivateFieldLooseBase = a("7.0.0-beta.0")`
  export default function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }
`, i.classPrivateFieldGet = a("7.0.0-beta.0")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldGet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i.classPrivateFieldSet = a("7.0.0-beta.0")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldSet(receiver, privateMap, value) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i.classPrivateFieldDestructureSet = a("7.4.4")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classExtractFieldDescriptor from "classExtractFieldDescriptor";
  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {
    var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i.classExtractFieldDescriptor = a("7.13.10")`
  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
  }
`, i.classStaticPrivateFieldSpecGet = a("7.0.2")`
  import classApplyDescriptorGet from "classApplyDescriptorGet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "get");
    return classApplyDescriptorGet(receiver, descriptor);
  }
`, i.classStaticPrivateFieldSpecSet = a("7.0.2")`
  import classApplyDescriptorSet from "classApplyDescriptorSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    classApplyDescriptorSet(receiver, descriptor, value);
    return value;
  }
`, i.classStaticPrivateMethodGet = a("7.3.2")`
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    return method;
  }
`, i.classStaticPrivateMethodSet = a("7.3.2")`
  export default function _classStaticPrivateMethodSet() {
    throw new TypeError("attempted to set read only static private field");
  }
`, i.classApplyDescriptorGet = a("7.13.10")`
  export default function _classApplyDescriptorGet(receiver, descriptor) {
    if (descriptor.get) {
      return descriptor.get.call(receiver);
    }
    return descriptor.value;
  }
`, i.classApplyDescriptorSet = a("7.13.10")`
  export default function _classApplyDescriptorSet(receiver, descriptor, value) {
    if (descriptor.set) {
      descriptor.set.call(receiver, value);
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }
      descriptor.value = value;
    }
  }
`, i.classApplyDescriptorDestructureSet = a("7.13.10")`
  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {
    if (descriptor.set) {
      if (!("__destrObj" in descriptor)) {
        descriptor.__destrObj = {
          set value(v) {
            descriptor.set.call(receiver, v)
          },
        };
      }
      return descriptor.__destrObj;
    } else {
      if (!descriptor.writable) {
        // This should only throw in strict mode, but class bodies are
        // always strict and private fields can only be used inside
        // class bodies.
        throw new TypeError("attempted to set read only private field");
      }

      return descriptor;
    }
  }
`, i.classStaticPrivateFieldDestructureSet = a("7.13.10")`
  import classApplyDescriptorDestructureSet from "classApplyDescriptorDestructureSet";
  import classCheckPrivateStaticAccess from "classCheckPrivateStaticAccess";
  import classCheckPrivateStaticFieldDescriptor from "classCheckPrivateStaticFieldDescriptor";
  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {
    classCheckPrivateStaticAccess(receiver, classConstructor);
    classCheckPrivateStaticFieldDescriptor(descriptor, "set");
    return classApplyDescriptorDestructureSet(receiver, descriptor);
  }
`, i.classCheckPrivateStaticAccess = a("7.13.10")`
  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {
    if (receiver !== classConstructor) {
      throw new TypeError("Private static access of wrong provenance");
    }
  }
`, i.classCheckPrivateStaticFieldDescriptor = a("7.13.10")`
  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {
    if (descriptor === undefined) {
      throw new TypeError("attempted to " + action + " private static field before its declaration");
    }
  }
`, i.decorate = a("7.1.5")`
  import toArray from "toArray";
  import toPropertyKey from "toPropertyKey";

  // These comments are stripped by @babel/template
  /*::
  type PropertyDescriptor =
    | {
        value: any,
        writable: boolean,
        configurable: boolean,
        enumerable: boolean,
      }
    | {
        get?: () => any,
        set?: (v: any) => void,
        configurable: boolean,
        enumerable: boolean,
      };

  type FieldDescriptor ={
    writable: boolean,
    configurable: boolean,
    enumerable: boolean,
  };

  type Placement = "static" | "prototype" | "own";
  type Key = string | symbol; // PrivateName is not supported yet.

  type ElementDescriptor =
    | {
        kind: "method",
        key: Key,
        placement: Placement,
        descriptor: PropertyDescriptor
      }
    | {
        kind: "field",
        key: Key,
        placement: Placement,
        descriptor: FieldDescriptor,
        initializer?: () => any,
      };

  // This is exposed to the user code
  type ElementObjectInput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
  };

  // This is exposed to the user code
  type ElementObjectOutput = ElementDescriptor & {
    [@@toStringTag]?: "Descriptor"
    extras?: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  // This is exposed to the user code
  type ClassObject = {
    [@@toStringTag]?: "Descriptor",
    kind: "class",
    elements: ElementDescriptor[],
  };

  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;
  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;
  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;

  // Only used by Babel in the transform output, not part of the spec.
  type ElementDefinition =
    | {
        kind: "method",
        value: any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
      }
    | {
        kind: "field",
        value: () => any,
        key: Key,
        static?: boolean,
        decorators?: ElementDecorator[],
    };

  declare function ClassFactory<C>(initialize: (instance: C) => void): {
    F: Class<C>,
    d: ElementDefinition[]
  }

  */

  /*::
  // Various combinations with/without extras and with one or many finishers

  type ElementFinisherExtras = {
    element: ElementDescriptor,
    finisher?: ClassFinisher,
    extras?: ElementDescriptor[],
  };

  type ElementFinishersExtras = {
    element: ElementDescriptor,
    finishers: ClassFinisher[],
    extras: ElementDescriptor[],
  };

  type ElementsFinisher = {
    elements: ElementDescriptor[],
    finisher?: ClassFinisher,
  };

  type ElementsFinishers = {
    elements: ElementDescriptor[],
    finishers: ClassFinisher[],
  };

  */

  /*::

  type Placements = {
    static: Key[],
    prototype: Key[],
    own: Key[],
  };

  */

  // ClassDefinitionEvaluation (Steps 26-*)
  export default function _decorate(
    decorators /*: ClassDecorator[] */,
    factory /*: ClassFactory */,
    superClass /*: ?Class<*> */,
    mixins /*: ?Array<Function> */,
  ) /*: Class<*> */ {
    var api = _getDecoratorsApi();
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        api = mixins[i](api);
      }
    }

    var r = factory(function initialize(O) {
      api.initializeInstanceElements(O, decorated.elements);
    }, superClass);
    var decorated = api.decorateClass(
      _coalesceClassElements(r.d.map(_createElementDescriptor)),
      decorators,
    );

    api.initializeClassElements(r.F, decorated.elements);

    return api.runClassFinishers(r.F, decorated.finishers);
  }

  function _getDecoratorsApi() {
    _getDecoratorsApi = function() {
      return api;
    };

    var api = {
      elementsDefinitionOrder: [["method"], ["field"]],

      // InitializeInstanceElements
      initializeInstanceElements: function(
        /*::<C>*/ O /*: C */,
        elements /*: ElementDescriptor[] */,
      ) {
        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            if (element.kind === kind && element.placement === "own") {
              this.defineClassElement(O, element);
            }
          }, this);
        }, this);
      },

      // InitializeClassElements
      initializeClassElements: function(
        /*::<C>*/ F /*: Class<C> */,
        elements /*: ElementDescriptor[] */,
      ) {
        var proto = F.prototype;

        ["method", "field"].forEach(function(kind) {
          elements.forEach(function(element /*: ElementDescriptor */) {
            var placement = element.placement;
            if (
              element.kind === kind &&
              (placement === "static" || placement === "prototype")
            ) {
              var receiver = placement === "static" ? F : proto;
              this.defineClassElement(receiver, element);
            }
          }, this);
        }, this);
      },

      // DefineClassElement
      defineClassElement: function(
        /*::<C>*/ receiver /*: C | Class<C> */,
        element /*: ElementDescriptor */,
      ) {
        var descriptor /*: PropertyDescriptor */ = element.descriptor;
        if (element.kind === "field") {
          var initializer = element.initializer;
          descriptor = {
            enumerable: descriptor.enumerable,
            writable: descriptor.writable,
            configurable: descriptor.configurable,
            value: initializer === void 0 ? void 0 : initializer.call(receiver),
          };
        }
        Object.defineProperty(receiver, element.key, descriptor);
      },

      // DecorateClass
      decorateClass: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var newElements /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];
        var placements /*: Placements */ = {
          static: [],
          prototype: [],
          own: [],
        };

        elements.forEach(function(element /*: ElementDescriptor */) {
          this.addElementPlacement(element, placements);
        }, this);

        elements.forEach(function(element /*: ElementDescriptor */) {
          if (!_hasDecorators(element)) return newElements.push(element);

          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(
            element,
            placements,
          );
          newElements.push(elementFinishersExtras.element);
          newElements.push.apply(newElements, elementFinishersExtras.extras);
          finishers.push.apply(finishers, elementFinishersExtras.finishers);
        }, this);

        if (!decorators) {
          return { elements: newElements, finishers: finishers };
        }

        var result /*: ElementsFinishers */ = this.decorateConstructor(
          newElements,
          decorators,
        );
        finishers.push.apply(finishers, result.finishers);
        result.finishers = finishers;

        return result;
      },

      // AddElementPlacement
      addElementPlacement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
        silent /*: boolean */,
      ) {
        var keys = placements[element.placement];
        if (!silent && keys.indexOf(element.key) !== -1) {
          throw new TypeError("Duplicated element (" + element.key + ")");
        }
        keys.push(element.key);
      },

      // DecorateElement
      decorateElement: function(
        element /*: ElementDescriptor */,
        placements /*: Placements */,
      ) /*: ElementFinishersExtras */ {
        var extras /*: ElementDescriptor[] */ = [];
        var finishers /*: ClassFinisher[] */ = [];

        for (
          var decorators = element.decorators, i = decorators.length - 1;
          i >= 0;
          i--
        ) {
          // (inlined) RemoveElementPlacement
          var keys = placements[element.placement];
          keys.splice(keys.indexOf(element.key), 1);

          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(
            element,
          );
          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(
            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||
              elementObject,
          );

          element = elementFinisherExtras.element;
          this.addElementPlacement(element, placements);

          if (elementFinisherExtras.finisher) {
            finishers.push(elementFinisherExtras.finisher);
          }

          var newExtras /*: ElementDescriptor[] | void */ =
            elementFinisherExtras.extras;
          if (newExtras) {
            for (var j = 0; j < newExtras.length; j++) {
              this.addElementPlacement(newExtras[j], placements);
            }
            extras.push.apply(extras, newExtras);
          }
        }

        return { element: element, finishers: finishers, extras: extras };
      },

      // DecorateConstructor
      decorateConstructor: function(
        elements /*: ElementDescriptor[] */,
        decorators /*: ClassDecorator[] */,
      ) /*: ElementsFinishers */ {
        var finishers /*: ClassFinisher[] */ = [];

        for (var i = decorators.length - 1; i >= 0; i--) {
          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);
          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(
            (0, decorators[i])(obj) /*: ClassObject */ || obj,
          );

          if (elementsAndFinisher.finisher !== undefined) {
            finishers.push(elementsAndFinisher.finisher);
          }

          if (elementsAndFinisher.elements !== undefined) {
            elements = elementsAndFinisher.elements;

            for (var j = 0; j < elements.length - 1; j++) {
              for (var k = j + 1; k < elements.length; k++) {
                if (
                  elements[j].key === elements[k].key &&
                  elements[j].placement === elements[k].placement
                ) {
                  throw new TypeError(
                    "Duplicated element (" + elements[j].key + ")",
                  );
                }
              }
            }
          }
        }

        return { elements: elements, finishers: finishers };
      },

      // FromElementDescriptor
      fromElementDescriptor: function(
        element /*: ElementDescriptor */,
      ) /*: ElementObject */ {
        var obj /*: ElementObject */ = {
          kind: element.kind,
          key: element.key,
          placement: element.placement,
          descriptor: element.descriptor,
        };

        var desc = {
          value: "Descriptor",
          configurable: true,
        };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        if (element.kind === "field") obj.initializer = element.initializer;

        return obj;
      },

      // ToElementDescriptors
      toElementDescriptors: function(
        elementObjects /*: ElementObject[] */,
      ) /*: ElementDescriptor[] */ {
        if (elementObjects === undefined) return;
        return toArray(elementObjects).map(function(elementObject) {
          var element = this.toElementDescriptor(elementObject);
          this.disallowProperty(elementObject, "finisher", "An element descriptor");
          this.disallowProperty(elementObject, "extras", "An element descriptor");
          return element;
        }, this);
      },

      // ToElementDescriptor
      toElementDescriptor: function(
        elementObject /*: ElementObject */,
      ) /*: ElementDescriptor */ {
        var kind = String(elementObject.kind);
        if (kind !== "method" && kind !== "field") {
          throw new TypeError(
            'An element descriptor\\'s .kind property must be either "method" or' +
              ' "field", but a decorator created an element descriptor with' +
              ' .kind "' +
              kind +
              '"',
          );
        }

        var key = toPropertyKey(elementObject.key);

        var placement = String(elementObject.placement);
        if (
          placement !== "static" &&
          placement !== "prototype" &&
          placement !== "own"
        ) {
          throw new TypeError(
            'An element descriptor\\'s .placement property must be one of "static",' +
              ' "prototype" or "own", but a decorator created an element descriptor' +
              ' with .placement "' +
              placement +
              '"',
          );
        }

        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;

        this.disallowProperty(elementObject, "elements", "An element descriptor");

        var element /*: ElementDescriptor */ = {
          kind: kind,
          key: key,
          placement: placement,
          descriptor: Object.assign({}, descriptor),
        };

        if (kind !== "field") {
          this.disallowProperty(elementObject, "initializer", "A method descriptor");
        } else {
          this.disallowProperty(
            descriptor,
            "get",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "set",
            "The property descriptor of a field descriptor",
          );
          this.disallowProperty(
            descriptor,
            "value",
            "The property descriptor of a field descriptor",
          );

          element.initializer = elementObject.initializer;
        }

        return element;
      },

      toElementFinisherExtras: function(
        elementObject /*: ElementObject */,
      ) /*: ElementFinisherExtras */ {
        var element /*: ElementDescriptor */ = this.toElementDescriptor(
          elementObject,
        );
        var finisher /*: ClassFinisher */ = _optionalCallableProperty(
          elementObject,
          "finisher",
        );
        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(
          elementObject.extras,
        );

        return { element: element, finisher: finisher, extras: extras };
      },

      // FromClassDescriptor
      fromClassDescriptor: function(
        elements /*: ElementDescriptor[] */,
      ) /*: ClassObject */ {
        var obj = {
          kind: "class",
          elements: elements.map(this.fromElementDescriptor, this),
        };

        var desc = { value: "Descriptor", configurable: true };
        Object.defineProperty(obj, Symbol.toStringTag, desc);

        return obj;
      },

      // ToClassDescriptor
      toClassDescriptor: function(
        obj /*: ClassObject */,
      ) /*: ElementsFinisher */ {
        var kind = String(obj.kind);
        if (kind !== "class") {
          throw new TypeError(
            'A class descriptor\\'s .kind property must be "class", but a decorator' +
              ' created a class descriptor with .kind "' +
              kind +
              '"',
          );
        }

        this.disallowProperty(obj, "key", "A class descriptor");
        this.disallowProperty(obj, "placement", "A class descriptor");
        this.disallowProperty(obj, "descriptor", "A class descriptor");
        this.disallowProperty(obj, "initializer", "A class descriptor");
        this.disallowProperty(obj, "extras", "A class descriptor");

        var finisher = _optionalCallableProperty(obj, "finisher");
        var elements = this.toElementDescriptors(obj.elements);

        return { elements: elements, finisher: finisher };
      },

      // RunClassFinishers
      runClassFinishers: function(
        constructor /*: Class<*> */,
        finishers /*: ClassFinisher[] */,
      ) /*: Class<*> */ {
        for (var i = 0; i < finishers.length; i++) {
          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);
          if (newConstructor !== undefined) {
            // NOTE: This should check if IsConstructor(newConstructor) is false.
            if (typeof newConstructor !== "function") {
              throw new TypeError("Finishers must return a constructor.");
            }
            constructor = newConstructor;
          }
        }
        return constructor;
      },

      disallowProperty: function(obj, name, objectType) {
        if (obj[name] !== undefined) {
          throw new TypeError(objectType + " can't have a ." + name + " property.");
        }
      }
    };

    return api;
  }

  // ClassElementEvaluation
  function _createElementDescriptor(
    def /*: ElementDefinition */,
  ) /*: ElementDescriptor */ {
    var key = toPropertyKey(def.key);

    var descriptor /*: PropertyDescriptor */;
    if (def.kind === "method") {
      descriptor = {
        value: def.value,
        writable: true,
        configurable: true,
        enumerable: false,
      };
    } else if (def.kind === "get") {
      descriptor = { get: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "set") {
      descriptor = { set: def.value, configurable: true, enumerable: false };
    } else if (def.kind === "field") {
      descriptor = { configurable: true, writable: true, enumerable: true };
    }

    var element /*: ElementDescriptor */ = {
      kind: def.kind === "field" ? "field" : "method",
      key: key,
      placement: def.static
        ? "static"
        : def.kind === "field"
        ? "own"
        : "prototype",
      descriptor: descriptor,
    };
    if (def.decorators) element.decorators = def.decorators;
    if (def.kind === "field") element.initializer = def.value;

    return element;
  }

  // CoalesceGetterSetter
  function _coalesceGetterSetter(
    element /*: ElementDescriptor */,
    other /*: ElementDescriptor */,
  ) {
    if (element.descriptor.get !== undefined) {
      other.descriptor.get = element.descriptor.get;
    } else {
      other.descriptor.set = element.descriptor.set;
    }
  }

  // CoalesceClassElements
  function _coalesceClassElements(
    elements /*: ElementDescriptor[] */,
  ) /*: ElementDescriptor[] */ {
    var newElements /*: ElementDescriptor[] */ = [];

    var isSameElement = function(
      other /*: ElementDescriptor */,
    ) /*: boolean */ {
      return (
        other.kind === "method" &&
        other.key === element.key &&
        other.placement === element.placement
      );
    };

    for (var i = 0; i < elements.length; i++) {
      var element /*: ElementDescriptor */ = elements[i];
      var other /*: ElementDescriptor */;

      if (
        element.kind === "method" &&
        (other = newElements.find(isSameElement))
      ) {
        if (
          _isDataDescriptor(element.descriptor) ||
          _isDataDescriptor(other.descriptor)
        ) {
          if (_hasDecorators(element) || _hasDecorators(other)) {
            throw new ReferenceError(
              "Duplicated methods (" + element.key + ") can't be decorated.",
            );
          }
          other.descriptor = element.descriptor;
        } else {
          if (_hasDecorators(element)) {
            if (_hasDecorators(other)) {
              throw new ReferenceError(
                "Decorators can't be placed on different accessors with for " +
                  "the same property (" +
                  element.key +
                  ").",
              );
            }
            other.decorators = element.decorators;
          }
          _coalesceGetterSetter(element, other);
        }
      } else {
        newElements.push(element);
      }
    }

    return newElements;
  }

  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {
    return element.decorators && element.decorators.length;
  }

  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {
    return (
      desc !== undefined &&
      !(desc.value === undefined && desc.writable === undefined)
    );
  }

  function _optionalCallableProperty /*::<T>*/(
    obj /*: T */,
    name /*: $Keys<T> */,
  ) /*: ?Function */ {
    var value = obj[name];
    if (value !== undefined && typeof value !== "function") {
      throw new TypeError("Expected '" + name + "' to be a function");
    }
    return value;
  }

`, i.classPrivateMethodGet = a("7.1.6")`
  export default function _classPrivateMethodGet(receiver, privateSet, fn) {
    if (!privateSet.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return fn;
  }
`, i.classPrivateMethodSet = a("7.1.6")`
    export default function _classPrivateMethodSet() {
      throw new TypeError("attempted to reassign private method");
    }
  `;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.wrapRegExp = t2.typeof = t2.objectSpread2 = t2.jsx = void 0;
            var n = r2(21);
            const s2 = { minVersion: "7.0.0-beta.0", ast: () => n.default.program.ast('\nvar REACT_ELEMENT_TYPE;\nexport default function _createRawReactElement(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE =\n      (typeof Symbol === "function" &&\n        \n        Symbol["for"] &&\n        Symbol["for"]("react.element")) ||\n      0xeac7;\n  }\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n  if (!props && childrenLength !== 0) {\n    \n    \n    props = { children: void 0 };\n  }\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n    props.children = childArray;\n  }\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : "" + key,\n    ref: null,\n    props: props,\n    _owner: null,\n  };\n}\n') };
            t2.jsx = s2;
            const i = { minVersion: "7.5.0", ast: () => n.default.program.ast('\nimport defineProperty from "defineProperty";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(source, key)\n        );\n      });\n    }\n  }\n  return target;\n}\n') };
            t2.objectSpread2 = i;
            const o = { minVersion: "7.0.0-beta.0", ast: () => n.default.program.ast('\nexport default function _typeof(obj) {\n  "@babel/helpers - typeof";\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj &&\n        typeof Symbol === "function" &&\n        obj.constructor === Symbol &&\n        obj !== Symbol.prototype\n        ? "symbol"\n        : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n') };
            t2.typeof = o;
            const a = { minVersion: "7.2.6", ast: () => n.default.program.ast('\nimport setPrototypeOf from "setPrototypeOf";\nimport inherits from "inherits";\nexport default function _wrapRegExp() {\n  _wrapRegExp = function (re, groups) {\n    return new BabelRegExp(re, undefined, groups);\n  };\n  var _super = RegExp.prototype;\n  var _groups = new WeakMap();\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n    \n    _groups.set(_this, groups || _groups.get(re));\n    return setPrototypeOf(_this, BabelRegExp.prototype);\n  }\n  inherits(BabelRegExp, RegExp);\n  BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n    if (result) result.groups = buildGroups(result, this);\n    return result;\n  };\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (typeof substitution === "string") {\n      var groups = _groups.get(this);\n      return _super[Symbol.replace].call(\n        this,\n        str,\n        substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n          return "$" + groups[name];\n        })\n      );\n    } else if (typeof substitution === "function") {\n      var _this = this;\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = arguments;\n        \n        if (typeof args[args.length - 1] !== "object") {\n          args = [].slice.call(args);\n          args.push(buildGroups(args, _this));\n        }\n        return substitution.apply(this, args);\n      });\n    } else {\n      return _super[Symbol.replace].call(this, str, substitution);\n    }\n  };\n  function buildGroups(result, re) {\n    \n    \n    var g = _groups.get(re);\n    return Object.keys(g).reduce(function (groups, name) {\n      groups[name] = result[g[name]];\n      return groups;\n    }, Object.create(null));\n  }\n  return _wrapRegExp.apply(this, arguments);\n}\n') };
            t2.wrapRegExp = a;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(30), s2 = r2(0), i = r2(460), o = r2(257);
            t2.default = class {
              constructor(e3, t3, r3) {
                this._defaultOpts = { importedSource: null, importedType: "commonjs", importedInterop: "babel", importingInterop: "babel", ensureLiveReference: false, ensureNoContext: false, importPosition: "before" };
                const n2 = e3.find((e4) => e4.isProgram());
                this._programPath = n2, this._programScope = n2.scope, this._hub = n2.hub, this._defaultOpts = this._applyDefaults(t3, r3, true);
              }
              addDefault(e3, t3) {
                return this.addNamed("default", e3, t3);
              }
              addNamed(e3, t3, r3) {
                return n(typeof e3 == "string"), this._generateImport(this._applyDefaults(t3, r3), e3);
              }
              addNamespace(e3, t3) {
                return this._generateImport(this._applyDefaults(e3, t3), null);
              }
              addSideEffect(e3, t3) {
                return this._generateImport(this._applyDefaults(e3, t3), false);
              }
              _applyDefaults(e3, t3, r3 = false) {
                const s3 = [];
                typeof e3 == "string" ? (s3.push({ importedSource: e3 }), s3.push(t3)) : (n(!t3, "Unexpected secondary arguments."), s3.push(e3));
                const i2 = Object.assign({}, this._defaultOpts);
                for (const e4 of s3)
                  e4 && (Object.keys(i2).forEach((t4) => {
                    e4[t4] !== void 0 && (i2[t4] = e4[t4]);
                  }), r3 || (e4.nameHint !== void 0 && (i2.nameHint = e4.nameHint), e4.blockHoist !== void 0 && (i2.blockHoist = e4.blockHoist)));
                return i2;
              }
              _generateImport(e3, t3) {
                const r3 = t3 === "default", n2 = !!t3 && !r3, a = t3 === null, { importedSource: l, importedType: c, importedInterop: u, importingInterop: p2, ensureLiveReference: f, ensureNoContext: d, nameHint: h3, importPosition: m, blockHoist: y } = e3;
                let g = h3 || t3;
                const b = (0, o.default)(this._programPath), v = b && p2 === "node", E = b && p2 === "babel";
                if (m === "after" && !b)
                  throw new Error('"importPosition": "after" is only supported in modules');
                const x = new i.default(l, this._programScope, this._hub);
                if (c === "es6") {
                  if (!v && !E)
                    throw new Error("Cannot import an ES6 module from CommonJS");
                  x.import(), a ? x.namespace(h3 || l) : (r3 || n2) && x.named(g, t3);
                } else {
                  if (c !== "commonjs")
                    throw new Error(`Unexpected interopType "${c}"`);
                  if (u === "babel")
                    if (v) {
                      g = g !== "default" ? g : l;
                      const e4 = `${l}$es6Default`;
                      x.import(), a ? x.default(e4).var(g || l).wildcardInterop() : r3 ? f ? x.default(e4).var(g || l).defaultInterop().read("default") : x.default(e4).var(g).defaultInterop().prop(t3) : n2 && x.default(e4).read(t3);
                    } else
                      E ? (x.import(), a ? x.namespace(g || l) : (r3 || n2) && x.named(g, t3)) : (x.require(), a ? x.var(g || l).wildcardInterop() : (r3 || n2) && f ? r3 ? (g = g !== "default" ? g : l, x.var(g).read(t3), x.defaultInterop()) : x.var(l).read(t3) : r3 ? x.var(g).defaultInterop().prop(t3) : n2 && x.var(g).prop(t3));
                  else if (u === "compiled")
                    v ? (x.import(), a ? x.default(g || l) : (r3 || n2) && x.default(l).read(g)) : E ? (x.import(), a ? x.namespace(g || l) : (r3 || n2) && x.named(g, t3)) : (x.require(), a ? x.var(g || l) : (r3 || n2) && (f ? x.var(l).read(g) : x.prop(t3).var(g)));
                  else {
                    if (u !== "uncompiled")
                      throw new Error(`Unknown importedInterop "${u}".`);
                    if (r3 && f)
                      throw new Error("No live reference for commonjs default");
                    v ? (x.import(), a ? x.default(g || l) : r3 ? x.default(g) : n2 && x.default(l).read(g)) : E ? (x.import(), a ? x.default(g || l) : r3 ? x.default(g) : n2 && x.named(g, t3)) : (x.require(), a ? x.var(g || l) : r3 ? x.var(g) : n2 && (f ? x.var(l).read(g) : x.var(g).prop(t3)));
                  }
                }
                const { statements: S, resultName: T } = x.done();
                return this._insertStatements(S, m, y), (r3 || n2) && d && T.type !== "Identifier" ? s2.sequenceExpression([s2.numericLiteral(0), T]) : T;
              }
              _insertStatements(e3, t3 = "before", r3 = 3) {
                const n2 = this._programPath.get("body");
                if (t3 === "after") {
                  for (let t4 = n2.length - 1; t4 >= 0; t4--)
                    if (n2[t4].isImportDeclaration())
                      return void n2[t4].insertAfter(e3);
                } else {
                  e3.forEach((e4) => {
                    e4._blockHoist = r3;
                  });
                  const t4 = n2.find((e4) => {
                    const t5 = e4.node._blockHoist;
                    return Number.isFinite(t5) && t5 < 4;
                  });
                  if (t4)
                    return void t4.insertBefore(e3);
                }
                this._programPath.unshiftContainer("body", e3);
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = r2(30), s2 = r2(0);
            t2.default = class {
              constructor(e3, t3, r3) {
                this._statements = [], this._resultName = null, this._scope = null, this._hub = null, this._importedSource = void 0, this._scope = t3, this._hub = r3, this._importedSource = e3;
              }
              done() {
                return { statements: this._statements, resultName: this._resultName };
              }
              import() {
                return this._statements.push(s2.importDeclaration([], s2.stringLiteral(this._importedSource))), this;
              }
              require() {
                return this._statements.push(s2.expressionStatement(s2.callExpression(s2.identifier("require"), [s2.stringLiteral(this._importedSource)]))), this;
              }
              namespace(e3 = "namespace") {
                const t3 = this._scope.generateUidIdentifier(e3), r3 = this._statements[this._statements.length - 1];
                return n(r3.type === "ImportDeclaration"), n(r3.specifiers.length === 0), r3.specifiers = [s2.importNamespaceSpecifier(t3)], this._resultName = s2.cloneNode(t3), this;
              }
              default(e3) {
                e3 = this._scope.generateUidIdentifier(e3);
                const t3 = this._statements[this._statements.length - 1];
                return n(t3.type === "ImportDeclaration"), n(t3.specifiers.length === 0), t3.specifiers = [s2.importDefaultSpecifier(e3)], this._resultName = s2.cloneNode(e3), this;
              }
              named(e3, t3) {
                if (t3 === "default")
                  return this.default(e3);
                e3 = this._scope.generateUidIdentifier(e3);
                const r3 = this._statements[this._statements.length - 1];
                return n(r3.type === "ImportDeclaration"), n(r3.specifiers.length === 0), r3.specifiers = [s2.importSpecifier(e3, s2.identifier(t3))], this._resultName = s2.cloneNode(e3), this;
              }
              var(e3) {
                e3 = this._scope.generateUidIdentifier(e3);
                let t3 = this._statements[this._statements.length - 1];
                return t3.type !== "ExpressionStatement" && (n(this._resultName), t3 = s2.expressionStatement(this._resultName), this._statements.push(t3)), this._statements[this._statements.length - 1] = s2.variableDeclaration("var", [s2.variableDeclarator(e3, t3.expression)]), this._resultName = s2.cloneNode(e3), this;
              }
              defaultInterop() {
                return this._interop(this._hub.addHelper("interopRequireDefault"));
              }
              wildcardInterop() {
                return this._interop(this._hub.addHelper("interopRequireWildcard"));
              }
              _interop(e3) {
                const t3 = this._statements[this._statements.length - 1];
                return t3.type === "ExpressionStatement" ? t3.expression = s2.callExpression(e3, [t3.expression]) : t3.type === "VariableDeclaration" ? (n(t3.declarations.length === 1), t3.declarations[0].init = s2.callExpression(e3, [t3.declarations[0].init])) : n.fail("Unexpected type."), this;
              }
              prop(e3) {
                const t3 = this._statements[this._statements.length - 1];
                return t3.type === "ExpressionStatement" ? t3.expression = s2.memberExpression(t3.expression, s2.identifier(e3)) : t3.type === "VariableDeclaration" ? (n(t3.declarations.length === 1), t3.declarations[0].init = s2.memberExpression(t3.declarations[0].init, s2.identifier(e3))) : n.fail("Unexpected type:" + t3.type), this;
              }
              read(e3) {
                this._resultName = s2.memberExpression(this._resultName, s2.identifier(e3));
              }
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              (0, s2.default)(e3.node, Object.assign({}, o, { noScope: true }));
            };
            var n = r2(70), s2 = r2(10), i = r2(0);
            const o = s2.default.visitors.merge([n.environmentVisitor, { ThisExpression(e3) {
              e3.replaceWith(i.unaryExpression("void", i.numericLiteral(0), true));
            } }]);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = new Map(), n2 = new Map(), i2 = (t4) => {
                e3.requeue(t4);
              };
              for (const [e4, n3] of t3.source) {
                for (const [t4, s3] of n3.imports)
                  r3.set(t4, [e4, s3, null]);
                for (const t4 of n3.importsNamespace)
                  r3.set(t4, [e4, null, t4]);
              }
              for (const [e4, r4] of t3.local) {
                let t4 = n2.get(e4);
                t4 || (t4 = [], n2.set(e4, t4)), t4.push(...r4.names);
              }
              const l2 = { metadata: t3, requeueInParent: i2, scope: e3.scope, exported: n2 };
              e3.traverse(a, l2), (0, o.default)(e3, new Set([...Array.from(r3.keys()), ...Array.from(n2.keys())]));
              const c4 = { seen: new WeakSet(), metadata: t3, requeueInParent: i2, scope: e3.scope, imported: r3, exported: n2, buildImportReference: ([e4, r4, n3], i3) => {
                const o2 = t3.source.get(e4);
                if (n3)
                  return o2.lazy && (i3 = s2.callExpression(i3, [])), i3;
                let a2 = s2.identifier(o2.name);
                if (o2.lazy && (a2 = s2.callExpression(a2, [])), r4 === "default" && o2.interop === "node-default")
                  return a2;
                const l3 = t3.stringSpecifiers.has(r4);
                return s2.memberExpression(a2, l3 ? s2.stringLiteral(r4) : s2.identifier(r4), l3);
              } };
              e3.traverse(u, c4);
            };
            var n = r2(30), s2 = r2(0), i = r2(21), o = r2(260);
            const a = { Scope(e3) {
              e3.skip();
            }, ClassDeclaration(e3) {
              const { requeueInParent: t3, exported: r3, metadata: n2 } = this, { id: i2 } = e3.node;
              if (!i2)
                throw new Error("Expected class to have a name");
              const o2 = i2.name, a2 = r3.get(o2) || [];
              if (a2.length > 0) {
                const r4 = s2.expressionStatement(l(n2, a2, s2.identifier(o2)));
                r4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(r4)[0]);
              }
            }, VariableDeclaration(e3) {
              const { requeueInParent: t3, exported: r3, metadata: n2 } = this;
              Object.keys(e3.getOuterBindingIdentifiers()).forEach((i2) => {
                const o2 = r3.get(i2) || [];
                if (o2.length > 0) {
                  const r4 = s2.expressionStatement(l(n2, o2, s2.identifier(i2)));
                  r4._blockHoist = e3.node._blockHoist, t3(e3.insertAfter(r4)[0]);
                }
              });
            } }, l = (e3, t3, r3) => (t3 || []).reduce((t4, r4) => {
              const { stringSpecifiers: n2 } = e3, i2 = n2.has(r4);
              return s2.assignmentExpression("=", s2.memberExpression(s2.identifier(e3.exportName), i2 ? s2.stringLiteral(r4) : s2.identifier(r4), i2), t4);
            }, r3), c = (e3) => i.default.expression.ast`
    (function() {
      throw new Error('"' + '${e3}' + '" is read-only.');
    })()
  `, u = { ReferencedIdentifier(e3) {
              const { seen: t3, buildImportReference: r3, scope: n2, imported: i2, requeueInParent: o2 } = this;
              if (t3.has(e3.node))
                return;
              t3.add(e3.node);
              const a2 = e3.node.name, l2 = i2.get(a2);
              if (l2) {
                const t4 = e3.scope.getBinding(a2);
                if (n2.getBinding(a2) !== t4)
                  return;
                const i3 = r3(l2, e3.node);
                if (i3.loc = e3.node.loc, (e3.parentPath.isCallExpression({ callee: e3.node }) || e3.parentPath.isOptionalCallExpression({ callee: e3.node }) || e3.parentPath.isTaggedTemplateExpression({ tag: e3.node })) && s2.isMemberExpression(i3))
                  e3.replaceWith(s2.sequenceExpression([s2.numericLiteral(0), i3]));
                else if (e3.isJSXIdentifier() && s2.isMemberExpression(i3)) {
                  const { object: t5, property: r4 } = i3;
                  e3.replaceWith(s2.jsxMemberExpression(s2.jsxIdentifier(t5.name), s2.jsxIdentifier(r4.name)));
                } else
                  e3.replaceWith(i3);
                o2(e3), e3.skip();
              }
            }, AssignmentExpression: { exit(e3) {
              const { scope: t3, seen: r3, imported: i2, exported: o2, requeueInParent: a2, buildImportReference: u2 } = this;
              if (r3.has(e3.node))
                return;
              r3.add(e3.node);
              const p2 = e3.get("left");
              if (!p2.isMemberExpression())
                if (p2.isIdentifier()) {
                  const r4 = p2.node.name;
                  if (t3.getBinding(r4) !== e3.scope.getBinding(r4))
                    return;
                  const f = o2.get(r4), d = i2.get(r4);
                  if ((f == null ? void 0 : f.length) > 0 || d) {
                    n(e3.node.operator === "=", "Path was not simplified");
                    const t4 = e3.node;
                    d && (t4.left = u2(d, t4.left), t4.right = s2.sequenceExpression([t4.right, c(r4)])), e3.replaceWith(l(this.metadata, f, t4)), a2(e3);
                  }
                } else {
                  const r4 = p2.getOuterBindingIdentifiers(), n2 = Object.keys(r4).filter((r5) => t3.getBinding(r5) === e3.scope.getBinding(r5)), u3 = n2.find((e4) => i2.has(e4));
                  u3 && (e3.node.right = s2.sequenceExpression([e3.node.right, c(u3)]));
                  const f = [];
                  if (n2.forEach((e4) => {
                    const t4 = o2.get(e4) || [];
                    t4.length > 0 && f.push(l(this.metadata, t4, s2.identifier(e4)));
                  }), f.length > 0) {
                    let t4 = s2.sequenceExpression(f);
                    e3.parentPath.isExpressionStatement() && (t4 = s2.expressionStatement(t4), t4._blockHoist = e3.parentPath.node._blockHoist), a2(e3.insertAfter(t4)[0]);
                  }
                }
            } }, "ForOfStatement|ForInStatement"(e3) {
              const { scope: t3, node: r3 } = e3, { left: n2 } = r3, { exported: i2, scope: o2 } = this;
              if (!s2.isVariableDeclaration(n2)) {
                let r4 = false;
                const a2 = e3.get("body"), l2 = a2.scope;
                for (const e4 of Object.keys(s2.getOuterBindingIdentifiers(n2)))
                  i2.get(e4) && o2.getBinding(e4) === t3.getBinding(e4) && (r4 = true, l2.hasOwnBinding(e4) && l2.rename(e4));
                if (!r4)
                  return;
                const c4 = t3.generateUidIdentifierBasedOnNode(n2);
                a2.unshiftContainer("body", s2.expressionStatement(s2.assignmentExpression("=", n2, c4))), e3.get("left").replaceWith(s2.variableDeclaration("let", [s2.variableDeclarator(s2.cloneNode(c4))])), t3.registerDeclaration(e3.get("left"));
              }
            } };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.hasExports = function(e3) {
              return e3.hasExports;
            }, t2.isSideEffectImport = o, t2.validateImportInteropOption = a, t2.default = function(e3, t3, { importInterop: r3, initializeReexports: s3 = false, lazy: a2 = false, esNamespaceOnly: p2 = false }) {
              t3 || (t3 = e3.scope.generateUidIdentifier("exports").name);
              const f = new Set();
              !function(e4) {
                e4.get("body").forEach((e5) => {
                  e5.isExportDefaultDeclaration() && (0, i.default)(e5);
                });
              }(e3);
              const { local: d, source: h3, hasExports: m } = function(e4, { lazy: t4, initializeReexports: r4 }, s4) {
                const i2 = function(e5, t5, r5) {
                  const n2 = new Map();
                  e5.get("body").forEach((e6) => {
                    let r6;
                    if (e6.isImportDeclaration())
                      r6 = "import";
                    else {
                      if (e6.isExportDefaultDeclaration() && (e6 = e6.get("declaration")), e6.isExportNamedDeclaration()) {
                        if (e6.node.declaration)
                          e6 = e6.get("declaration");
                        else if (t5 && e6.node.source && e6.get("source").isStringLiteral())
                          return void e6.get("specifiers").forEach((e7) => {
                            u(e7), n2.set(e7.get("local").node.name, "block");
                          });
                      }
                      if (e6.isFunctionDeclaration())
                        r6 = "hoisted";
                      else if (e6.isClassDeclaration())
                        r6 = "block";
                      else if (e6.isVariableDeclaration({ kind: "var" }))
                        r6 = "var";
                      else {
                        if (!e6.isVariableDeclaration())
                          return;
                        r6 = "block";
                      }
                    }
                    Object.keys(e6.getOuterBindingIdentifiers()).forEach((e7) => {
                      n2.set(e7, r6);
                    });
                  });
                  const s5 = new Map(), i3 = (e6) => {
                    const t6 = e6.node.name;
                    let r6 = s5.get(t6);
                    if (!r6) {
                      const i4 = n2.get(t6);
                      if (i4 === void 0)
                        throw e6.buildCodeFrameError(`Exporting local "${t6}", which is not declared.`);
                      r6 = { names: [], kind: i4 }, s5.set(t6, r6);
                    }
                    return r6;
                  };
                  return e5.get("body").forEach((e6) => {
                    if (!e6.isExportNamedDeclaration() || !t5 && e6.node.source) {
                      if (e6.isExportDefaultDeclaration()) {
                        const t6 = e6.get("declaration");
                        if (!t6.isFunctionDeclaration() && !t6.isClassDeclaration())
                          throw t6.buildCodeFrameError("Unexpected default expression export.");
                        i3(t6.get("id")).names.push("default");
                      }
                    } else if (e6.node.declaration) {
                      const t6 = e6.get("declaration"), r6 = t6.getOuterBindingIdentifierPaths();
                      Object.keys(r6).forEach((e7) => {
                        if (e7 === "__esModule")
                          throw t6.buildCodeFrameError('Illegal export "__esModule".');
                        i3(r6[e7]).names.push(e7);
                      });
                    } else
                      e6.get("specifiers").forEach((e7) => {
                        const t6 = e7.get("local"), n3 = e7.get("exported"), s6 = i3(t6), o2 = c(n3, r5);
                        if (o2 === "__esModule")
                          throw n3.buildCodeFrameError('Illegal export "__esModule".');
                        s6.names.push(o2);
                      });
                  }), s5;
                }(e4, r4, s4), a3 = new Map(), l2 = (t5) => {
                  const r5 = t5.value;
                  let s5 = a3.get(r5);
                  return s5 || (s5 = { name: e4.scope.generateUidIdentifier((0, n.basename)(r5, (0, n.extname)(r5))).name, interop: "none", loc: null, imports: new Map(), importsNamespace: new Set(), reexports: new Map(), reexportNamespace: new Set(), reexportAll: null, lazy: false, source: r5 }, a3.set(r5, s5)), s5;
                };
                let p3 = false;
                e4.get("body").forEach((e5) => {
                  if (e5.isImportDeclaration()) {
                    const t5 = l2(e5.node.source);
                    t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
                      if (e6.isImportDefaultSpecifier()) {
                        const r5 = e6.get("local").node.name;
                        t5.imports.set(r5, "default");
                        const n2 = i2.get(r5);
                        n2 && (i2.delete(r5), n2.names.forEach((e7) => {
                          t5.reexports.set(e7, "default");
                        }));
                      } else if (e6.isImportNamespaceSpecifier()) {
                        const r5 = e6.get("local").node.name;
                        t5.importsNamespace.add(r5);
                        const n2 = i2.get(r5);
                        n2 && (i2.delete(r5), n2.names.forEach((e7) => {
                          t5.reexportNamespace.add(e7);
                        }));
                      } else if (e6.isImportSpecifier()) {
                        const r5 = c(e6.get("imported"), s4), n2 = e6.get("local").node.name;
                        t5.imports.set(n2, r5);
                        const o2 = i2.get(n2);
                        o2 && (i2.delete(n2), o2.names.forEach((e7) => {
                          t5.reexports.set(e7, r5);
                        }));
                      }
                    });
                  } else if (e5.isExportAllDeclaration()) {
                    p3 = true;
                    const t5 = l2(e5.node.source);
                    t5.loc || (t5.loc = e5.node.loc), t5.reexportAll = { loc: e5.node.loc };
                  } else if (e5.isExportNamedDeclaration() && e5.node.source) {
                    p3 = true;
                    const t5 = l2(e5.node.source);
                    t5.loc || (t5.loc = e5.node.loc), e5.get("specifiers").forEach((e6) => {
                      u(e6);
                      const r5 = c(e6.get("local"), s4), n2 = c(e6.get("exported"), s4);
                      if (t5.reexports.set(n2, r5), n2 === "__esModule")
                        throw e6.get("exported").buildCodeFrameError('Illegal export "__esModule".');
                    });
                  } else
                    (e5.isExportNamedDeclaration() || e5.isExportDefaultDeclaration()) && (p3 = true);
                });
                for (const e5 of a3.values()) {
                  let t5 = false, r5 = false;
                  e5.importsNamespace.size > 0 && (t5 = true, r5 = true), e5.reexportAll && (r5 = true);
                  for (const n2 of e5.imports.values())
                    n2 === "default" ? t5 = true : r5 = true;
                  for (const n2 of e5.reexports.values())
                    n2 === "default" ? t5 = true : r5 = true;
                  t5 && r5 ? e5.interop = "namespace" : t5 && (e5.interop = "default");
                }
                for (const [e5, r5] of a3)
                  if (t4 !== false && !o(r5) && !r5.reexportAll)
                    if (t4 === true)
                      r5.lazy = !/\./.test(e5);
                    else if (Array.isArray(t4))
                      r5.lazy = t4.indexOf(e5) !== -1;
                    else {
                      if (typeof t4 != "function")
                        throw new Error(".lazy must be a boolean, string array, or function");
                      r5.lazy = t4(e5);
                    }
                return { hasExports: p3, local: i2, source: a3 };
              }(e3, { initializeReexports: s3, lazy: a2 }, f);
              !function(e4) {
                e4.get("body").forEach((e5) => {
                  if (e5.isImportDeclaration())
                    e5.remove();
                  else if (e5.isExportNamedDeclaration())
                    e5.node.declaration ? (e5.node.declaration._blockHoist = e5.node._blockHoist, e5.replaceWith(e5.node.declaration)) : e5.remove();
                  else if (e5.isExportDefaultDeclaration()) {
                    const t4 = e5.get("declaration");
                    if (!t4.isFunctionDeclaration() && !t4.isClassDeclaration())
                      throw t4.buildCodeFrameError("Unexpected default expression export.");
                    t4._blockHoist = e5.node._blockHoist, e5.replaceWith(t4);
                  } else
                    e5.isExportAllDeclaration() && e5.remove();
                });
              }(e3);
              for (const [, e4] of h3) {
                e4.importsNamespace.size > 0 && (e4.name = e4.importsNamespace.values().next().value);
                const t4 = l(r3, e4.source);
                t4 === "none" ? e4.interop = "none" : t4 === "node" && e4.interop === "namespace" ? e4.interop = "node-namespace" : t4 === "node" && e4.interop === "default" ? e4.interop = "node-default" : p2 && e4.interop === "namespace" && (e4.interop = "default");
              }
              return { exportName: t3, exportNameListName: null, hasExports: m, local: d, source: h3, stringSpecifiers: f };
            };
            var n = r2(8), s2 = r2(63), i = r2(132);
            function o(e3) {
              return e3.imports.size === 0 && e3.importsNamespace.size === 0 && e3.reexports.size === 0 && e3.reexportNamespace.size === 0 && !e3.reexportAll;
            }
            function a(e3) {
              if (typeof e3 != "function" && e3 !== "none" && e3 !== "babel" && e3 !== "node")
                throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${e3}).`);
              return e3;
            }
            function l(e3, t3) {
              return typeof e3 == "function" ? a(e3(t3)) : e3;
            }
            function c(e3, t3) {
              if (e3.isIdentifier())
                return e3.node.name;
              if (e3.isStringLiteral()) {
                const r3 = e3.node.value;
                return (0, s2.isIdentifierName)(r3) || t3.add(r3), r3;
              }
              throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${e3.node.type}`);
            }
            function u(e3) {
              if (!e3.isExportSpecifier())
                throw e3.isExportNamespaceSpecifier() ? e3.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.") : e3.buildCodeFrameError("Unexpected export specifier type");
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = r2;
            {
              const e3 = r2;
              t2.default = r2 = function(t3, r3) {
                var n, s2, i, o;
                return e3(t3, { moduleId: (n = r3.moduleId) != null ? n : t3.moduleId, moduleIds: (s2 = r3.moduleIds) != null ? s2 : t3.moduleIds, getModuleId: (i = r3.getModuleId) != null ? i : t3.getModuleId, moduleRoot: (o = r3.moduleRoot) != null ? o : t3.moduleRoot });
              };
            }
            function r2(e3, t3) {
              const { filename: r3, filenameRelative: n = r3, sourceRoot: s2 = t3.moduleRoot } = e3, { moduleId: i, moduleIds: o = !!i, getModuleId: a, moduleRoot: l = s2 } = t3;
              if (!o)
                return null;
              if (i != null && !a)
                return i;
              let c = l != null ? l + "/" : "";
              if (n) {
                const e4 = s2 != null ? new RegExp("^" + s2 + "/?") : "";
                c += n.replace(e4, "").replace(/\.(\w*?)$/, "");
              }
              return c = c.replace(/\\/g, "/"), a && a(c) || c;
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(211);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(133);
              return s2 = function() {
                return e3;
              }, e3;
            }
            function i() {
              const e3 = r2(21);
              return i = function() {
                return e3;
              }, e3;
            }
            function o() {
              const e3 = r2(0);
              return o = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3 = "global") {
              let r3;
              const n2 = { global: l, module: c, umd: u, var: p2 }[t3];
              if (!n2)
                throw new Error(`Unsupported output type ${t3}`);
              return r3 = n2(e3), (0, s2().default)(r3).code;
            };
            var a = r2(126);
            function l(e3) {
              const t3 = o().identifier("babelHelpers"), r3 = [], n2 = o().functionExpression(null, [o().identifier("global")], o().blockStatement(r3)), s3 = o().program([o().expressionStatement(o().callExpression(n2, [o().conditionalExpression(o().binaryExpression("===", o().unaryExpression("typeof", o().identifier("global")), o().stringLiteral("undefined")), o().identifier("self"), o().identifier("global"))]))]);
              return r3.push(o().variableDeclaration("var", [o().variableDeclarator(t3, o().assignmentExpression("=", o().memberExpression(o().identifier("global"), t3), o().objectExpression([])))])), f(r3, t3, e3), s3;
            }
            function c(e3) {
              const t3 = [], r3 = f(t3, null, e3);
              return t3.unshift(o().exportNamedDeclaration(null, Object.keys(r3).map((e4) => o().exportSpecifier(o().cloneNode(r3[e4]), o().identifier(e4))))), o().program(t3, [], "module");
            }
            function u(e3) {
              const t3 = o().identifier("babelHelpers"), r3 = [];
              return r3.push(o().variableDeclaration("var", [o().variableDeclarator(t3, o().identifier("global"))])), f(r3, t3, e3), o().program([(n2 = { FACTORY_PARAMETERS: o().identifier("global"), BROWSER_ARGUMENTS: o().assignmentExpression("=", o().memberExpression(o().identifier("root"), t3), o().objectExpression([])), COMMON_ARGUMENTS: o().identifier("exports"), AMD_ARGUMENTS: o().arrayExpression([o().stringLiteral("exports")]), FACTORY_BODY: r3, UMD_ROOT: o().identifier("this") }, i().default`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(n2))]);
              var n2;
            }
            function p2(e3) {
              const t3 = o().identifier("babelHelpers"), r3 = [];
              r3.push(o().variableDeclaration("var", [o().variableDeclarator(t3, o().objectExpression([]))]));
              const n2 = o().program(r3);
              return f(r3, t3, e3), r3.push(o().expressionStatement(t3)), n2;
            }
            function f(e3, t3, r3) {
              const s3 = (e4) => t3 ? o().memberExpression(t3, o().identifier(e4)) : o().identifier(`_${e4}`), i2 = {};
              return n().list.forEach(function(t4) {
                if (r3 && r3.indexOf(t4) < 0)
                  return;
                const o2 = i2[t4] = s3(t4);
                n().ensure(t4, a.default);
                const { nodes: l2 } = n().get(t4, s3, o2);
                e3.push(...l2);
              }), i2;
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var s2 = r2(287), i = r2(150), o = r2(9), a = r2(79), l = r2(80), c = r2(300);
            function u() {
              const e3 = r2(10);
              return u = function() {
                return e3;
              }, e3;
            }
            var p2 = r2(81), f = r2(82), d = r2(484), h3 = r2(485), m = r2(303), y = (r2(302), n()(function* (e3) {
              var t3;
              const r3 = yield* (0, m.default)(e3);
              if (!r3)
                return null;
              const { options: n2, context: s3, fileHandling: o2 } = r3;
              if (o2 === "ignored")
                return null;
              const a2 = {}, { plugins: c4, presets: u2 } = n2;
              if (!c4 || !u2)
                throw new Error("Assertion failure - plugins and presets exist");
              const p3 = Object.assign({}, s3, { targets: n2.targets }), d2 = (e4) => {
                const t4 = (0, l.getItemDescriptor)(e4);
                if (!t4)
                  throw new Error("Assertion failure - must be config item");
                return t4;
              }, h4 = u2.map(d2), y2 = c4.map(d2), b2 = [[]], v2 = [];
              if (yield* g(s3, function* e4(t4, r4) {
                const n3 = [];
                for (let e5 = 0; e5 < t4.length; e5++) {
                  const s4 = t4[e5];
                  if (s4.options !== false)
                    try {
                      s4.ownPass ? n3.push({ preset: yield* w(s4, p3), pass: [] }) : n3.unshift({ preset: yield* w(s4, p3), pass: r4 });
                    } catch (r5) {
                      throw r5.code === "BABEL_UNKNOWN_OPTION" && (0, f.checkNoUnwrappedItemOptionPairs)(t4, e5, "preset", r5), r5;
                    }
                }
                if (n3.length > 0) {
                  b2.splice(1, 0, ...n3.map((e5) => e5.pass).filter((e5) => e5 !== r4));
                  for (const { preset: t5, pass: r5 } of n3) {
                    if (!t5)
                      return true;
                    if (r5.push(...t5.plugins), yield* e4(t5.presets, r5))
                      return true;
                    t5.options.forEach((e5) => {
                      (0, i.mergeOptions)(a2, e5);
                    });
                  }
                }
              })(h4, b2[0]))
                return null;
              const E2 = a2;
              (0, i.mergeOptions)(E2, n2);
              const S2 = Object.assign({}, p3, { assumptions: (t3 = E2.assumptions) != null ? t3 : {} });
              return yield* g(s3, function* () {
                b2[0].unshift(...y2);
                for (const e4 of b2) {
                  const t4 = [];
                  v2.push(t4);
                  for (let r4 = 0; r4 < e4.length; r4++) {
                    const n3 = e4[r4];
                    if (n3.options !== false)
                      try {
                        t4.push(yield* x(n3, S2));
                      } catch (t5) {
                        throw t5.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY" && (0, f.checkNoUnwrappedItemOptionPairs)(e4, r4, "plugin", t5), t5;
                      }
                  }
                }
              })(), E2.plugins = v2[0], E2.presets = v2.slice(1).filter((e4) => e4.length > 0).map((e4) => ({ plugins: e4 })), E2.passPerPreset = E2.presets.length > 0, { options: E2, passes: v2 };
            }));
            function g(e3, t3) {
              return function* (r3, n2) {
                try {
                  return yield* t3(r3, n2);
                } catch (t4) {
                  throw /^\[BABEL\]/.test(t4.message) || (t4.message = `[BABEL] ${e3.filename || "unknown"}: ${t4.message}`), t4;
                }
              };
            }
            t2.default = y;
            const b = (e3) => (0, p2.makeWeakCache)(function* ({ value: t3, options: r3, dirname: n2, alias: i2 }, a2) {
              if (r3 === false)
                throw new Error("Assertion failure");
              r3 = r3 || {};
              let l2 = t3;
              if (typeof t3 == "function") {
                const c4 = (0, s2.maybeAsync)(t3, "You appear to be using an async plugin/preset, but Babel has been called synchronously"), u2 = Object.assign({}, o, e3(a2));
                try {
                  l2 = yield* c4(u2, r3, n2);
                } catch (e4) {
                  throw i2 && (e4.message += ` (While processing: ${JSON.stringify(i2)})`), e4;
                }
              }
              if (!l2 || typeof l2 != "object")
                throw new Error("Plugin/Preset did not return an object.");
              if ((0, s2.isThenable)(l2))
                throw yield* [], new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(i2)})`);
              return { value: l2, options: r3, dirname: n2, alias: i2 };
            }), v = b(h3.makePluginAPI), E = b(h3.makePresetAPI);
            function* x(e3, t3) {
              if (e3.value instanceof a.default) {
                if (e3.options)
                  throw new Error("Passed options to an existing Plugin instance will not work.");
                return e3.value;
              }
              return yield* S(yield* v(e3, t3), t3);
            }
            const S = (0, p2.makeWeakCache)(function* ({ value: e3, options: t3, dirname: r3, alias: n2 }, i2) {
              const o2 = (0, d.validatePluginObject)(e3), l2 = Object.assign({}, o2);
              if (l2.visitor && (l2.visitor = u().default.explode(Object.assign({}, l2.visitor))), l2.inherits) {
                const e4 = { name: void 0, alias: `${n2}$inherits`, value: l2.inherits, options: t3, dirname: r3 }, o3 = yield* (0, s2.forwardAsync)(x, (t4) => i2.invalidate((r4) => t4(e4, r4)));
                l2.pre = A(o3.pre, l2.pre), l2.post = A(o3.post, l2.post), l2.manipulateOptions = A(o3.manipulateOptions, l2.manipulateOptions), l2.visitor = u().default.visitors.merge([o3.visitor || {}, l2.visitor || {}]);
              }
              return new a.default(l2, t3, n2);
            }), T = (e3, t3) => {
              if (e3.test || e3.include || e3.exclude) {
                const e4 = t3.name ? `"${t3.name}"` : "/* your preset */";
                throw new Error([`Preset ${e4} requires a filename to be set when babel is called directly,`, "```", `babel.transform(code, { filename: 'file.ts', presets: [${e4}] });`, "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
              }
            };
            function* w(e3, t3) {
              const r3 = P(yield* E(e3, t3));
              return ((e4, t4, r4) => {
                if (!t4.filename) {
                  const { options: t5 } = e4;
                  T(t5, r4), t5.overrides && t5.overrides.forEach((e5) => T(e5, r4));
                }
              })(r3, t3, e3), yield* (0, c.buildPresetChain)(r3, t3);
            }
            const P = (0, p2.makeWeakCacheSync)(({ value: e3, dirname: t3, alias: r3 }) => ({ options: (0, f.validate)("preset", e3), alias: r3, dirname: t3 }));
            function A(e3, t3) {
              const r3 = [e3, t3].filter(Boolean);
              return r3.length <= 1 ? r3[0] : function(...e4) {
                for (const t4 of r3)
                  t4.apply(this, e4);
              };
            }
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('[{"name":"nodejs","version":"0.2.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.3.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.4.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.5.0","date":"2011-08-26","lts":false,"security":false},{"name":"nodejs","version":"0.6.0","date":"2011-11-04","lts":false,"security":false},{"name":"nodejs","version":"0.7.0","date":"2012-01-17","lts":false,"security":false},{"name":"nodejs","version":"0.8.0","date":"2012-06-22","lts":false,"security":false},{"name":"nodejs","version":"0.9.0","date":"2012-07-20","lts":false,"security":false},{"name":"nodejs","version":"0.10.0","date":"2013-03-11","lts":false,"security":false},{"name":"nodejs","version":"0.11.0","date":"2013-03-28","lts":false,"security":false},{"name":"nodejs","version":"0.12.0","date":"2015-02-06","lts":false,"security":false},{"name":"iojs","version":"1.0.0","date":"2015-01-14"},{"name":"iojs","version":"1.1.0","date":"2015-02-03"},{"name":"iojs","version":"1.2.0","date":"2015-02-11"},{"name":"iojs","version":"1.3.0","date":"2015-02-20"},{"name":"iojs","version":"1.5.0","date":"2015-03-06"},{"name":"iojs","version":"1.6.0","date":"2015-03-20"},{"name":"iojs","version":"2.0.0","date":"2015-05-04"},{"name":"iojs","version":"2.1.0","date":"2015-05-24"},{"name":"iojs","version":"2.2.0","date":"2015-06-01"},{"name":"iojs","version":"2.3.0","date":"2015-06-13"},{"name":"iojs","version":"2.4.0","date":"2015-07-17"},{"name":"iojs","version":"2.5.0","date":"2015-07-28"},{"name":"iojs","version":"3.0.0","date":"2015-08-04"},{"name":"iojs","version":"3.1.0","date":"2015-08-19"},{"name":"iojs","version":"3.2.0","date":"2015-08-25"},{"name":"iojs","version":"3.3.0","date":"2015-09-02"},{"name":"nodejs","version":"4.0.0","date":"2015-09-08","lts":false,"security":false},{"name":"nodejs","version":"4.1.0","date":"2015-09-17","lts":false,"security":false},{"name":"nodejs","version":"4.2.0","date":"2015-10-12","lts":"Argon","security":false},{"name":"nodejs","version":"4.3.0","date":"2016-02-09","lts":"Argon","security":false},{"name":"nodejs","version":"4.4.0","date":"2016-03-08","lts":"Argon","security":false},{"name":"nodejs","version":"4.5.0","date":"2016-08-16","lts":"Argon","security":false},{"name":"nodejs","version":"4.6.0","date":"2016-09-27","lts":"Argon","security":true},{"name":"nodejs","version":"4.7.0","date":"2016-12-06","lts":"Argon","security":false},{"name":"nodejs","version":"4.8.0","date":"2017-02-21","lts":"Argon","security":false},{"name":"nodejs","version":"4.9.0","date":"2018-03-28","lts":"Argon","security":true},{"name":"nodejs","version":"5.0.0","date":"2015-10-29","lts":false,"security":false},{"name":"nodejs","version":"5.1.0","date":"2015-11-17","lts":false,"security":false},{"name":"nodejs","version":"5.2.0","date":"2015-12-09","lts":false,"security":false},{"name":"nodejs","version":"5.3.0","date":"2015-12-15","lts":false,"security":false},{"name":"nodejs","version":"5.4.0","date":"2016-01-06","lts":false,"security":false},{"name":"nodejs","version":"5.5.0","date":"2016-01-21","lts":false,"security":false},{"name":"nodejs","version":"5.6.0","date":"2016-02-09","lts":false,"security":false},{"name":"nodejs","version":"5.7.0","date":"2016-02-23","lts":false,"security":false},{"name":"nodejs","version":"5.8.0","date":"2016-03-09","lts":false,"security":false},{"name":"nodejs","version":"5.9.0","date":"2016-03-16","lts":false,"security":false},{"name":"nodejs","version":"5.10.0","date":"2016-04-01","lts":false,"security":false},{"name":"nodejs","version":"5.11.0","date":"2016-04-21","lts":false,"security":false},{"name":"nodejs","version":"5.12.0","date":"2016-06-23","lts":false,"security":false},{"name":"nodejs","version":"6.0.0","date":"2016-04-26","lts":false,"security":false},{"name":"nodejs","version":"6.1.0","date":"2016-05-05","lts":false,"security":false},{"name":"nodejs","version":"6.2.0","date":"2016-05-17","lts":false,"security":false},{"name":"nodejs","version":"6.3.0","date":"2016-07-06","lts":false,"security":false},{"name":"nodejs","version":"6.4.0","date":"2016-08-12","lts":false,"security":false},{"name":"nodejs","version":"6.5.0","date":"2016-08-26","lts":false,"security":false},{"name":"nodejs","version":"6.6.0","date":"2016-09-14","lts":false,"security":false},{"name":"nodejs","version":"6.7.0","date":"2016-09-27","lts":false,"security":true},{"name":"nodejs","version":"6.8.0","date":"2016-10-12","lts":false,"security":false},{"name":"nodejs","version":"6.9.0","date":"2016-10-18","lts":"Boron","security":false},{"name":"nodejs","version":"6.10.0","date":"2017-02-21","lts":"Boron","security":false},{"name":"nodejs","version":"6.11.0","date":"2017-06-06","lts":"Boron","security":false},{"name":"nodejs","version":"6.12.0","date":"2017-11-06","lts":"Boron","security":false},{"name":"nodejs","version":"6.13.0","date":"2018-02-10","lts":"Boron","security":false},{"name":"nodejs","version":"6.14.0","date":"2018-03-28","lts":"Boron","security":true},{"name":"nodejs","version":"6.15.0","date":"2018-11-27","lts":"Boron","security":true},{"name":"nodejs","version":"6.16.0","date":"2018-12-26","lts":"Boron","security":false},{"name":"nodejs","version":"6.17.0","date":"2019-02-28","lts":"Boron","security":true},{"name":"nodejs","version":"7.0.0","date":"2016-10-25","lts":false,"security":false},{"name":"nodejs","version":"7.1.0","date":"2016-11-08","lts":false,"security":false},{"name":"nodejs","version":"7.2.0","date":"2016-11-22","lts":false,"security":false},{"name":"nodejs","version":"7.3.0","date":"2016-12-20","lts":false,"security":false},{"name":"nodejs","version":"7.4.0","date":"2017-01-04","lts":false,"security":false},{"name":"nodejs","version":"7.5.0","date":"2017-01-31","lts":false,"security":false},{"name":"nodejs","version":"7.6.0","date":"2017-02-21","lts":false,"security":false},{"name":"nodejs","version":"7.7.0","date":"2017-02-28","lts":false,"security":false},{"name":"nodejs","version":"7.8.0","date":"2017-03-29","lts":false,"security":false},{"name":"nodejs","version":"7.9.0","date":"2017-04-11","lts":false,"security":false},{"name":"nodejs","version":"7.10.0","date":"2017-05-02","lts":false,"security":false},{"name":"nodejs","version":"8.0.0","date":"2017-05-30","lts":false,"security":false},{"name":"nodejs","version":"8.1.0","date":"2017-06-08","lts":false,"security":false},{"name":"nodejs","version":"8.2.0","date":"2017-07-19","lts":false,"security":false},{"name":"nodejs","version":"8.3.0","date":"2017-08-08","lts":false,"security":false},{"name":"nodejs","version":"8.4.0","date":"2017-08-15","lts":false,"security":false},{"name":"nodejs","version":"8.5.0","date":"2017-09-12","lts":false,"security":false},{"name":"nodejs","version":"8.6.0","date":"2017-09-26","lts":false,"security":false},{"name":"nodejs","version":"8.7.0","date":"2017-10-11","lts":false,"security":false},{"name":"nodejs","version":"8.8.0","date":"2017-10-24","lts":false,"security":false},{"name":"nodejs","version":"8.9.0","date":"2017-10-31","lts":"Carbon","security":false},{"name":"nodejs","version":"8.10.0","date":"2018-03-06","lts":"Carbon","security":false},{"name":"nodejs","version":"8.11.0","date":"2018-03-28","lts":"Carbon","security":true},{"name":"nodejs","version":"8.12.0","date":"2018-09-10","lts":"Carbon","security":false},{"name":"nodejs","version":"8.13.0","date":"2018-11-20","lts":"Carbon","security":false},{"name":"nodejs","version":"8.14.0","date":"2018-11-27","lts":"Carbon","security":true},{"name":"nodejs","version":"8.15.0","date":"2018-12-26","lts":"Carbon","security":false},{"name":"nodejs","version":"8.16.0","date":"2019-04-16","lts":"Carbon","security":false},{"name":"nodejs","version":"8.17.0","date":"2019-12-17","lts":"Carbon","security":true},{"name":"nodejs","version":"9.0.0","date":"2017-10-31","lts":false,"security":false},{"name":"nodejs","version":"9.1.0","date":"2017-11-07","lts":false,"security":false},{"name":"nodejs","version":"9.2.0","date":"2017-11-14","lts":false,"security":false},{"name":"nodejs","version":"9.3.0","date":"2017-12-12","lts":false,"security":false},{"name":"nodejs","version":"9.4.0","date":"2018-01-10","lts":false,"security":false},{"name":"nodejs","version":"9.5.0","date":"2018-01-31","lts":false,"security":false},{"name":"nodejs","version":"9.6.0","date":"2018-02-21","lts":false,"security":false},{"name":"nodejs","version":"9.7.0","date":"2018-03-01","lts":false,"security":false},{"name":"nodejs","version":"9.8.0","date":"2018-03-07","lts":false,"security":false},{"name":"nodejs","version":"9.9.0","date":"2018-03-21","lts":false,"security":false},{"name":"nodejs","version":"9.10.0","date":"2018-03-28","lts":false,"security":true},{"name":"nodejs","version":"9.11.0","date":"2018-04-04","lts":false,"security":false},{"name":"nodejs","version":"10.0.0","date":"2018-04-24","lts":false,"security":false},{"name":"nodejs","version":"10.1.0","date":"2018-05-08","lts":false,"security":false},{"name":"nodejs","version":"10.2.0","date":"2018-05-23","lts":false,"security":false},{"name":"nodejs","version":"10.3.0","date":"2018-05-29","lts":false,"security":false},{"name":"nodejs","version":"10.4.0","date":"2018-06-06","lts":false,"security":false},{"name":"nodejs","version":"10.5.0","date":"2018-06-20","lts":false,"security":false},{"name":"nodejs","version":"10.6.0","date":"2018-07-04","lts":false,"security":false},{"name":"nodejs","version":"10.7.0","date":"2018-07-18","lts":false,"security":false},{"name":"nodejs","version":"10.8.0","date":"2018-08-01","lts":false,"security":false},{"name":"nodejs","version":"10.9.0","date":"2018-08-15","lts":false,"security":false},{"name":"nodejs","version":"10.10.0","date":"2018-09-06","lts":false,"security":false},{"name":"nodejs","version":"10.11.0","date":"2018-09-19","lts":false,"security":false},{"name":"nodejs","version":"10.12.0","date":"2018-10-10","lts":false,"security":false},{"name":"nodejs","version":"10.13.0","date":"2018-10-30","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.14.0","date":"2018-11-27","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.15.0","date":"2018-12-26","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.16.0","date":"2019-05-28","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.17.0","date":"2019-10-22","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.18.0","date":"2019-12-17","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.19.0","date":"2020-02-05","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.20.0","date":"2020-03-26","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.21.0","date":"2020-06-02","lts":"Dubnium","security":true},{"name":"nodejs","version":"10.22.0","date":"2020-07-21","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.23.0","date":"2020-10-27","lts":"Dubnium","security":false},{"name":"nodejs","version":"10.24.0","date":"2021-02-23","lts":"Dubnium","security":true},{"name":"nodejs","version":"11.0.0","date":"2018-10-23","lts":false,"security":false},{"name":"nodejs","version":"11.1.0","date":"2018-10-30","lts":false,"security":false},{"name":"nodejs","version":"11.2.0","date":"2018-11-15","lts":false,"security":false},{"name":"nodejs","version":"11.3.0","date":"2018-11-27","lts":false,"security":true},{"name":"nodejs","version":"11.4.0","date":"2018-12-07","lts":false,"security":false},{"name":"nodejs","version":"11.5.0","date":"2018-12-18","lts":false,"security":false},{"name":"nodejs","version":"11.6.0","date":"2018-12-26","lts":false,"security":false},{"name":"nodejs","version":"11.7.0","date":"2019-01-17","lts":false,"security":false},{"name":"nodejs","version":"11.8.0","date":"2019-01-24","lts":false,"security":false},{"name":"nodejs","version":"11.9.0","date":"2019-01-30","lts":false,"security":false},{"name":"nodejs","version":"11.10.0","date":"2019-02-14","lts":false,"security":false},{"name":"nodejs","version":"11.11.0","date":"2019-03-05","lts":false,"security":false},{"name":"nodejs","version":"11.12.0","date":"2019-03-14","lts":false,"security":false},{"name":"nodejs","version":"11.13.0","date":"2019-03-28","lts":false,"security":false},{"name":"nodejs","version":"11.14.0","date":"2019-04-10","lts":false,"security":false},{"name":"nodejs","version":"11.15.0","date":"2019-04-30","lts":false,"security":false},{"name":"nodejs","version":"12.0.0","date":"2019-04-23","lts":false,"security":false},{"name":"nodejs","version":"12.1.0","date":"2019-04-29","lts":false,"security":false},{"name":"nodejs","version":"12.2.0","date":"2019-05-07","lts":false,"security":false},{"name":"nodejs","version":"12.3.0","date":"2019-05-21","lts":false,"security":false},{"name":"nodejs","version":"12.4.0","date":"2019-06-04","lts":false,"security":false},{"name":"nodejs","version":"12.5.0","date":"2019-06-26","lts":false,"security":false},{"name":"nodejs","version":"12.6.0","date":"2019-07-03","lts":false,"security":false},{"name":"nodejs","version":"12.7.0","date":"2019-07-23","lts":false,"security":false},{"name":"nodejs","version":"12.8.0","date":"2019-08-06","lts":false,"security":false},{"name":"nodejs","version":"12.9.0","date":"2019-08-20","lts":false,"security":false},{"name":"nodejs","version":"12.10.0","date":"2019-09-04","lts":false,"security":false},{"name":"nodejs","version":"12.11.0","date":"2019-09-25","lts":false,"security":false},{"name":"nodejs","version":"12.12.0","date":"2019-10-11","lts":false,"security":false},{"name":"nodejs","version":"12.13.0","date":"2019-10-21","lts":"Erbium","security":false},{"name":"nodejs","version":"12.14.0","date":"2019-12-17","lts":"Erbium","security":true},{"name":"nodejs","version":"12.15.0","date":"2020-02-05","lts":"Erbium","security":true},{"name":"nodejs","version":"12.16.0","date":"2020-02-11","lts":"Erbium","security":false},{"name":"nodejs","version":"12.17.0","date":"2020-05-26","lts":"Erbium","security":false},{"name":"nodejs","version":"12.18.0","date":"2020-06-02","lts":"Erbium","security":true},{"name":"nodejs","version":"12.19.0","date":"2020-10-06","lts":"Erbium","security":false},{"name":"nodejs","version":"12.20.0","date":"2020-11-24","lts":"Erbium","security":false},{"name":"nodejs","version":"12.21.0","date":"2021-02-23","lts":"Erbium","security":true},{"name":"nodejs","version":"12.22.0","date":"2021-03-30","lts":"Erbium","security":false},{"name":"nodejs","version":"13.0.0","date":"2019-10-22","lts":false,"security":false},{"name":"nodejs","version":"13.1.0","date":"2019-11-05","lts":false,"security":false},{"name":"nodejs","version":"13.2.0","date":"2019-11-21","lts":false,"security":false},{"name":"nodejs","version":"13.3.0","date":"2019-12-03","lts":false,"security":false},{"name":"nodejs","version":"13.4.0","date":"2019-12-17","lts":false,"security":true},{"name":"nodejs","version":"13.5.0","date":"2019-12-18","lts":false,"security":false},{"name":"nodejs","version":"13.6.0","date":"2020-01-07","lts":false,"security":false},{"name":"nodejs","version":"13.7.0","date":"2020-01-21","lts":false,"security":false},{"name":"nodejs","version":"13.8.0","date":"2020-02-05","lts":false,"security":true},{"name":"nodejs","version":"13.9.0","date":"2020-02-18","lts":false,"security":false},{"name":"nodejs","version":"13.10.0","date":"2020-03-04","lts":false,"security":false},{"name":"nodejs","version":"13.11.0","date":"2020-03-12","lts":false,"security":false},{"name":"nodejs","version":"13.12.0","date":"2020-03-26","lts":false,"security":false},{"name":"nodejs","version":"13.13.0","date":"2020-04-14","lts":false,"security":false},{"name":"nodejs","version":"13.14.0","date":"2020-04-29","lts":false,"security":false},{"name":"nodejs","version":"14.0.0","date":"2020-04-21","lts":false,"security":false},{"name":"nodejs","version":"14.1.0","date":"2020-04-29","lts":false,"security":false},{"name":"nodejs","version":"14.2.0","date":"2020-05-05","lts":false,"security":false},{"name":"nodejs","version":"14.3.0","date":"2020-05-19","lts":false,"security":false},{"name":"nodejs","version":"14.4.0","date":"2020-06-02","lts":false,"security":true},{"name":"nodejs","version":"14.5.0","date":"2020-06-30","lts":false,"security":false},{"name":"nodejs","version":"14.6.0","date":"2020-07-20","lts":false,"security":false},{"name":"nodejs","version":"14.7.0","date":"2020-07-29","lts":false,"security":false},{"name":"nodejs","version":"14.8.0","date":"2020-08-11","lts":false,"security":false},{"name":"nodejs","version":"14.9.0","date":"2020-08-27","lts":false,"security":false},{"name":"nodejs","version":"14.10.0","date":"2020-09-08","lts":false,"security":false},{"name":"nodejs","version":"14.11.0","date":"2020-09-15","lts":false,"security":true},{"name":"nodejs","version":"14.12.0","date":"2020-09-22","lts":false,"security":false},{"name":"nodejs","version":"14.13.0","date":"2020-09-29","lts":false,"security":false},{"name":"nodejs","version":"14.14.0","date":"2020-10-15","lts":false,"security":false},{"name":"nodejs","version":"14.15.0","date":"2020-10-27","lts":"Fermium","security":false},{"name":"nodejs","version":"14.16.0","date":"2021-02-23","lts":"Fermium","security":true},{"name":"nodejs","version":"14.17.0","date":"2021-05-11","lts":"Fermium","security":false},{"name":"nodejs","version":"15.0.0","date":"2020-10-20","lts":false,"security":false},{"name":"nodejs","version":"15.1.0","date":"2020-11-04","lts":false,"security":false},{"name":"nodejs","version":"15.2.0","date":"2020-11-10","lts":false,"security":false},{"name":"nodejs","version":"15.3.0","date":"2020-11-24","lts":false,"security":false},{"name":"nodejs","version":"15.4.0","date":"2020-12-09","lts":false,"security":false},{"name":"nodejs","version":"15.5.0","date":"2020-12-22","lts":false,"security":false},{"name":"nodejs","version":"15.6.0","date":"2021-01-14","lts":false,"security":false},{"name":"nodejs","version":"15.7.0","date":"2021-01-25","lts":false,"security":false},{"name":"nodejs","version":"15.8.0","date":"2021-02-02","lts":false,"security":false},{"name":"nodejs","version":"15.9.0","date":"2021-02-18","lts":false,"security":false},{"name":"nodejs","version":"15.10.0","date":"2021-02-23","lts":false,"security":true},{"name":"nodejs","version":"15.11.0","date":"2021-03-03","lts":false,"security":false},{"name":"nodejs","version":"15.12.0","date":"2021-03-17","lts":false,"security":false},{"name":"nodejs","version":"15.13.0","date":"2021-03-31","lts":false,"security":false},{"name":"nodejs","version":"15.14.0","date":"2021-04-06","lts":false,"security":false},{"name":"nodejs","version":"16.0.0","date":"2021-04-20","lts":false,"security":false},{"name":"nodejs","version":"16.1.0","date":"2021-05-04","lts":false,"security":false},{"name":"nodejs","version":"16.2.0","date":"2021-05-19","lts":false,"security":false},{"name":"nodejs","version":"16.3.0","date":"2021-06-03","lts":false,"security":false}]');
          }, (e2, t2, r2) => {
            const { browsers: n } = r2(469), s2 = r2(470).browserVersions, i = r2(294);
            function o(e3) {
              return Object.keys(e3).reduce((t3, r3) => (t3[s2[r3]] = e3[r3], t3), {});
            }
            e2.exports.a = Object.keys(i).reduce((e3, t3) => {
              let r3 = i[t3];
              return e3[n[t3]] = Object.keys(r3).reduce((e4, t4) => (t4 === "A" ? e4.usage_global = o(r3[t4]) : t4 === "C" ? e4.versions = r3[t4].reduce((e5, t5) => (t5 === "" ? e5.push(null) : e5.push(s2[t5]), e5), []) : t4 === "D" ? e4.prefix_exceptions = o(r3[t4]) : t4 === "E" ? e4.browser = r3[t4] : t4 === "F" ? e4.release_date = Object.keys(r3[t4]).reduce((e5, n2) => (e5[s2[n2]] = r3[t4][n2], e5), {}) : e4.prefix = r3[t4], e4), {}), e3;
            }, {});
          }, (e2, t2, r2) => {
            e2.exports.browsers = r2(292);
          }, (e2, t2, r2) => {
            e2.exports.browserVersions = r2(293);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('{"v0.8":{"start":"2012-06-25","end":"2014-07-31"},"v0.10":{"start":"2013-03-11","end":"2016-10-31"},"v0.12":{"start":"2015-02-06","end":"2016-12-31"},"v4":{"start":"2015-09-08","lts":"2015-10-12","maintenance":"2017-04-01","end":"2018-04-30","codename":"Argon"},"v5":{"start":"2015-10-29","maintenance":"2016-04-30","end":"2016-06-30"},"v6":{"start":"2016-04-26","lts":"2016-10-18","maintenance":"2018-04-30","end":"2019-04-30","codename":"Boron"},"v7":{"start":"2016-10-25","maintenance":"2017-04-30","end":"2017-06-30"},"v8":{"start":"2017-05-30","lts":"2017-10-31","maintenance":"2019-01-01","end":"2019-12-31","codename":"Carbon"},"v9":{"start":"2017-10-01","maintenance":"2018-04-01","end":"2018-06-30"},"v10":{"start":"2018-04-24","lts":"2018-10-30","maintenance":"2020-05-19","end":"2021-04-30","codename":"Dubnium"},"v11":{"start":"2018-10-23","maintenance":"2019-04-22","end":"2019-06-01"},"v12":{"start":"2019-04-23","lts":"2019-10-21","maintenance":"2020-11-30","end":"2022-04-30","codename":"Erbium"},"v13":{"start":"2019-10-22","maintenance":"2020-04-01","end":"2020-06-01"},"v14":{"start":"2020-04-21","lts":"2020-10-27","maintenance":"2021-10-19","end":"2023-04-30","codename":"Fermium"},"v15":{"start":"2020-10-20","maintenance":"2021-04-01","end":"2021-06-01"},"v16":{"start":"2021-04-20","lts":"2021-10-26","maintenance":"2022-10-18","end":"2024-04-30","codename":""},"v17":{"start":"2021-10-19","maintenance":"2022-04-01","end":"2022-06-01"},"v18":{"start":"2022-04-19","lts":"2022-10-25","maintenance":"2023-10-18","end":"2025-04-30","codename":""}}');
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.OptionValidator = void 0;
            var n = r2(298);
            t2.OptionValidator = class {
              constructor(e3) {
                this.descriptor = e3;
              }
              validateTopLevelOptions(e3, t3) {
                const r3 = Object.keys(t3);
                for (const t4 of Object.keys(e3))
                  if (!r3.includes(t4))
                    throw new Error(this.formatMessage(`'${t4}' is not a valid top-level option.
- Did you mean '${(0, n.findSuggestion)(t4, r3)}'?`));
              }
              validateBooleanOption(e3, t3, r3) {
                return t3 === void 0 ? r3 : (this.invariant(typeof t3 == "boolean", `'${e3}' option must be a boolean.`), t3);
              }
              validateStringOption(e3, t3, r3) {
                return t3 === void 0 ? r3 : (this.invariant(typeof t3 == "string", `'${e3}' option must be a string.`), t3);
              }
              invariant(e3, t3) {
                if (!e3)
                  throw new Error(this.formatMessage(t3));
              }
              formatMessage(e3) {
                return `${this.descriptor}: ${e3}`;
              }
            };
          }, (e2, t2, r2) => {
            e2.exports = r2(475);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('{"es6.module":{"chrome":"61","and_chr":"61","edge":"16","firefox":"60","and_ff":"60","node":"13.2.0","opera":"48","op_mob":"48","safari":"10.1","ios":"10.3","samsung":"8.2","android":"61","electron":"2.0","ios_saf":"10.3"}}');
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.TargetNames = void 0, t2.TargetNames = { node: "node", chrome: "chrome", opera: "opera", edge: "edge", firefox: "firefox", safari: "safari", ie: "ie", ios: "ios", android: "android", electron: "electron", samsung: "samsung" };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.getInclusionReasons = function(e3, t3, r3) {
              const o = r3[e3] || {};
              return Object.keys(t3).reduce((e4, r4) => {
                const a = (0, i.getLowestImplementedVersion)(o, r4), l = t3[r4];
                if (a) {
                  const t4 = (0, i.isUnreleasedVersion)(a, r4);
                  (0, i.isUnreleasedVersion)(l, r4) || !t4 && !n.lt(l.toString(), (0, i.semverify)(a)) || (e4[r4] = (0, s2.prettifyVersion)(l));
                } else
                  e4[r4] = (0, s2.prettifyVersion)(l);
                return e4;
              }, {});
            };
            var n = r2(28), s2 = r2(299), i = r2(152);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.targetsSupported = o, t2.isRequired = a, t2.default = function(e3, t3, r3, n2, s3, i2, o2) {
              const l = new Set(), c = { compatData: e3, includes: t3, excludes: r3 };
              for (const t4 in e3)
                if (a(t4, n2, c))
                  l.add(t4);
                else if (o2) {
                  const e4 = o2.get(t4);
                  e4 && l.add(e4);
                }
              return s3 && s3.forEach((e4) => !r3.has(e4) && l.add(e4)), i2 && i2.forEach((e4) => !t3.has(e4) && l.delete(e4)), l;
            };
            var n = r2(28), s2 = r2(479), i = r2(152);
            function o(e3, t3) {
              const r3 = Object.keys(e3);
              return r3.length !== 0 && r3.filter((r4) => {
                const s3 = (0, i.getLowestImplementedVersion)(t3, r4);
                if (!s3)
                  return true;
                const o2 = e3[r4];
                if ((0, i.isUnreleasedVersion)(o2, r4))
                  return false;
                if ((0, i.isUnreleasedVersion)(s3, r4))
                  return true;
                if (!n.valid(o2.toString()))
                  throw new Error(`Invalid version passed for target "${r4}": "${o2}". Versions must be in semver format (major.minor.patch)`);
                return n.gt((0, i.semverify)(s3), o2.toString());
              }).length === 0;
            }
            function a(e3, t3, { compatData: r3 = s2, includes: n2, excludes: i2 } = {}) {
              return !(i2 != null && i2.has(e3) || (n2 == null || !n2.has(e3)) && o(t3, r3[e3]));
            }
          }, (e2, t2, r2) => {
            e2.exports = r2(480);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('{"proposal-class-static-block":{"chrome":"91","electron":"13.0"},"proposal-private-property-in-object":{"chrome":"91","firefox":"90","electron":"13.0"},"proposal-class-properties":{"chrome":"74","opera":"62","edge":"79","firefox":"90","safari":"14.1","node":"12","samsung":"11","electron":"6.0"},"proposal-private-methods":{"chrome":"84","opera":"70","edge":"84","firefox":"90","safari":"15","node":"14.6","electron":"10.0"},"proposal-numeric-separator":{"chrome":"75","opera":"62","edge":"79","firefox":"70","safari":"13","node":"12.5","ios":"13","samsung":"11","electron":"6.0"},"proposal-logical-assignment-operators":{"chrome":"85","opera":"71","edge":"85","firefox":"79","safari":"14","node":"15","ios":"14","electron":"10.0"},"proposal-nullish-coalescing-operator":{"chrome":"80","opera":"67","edge":"80","firefox":"72","safari":"13.1","node":"14","ios":"13.4","samsung":"13","electron":"8.0"},"proposal-optional-chaining":{"firefox":"74","safari":"13.1","ios":"13.4"},"proposal-json-strings":{"chrome":"66","opera":"53","edge":"79","firefox":"62","safari":"12","node":"10","ios":"12","samsung":"9","electron":"3.0"},"proposal-optional-catch-binding":{"chrome":"66","opera":"53","edge":"79","firefox":"58","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-parameters":{"chrome":"49","opera":"36","edge":"18","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"proposal-async-generator-functions":{"chrome":"63","opera":"50","edge":"79","firefox":"57","safari":"12","node":"10","ios":"12","samsung":"8","electron":"3.0"},"proposal-object-rest-spread":{"chrome":"60","opera":"47","edge":"79","firefox":"55","safari":"11.1","node":"8.3","ios":"11.3","samsung":"8","electron":"2.0"},"transform-dotall-regex":{"chrome":"62","opera":"49","edge":"79","firefox":"78","safari":"11.1","node":"8.10","ios":"11.3","samsung":"8","electron":"3.0"},"proposal-unicode-property-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-named-capturing-groups-regex":{"chrome":"64","opera":"51","edge":"79","firefox":"78","safari":"11.1","node":"10","ios":"11.3","samsung":"9","electron":"3.0"},"transform-async-to-generator":{"chrome":"55","opera":"42","edge":"15","firefox":"52","safari":"11","node":"7.6","ios":"11","samsung":"6","electron":"1.6"},"transform-exponentiation-operator":{"chrome":"52","opera":"39","edge":"14","firefox":"52","safari":"10.1","node":"7","ios":"10.3","samsung":"6","electron":"1.3"},"transform-template-literals":{"chrome":"41","opera":"28","edge":"13","firefox":"34","safari":"13","node":"4","ios":"13","samsung":"3.4","electron":"0.21"},"transform-literals":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-function-name":{"chrome":"51","opera":"38","edge":"79","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-arrow-functions":{"chrome":"47","opera":"34","edge":"13","firefox":"45","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.36"},"transform-block-scoped-functions":{"chrome":"41","opera":"28","edge":"12","firefox":"46","safari":"10","node":"4","ie":"11","ios":"10","samsung":"3.4","electron":"0.21"},"transform-classes":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-object-super":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-shorthand-properties":{"chrome":"43","opera":"30","edge":"12","firefox":"33","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.27"},"transform-duplicate-keys":{"chrome":"42","opera":"29","edge":"12","firefox":"34","safari":"9","node":"4","ios":"9","samsung":"3.4","electron":"0.25"},"transform-computed-properties":{"chrome":"44","opera":"31","edge":"12","firefox":"34","safari":"7.1","node":"4","ios":"8","samsung":"4","electron":"0.30"},"transform-for-of":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-sticky-regex":{"chrome":"49","opera":"36","edge":"13","firefox":"3","safari":"10","node":"6","ios":"10","samsung":"5","electron":"0.37"},"transform-unicode-escapes":{"chrome":"44","opera":"31","edge":"12","firefox":"53","safari":"9","node":"4","ios":"9","samsung":"4","electron":"0.30"},"transform-unicode-regex":{"chrome":"50","opera":"37","edge":"13","firefox":"46","safari":"12","node":"6","ios":"12","samsung":"5","electron":"1.1"},"transform-spread":{"chrome":"46","opera":"33","edge":"13","firefox":"45","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-destructuring":{"chrome":"51","opera":"38","edge":"15","firefox":"53","safari":"10","node":"6.5","ios":"10","samsung":"5","electron":"1.2"},"transform-block-scoping":{"chrome":"49","opera":"36","edge":"14","firefox":"51","safari":"11","node":"6","ios":"11","samsung":"5","electron":"0.37"},"transform-typeof-symbol":{"chrome":"38","opera":"25","edge":"12","firefox":"36","safari":"9","node":"0.12","ios":"9","samsung":"3","electron":"0.20"},"transform-new-target":{"chrome":"46","opera":"33","edge":"14","firefox":"41","safari":"10","node":"5","ios":"10","samsung":"5","electron":"0.36"},"transform-regenerator":{"chrome":"50","opera":"37","edge":"13","firefox":"53","safari":"10","node":"6","ios":"10","samsung":"5","electron":"1.1"},"transform-member-expression-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"transform-property-literals":{"chrome":"7","opera":"12","edge":"12","firefox":"2","safari":"5.1","node":"0.10","ie":"9","android":"4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"transform-reserved-words":{"chrome":"13","opera":"10.50","edge":"12","firefox":"2","safari":"3.1","node":"0.10","ie":"9","android":"4.4","ios":"6","phantom":"2","samsung":"1","electron":"0.20"},"proposal-export-namespace-from":{"chrome":"72","and_chr":"72","edge":"79","firefox":"80","and_ff":"80","node":"13.2","opera":"60","op_mob":"51","samsung":"11.0","android":"72","electron":"5.0"}}');
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0, t2.default = { auxiliaryComment: { message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`" }, blacklist: { message: "Put the specific transforms you want in the `plugins` option" }, breakConfig: { message: "This is not a necessary option in Babel 6" }, experimental: { message: "Put the specific transforms you want in the `plugins` option" }, externalHelpers: { message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/" }, extra: { message: "" }, jsxPragma: { message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/" }, loose: { message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option." }, metadataUsedHelpers: { message: "Not required anymore as this is enabled by default" }, modules: { message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules" }, nonStandard: { message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/" }, optional: { message: "Put the specific transforms you want in the `plugins` option" }, sourceMapName: { message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." }, stage: { message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets" }, whitelist: { message: "Put the specific transforms you want in the `plugins` option" }, resolveModuleSource: { version: 6, message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options" }, metadata: { version: 6, message: "Generated plugin metadata is always included in the output result" }, sourceMapTarget: { version: 6, message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves." } };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(8);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = n().resolve(t3, e3).split(n().sep);
              return new RegExp(["^", ...r3.map((e4, t4) => {
                const n2 = t4 === r3.length - 1;
                return e4 === "**" ? n2 ? u : c : e4 === "*" ? n2 ? l : a : e4.indexOf("*.") === 0 ? o + p2(e4.slice(1)) + (n2 ? i : s2) : p2(e4) + (n2 ? i : s2);
              })].join(""));
            };
            const s2 = `\\${n().sep}`, i = `(?:${s2}|$)`, o = `[^${s2}]+`, a = `(?:${o}${s2})`, l = `(?:${o}${i})`, c = `${a}*?`, u = `${a}*?${l}?`;
            function p2(e3) {
              return e3.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.ConfigPrinter = t2.ChainFormatter = void 0;
            const s2 = { Programmatic: 0, Config: 1 };
            t2.ChainFormatter = s2;
            const i = { title(e3, t3, r3) {
              let n2 = "";
              return e3 === s2.Programmatic ? (n2 = "programmatic options", t3 && (n2 += " from " + t3)) : n2 = "config " + r3, n2;
            }, loc(e3, t3) {
              let r3 = "";
              return e3 != null && (r3 += `.overrides[${e3}]`), t3 != null && (r3 += `.env["${t3}"]`), r3;
            }, *optionsAndDescriptors(e3) {
              const t3 = Object.assign({}, e3.options);
              delete t3.overrides, delete t3.env;
              const r3 = [...yield* e3.plugins()];
              r3.length && (t3.plugins = r3.map((e4) => o(e4)));
              const n2 = [...yield* e3.presets()];
              return n2.length && (t3.presets = [...n2].map((e4) => o(e4))), JSON.stringify(t3, void 0, 2);
            } };
            function o(e3) {
              var t3;
              let r3 = (t3 = e3.file) == null ? void 0 : t3.request;
              return r3 == null && (typeof e3.value == "object" ? r3 = e3.value : typeof e3.value == "function" && (r3 = `[Function: ${e3.value.toString().substr(0, 50)} ... ]`)), r3 == null && (r3 = "[Unknown]"), e3.options === void 0 ? r3 : e3.name == null ? [r3, e3.options] : [r3, e3.options, e3.name];
            }
            class a {
              constructor() {
                this._stack = [];
              }
              configure(e3, t3, { callerName: r3, filepath: n2 }) {
                return e3 ? (e4, s3, i2) => {
                  this._stack.push({ type: t3, callerName: r3, filepath: n2, content: e4, index: s3, envName: i2 });
                } : () => {
                };
              }
              static *format(e3) {
                let t3 = i.title(e3.type, e3.callerName, e3.filepath);
                const r3 = i.loc(e3.index, e3.envName);
                return r3 && (t3 += ` ${r3}`), `${t3}
${yield* i.optionsAndDescriptors(e3.content)}`;
              }
              *output() {
                return this._stack.length === 0 ? "" : (yield* n().all(this._stack.map((e3) => a.format(e3)))).join("\n\n");
              }
            }
            t2.ConfigPrinter = a;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.validatePluginObject = function(e3) {
              const t3 = { type: "root", source: "plugin" };
              return Object.keys(e3).forEach((r3) => {
                const n2 = s2[r3];
                if (!n2) {
                  const e4 = new Error(`.${r3} is not a valid Plugin property`);
                  throw e4.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY", e4;
                }
                n2({ type: "option", name: r3, parent: t3 }, e3[r3]);
              }), e3;
            };
            var n = r2(301);
            const s2 = { name: n.assertString, manipulateOptions: n.assertFunction, pre: n.assertFunction, post: n.assertFunction, inherits: n.assertFunction, visitor: function(e3, t3) {
              const r3 = (0, n.assertObject)(e3, t3);
              if (r3 && (Object.keys(r3).forEach((e4) => function(e5, t4) {
                if (t4 && typeof t4 == "object")
                  Object.keys(t4).forEach((t5) => {
                    if (t5 !== "enter" && t5 !== "exit")
                      throw new Error(`.visitor["${e5}"] may only have .enter and/or .exit handlers.`);
                  });
                else if (typeof t4 != "function")
                  throw new Error(`.visitor["${e5}"] must be a function`);
                return t4;
              }(e4, r3[e4])), r3.enter || r3.exit))
                throw new Error(`${(0, n.msg)(e3)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
              return r3;
            }, parserOverride: n.assertFunction, generatorOverride: n.assertFunction };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(28);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.makeConfigAPI = o, t2.makePresetAPI = a, t2.makePluginAPI = function(e3) {
              return Object.assign({}, a(e3), { assumption: (t3) => e3.using((e4) => e4.assumptions[t3]) });
            };
            var s2 = r2(9), i = r2(81);
            function o(e3) {
              return { version: s2.version, cache: e3.simple(), env: (t3) => e3.using((e4) => t3 === void 0 ? e4.envName : typeof t3 == "function" ? (0, i.assertSimpleType)(t3(e4.envName)) : (Array.isArray(t3) || (t3 = [t3]), t3.some((t4) => {
                if (typeof t4 != "string")
                  throw new Error("Unexpected non-string value");
                return t4 === e4.envName;
              }))), async: () => false, caller: (t3) => e3.using((e4) => (0, i.assertSimpleType)(t3(e4.caller))), assertVersion: l };
            }
            function a(e3) {
              return Object.assign({}, o(e3), { targets: () => JSON.parse(e3.using((e4) => JSON.stringify(e4.targets))) });
            }
            function l(e3) {
              if (typeof e3 == "number") {
                if (!Number.isInteger(e3))
                  throw new Error("Expected string or integer value.");
                e3 = `^${e3}.0.0-0`;
              }
              if (typeof e3 != "string")
                throw new Error("Expected string or integer value.");
              if (n().satisfies(s2.version, e3))
                return;
              const t3 = Error.stackTraceLimit;
              typeof t3 == "number" && t3 < 25 && (Error.stackTraceLimit = 25);
              const r3 = new Error(`Requires Babel "${e3}", but was loaded with "${s2.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
              throw typeof t3 == "number" && (Error.stackTraceLimit = t3), Object.assign(r3, { code: "BABEL_VERSION_UNSUPPORTED", version: s2.version, range: e3 });
            }
            r2(302);
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.transformAsync = t2.transformSync = t2.transform = void 0;
            var s2 = r2(78), i = r2(304);
            const o = n()(function* (e3, t3) {
              const r3 = yield* (0, s2.default)(t3);
              return r3 === null ? null : yield* (0, i.run)(r3, e3);
            });
            t2.transform = function(e3, t3, r3) {
              if (typeof t3 == "function" && (r3 = t3, t3 = void 0), r3 === void 0)
                return o.sync(e3, t3);
              o.errback(e3, t3, r3);
            };
            const a = o.sync;
            t2.transformSync = a;
            const l = o.async;
            t2.transformAsync = l;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            class r2 {
              constructor(e3, t3, r3) {
                this._map = new Map(), this.key = void 0, this.file = void 0, this.opts = void 0, this.cwd = void 0, this.filename = void 0, this.key = t3, this.file = e3, this.opts = r3 || {}, this.cwd = e3.opts.cwd, this.filename = e3.opts.filename;
              }
              set(e3, t3) {
                this._map.set(e3, t3);
              }
              get(e3) {
                return this._map.get(e3);
              }
              availableHelper(e3, t3) {
                return this.file.availableHelper(e3, t3);
              }
              addHelper(e3) {
                return this.file.addHelper(e3);
              }
              addImport() {
                return this.file.addImport();
              }
              buildCodeFrameError(e3, t3, r3) {
                return this.file.buildCodeFrameError(e3, t3, r3);
              }
            }
            t2.default = r2, r2.prototype.getModuleName = function() {
              return this.file.getModuleName();
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(10);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function() {
              return i || (i = new s2.default(Object.assign({}, a, { visitor: n().default.explode(a.visitor) }), {})), i;
            };
            var s2 = r2(79);
            let i;
            function o(e3) {
              const t3 = e3 == null ? void 0 : e3._blockHoist;
              return t3 == null ? 1 : t3 === true ? 2 : t3;
            }
            const a = { name: "internal.blockHoist", visitor: { Block: { exit({ node: e3 }) {
              const { body: t3 } = e3;
              let r3 = Math.pow(2, 30) - 1, n2 = false;
              for (let e4 = 0; e4 < t3.length; e4++) {
                const s3 = o(t3[e4]);
                if (s3 > r3) {
                  n2 = true;
                  break;
                }
                r3 = s3;
              }
              n2 && (e3.body = function(e4) {
                const t4 = Object.create(null);
                for (let r5 = 0; r5 < e4.length; r5++) {
                  const n4 = e4[r5], s3 = o(n4);
                  (t4[s3] || (t4[s3] = [])).push(n4);
                }
                const r4 = Object.keys(t4).map((e5) => +e5).sort((e5, t5) => t5 - e5);
                let n3 = 0;
                for (const s3 of r4) {
                  const r5 = t4[s3];
                  for (const t5 of r5)
                    e4[n3++] = t5;
                }
                return e4;
              }(t3.slice()));
            } } } };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(490);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(8);
              return s2 = function() {
                return e3;
              }, e3;
            }
            function i() {
              const e3 = r2(65);
              return i = function() {
                return e3;
              }, e3;
            }
            function o() {
              const e3 = r2(0);
              return o = function() {
                return e3;
              }, e3;
            }
            function a() {
              const e3 = r2(491);
              return a = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function* (e3, t3, r3, i2) {
              if (r3 = `${r3 || ""}`, i2) {
                if (i2.type === "Program")
                  i2 = o().file(i2, [], []);
                else if (i2.type !== "File")
                  throw new Error("AST root must be a Program or File node");
                t3.cloneInputAst && (i2 = (0, u.default)(i2));
              } else
                i2 = yield* (0, c.default)(e3, t3, r3);
              let h4 = null;
              if (t3.inputSourceMap !== false) {
                if (typeof t3.inputSourceMap == "object" && (h4 = a().fromObject(t3.inputSourceMap)), !h4) {
                  const e4 = m(f, i2);
                  if (e4)
                    try {
                      h4 = a().fromComment(e4);
                    } catch (e5) {
                      p2("discarding unknown inline input sourcemap", e5);
                    }
                }
                if (!h4) {
                  const e4 = m(d, i2);
                  if (typeof t3.filename == "string" && e4)
                    try {
                      const r4 = d.exec(e4), i3 = n().readFileSync(s2().resolve(s2().dirname(t3.filename), r4[1]));
                      i3.length > 1e6 ? p2("skip merging input map > 1 MB") : h4 = a().fromJSON(i3);
                    } catch (e5) {
                      p2("discarding unknown file input sourcemap", e5);
                    }
                  else
                    e4 && p2("discarding un-loadable file input sourcemap");
                }
              }
              return new l.default(t3, { code: r3, ast: i2, inputMap: h4 });
            };
            var l = r2(126), c = r2(306), u = r2(493);
            const p2 = i()("babel:transform:file"), f = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/, d = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
            function h3(e3, t3, r3) {
              return t3 && (t3 = t3.filter(({ value: t4 }) => !e3.test(t4) || (r3 = t4, false))), [t3, r3];
            }
            function m(e3, t3) {
              let r3 = null;
              return o().traverseFast(t3, (t4) => {
                [t4.leadingComments, r3] = h3(e3, t4.leadingComments, r3), [t4.innerComments, r3] = h3(e3, t4.innerComments, r3), [t4.trailingComments, r3] = h3(e3, t4.trailingComments, r3);
              }), r3;
            }
          }, () => {
          }, () => {
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, s2) {
              let i = `Support for the experimental syntax '${e3}' isn't currently enabled (${t3.line}:${t3.column + 1}):

` + s2;
              const o = r2[e3];
              if (o) {
                const { syntax: e4, transform: t4 } = o;
                if (e4) {
                  const r3 = n(e4);
                  if (t4) {
                    i += `

Add ${n(t4)} to the '${t4.name.startsWith("@babel/plugin") ? "plugins" : "presets"}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${r3} to the 'plugins' section to enable parsing.`;
                  } else
                    i += `

Add ${r3} to the 'plugins' section of your Babel config to enable parsing.`;
                }
              }
              return i;
            };
            const r2 = { asyncDoExpressions: { syntax: { name: "@babel/plugin-syntax-async-do-expressions", url: "https://git.io/JYer8" } }, classProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-class-properties", url: "https://git.io/vb4SL" } }, classPrivateProperties: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-class-properties", url: "https://git.io/vb4SL" } }, classPrivateMethods: { syntax: { name: "@babel/plugin-syntax-class-properties", url: "https://git.io/vb4yQ" }, transform: { name: "@babel/plugin-proposal-private-methods", url: "https://git.io/JvpRG" } }, classStaticBlock: { syntax: { name: "@babel/plugin-syntax-class-static-block", url: "https://git.io/JTLB6" }, transform: { name: "@babel/plugin-proposal-class-static-block", url: "https://git.io/JTLBP" } }, decimal: { syntax: { name: "@babel/plugin-syntax-decimal", url: "https://git.io/JfKOH" } }, decorators: { syntax: { name: "@babel/plugin-syntax-decorators", url: "https://git.io/vb4y9" }, transform: { name: "@babel/plugin-proposal-decorators", url: "https://git.io/vb4ST" } }, doExpressions: { syntax: { name: "@babel/plugin-syntax-do-expressions", url: "https://git.io/vb4yh" }, transform: { name: "@babel/plugin-proposal-do-expressions", url: "https://git.io/vb4S3" } }, dynamicImport: { syntax: { name: "@babel/plugin-syntax-dynamic-import", url: "https://git.io/vb4Sv" } }, exportDefaultFrom: { syntax: { name: "@babel/plugin-syntax-export-default-from", url: "https://git.io/vb4SO" }, transform: { name: "@babel/plugin-proposal-export-default-from", url: "https://git.io/vb4yH" } }, exportNamespaceFrom: { syntax: { name: "@babel/plugin-syntax-export-namespace-from", url: "https://git.io/vb4Sf" }, transform: { name: "@babel/plugin-proposal-export-namespace-from", url: "https://git.io/vb4SG" } }, flow: { syntax: { name: "@babel/plugin-syntax-flow", url: "https://git.io/vb4yb" }, transform: { name: "@babel/preset-flow", url: "https://git.io/JfeDn" } }, functionBind: { syntax: { name: "@babel/plugin-syntax-function-bind", url: "https://git.io/vb4y7" }, transform: { name: "@babel/plugin-proposal-function-bind", url: "https://git.io/vb4St" } }, functionSent: { syntax: { name: "@babel/plugin-syntax-function-sent", url: "https://git.io/vb4yN" }, transform: { name: "@babel/plugin-proposal-function-sent", url: "https://git.io/vb4SZ" } }, importMeta: { syntax: { name: "@babel/plugin-syntax-import-meta", url: "https://git.io/vbKK6" } }, jsx: { syntax: { name: "@babel/plugin-syntax-jsx", url: "https://git.io/vb4yA" }, transform: { name: "@babel/preset-react", url: "https://git.io/JfeDR" } }, importAssertions: { syntax: { name: "@babel/plugin-syntax-import-assertions", url: "https://git.io/JUbkv" } }, moduleStringNames: { syntax: { name: "@babel/plugin-syntax-module-string-names", url: "https://git.io/JTL8G" } }, numericSeparator: { syntax: { name: "@babel/plugin-syntax-numeric-separator", url: "https://git.io/vb4Sq" }, transform: { name: "@babel/plugin-proposal-numeric-separator", url: "https://git.io/vb4yS" } }, optionalChaining: { syntax: { name: "@babel/plugin-syntax-optional-chaining", url: "https://git.io/vb4Sc" }, transform: { name: "@babel/plugin-proposal-optional-chaining", url: "https://git.io/vb4Sk" } }, pipelineOperator: { syntax: { name: "@babel/plugin-syntax-pipeline-operator", url: "https://git.io/vb4yj" }, transform: { name: "@babel/plugin-proposal-pipeline-operator", url: "https://git.io/vb4SU" } }, privateIn: { syntax: { name: "@babel/plugin-syntax-private-property-in-object", url: "https://git.io/JfK3q" }, transform: { name: "@babel/plugin-proposal-private-property-in-object", url: "https://git.io/JfK3O" } }, recordAndTuple: { syntax: { name: "@babel/plugin-syntax-record-and-tuple", url: "https://git.io/JvKp3" } }, throwExpressions: { syntax: { name: "@babel/plugin-syntax-throw-expressions", url: "https://git.io/vb4SJ" }, transform: { name: "@babel/plugin-proposal-throw-expressions", url: "https://git.io/vb4yF" } }, typescript: { syntax: { name: "@babel/plugin-syntax-typescript", url: "https://git.io/vb4SC" }, transform: { name: "@babel/preset-typescript", url: "https://git.io/JfeDz" } }, asyncGenerators: { syntax: { name: "@babel/plugin-syntax-async-generators", url: "https://git.io/vb4SY" }, transform: { name: "@babel/plugin-proposal-async-generator-functions", url: "https://git.io/vb4yp" } }, logicalAssignment: { syntax: { name: "@babel/plugin-syntax-logical-assignment-operators", url: "https://git.io/vAlBp" }, transform: { name: "@babel/plugin-proposal-logical-assignment-operators", url: "https://git.io/vAlRe" } }, nullishCoalescingOperator: { syntax: { name: "@babel/plugin-syntax-nullish-coalescing-operator", url: "https://git.io/vb4yx" }, transform: { name: "@babel/plugin-proposal-nullish-coalescing-operator", url: "https://git.io/vb4Se" } }, objectRestSpread: { syntax: { name: "@babel/plugin-syntax-object-rest-spread", url: "https://git.io/vb4y5" }, transform: { name: "@babel/plugin-proposal-object-rest-spread", url: "https://git.io/vb4Ss" } }, optionalCatchBinding: { syntax: { name: "@babel/plugin-syntax-optional-catch-binding", url: "https://git.io/vb4Sn" }, transform: { name: "@babel/plugin-proposal-optional-catch-binding", url: "https://git.io/vb4SI" } } };
            r2.privateIn.syntax = r2.privateIn.transform;
            const n = ({ name: e3, url: t3 }) => `${e3} (${t3})`;
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3) {
              return JSON.parse(JSON.stringify(e3, n), s2);
            };
            const r2 = "$$ babel internal serialized type" + Math.random();
            function n(e3, t3) {
              return typeof t3 != "bigint" ? t3 : { [r2]: "BigInt", value: t3.toString() };
            }
            function s2(e3, t3) {
              return t3 && typeof t3 == "object" ? t3[r2] !== "BigInt" ? t3 : BigInt(t3.value) : t3;
            }
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(495);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2() {
              const e3 = r2(133);
              return s2 = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const { opts: r3, ast: o, code: a, inputMap: l } = t3, c = [];
              for (const t4 of e3)
                for (const e4 of t4) {
                  const { generatorOverride: t5 } = e4;
                  if (t5) {
                    const e5 = t5(o, r3.generatorOpts, a, s2().default);
                    e5 !== void 0 && c.push(e5);
                  }
                }
              let u;
              if (c.length === 0)
                u = (0, s2().default)(o, r3.generatorOpts, a);
              else {
                if (c.length !== 1)
                  throw new Error("More than one plugin attempted to override codegen.");
                if (u = c[0], typeof u.then == "function")
                  throw new Error("You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.");
              }
              let { code: p2, map: f } = u;
              return f && l && (f = (0, i.default)(l.toObject(), f)), r3.sourceMaps !== "inline" && r3.sourceMaps !== "both" || (p2 += "\n" + n().fromObject(f).toComment()), r3.sourceMaps === "inline" && (f = null), { outputCode: p2, outputMap: f };
            };
            var i = r2(496);
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(497);
              return n = function() {
                return e3;
              }, e3;
            }
            function s2(e3) {
              return `${e3.line}/${e3.columnStart}`;
            }
            function i(e3) {
              const t3 = new (n()).SourceMapConsumer(Object.assign({}, e3, { sourceRoot: null })), r3 = new Map(), s3 = new Map();
              let i2 = null;
              return t3.computeColumnSpans(), t3.eachMapping((e4) => {
                if (e4.originalLine === null)
                  return;
                let n2 = r3.get(e4.source);
                n2 || (n2 = { path: e4.source, content: t3.sourceContentFor(e4.source, true) }, r3.set(e4.source, n2));
                let o = s3.get(n2);
                o || (o = { source: n2, mappings: [] }, s3.set(n2, o));
                const a = { line: e4.originalLine, columnStart: e4.originalColumn, columnEnd: 1 / 0, name: e4.name };
                i2 && i2.source === n2 && i2.mapping.line === e4.originalLine && (i2.mapping.columnEnd = e4.originalColumn), i2 = { source: n2, mapping: a }, o.mappings.push({ original: a, generated: t3.allGeneratedPositionsFor({ source: e4.source, line: e4.originalLine, column: e4.originalColumn }).map((e5) => ({ line: e5.line, columnStart: e5.column, columnEnd: e5.lastColumn + 1 })) });
              }, null, n().SourceMapConsumer.ORIGINAL_ORDER), { file: e3.file, sourceRoot: e3.sourceRoot, sources: Array.from(s3.values()) };
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              const r3 = i(e3), o = i(t3), a = new (n()).SourceMapGenerator();
              for (const { source: e4 } of r3.sources)
                typeof e4.content == "string" && a.setSourceContent(e4.path, e4.content);
              if (o.sources.length === 1) {
                const e4 = o.sources[0], t4 = new Map();
                !function(e5, t5) {
                  for (const { source: r4, mappings: n2 } of e5.sources)
                    for (const { original: e6, generated: s3 } of n2)
                      for (const n3 of s3)
                        t5(n3, e6, r4);
                }(r3, (r4, n2, i2) => {
                  !function(e5, t5, r5) {
                    const n3 = function({ mappings: e6 }, { line: t6, columnStart: r6, columnEnd: n4 }) {
                      return function(e7, t7) {
                        const r7 = [];
                        for (let n5 = function(e8, t8) {
                          let r8 = 0, n6 = e8.length;
                          for (; r8 < n6; ) {
                            const s4 = Math.floor((r8 + n6) / 2), i3 = t8(e8[s4]);
                            if (i3 === 0) {
                              r8 = s4;
                              break;
                            }
                            i3 >= 0 ? n6 = s4 : r8 = s4 + 1;
                          }
                          let s3 = r8;
                          if (s3 < e8.length) {
                            for (; s3 >= 0 && t8(e8[s3]) >= 0; )
                              s3--;
                            return s3 + 1;
                          }
                          return s3;
                        }(e7, t7); n5 < e7.length && t7(e7[n5]) === 0; n5++)
                          r7.push(e7[n5]);
                        return r7;
                      }(e6, ({ original: e7 }) => t6 > e7.line ? -1 : t6 < e7.line ? 1 : r6 >= e7.columnEnd ? -1 : n4 <= e7.columnStart ? 1 : 0);
                    }(e5, t5);
                    for (const { generated: e6 } of n3)
                      for (const t6 of e6)
                        r5(t6);
                  }(e4, r4, (e5) => {
                    const r5 = s2(e5);
                    t4.has(r5) || (t4.set(r5, e5), a.addMapping({ source: i2.path, original: { line: n2.line, column: n2.columnStart }, generated: { line: e5.line, column: e5.columnStart }, name: n2.name }));
                  });
                });
                for (const e5 of t4.values()) {
                  if (e5.columnEnd === 1 / 0)
                    continue;
                  const r4 = { line: e5.line, columnStart: e5.columnEnd }, n2 = s2(r4);
                  t4.has(n2) || a.addMapping({ generated: { line: r4.line, column: r4.columnStart } });
                }
              }
              const l = a.toJSON();
              return typeof r3.sourceRoot == "string" && (l.sourceRoot = r3.sourceRoot), l;
            };
          }, () => {
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFileSync = function() {
              throw new Error("Transforming files is not supported in browsers");
            }, t2.transformFileAsync = function() {
              return Promise.reject(new Error("Transforming files is not supported in browsers"));
            }, t2.transformFile = void 0, t2.transformFile = function(e3, t3, r2) {
              typeof t3 == "function" && (r2 = t3), r2(new Error("Transforming files is not supported in browsers"), null);
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.transformFromAstAsync = t2.transformFromAstSync = t2.transformFromAst = void 0;
            var s2 = r2(78), i = r2(304);
            const o = n()(function* (e3, t3, r3) {
              const n2 = yield* (0, s2.default)(r3);
              if (n2 === null)
                return null;
              if (!e3)
                throw new Error("No AST given");
              return yield* (0, i.run)(n2, t3, e3);
            });
            t2.transformFromAst = function(e3, t3, r3, n2) {
              if (typeof r3 == "function" && (n2 = r3, r3 = void 0), n2 === void 0)
                return o.sync(e3, t3, r3);
              o.errback(e3, t3, r3, n2);
            };
            const a = o.sync;
            t2.transformFromAstSync = a;
            const l = o.async;
            t2.transformFromAstAsync = l;
          }, (e2, t2, r2) => {
            "use strict";
            function n() {
              const e3 = r2(14);
              return n = function() {
                return e3;
              }, e3;
            }
            Object.defineProperty(t2, "__esModule", { value: true }), t2.parseAsync = t2.parseSync = t2.parse = void 0;
            var s2 = r2(78), i = r2(306), o = r2(305);
            const a = n()(function* (e3, t3) {
              const r3 = yield* (0, s2.default)(t3);
              return r3 === null ? null : yield* (0, i.default)(r3.passes, (0, o.default)(r3), e3);
            });
            t2.parse = function(e3, t3, r3) {
              if (typeof t3 == "function" && (r3 = t3, t3 = void 0), r3 === void 0)
                return a.sync(e3, t3);
              a.errback(e3, t3, r3);
            };
            const l = a.sync;
            t2.parseSync = l;
            const c = a.async;
            t2.parseAsync = c;
          }, (e2, t2, r2) => {
            "use strict";
            t2.a = void 0;
            var n = r2(4), s2 = r2(239), i = r2(260), o = r2(9), a = r2(502), l = (0, n.declare)((e3, t3) => {
              var r3, n2;
              e3.assertVersion(7);
              const l2 = (0, a.createDynamicImportTransform)(e3), { strictNamespace: c = false, mjsStrictNamespace: u = true, allowTopLevelThis: p2, strict: f, strictMode: d, noInterop: h3, importInterop: m, lazy: y = false, allowCommonJSExports: g = true } = t3, b = (r3 = e3.assumption("constantReexports")) != null ? r3 : t3.loose, v = (n2 = e3.assumption("enumerableModuleMeta")) != null ? n2 : t3.loose;
              if (!(typeof y == "boolean" || typeof y == "function" || Array.isArray(y) && y.every((e4) => typeof e4 == "string")))
                throw new Error(".lazy must be a boolean, array of strings, or a function");
              if (typeof c != "boolean")
                throw new Error(".strictNamespace must be a boolean, or undefined");
              if (typeof u != "boolean")
                throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
              const E = (e4) => o.template.expression.ast`
    (function(){
      throw new Error(
        "The CommonJS '" + "${e4}" + "' variable is not available in ES6 modules." +
        "Consider setting setting sourceType:script or sourceType:unambiguous in your " +
        "Babel config for this file.");
    })()
  `, x = { ReferencedIdentifier(e4) {
                const t4 = e4.node.name;
                if (t4 !== "module" && t4 !== "exports")
                  return;
                const r4 = e4.scope.getBinding(t4);
                this.scope.getBinding(t4) !== r4 || e4.parentPath.isObjectProperty({ value: e4.node }) && e4.parentPath.parentPath.isObjectPattern() || e4.parentPath.isAssignmentExpression({ left: e4.node }) || e4.isAssignmentExpression({ left: e4.node }) || e4.replaceWith(E(t4));
              }, AssignmentExpression(e4) {
                const t4 = e4.get("left");
                if (t4.isIdentifier()) {
                  const t5 = e4.node.name;
                  if (t5 !== "module" && t5 !== "exports")
                    return;
                  const r4 = e4.scope.getBinding(t5);
                  if (this.scope.getBinding(t5) !== r4)
                    return;
                  const n3 = e4.get("right");
                  n3.replaceWith(o.types.sequenceExpression([n3.node, E(t5)]));
                } else if (t4.isPattern()) {
                  const r4 = t4.getOuterBindingIdentifiers(), n3 = Object.keys(r4).filter((t5) => (t5 === "module" || t5 === "exports") && this.scope.getBinding(t5) === e4.scope.getBinding(t5))[0];
                  if (n3) {
                    const t5 = e4.get("right");
                    t5.replaceWith(o.types.sequenceExpression([t5.node, E(n3)]));
                  }
                }
              } };
              return { name: "transform-modules-commonjs", pre() {
                this.file.set("@babel/plugin-transform-modules-*", "commonjs");
              }, visitor: { CallExpression(e4) {
                if (!this.file.has("@babel/plugin-proposal-dynamic-import"))
                  return;
                if (!e4.get("callee").isImport())
                  return;
                let { scope: t4 } = e4;
                do {
                  t4.rename("require");
                } while (t4 = t4.parent);
                l2(this, e4.get("callee"));
              }, Program: { exit(e4, r4) {
                if (!(0, s2.isModule)(e4))
                  return;
                e4.scope.rename("exports"), e4.scope.rename("module"), e4.scope.rename("require"), e4.scope.rename("__filename"), e4.scope.rename("__dirname"), g || ((0, i.default)(e4, new Set(["module", "exports"])), e4.traverse(x, { scope: e4.scope }));
                let n3 = (0, s2.getModuleName)(this.file.opts, t3);
                n3 && (n3 = o.types.stringLiteral(n3));
                const { meta: a2, headers: l3 } = (0, s2.rewriteModuleStatementsAndPrepareHeader)(e4, { exportName: "exports", constantReexports: b, enumerableModuleMeta: v, strict: f, strictMode: d, allowTopLevelThis: p2, noInterop: h3, importInterop: m, lazy: y, esNamespaceOnly: typeof r4.filename == "string" && /\.mjs$/.test(r4.filename) ? u : c });
                for (const [t4, r5] of a2.source) {
                  const n4 = o.types.callExpression(o.types.identifier("require"), [o.types.stringLiteral(t4)]);
                  let i2;
                  if ((0, s2.isSideEffectImport)(r5)) {
                    if (r5.lazy)
                      throw new Error("Assertion failure");
                    i2 = o.types.expressionStatement(n4);
                  } else {
                    const t5 = (0, s2.wrapInterop)(e4, n4, r5.interop) || n4;
                    i2 = r5.lazy ? o.template.ast`
                  function ${r5.name}() {
                    const data = ${t5};
                    ${r5.name} = function(){ return data; };
                    return data;
                  }
                ` : o.template.ast`
                  var ${r5.name} = ${t5};
                `;
                  }
                  i2.loc = r5.loc, l3.push(i2), l3.push(...(0, s2.buildNamespaceInitStatements)(a2, r5, b));
                }
                (0, s2.ensureStatementsHoisted)(l3), e4.unshiftContainer("body", l3);
              } } } };
            });
            t2.a = l;
          }, (e2, t2, r2) => {
            e2.exports = r2(503);
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            function r2(e3, t3) {
              var r3 = t3.arguments, n = function(e4, t4) {
                if (Array.isArray(e4))
                  return e4;
                if (Symbol.iterator in Object(e4))
                  return function(e5, t5) {
                    var r4 = [], n2 = true, s2 = false, i = void 0;
                    try {
                      for (var o, a = e5[Symbol.iterator](); !(n2 = (o = a.next()).done) && (r4.push(o.value), !t5 || r4.length !== t5); n2 = true)
                        ;
                    } catch (e6) {
                      s2 = true, i = e6;
                    } finally {
                      try {
                        !n2 && a.return && a.return();
                      } finally {
                        if (s2)
                          throw i;
                      }
                    }
                    return r4;
                  }(e4, t4);
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
              }(r3, 1)[0];
              return e3.isStringLiteral(n) || e3.isTemplateLiteral(n) ? (e3.removeComments(n), n) : e3.templateLiteral([e3.templateElement({ raw: "", cooked: "" }), e3.templateElement({ raw: "", cooked: "" }, true)], r3);
            }
            t2.getImportSource = r2, t2.createDynamicImportTransform = function(e3) {
              var t3 = e3.template, n = e3.types, s2 = { static: { interop: t3("Promise.resolve().then(() => INTEROP(require(SOURCE)))"), noInterop: t3("Promise.resolve().then(() => require(SOURCE))") }, dynamic: { interop: t3("Promise.resolve(SOURCE).then(s => INTEROP(require(s)))"), noInterop: t3("Promise.resolve(SOURCE).then(s => require(s))") } }, i = typeof WeakSet == "function" && new WeakSet();
              return function(e4, t4) {
                if (i) {
                  if (i.has(t4))
                    return;
                  i.add(t4);
                }
                var o, a = r2(n, t4.parent), l = (o = a, n.isStringLiteral(o) || n.isTemplateLiteral(o) && o.expressions.length === 0 ? s2.static : s2.dynamic), c = e4.opts.noInterop ? l.noInterop({ SOURCE: a }) : l.interop({ SOURCE: a, INTEROP: e4.addHelper("interopRequireWildcard") });
                t4.parentPath.replaceWith(c);
              };
            };
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(7), s2 = r2(505), i = r2(509), o = r2(316), a = r2(8), l = r2(315), c = r2(510), u = r2(83), p2 = r2(512), f = r2(84), d = r2(96), h3 = r2(518), m = r2(329), y = r2(27), g = r2(95);
            function b(e3) {
              return e3 && typeof e3 == "object" && "default" in e3 ? e3.default : e3;
            }
            function v(e3) {
              if (e3 && e3.__esModule)
                return e3;
              var t3 = Object.create(null);
              return e3 && Object.keys(e3).forEach(function(r3) {
                t3[r3] = e3[r3];
              }), t3.default = e3, Object.freeze(t3);
            }
            var E = v(s2), x = b(o), S = b(a), T = v(p2), w = b(f), P = b(d), A = b(h3), O = b(m);
            const C = /\bv-bind\(\s*(?:'([^']+)'|"([^"]+)"|([^'"][^)]*))\s*\)/g;
            function I(e3, t3, r3) {
              return `{
  ${e3.map((e4) => `"${k2(t3, e4, r3)}": (${e4})`).join(",\n  ")}
}`;
            }
            function k2(e3, t3, r3) {
              return r3 ? x(e3 + t3) : `${e3}-${t3.replace(/([^\w-])/g, "_")}`;
            }
            const N = (e3) => {
              const { id: t3, isProd: r3 } = e3;
              return { postcssPlugin: "vue-sfc-vars", Declaration(e4) {
                C.test(e4.value) && (e4.value = e4.value.replace(C, (e5, n2, s3, i2) => `var(--${k2(t3, n2 || s3 || i2, r3)})`));
              } };
            };
            function _(e3, t3, r3, n2) {
              const i2 = I(e3, r3, n2), o2 = s2.createSimpleExpression(i2, false), a2 = s2.createTransformContext(s2.createRoot([]), { prefixIdentifiers: true, inline: true, bindingMetadata: t3.__isScriptSetup === false ? void 0 : t3 }), l2 = s2.processExpression(o2, a2);
              return `_useCssVars(_ctx => (${l2.type === 4 ? l2.content : l2.children.map((e4) => typeof e4 == "string" ? e4 : e4.content).join("")}))`;
            }
            N.postcss = true;
            const j = {};
            function D(e3) {
              n !== void 0 || j[e3] || (j[e3] = true);
            }
            function L(e3, t3) {
              typeof window == "undefined" && (D(`${e3} is still an experimental proposal.
Follow its status at https://github.com/vuejs/rfcs/pull/${t3}.`), D("When using experimental features,\nit is recommended to pin your vue dependencies to exact versions to avoid breakage."));
            }
            const M = new (r2(149))(500);
            function B(e3, t3 = false) {
              const r3 = new SyntaxError(`Single file component can contain only one <${e3.tag}${t3 ? " setup" : ""}> element`);
              return r3.loc = e3.loc, r3;
            }
            function R(e3, t3, r3) {
              const n2 = e3.tag;
              let { start: s3, end: i2 } = e3.loc, o2 = "";
              e3.children.length && (s3 = e3.children[0].loc.start, i2 = e3.children[e3.children.length - 1].loc.end, o2 = t3.slice(s3.offset, i2.offset));
              const a2 = {}, l2 = { type: n2, content: o2, loc: { source: o2, start: s3, end: i2 }, attrs: a2 };
              return r3 && (l2.content = function(e4, t4, r4) {
                if (e4 = e4.slice(0, t4.loc.start.offset), r4 === "space")
                  return e4.replace($, " ");
                {
                  const r5 = e4.split(F).length, n3 = t4.type !== "script" || t4.lang ? "\n" : "//\n";
                  return Array(r5).join(n3);
                }
              }(t3, l2, r3) + l2.content), e3.props.forEach((e4) => {
                e4.type === 6 && (a2[e4.name] = e4.value && e4.value.content || true, e4.name === "lang" ? l2.lang = e4.value && e4.value.content : e4.name === "src" ? l2.src = e4.value && e4.value.content : n2 === "style" ? e4.name === "scoped" ? l2.scoped = true : e4.name === "module" && (l2.module = a2[e4.name]) : n2 === "script" && e4.name === "setup" && (l2.setup = a2.setup));
              }), l2;
            }
            const F = /\r?\n/g, U = /^(?:\/\/)?\s*$/, $ = /./g;
            function q(e3, t3, r3, n2, s3) {
              const o2 = new i.SourceMapGenerator({ file: e3.replace(/\\/g, "/"), sourceRoot: n2.replace(/\\/g, "/") });
              return o2.setSourceContent(e3, t3), r3.split(F).forEach((t4, r4) => {
                if (!U.test(t4)) {
                  const n3 = r4 + 1 + s3, i2 = r4 + 1;
                  for (let r5 = 0; r5 < t4.length; r5++)
                    /\s/.test(t4[r5]) || o2.addMapping({ source: e3, original: { line: n3, column: r5 }, generated: { line: i2, column: r5 } });
                }
              }), JSON.parse(o2.toString());
            }
            function V(e3) {
              const t3 = e3.charAt(0);
              return t3 === "." || t3 === "~" || t3 === "@";
            }
            const W = /^https?:\/\//;
            function K(e3) {
              return W.test(e3);
            }
            const G = /^\s*data:/i;
            function H(e3) {
              return G.test(e3);
            }
            function J(e3) {
              if (e3.charAt(0) === "~") {
                const t3 = e3.charAt(1);
                e3 = e3.slice(t3 === "/" ? 2 : 1);
              }
              return Y(e3);
            }
            function Y(e3) {
              return c.parse(u.isString(e3) ? e3 : "", false, true);
            }
            const X = { base: null, includeAbsolute: false, tags: { video: ["src", "poster"], source: ["src"], img: ["src"], image: ["xlink:href", "href"], use: ["xlink:href", "href"] } }, z = (e3) => (t3, r3) => Q(t3, r3, e3), Q = (e3, t3, r3 = X) => {
              if (e3.type === 1) {
                if (!e3.props.length)
                  return;
                const n2 = r3.tags || X.tags, s3 = n2[e3.tag], i2 = n2["*"];
                if (!s3 && !i2)
                  return;
                const o2 = (s3 || []).concat(i2 || []);
                e3.props.forEach((n3, s4) => {
                  if (n3.type !== 6 || !o2.includes(n3.name) || !n3.value || K(n3.value.content) || H(n3.value.content) || n3.value.content[0] === "#" || !r3.includeAbsolute && !V(n3.value.content))
                    return;
                  const i3 = J(n3.value.content);
                  if (r3.base && n3.value.content[0] === ".") {
                    const e4 = J(r3.base), t4 = e4.protocol || "", s5 = e4.host ? t4 + "//" + e4.host : "", o3 = e4.path || "/";
                    return void (n3.value.content = s5 + (S.posix || S).join(o3, i3.path + (i3.hash || "")));
                  }
                  const a2 = function(e4, t4, r4, n4) {
                    if (e4) {
                      const s5 = n4.imports.find((t5) => t5.path === e4);
                      if (s5)
                        return s5.exp;
                      const i4 = `_imports_${n4.imports.length}`, o3 = l.createSimpleExpression(i4, false, r4, 2);
                      return n4.imports.push({ exp: o3, path: e4 }), t4 && e4 ? n4.hoist(l.createSimpleExpression(`${i4} + '${t4}'`, false, r4, 2)) : o3;
                    }
                    return l.createSimpleExpression("''", false, r4, 2);
                  }(i3.path, i3.hash, n3.loc, t3);
                  e3.props[s4] = { type: 7, name: "bind", arg: l.createSimpleExpression(n3.name, true, n3.loc), exp: a2, modifiers: [], loc: n3.loc };
                });
              }
            }, Z = ["img", "source"], ee = /( |\\t|\\n|\\f|\\r)+/g, te = (e3) => (t3, r3) => re(t3, r3, e3), re = (e3, t3, r3 = X) => {
              e3.type === 1 && Z.includes(e3.tag) && e3.props.length && e3.props.forEach((n2, s3) => {
                if (n2.name === "srcset" && n2.type === 6) {
                  if (!n2.value)
                    return;
                  const i2 = n2.value.content;
                  if (!i2)
                    return;
                  const o2 = i2.split(",").map((e4) => {
                    const [t4, r4] = e4.replace(ee, " ").trim().split(" ", 2);
                    return { url: t4, descriptor: r4 };
                  });
                  for (let e4 = 0; e4 < o2.length; e4++) {
                    const { url: t4 } = o2[e4];
                    H(t4) && (o2[e4 + 1].url = t4 + "," + o2[e4 + 1].url, o2.splice(e4, 1));
                  }
                  if (!o2.some(({ url: e4 }) => !K(e4) && !H(e4) && (r3.includeAbsolute || V(e4))))
                    return;
                  if (r3.base) {
                    const e4 = r3.base, t4 = [];
                    return o2.forEach(({ url: r4, descriptor: n3 }) => {
                      n3 = n3 ? ` ${n3}` : "", V(r4) ? t4.push((S.posix || S).join(e4, r4) + n3) : t4.push(r4 + n3);
                    }), void (n2.value.content = t4.join(", "));
                  }
                  const a2 = l.createCompoundExpression([], n2.loc);
                  o2.forEach(({ url: e4, descriptor: s4 }, i3) => {
                    if (K(e4) || H(e4) || !r3.includeAbsolute && !V(e4)) {
                      const t4 = l.createSimpleExpression(`"${e4}"`, false, n2.loc, 2);
                      a2.children.push(t4);
                    } else {
                      const { path: r4 } = J(e4);
                      let s5;
                      if (r4) {
                        const e5 = t3.imports.findIndex((e6) => e6.path === r4);
                        e5 > -1 ? s5 = l.createSimpleExpression(`_imports_${e5}`, false, n2.loc, 2) : (s5 = l.createSimpleExpression(`_imports_${t3.imports.length}`, false, n2.loc, 2), t3.imports.push({ exp: s5, path: r4 })), a2.children.push(s5);
                      }
                    }
                    const c5 = o2.length - 1 > i3;
                    s4 && c5 ? a2.children.push(` + ' ${s4}, ' + `) : s4 ? a2.children.push(` + ' ${s4}'`) : c5 && a2.children.push(" + ', ' + ");
                  });
                  const c4 = t3.hoist(a2);
                  c4.constType = 2, e3.props[s3] = { type: 7, name: "bind", arg: l.createSimpleExpression("srcset", true, n2.loc), exp: c4, modifiers: [], loc: n2.loc };
                }
              });
            };
            function ne({ source: e3, filename: t3, preprocessOptions: r3 }, n2) {
              let s3 = "", i2 = null;
              if (n2.render(e3, Object.assign({ filename: t3 }, r3), (e4, t4) => {
                e4 && (i2 = e4), s3 = t4;
              }), i2)
                throw i2;
              return s3;
            }
            function se(e3) {
              const { preprocessLang: t3, preprocessCustomRequire: n2 } = e3, s3 = !!t3 && (n2 ? n2(t3) : r2(519)[t3]);
              if (!s3)
                return t3 ? { code: "export default function render() {}", source: e3.source, tips: [`Component ${e3.filename} uses lang ${t3} for template. Please install the language preprocessor.`], errors: [`Component ${e3.filename} uses lang ${t3} for template, however it is not installed.`] } : ie(e3);
              try {
                return ie(Object.assign(Object.assign({}, e3), { source: ne(e3, s3) }));
              } catch (t4) {
                return { code: "export default function render() {}", source: e3.source, tips: [], errors: [t4] };
              }
            }
            function ie({ filename: e3, id: t3, scoped: r3, slotted: n2, inMap: s3, source: o2, ssr: a2 = false, ssrCssVars: l2, isProd: c4 = false, compiler: p3 = a2 ? T : E, compilerOptions: f2 = {}, transformAssetUrls: d2 }) {
              const h4 = [], m2 = [];
              let y2 = [];
              if (u.isObject(d2)) {
                const e4 = (g2 = d2, Object.keys(g2).some((e5) => u.isArray(g2[e5])) ? Object.assign(Object.assign({}, X), { tags: g2 }) : Object.assign(Object.assign({}, X), g2));
                y2 = [z(e4), te(e4)];
              } else
                d2 !== false && (y2 = [Q, re]);
              var g2;
              a2 && !l2 && D("compileTemplate is called with `ssr: true` but no corresponding `cssVars` option.`."), t3 || (D("compileTemplate now requires the `id` option.`."), t3 = "");
              const b2 = t3.replace(/^data-v-/, ""), v2 = `data-v-${b2}`;
              let { code: x2, ast: S2, preamble: w2, map: P2 } = p3.compile(o2, Object.assign(Object.assign({ mode: "module", prefixIdentifiers: true, hoistStatic: true, cacheHandlers: true, ssrCssVars: a2 && l2 && l2.length ? I(l2, b2, c4) : "", scopeId: r3 ? v2 : void 0, slotted: n2 }, f2), { nodeTransforms: y2.concat(f2.nodeTransforms || []), filename: e3, sourceMap: true, onError: (e4) => h4.push(e4), onWarn: (e4) => m2.push(e4) }));
              s3 && (P2 && (P2 = function(e4, t4) {
                if (!e4)
                  return t4;
                if (!t4)
                  return e4;
                const r4 = new i.SourceMapConsumer(e4), n3 = new i.SourceMapConsumer(t4), s4 = new i.SourceMapGenerator();
                n3.eachMapping((e5) => {
                  if (e5.originalLine == null)
                    return;
                  const t5 = r4.originalPositionFor({ line: e5.originalLine, column: e5.originalColumn });
                  t5.source != null && s4.addMapping({ generated: { line: e5.generatedLine, column: e5.generatedColumn }, original: { line: t5.line, column: e5.originalColumn }, source: t5.source, name: t5.name });
                });
                const o3 = s4;
                return r4.sources.forEach((e5) => {
                  o3._sources.add(e5);
                  const t5 = r4.sourceContentFor(e5);
                  t5 != null && s4.setSourceContent(e5, t5);
                }), o3._sourceRoot = e4.sourceRoot, o3._file = e4.file, o3.toJSON();
              }(s3, P2)), h4.length && function(e4, t4, r4) {
                const n3 = r4.sourcesContent[0], s4 = n3.indexOf(t4), i2 = n3.slice(0, s4).split(/\r?\n/).length - 1;
                e4.forEach((e5) => {
                  e5.loc && (e5.loc.start.line += i2, e5.loc.start.offset += s4, e5.loc.end !== e5.loc.start && (e5.loc.end.line += i2, e5.loc.end.offset += s4));
                });
              }(h4, o2, s3));
              const A2 = m2.map((e4) => {
                let t4 = e4.message;
                return e4.loc && (t4 += `
${u.generateCodeFrame(o2, e4.loc.start.offset, e4.loc.end.offset)}`), t4;
              });
              return { code: x2, ast: S2, preamble: w2, source: o2, errors: h4, tips: A2, map: P2 };
            }
            const oe = () => ({ postcssPlugin: "vue-sfc-trim", Once(e3) {
              e3.walk(({ type: e4, raws: t3 }) => {
                e4 !== "rule" && e4 !== "atrule" || (t3.before && (t3.before = "\n"), "after" in t3 && t3.after && (t3.after = "\n"));
              });
            } });
            oe.postcss = true;
            const ae = /^(-\w+-)?animation-name$/, le = /^(-\w+-)?animation$/, ce = (e3 = "") => {
              const t3 = Object.create(null), r3 = e3.replace(/^data-v-/, "");
              return { postcssPlugin: "vue-sfc-scoped", Rule(t4) {
                !function(e4, t5) {
                  ue.has(t5) || t5.parent && t5.parent.type === "atrule" && /-?keyframes$/.test(t5.parent.name) || (ue.add(t5), t5.selector = P((t6) => {
                    t6.each((r4) => {
                      pe(e4, r4, t6);
                    });
                  }).processSync(t5.selector));
                }(e3, t4);
              }, AtRule(e4) {
                /-?keyframes$/.test(e4.name) && !e4.params.endsWith(`-${r3}`) && (t3[e4.params] = e4.params = e4.params + "-" + r3);
              }, OnceExit(e4) {
                Object.keys(t3).length && e4.walkDecls((e5) => {
                  ae.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => t3[e6.trim()] || e6.trim()).join(",")), le.test(e5.prop) && (e5.value = e5.value.split(",").map((e6) => {
                    const r4 = e6.trim().split(/\s+/), n2 = r4.findIndex((e7) => t3[e7]);
                    return n2 !== -1 ? (r4.splice(n2, 1, t3[r4[n2]]), r4.join(" ")) : e6;
                  }).join(","));
                });
              } };
            }, ue = new WeakSet();
            function pe(e3, t3, r3, n2 = false) {
              let s3 = null, i2 = true;
              if (t3.each((n3) => {
                if (n3.type === "combinator" && (n3.value === ">>>" || n3.value === "/deep/"))
                  return n3.value = " ", n3.spaces.before = n3.spaces.after = "", false;
                if (n3.type === "pseudo") {
                  const { value: s4 } = n3;
                  if (s4 === ":deep" || s4 === "::v-deep") {
                    if (n3.nodes.length) {
                      let e4 = n3;
                      n3.nodes[0].each((r5) => {
                        t3.insertAfter(e4, r5), e4 = r5;
                      });
                      const r4 = t3.at(t3.index(n3) - 1);
                      r4 && fe(r4) || t3.insertAfter(n3, P.combinator({ value: " " })), t3.removeChild(n3);
                    } else {
                      const e4 = t3.at(t3.index(n3) - 1);
                      e4 && fe(e4) && t3.removeChild(e4), t3.removeChild(n3);
                    }
                    return false;
                  }
                  if (s4 === ":slotted" || s4 === "::v-slotted") {
                    pe(e3, n3.nodes[0], r3, true);
                    let s5 = n3;
                    return n3.nodes[0].each((e4) => {
                      t3.insertAfter(s5, e4), s5 = e4;
                    }), t3.removeChild(n3), i2 = false, false;
                  }
                  if (s4 === ":global" || s4 === "::v-global")
                    return r3.insertAfter(t3, n3.nodes[0]), r3.removeChild(t3), false;
                }
                n3.type !== "pseudo" && n3.type !== "combinator" && (s3 = n3);
              }), s3 ? s3.spaces.after = "" : t3.first.spaces.before = "", i2) {
                const r4 = n2 ? e3 + "-s" : e3;
                t3.insertAfter(s3, P.attribute({ attribute: r4, value: r4, raws: {}, quoteMark: '"' }));
              }
            }
            function fe(e3) {
              return e3.type === "combinator" && /^\s+$/.test(e3.value);
            }
            ce.postcss = true;
            const de = (e3, t3, n2, s3 = r2(312)) => {
              const i2 = s3("sass"), o2 = Object.assign(Object.assign({}, n2), { data: me(e3, n2.filename, n2.additionalData), file: n2.filename, outFile: n2.filename, sourceMap: !!t3 });
              try {
                const e4 = i2.renderSync(o2), r3 = e4.stats.includedFiles;
                return t3 ? { code: e4.css.toString(), map: A(t3, JSON.parse(e4.map.toString())), errors: [], dependencies: r3 } : { code: e4.css.toString(), errors: [], dependencies: r3 };
              } catch (e4) {
                return { code: "", errors: [e4], dependencies: [] };
              }
            }, he = (e3, t3, n2, s3 = r2(312)) => {
              const i2 = s3("stylus");
              try {
                const r3 = i2(e3);
                Object.keys(n2).forEach((e4) => r3.set(e4, n2[e4])), t3 && r3.set("sourcemap", { inline: false, comment: false });
                const s4 = r3.render(), o2 = r3.deps();
                return t3 ? { code: s4, map: A(t3, r3.sourcemap), errors: [], dependencies: o2 } : { code: s4, errors: [], dependencies: o2 };
              } catch (e4) {
                return { code: "", errors: [e4], dependencies: [] };
              }
            };
            function me(e3, t3, r3) {
              return r3 ? u.isFunction(r3) ? r3(e3, t3) : r3 + e3 : e3;
            }
            const ye = { less: (e3, t3, n2, s3 = r2(312)) => {
              const i2 = s3("less");
              let o2, a2 = null;
              if (i2.render(me(e3, n2.filename, n2.additionalData), Object.assign(Object.assign({}, n2), { syncImport: true }), (e4, t4) => {
                a2 = e4, o2 = t4;
              }), a2)
                return { code: "", errors: [a2], dependencies: [] };
              const l2 = o2.imports;
              return t3 ? { code: o2.css.toString(), map: A(t3, o2.map), errors: [], dependencies: l2 } : { code: o2.css.toString(), errors: [], dependencies: l2 };
            }, sass: (e3, t3, r3, n2) => de(e3, t3, Object.assign(Object.assign({}, r3), { indentedSyntax: true }), n2), scss: de, styl: he, stylus: he };
            const ge = /((?:^|\n|;)\s*)export(\s*)default/, be = /((?:^|\n|;)\s*)export(.+)as(\s*)default/s, ve = /((?:^|\n|;)\s*)export\s+default\s+class\s+([\w$]+)/;
            function Ee(e3) {
              return ge.test(e3) || be.test(e3);
            }
            const xe = "defineProps", Se = "defineEmit", Te = "defineExpose", we = "withDefaults", Pe = "defineEmits";
            function Ae(e3, t3, r3) {
              e3[t3.name] = { type: r3, rangeNode: t3 };
            }
            function Oe(e3, t3, r3) {
              if (e3.type === "VariableDeclaration") {
                const n2 = e3.kind === "const";
                for (const { id: s3, init: i2 } of e3.declarations) {
                  const e4 = !(!n2 || !Fe(i2, (e5) => e5 === xe || e5 === Se || e5 === Pe || e5 === we));
                  if (s3.type === "Identifier") {
                    let o2;
                    const a2 = r3.reactive || "reactive";
                    o2 = Fe(i2, a2) ? "setup-let" : e4 || n2 && Ue(i2, a2) ? "setup-const" : n2 ? Fe(i2, r3.ref || "ref") ? "setup-ref" : "setup-maybe-ref" : "setup-let", Ae(t3, s3, o2);
                  } else
                    s3.type === "ObjectPattern" ? Ce(s3, t3, n2, e4) : s3.type === "ArrayPattern" && Ie(s3, t3, n2, e4);
                }
              } else
                e3.type !== "FunctionDeclaration" && e3.type !== "ClassDeclaration" || (t3[e3.id.name] = { type: "setup-const", rangeNode: e3.id });
            }
            function Ce(e3, t3, r3, n2 = false) {
              for (const s3 of e3.properties)
                if (s3.type === "ObjectProperty") {
                  if (s3.key.type === "Identifier")
                    if (s3.key === s3.value) {
                      const e4 = n2 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
                      Ae(t3, s3.key, e4);
                    } else
                      ke(s3.value, t3, r3, n2);
                } else {
                  const e4 = r3 ? "setup-const" : "setup-let";
                  Ae(t3, s3.argument, e4);
                }
            }
            function Ie(e3, t3, r3, n2 = false) {
              for (const s3 of e3.elements)
                s3 && ke(s3, t3, r3, n2);
            }
            function ke(e3, t3, r3, n2 = false) {
              if (e3.type === "Identifier")
                Ae(t3, e3, n2 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let");
              else if (e3.type === "RestElement") {
                const n3 = r3 ? "setup-const" : "setup-let";
                Ae(t3, e3.argument, n3);
              } else if (e3.type === "ObjectPattern")
                Ce(e3, t3, r3);
              else if (e3.type === "ArrayPattern")
                Ie(e3, t3, r3);
              else if (e3.type === "AssignmentPattern")
                if (e3.left.type === "Identifier") {
                  const s3 = n2 ? "setup-const" : r3 ? "setup-maybe-ref" : "setup-let";
                  Ae(t3, e3.left, s3);
                } else
                  ke(e3.left, t3, r3);
            }
            function Ne(e3, t3) {
              e3.type === "TSInterfaceDeclaration" ? t3[e3.id.name] = ["Object"] : e3.type === "TSTypeAliasDeclaration" ? t3[e3.id.name] = _e(e3.typeAnnotation, t3) : e3.type === "ExportNamedDeclaration" && e3.declaration && Ne(e3.declaration, t3);
            }
            function _e(e3, t3) {
              switch (e3.type) {
                case "TSStringKeyword":
                  return ["String"];
                case "TSNumberKeyword":
                  return ["Number"];
                case "TSBooleanKeyword":
                  return ["Boolean"];
                case "TSObjectKeyword":
                case "TSTypeLiteral":
                  return ["Object"];
                case "TSFunctionType":
                  return ["Function"];
                case "TSArrayType":
                case "TSTupleType":
                  return ["Array"];
                case "TSLiteralType":
                  switch (e3.literal.type) {
                    case "StringLiteral":
                      return ["String"];
                    case "BooleanLiteral":
                      return ["Boolean"];
                    case "NumericLiteral":
                    case "BigIntLiteral":
                      return ["Number"];
                    default:
                      return ["null"];
                  }
                case "TSTypeReference":
                  if (e3.typeName.type === "Identifier") {
                    if (t3[e3.typeName.name])
                      return t3[e3.typeName.name];
                    switch (e3.typeName.name) {
                      case "Array":
                      case "Function":
                      case "Object":
                      case "Set":
                      case "Map":
                      case "WeakSet":
                      case "WeakMap":
                        return [e3.typeName.name];
                      case "Record":
                      case "Partial":
                      case "Readonly":
                      case "Pick":
                      case "Omit":
                      case "Exclude":
                      case "Extract":
                      case "Required":
                      case "InstanceType":
                        return ["Object"];
                    }
                  }
                  return ["null"];
                case "TSUnionType":
                  return [...new Set([].concat(e3.types.map((e4) => _e(e4, t3))))];
                case "TSIntersectionType":
                  return ["Object"];
                default:
                  return ["null"];
              }
            }
            function je(e3, t3) {
              if (e3.type === "Identifier" && e3.typeAnnotation && e3.typeAnnotation.type === "TSTypeAnnotation") {
                const r3 = e3.typeAnnotation.typeAnnotation;
                if (r3.type === "TSLiteralType")
                  t3.add(String(r3.literal.value));
                else if (r3.type === "TSUnionType")
                  for (const e4 of r3.types)
                    e4.type === "TSLiteralType" && t3.add(String(e4.literal.value));
              }
            }
            function De(e3, t3, r3) {
              const { name: n2 } = t3;
              e3.scopeIds && e3.scopeIds.has(n2) || (n2 in r3 ? r3[n2]++ : r3[n2] = 1, (e3.scopeIds || (e3.scopeIds = new Set())).add(n2));
            }
            function Le(e3, t3) {
              const r3 = [], n2 = Object.create(null);
              g.walk(e3, { enter(e4, s3) {
                s3 && r3.push(s3), e4.type === "Identifier" ? !n2[e4.name] && function(e5, t4, r4) {
                  if (!t4)
                    return true;
                  if ((t4.type === "VariableDeclarator" || t4.type === "ClassDeclaration") && t4.id === e5)
                    return false;
                  if (Re(t4)) {
                    if (t4.id === e5)
                      return false;
                    if (t4.params.includes(e5))
                      return false;
                  }
                  return !Be(e5, t4) && (!(t4.type === "ArrayPattern" && !$e(t4, r4)) && (!!(t4.type !== "MemberExpression" && t4.type !== "OptionalMemberExpression" || t4.property !== e5 || t4.computed) && e5.name !== "arguments"));
                }(e4, s3, r3) && t3(e4, s3, r3) : Re(e4) ? (e4.body.type === "BlockStatement" && e4.body.body.forEach((t4) => {
                  if (t4.type === "VariableDeclaration")
                    for (const r4 of t4.declarations)
                      Ge(r4.id).forEach((t5) => {
                        De(e4, t5, n2);
                      });
                }), e4.params.forEach((t4) => g.walk(t4, { enter(t5, r4) {
                  t5.type !== "Identifier" || Be(t5, r4) || r4 && r4.type === "AssignmentPattern" && r4.right === t5 || De(e4, t5, n2);
                } }))) : e4.type === "ObjectProperty" && s3.type === "ObjectPattern" && (e4.inPattern = true);
              }, leave(e4, t4) {
                t4 && r3.pop(), e4.scopeIds && e4.scopeIds.forEach((e5) => {
                  n2[e5]--, n2[e5] === 0 && delete n2[e5];
                });
              } });
            }
            const Me = (e3) => e3 && (e3.type === "ObjectProperty" || e3.type === "ObjectMethod") && !e3.computed, Be = (e3, t3) => Me(t3) && t3.key === e3;
            function Re(e3) {
              return /Function(?:Expression|Declaration)$|Method$/.test(e3.type);
            }
            function Fe(e3, t3) {
              return !(!e3 || e3.type !== "CallExpression" || e3.callee.type !== "Identifier" || !(typeof t3 == "string" ? e3.callee.name === t3 : t3(e3.callee.name)));
            }
            function Ue(e3, t3) {
              if (Fe(e3, t3))
                return true;
              switch (e3.type) {
                case "UnaryExpression":
                case "BinaryExpression":
                case "ArrayExpression":
                case "ObjectExpression":
                case "FunctionExpression":
                case "ArrowFunctionExpression":
                case "UpdateExpression":
                case "ClassExpression":
                case "TaggedTemplateExpression":
                  return true;
                case "SequenceExpression":
                  return Ue(e3.expressions[e3.expressions.length - 1], t3);
                default:
                  return !!e3.type.endsWith("Literal");
              }
            }
            function $e(e3, t3) {
              if (e3 && (e3.type === "ObjectProperty" || e3.type === "ArrayPattern")) {
                let e4 = t3.length;
                for (; e4--; ) {
                  const r3 = t3[e4];
                  if (r3.type === "AssignmentExpression") {
                    const e5 = t3[0];
                    return !(e5.type === "LabeledStatement" && e5.label.name === "ref");
                  }
                  if (r3.type !== "ObjectProperty" && !r3.type.endsWith("Pattern"))
                    break;
                }
              }
              return false;
            }
            function qe(e3) {
              for (const t3 of e3)
                if (t3.type === "ExportDefaultDeclaration" && t3.declaration.type === "ObjectExpression")
                  return Ve(t3.declaration);
              return {};
            }
            function Ve(e3) {
              const t3 = {};
              Object.defineProperty(t3, "__isScriptSetup", { enumerable: false, value: false });
              for (const r3 of e3.properties)
                if (r3.type !== "ObjectProperty" || r3.computed || r3.key.type !== "Identifier") {
                  if (r3.type === "ObjectMethod" && r3.key.type === "Identifier" && (r3.key.name === "setup" || r3.key.name === "data")) {
                    for (const e4 of r3.body.body)
                      if (e4.type === "ReturnStatement" && e4.argument && e4.argument.type === "ObjectExpression")
                        for (const n2 of We(e4.argument))
                          t3[n2] = r3.key.name === "setup" ? "setup-maybe-ref" : "data";
                  }
                } else if (r3.key.name === "props")
                  for (const e4 of Ke(r3.value))
                    t3[e4] = "props";
                else if (r3.key.name === "inject")
                  for (const e4 of Ke(r3.value))
                    t3[e4] = "options";
                else if (r3.value.type === "ObjectExpression" && (r3.key.name === "computed" || r3.key.name === "methods"))
                  for (const e4 of We(r3.value))
                    t3[e4] = "options";
              return t3;
            }
            function We(e3) {
              const t3 = [];
              for (const r3 of e3.properties)
                r3.type !== "ObjectProperty" && r3.type !== "ObjectMethod" || r3.computed || (r3.key.type === "Identifier" ? t3.push(r3.key.name) : r3.key.type === "StringLiteral" && t3.push(r3.key.value));
              return t3;
            }
            function Ke(e3) {
              return e3.type === "ArrayExpression" ? function(e4) {
                const t3 = [];
                for (const r3 of e4.elements)
                  r3 && r3.type === "StringLiteral" && t3.push(r3.value);
                return t3;
              }(e3) : e3.type === "ObjectExpression" ? We(e3) : [];
            }
            function Ge(e3, t3 = []) {
              switch (e3.type) {
                case "Identifier":
                  t3.push(e3);
                  break;
                case "MemberExpression":
                  let r3 = e3;
                  for (; r3.type === "MemberExpression"; )
                    r3 = r3.object;
                  t3.push(r3);
                  break;
                case "ObjectPattern":
                  e3.properties.forEach((e4) => {
                    e4.type === "RestElement" ? Ge(e4.argument, t3) : Ge(e4.value, t3);
                  });
                  break;
                case "ArrayPattern":
                  e3.elements.forEach((e4) => {
                    e4 && Ge(e4, t3);
                  });
                  break;
                case "RestElement":
                  Ge(e3.argument, t3);
                  break;
                case "AssignmentPattern":
                  Ge(e3.left, t3);
              }
              return t3;
            }
            function He(e3) {
              return { start: e3.start, end: e3.end };
            }
            l.generateCodeFrame, y.parse, g.walk, t2.a = function(e3, t3) {
              let { script: r3, scriptSetup: n2, source: s3, filename: i2 } = e3;
              const o2 = !!t3.refSugar, a2 = !!t3.parseOnly;
              n2 ? !a2 && L("<script setup>", 227) : a2 && (n2 = { type: "script", content: "", attrs: {}, loc: l.locStub }), t3 || (t3 = { id: "" }), t3.id || D("compileScript now requires passing the `id` option.\nUpgrade your vite or vue-loader version for compatibility with the latest experimental proposals."), e3.template && e3.template.attrs["inherit-attrs"] === "false" && D('experimetnal support for <template inherit-attrs="false"> support has been removed. Use a <script> block with `export default` to declare options.');
              const c4 = t3.id ? t3.id.replace(/^data-v-/, "") : "", p3 = e3.cssVars, f2 = r3 && r3.lang, d2 = n2 && n2.lang, h4 = f2 === "ts" || f2 === "tsx" || d2 === "ts" || d2 === "tsx", m2 = [...u.babelParserDefaultPlugins, "jsx"];
              if (t3.babelParserPlugins && m2.push(...t3.babelParserPlugins), h4 && m2.push("typescript", "decorators-legacy"), !n2) {
                if (!r3)
                  throw new Error("[@vue/compiler-sfc] SFC contains no <script> tags.");
                if (f2 && !h4 && f2 !== "jsx")
                  return r3;
                try {
                  const e4 = y.parse(r3.content, { plugins: m2, sourceType: "module", errorRecovery: a2 }).program.body, n3 = qe(e4);
                  let s4 = r3.content;
                  return p3.length && (s4 = function(e5, t4, r4) {
                    if (!Ee(e5))
                      return e5 + `
const ${t4} = {}`;
                    let n4;
                    const s5 = e5.match(ve);
                    if (n4 = s5 ? e5.replace(ve, "$1class $2") + `
const ${t4} = ${s5[2]}` : e5.replace(ge, `$1const ${t4} =`), !Ee(n4))
                      return n4;
                    const i3 = new O(e5);
                    return y.parse(e5, { sourceType: "module", plugins: r4 }).program.body.forEach((r5) => {
                      r5.type === "ExportDefaultDeclaration" && i3.overwrite(r5.start, r5.declaration.start, `const ${t4} = `), r5.type === "ExportNamedDeclaration" && r5.specifiers.forEach((r6) => {
                        if (r6.type === "ExportSpecifier" && r6.exported.type === "Identifier" && r6.exported.name === "default") {
                          const n5 = r6.end;
                          i3.overwrite(r6.start, e5.charAt(n5) === "," ? n5 + 1 : n5, ""), i3.append(`
const ${t4} = ${r6.local.name}`);
                        }
                      });
                    }), i3.toString();
                  }(s4, "__default__", m2), p3.length && (s4 += function(e5, t4, r4, n4) {
                    return `
import { useCssVars as _useCssVars } from 'vue'
const __injectCSSVars__ = () => {
${_(e5, t4, r4, n4)}}
const __setup__ = __default__.setup
__default__.setup = __setup__
  ? (props, ctx) => { __injectCSSVars__();return __setup__(props, ctx) }
  : __injectCSSVars__
`;
                  }(p3, n3, c4, !!t3.isProd)), s4 += "\nexport default __default__"), Object.assign(Object.assign({}, r3), { content: s4, bindings: n3, scriptAst: e4 });
                } catch (e4) {
                  return r3;
                }
              }
              if (r3 && f2 !== d2)
                throw new Error("[@vue/compiler-sfc] <script> and <script setup> must have the same language type.");
              if (d2 && !h4 && d2 !== "jsx")
                return n2;
              const b2 = {}, v2 = a2 ? { scriptBindings: [], scriptSetupBindings: [] } : void 0, E2 = new Set(), x2 = Object.create(null), S2 = Object.create(null), T2 = Object.create(null), w2 = Object.create(null), P2 = new Set();
              let A2, C2, I2, k3, N2, j2, M2, B2, R2, F2, U2 = false, $2 = false, q2 = false, V2 = false, W2 = false;
              const K2 = {}, G2 = new Set(), H2 = {}, J2 = new O(s3), Y2 = n2.loc.start.offset, X2 = n2.loc.end.offset, z2 = r3 && r3.loc.start.offset, Q2 = r3 && r3.loc.end.offset;
              function Z2(e4) {
                return E2.add(e4), `_${e4}`;
              }
              function ee2(t4, r4, n3) {
                try {
                  return r4.errorRecovery = a2, y.parse(t4, r4).program.body;
                } catch (t5) {
                  throw t5.message = `[@vue/compiler-sfc] ${t5.message}

${e3.filename}
${u.generateCodeFrame(s3, t5.pos + n3, t5.pos + n3 + 1)}`, t5;
                }
              }
              function te2(t4, r4, n3 = r4.end + Y2) {
                throw new Error(`[@vue/compiler-sfc] ${t4}

${e3.filename}
${u.generateCodeFrame(s3, r4.start + Y2, n3)}`);
              }
              function re2(e4, t4, r4, n3, s4, i3) {
                e4 === "vue" && r4 && (S2[r4] = t4), x2[t4] = { isType: n3, imported: r4 || "default", source: e4, rangeNode: i3, isFromSetup: s4 };
              }
              function ne2(e4) {
                return !!Fe(e4, xe) && (U2 && te2("duplicate defineProps() call", e4), U2 = true, C2 = e4.arguments[0], e4.typeParameters && (C2 && te2("defineProps() cannot accept both type and non-type arguments at the same time. Use one or the other.", e4), N2 = e4.typeParameters.params[0], k3 = ae2(N2, (e5) => e5.type === "TSTypeLiteral"), k3 || te2("type argument passed to defineProps() must be a literal type, or a reference to an interface or literal type.", N2)), true);
              }
              function ie2(e4) {
                return !!Fe(e4, we) && (ne2(e4.arguments[0]) ? (C2 && te2("withDefaults can only be used with type-based defineProps declaration.", e4), I2 = e4.arguments[1]) : te2("withDefaults' first argument must be a defineProps call.", e4.arguments[0] || e4), true);
              }
              function oe2(e4) {
                return !!Fe(e4, (e5) => e5 === Se || e5 === Pe) && ($2 && te2("duplicate defineEmits() call", e4), $2 = true, M2 = e4.arguments[0], e4.typeParameters && (M2 && te2("defineEmit() cannot accept both type and non-type arguments at the same time. Use one or the other.", e4), R2 = e4.typeParameters.params[0], B2 = ae2(R2, (e5) => e5.type === "TSFunctionType" || e5.type === "TSTypeLiteral"), B2 || te2("type argument passed to defineEmits() must be a function type, a literal type with call signatures, or a reference to the above types.", R2)), true);
              }
              function ae2(e4, t4) {
                if (t4(e4))
                  return e4;
                if (e4.type === "TSTypeReference" && e4.typeName.type === "Identifier") {
                  const r4 = e4.typeName.name, n3 = (e5) => e5.type === "TSInterfaceDeclaration" && e5.id.name === r4 ? e5.body : e5.type === "TSTypeAliasDeclaration" && e5.id.name === r4 && t4(e5.typeAnnotation) ? e5.typeAnnotation : e5.type === "ExportNamedDeclaration" && e5.declaration ? n3(e5.declaration) : void 0;
                  for (const e5 of me2) {
                    const t5 = n3(e5);
                    if (t5)
                      return t5;
                  }
                }
              }
              function le2(e4) {
                return !!Fe(e4, Te) && (q2 && te2("duplicate defineExpose() call", e4), q2 = true, true);
              }
              function ce2(e4, t4) {
                e4 && Le(e4, (e5) => {
                  T2[e5.name] && te2(`\`${t4}()\` in <script setup> cannot reference locally declared variables because it will be hoisted outside of the setup() function. If your component options requires initialization in the module scope, use a separate normal <script> to export the options instead.`, e5);
                });
              }
              function ue2(e4, t4) {
                if (e4.type === "AssignmentExpression") {
                  const { left: r4, right: n3 } = e4;
                  if (r4.type === "Identifier")
                    pe2(r4), J2.prependRight(n3.start + Y2, `${Z2("ref")}(`), J2.appendLeft(n3.end + Y2, ")");
                  else if (r4.type === "ObjectPattern") {
                    for (let e5 = r4.start; e5 > 0; e5--)
                      if (s3[e5 + Y2] === "(") {
                        J2.remove(e5 + Y2, e5 + Y2 + 1);
                        break;
                      }
                    for (let e5 = n3.end; e5 > 0; e5++)
                      if (s3[e5 + Y2] === ")") {
                        J2.remove(e5 + Y2, e5 + Y2 + 1);
                        break;
                      }
                    fe2(r4, t4);
                  } else
                    r4.type === "ArrayPattern" && de2(r4, t4);
                } else
                  e4.type === "SequenceExpression" ? e4.expressions.forEach((e5) => ue2(e5, t4)) : e4.type === "Identifier" ? (pe2(e4), J2.appendLeft(e4.end + Y2, ` = ${Z2("ref")}()`)) : te2("ref: statements can only contain assignment expressions.", e4);
              }
              function pe2(e4) {
                e4.name[0] === "$" && te2("ref variable identifiers cannot start with $.", e4), w2[e4.name] = T2[e4.name] = { type: "setup-ref", rangeNode: e4 }, P2.add(e4);
              }
              function fe2(e4, t4) {
                for (const r4 of e4.properties) {
                  let e5;
                  r4.type === "ObjectProperty" ? r4.key.start === r4.value.start ? (e5 = r4.key, J2.appendLeft(e5.end + Y2, `: __${e5.name}`), r4.value.type === "AssignmentPattern" && P2.add(r4.value.left)) : r4.value.type === "Identifier" ? (e5 = r4.value, J2.prependRight(e5.start + Y2, "__")) : r4.value.type === "ObjectPattern" ? fe2(r4.value, t4) : r4.value.type === "ArrayPattern" ? de2(r4.value, t4) : r4.value.type === "AssignmentPattern" && (e5 = r4.value.left, J2.prependRight(e5.start + Y2, "__")) : (e5 = r4.argument, J2.prependRight(e5.start + Y2, "__")), e5 && (pe2(e5), J2.appendLeft(t4.end + Y2, `
const ${e5.name} = ${Z2("ref")}(__${e5.name});`));
                }
              }
              function de2(e4, t4) {
                for (const r4 of e4.elements) {
                  if (!r4)
                    continue;
                  let e5;
                  r4.type === "Identifier" ? e5 = r4 : r4.type === "AssignmentPattern" ? e5 = r4.left : r4.type === "RestElement" ? e5 = r4.argument : r4.type === "ObjectPattern" ? fe2(r4, t4) : r4.type === "ArrayPattern" && de2(r4, t4), e5 && (pe2(e5), J2.prependRight(e5.start + Y2, "__"), J2.appendLeft(t4.end + Y2, `
const ${e5.name} = ${Z2("ref")}(__${e5.name});`));
                }
              }
              let he2;
              if (r3) {
                he2 = ee2(r3.content, { plugins: m2, sourceType: "module" }, z2);
                for (const e4 of he2)
                  if (e4.type === "ImportDeclaration")
                    for (const t4 of e4.specifiers) {
                      const r4 = t4.type === "ImportSpecifier" && t4.imported.type === "Identifier" && t4.imported.name;
                      re2(e4.source.value, t4.local.name, r4, e4.importKind === "type", false, t4.local);
                    }
                  else if (e4.type === "ExportDefaultDeclaration") {
                    A2 = e4;
                    const t4 = e4.start + z2;
                    J2.overwrite(t4, t4 + "export default".length, "const __default__ =");
                  } else if (e4.type === "ExportNamedDeclaration" && e4.specifiers) {
                    const t4 = e4.specifiers.find((e5) => e5.exported.type === "Identifier" && e5.exported.name === "default");
                    t4 && (A2 = e4, e4.specifiers.length > 1 ? J2.remove(t4.start + z2, t4.end + z2) : J2.remove(e4.start + z2, e4.end + z2), e4.source ? J2.prepend(`import { ${t4.local.name} as __default__ } from '${e4.source.value}'
`) : J2.append(`
const __default__ = ${t4.local.name}
`));
                  }
              }
              const me2 = ee2(n2.content, { plugins: [...m2, "topLevelAwait"], sourceType: "module" }, Y2);
              for (const e4 of me2) {
                const t4 = e4.start + Y2;
                let r4 = e4.end + Y2;
                for (e4.trailingComments && e4.trailingComments.length > 0 && (r4 = e4.trailingComments[e4.trailingComments.length - 1].end + Y2); r4 <= s3.length && /\s/.test(s3.charAt(r4)); )
                  r4++;
                if (e4.type === "LabeledStatement" && e4.label.name === "ref" && e4.body.type === "ExpressionStatement" && (o2 ? (!a2 && L("ref: sugar", 228), J2.overwrite(e4.label.start + Y2, e4.body.start + Y2, "const "), ue2(e4.body.expression, e4)) : te2("ref: sugar now needs to be explicitly enabled via @vitejs/plugin-vue or vue-loader options:\n- @vitejs/plugin-vue: via `script.refSugar`\n- vue-loader: via `refSugar` (requires 16.3.0+)", e4)), e4.type === "ImportDeclaration") {
                  J2.move(t4, r4, 0);
                  let n3 = 0;
                  const s4 = (t5) => {
                    const r5 = t5 > n3;
                    n3++;
                    const s5 = e4.specifiers[t5], i3 = e4.specifiers[t5 + 1];
                    J2.remove(r5 ? e4.specifiers[t5 - 1].end + Y2 : s5.start + Y2, i3 && !r5 ? i3.start + Y2 : s5.end + Y2);
                  };
                  for (let t5 = 0; t5 < e4.specifiers.length; t5++) {
                    const r5 = e4.specifiers[t5], n4 = r5.local.name, i3 = r5.type === "ImportSpecifier" && r5.imported.type === "Identifier" && r5.imported.name, o3 = e4.source.value, a3 = x2[n4];
                    o3 !== "vue" || i3 !== xe && i3 !== Se && i3 !== Pe && i3 !== Te ? a3 ? a3.source === o3 && a3.imported === i3 ? s4(t5) : te2("different imports aliased to same local name.", r5) : re2(o3, n4, i3, e4.importKind === "type", true, r5.local) : (D(`\`${i3}\` is a compiler macro and no longer needs to be imported.`), s4(t5));
                  }
                  e4.specifiers.length && n3 === e4.specifiers.length && J2.remove(e4.start + Y2, e4.end + Y2);
                }
                if (e4.type === "ExpressionStatement") {
                  if (ne2(e4.expression) || oe2(e4.expression) || ie2(e4.expression))
                    J2.remove(e4.start + Y2, e4.end + Y2);
                  else if (le2(e4.expression)) {
                    const t5 = e4.expression.callee;
                    J2.overwrite(t5.start + Y2, t5.end + Y2, "expose");
                  }
                }
                if (e4.type === "VariableDeclaration" && !e4.declare) {
                  const t5 = e4.declarations.length;
                  let r5 = t5;
                  for (let s4 = 0; s4 < t5; s4++) {
                    const i3 = e4.declarations[s4];
                    if (i3.init) {
                      const o3 = ne2(i3.init) || ie2(i3.init);
                      o3 && (j2 = n2.content.slice(i3.id.start, i3.id.end));
                      const a3 = oe2(i3.init);
                      if (a3 && (F2 = n2.content.slice(i3.id.start, i3.id.end)), o3 || a3)
                        if (r5 === 1)
                          J2.remove(e4.start + Y2, e4.end + Y2);
                        else {
                          let n3 = i3.start + Y2, o4 = i3.end + Y2;
                          s4 < t5 - 1 ? o4 = e4.declarations[s4 + 1].start + Y2 : n3 = e4.declarations[s4 - 1].end + Y2, J2.remove(n3, o4), r5--;
                        }
                    }
                  }
                }
                e4.type !== "VariableDeclaration" && e4.type !== "FunctionDeclaration" && e4.type !== "ClassDeclaration" || e4.declare || Oe(e4, T2, S2), (e4.type === "VariableDeclaration" && !e4.declare || e4.type.endsWith("Statement")) && g.walk(e4, { enter(e5) {
                  Re(e5) && this.skip(), e5.type === "AwaitExpression" && (V2 = true, J2.prependRight(e5.argument.start + Y2, Z2("withAsyncContext") + "("), J2.appendLeft(e5.argument.end + Y2, ")"));
                } }), (e4.type === "ExportNamedDeclaration" && e4.exportKind !== "type" || e4.type === "ExportAllDeclaration" || e4.type === "ExportDefaultDeclaration") && te2("<script setup> cannot contain ES module exports. If you are using a previous version of <script setup>, please consult the updated RFC at https://github.com/vuejs/rfcs/pull/227.", e4), h4 && (e4.type !== "TSEnumDeclaration" || e4.const || Ae(T2, e4.id, "setup-const"), (e4.type.startsWith("TS") || e4.type === "ExportNamedDeclaration" && e4.exportKind === "type" || e4.type === "VariableDeclaration" && e4.declare) && (Ne(e4, H2), J2.move(t4, r4, 0)));
              }
              if (a2) {
                for (const e4 in x2) {
                  const { rangeNode: t4, isFromSetup: r4 } = x2[e4];
                  (r4 ? v2.scriptSetupBindings : v2.scriptBindings).push(He(t4));
                }
                for (const e4 in T2)
                  v2.scriptSetupBindings.push(He(T2[e4].rangeNode));
                return C2 && (v2.propsRuntimeArg = He(C2)), N2 && (v2.propsTypeArg = He(N2)), M2 && (v2.emitsRuntimeArg = He(M2)), R2 && (v2.emitsTypeArg = He(R2)), I2 && (v2.withDefaultsArg = He(I2)), Object.assign(Object.assign({}, n2), { ranges: v2, scriptAst: he2, scriptSetupAst: me2 });
              }
              if (o2 && Object.keys(w2).length)
                for (const e4 of me2)
                  e4.type !== "ImportDeclaration" && Le(e4, (e5, t4, r4) => {
                    w2[e5.name] && !P2.has(e5) ? Me(t4) && t4.shorthand ? t4.inPattern && !$e(t4, r4) || J2.appendLeft(e5.end + Y2, `: ${e5.name}.value`) : J2.appendLeft(e5.end + Y2, ".value") : e5.name[0] === "$" && w2[e5.name.slice(1)] && J2.remove(e5.start + Y2, e5.start + Y2 + 1);
                  });
              if (k3 && function(e4, t4, r4) {
                const n3 = e4.type === "TSTypeLiteral" ? e4.members : e4.body;
                for (const e5 of n3)
                  if ((e5.type === "TSPropertySignature" || e5.type === "TSMethodSignature") && e5.key.type === "Identifier") {
                    let n4;
                    e5.type === "TSMethodSignature" ? n4 = ["Function"] : e5.typeAnnotation && (n4 = _e(e5.typeAnnotation.typeAnnotation, r4)), t4[e5.key.name] = { key: e5.key.name, required: !e5.optional, type: n4 || ["null"] };
                  }
              }(k3, K2, H2), B2 && function(e4, t4) {
                if (e4.type !== "TSTypeLiteral" && e4.type !== "TSInterfaceBody")
                  je(e4.parameters[0], t4);
                else {
                  const r4 = e4.type === "TSTypeLiteral" ? e4.members : e4.body;
                  for (let e5 of r4)
                    e5.type === "TSCallSignatureDeclaration" && je(e5.parameters[0], t4);
                }
              }(B2, G2), ce2(C2, xe), ce2(I2, xe), ce2(M2, xe), r3 ? Y2 < z2 ? (J2.remove(0, Y2), J2.remove(X2, z2), J2.remove(Q2, s3.length)) : (J2.remove(0, z2), J2.remove(Q2, Y2), J2.remove(X2, s3.length)) : (J2.remove(0, Y2), J2.remove(X2, s3.length)), he2 && Object.assign(b2, qe(he2)), C2)
                for (const e4 of Ke(C2))
                  b2[e4] = "props";
              for (const e4 in K2)
                b2[e4] = "props";
              for (const [e4, { isType: t4, imported: r4, source: n3 }] of Object.entries(x2))
                t4 || (b2[e4] = r4 === "default" && n3.endsWith(".vue") || n3 === "vue" ? "setup-const" : "setup-maybe-ref");
              for (const e4 in T2)
                b2[e4] = T2[e4].type;
              p3.length && (E2.add("useCssVars"), E2.add("unref"), J2.prependRight(Y2, `
${_(p3, b2, c4, !!t3.isProd)}
`));
              let ye2 = "__props";
              k3 && (ye2 += `: ${n2.content.slice(k3.start, k3.end)}`), j2 && J2.prependRight(Y2, `
const ${j2} = __props`);
              const be2 = q2 || !t3.inlineTemplate ? ["expose"] : [];
              let Ce2;
              if (F2 && be2.push(F2 === "emit" ? "emit" : `emit: ${F2}`), be2.length && (ye2 += `, { ${be2.join(", ")} }`, B2 && (ye2 += `: { emit: (${n2.content.slice(B2.start, B2.end)}), expose: any, slots: any, attrs: any }`)), t3.inlineTemplate)
                if (e3.template && !e3.template.src) {
                  t3.templateOptions && t3.templateOptions.ssr && (W2 = true);
                  const { code: r4, ast: n3, preamble: o3, tips: a3, errors: p4 } = se(Object.assign(Object.assign({ filename: i2, source: e3.template.content, inMap: e3.template.map }, t3.templateOptions), { id: c4, scoped: e3.styles.some((e4) => e4.scoped), isProd: t3.isProd, ssrCssVars: e3.cssVars, compilerOptions: Object.assign(Object.assign({}, t3.templateOptions && t3.templateOptions.compilerOptions), { inline: true, isTS: h4, bindingMetadata: b2 }) }));
                  a3.length && a3.forEach(D);
                  const f3 = p4[0];
                  if (typeof f3 == "string")
                    throw new Error(f3);
                  if (f3)
                    throw f3.loc && (f3.message += "\n\n" + e3.filename + "\n" + u.generateCodeFrame(s3, f3.loc.start.offset, f3.loc.end.offset) + "\n"), f3;
                  o3 && J2.prepend(o3), n3 && n3.helpers.includes(l.UNREF) && E2.delete("unref"), Ce2 = r4;
                } else
                  Ce2 = "() => {}";
              else {
                const e4 = Object.assign({}, T2);
                for (const t4 in x2)
                  x2[t4].isType || (e4[t4] = true);
                Ce2 = `{ ${Object.keys(e4).join(", ")} }`;
              }
              t3.inlineTemplate ? J2.appendRight(X2, `
return ${Ce2}
}

`) : J2.appendRight(X2, `
const __returned__ = ${Ce2}
Object.defineProperty(__returned__, '__isScriptSetup', { enumerable: false, value: true })
return __returned__
}

`);
              let Ie2 = "";
              var ke2;
              W2 && (Ie2 += "\n  __ssrInlineRender: true,"), C2 ? Ie2 += `
  props: ${n2.content.slice(C2.start, C2.end).trim()},` : k3 && (Ie2 += function(e4) {
                const t4 = Object.keys(e4);
                if (!t4.length)
                  return "";
                const r4 = I2 && I2.type === "ObjectExpression" && I2.properties.every((e5) => e5.type === "ObjectProperty" && !e5.computed);
                let n3 = `{
    ${t4.map((t5) => {
                  let n4;
                  if (r4) {
                    const e5 = I2.properties.find((e6) => e6.key.name === t5);
                    e5 && (n4 = `default: ${s3.slice(e5.value.start + Y2, e5.value.end + Y2)}`);
                  }
                  {
                    const { type: r5, required: s4 } = e4[t5];
                    return `${t5}: { type: ${i3 = r5, i3.some((e5) => e5 === "null") ? "null" : i3.length > 1 ? `[${i3.join(", ")}]` : i3[0]}, required: ${s4}${n4 ? `, ${n4}` : ""} }`;
                  }
                  var i3;
                }).join(",\n    ")}
  }`;
                return I2 && !r4 && (n3 = `${Z2("mergeDefaults")}(${n3}, ${s3.slice(I2.start + Y2, I2.end + Y2)})`), `
  props: ${n3} as unknown as undefined,`;
              }(K2)), M2 ? Ie2 += `
  emits: ${n2.content.slice(M2.start, M2.end).trim()},` : B2 && (Ie2 += (ke2 = G2).size ? `
  emits: [${Array.from(ke2).map((e4) => JSON.stringify(e4)).join(", ")}] as unknown as undefined,` : "");
              const De2 = q2 || t3.inlineTemplate ? "" : "  expose()\n";
              if (h4) {
                const e4 = A2 ? "\n  ...__default__," : "";
                J2.prependLeft(Y2, `
export default ${Z2("defineComponent")}({${e4}${Ie2}
  ${V2 ? "async " : ""}setup(${ye2}) {
${De2}`), J2.appendRight(X2, "})");
              } else
                A2 ? (J2.prependLeft(Y2, `
${V2 ? "async " : ""}function setup(${ye2}) {
`), J2.append(`
export default /*#__PURE__*/ Object.assign(__default__, {${Ie2}
  setup
})
`)) : (J2.prependLeft(Y2, `
export default {${Ie2}
  ${V2 ? "async " : ""}setup(${ye2}) {
${De2}`), J2.appendRight(X2, "}"));
              return E2.size > 0 && J2.prepend(`import { ${[...E2].map((e4) => `${e4} as _${e4}`).join(", ")} } from 'vue'
`), J2.trim(), Object.assign(Object.assign({}, n2), { bindings: b2, content: J2.toString(), map: J2.generateMap({ source: i2, hires: true, includeContent: true }), scriptAst: he2, scriptSetupAst: me2 });
            }, t2.b = function(e3) {
              return function(e4) {
                const { filename: t3, id: n2, scoped: s3 = false, trim: i2 = true, isProd: o2 = false, modules: a2 = false, modulesOptions: l2 = {}, preprocessLang: c4, postcssOptions: u2, postcssPlugins: p3 } = e4, f2 = c4 && ye[c4], d2 = f2 && function(e5, t4) {
                  return t4(e5.source, e5.inMap || e5.map, Object.assign({ filename: e5.filename }, e5.preprocessOptions), e5.preprocessCustomRequire);
                }(e4, f2), h4 = d2 ? d2.map : e4.inMap || e4.map, m2 = d2 ? d2.code : e4.source, y2 = n2.replace(/^data-v-/, ""), g2 = `data-v-${y2}`, b2 = (p3 || []).slice();
                let v2;
                if (b2.unshift(N({ id: y2, isProd: o2 })), i2 && b2.push(oe()), s3 && b2.push(ce(g2)), a2) {
                  if (!e4.isAsync)
                    throw new Error("[@vue/compiler-sfc] `modules` option can only be used with compileStyleAsync().");
                  b2.push(r2(310)(Object.assign(Object.assign({}, l2), { getJSON: (e5, t4) => {
                    v2 = t4;
                  } })));
                }
                const E2 = Object.assign(Object.assign({}, u2), { to: t3, from: t3 });
                let x2, S2, T2;
                h4 && (E2.map = { inline: false, annotation: false, prev: h4 });
                const P2 = new Set(d2 ? d2.dependencies : []);
                P2.delete(t3);
                const A2 = [];
                d2 && d2.errors.length && A2.push(...d2.errors);
                const O2 = (e5) => (e5.forEach((e6) => {
                  e6.type === "dependency" && P2.add(e6.file);
                }), P2);
                try {
                  if (x2 = w(b2).process(m2, E2), e4.isAsync)
                    return x2.then((e5) => ({ code: e5.css || "", map: e5.map && e5.map.toJSON(), errors: A2, modules: v2, rawResult: e5, dependencies: O2(e5.messages) })).catch((e5) => ({ code: "", map: void 0, errors: [...A2, e5], rawResult: void 0, dependencies: P2 }));
                  O2(x2.messages), S2 = x2.css, T2 = x2.map;
                } catch (e5) {
                  A2.push(e5);
                }
                return { code: S2 || "", map: T2 && T2.toJSON(), errors: A2, rawResult: x2, dependencies: P2 };
              }(Object.assign(Object.assign({}, e3), { isAsync: true }));
            }, t2.c = se, t2.d = function(e3, { sourceMap: t3 = true, filename: r3 = "anonymous.vue", sourceRoot: n2 = "", pad: s3 = false, compiler: i2 = E } = {}) {
              const o2 = e3 + t3 + r3 + n2 + s3 + i2.parse, a2 = M.get(o2);
              if (a2)
                return a2;
              const l2 = { filename: r3, source: e3, template: null, script: null, scriptSetup: null, styles: [], customBlocks: [], cssVars: [], slotted: false }, c4 = [];
              if (i2.parse(e3, { isNativeTag: () => true, isPreTag: () => true, getTextMode: ({ tag: e4, props: t4 }, r4) => !r4 && e4 !== "template" || e4 === "template" && t4.some((e5) => e5.type === 6 && e5.name === "lang" && e5.value && e5.value.content && e5.value.content !== "html") ? 2 : 0, onError: (e4) => {
                c4.push(e4);
              } }).children.forEach((t4) => {
                if (t4.type === 1 && (t4.children.length || function(e4) {
                  return e4.props.some((e5) => e5.type === 6 && e5.name === "src");
                }(t4) || t4.tag === "template"))
                  switch (t4.tag) {
                    case "template":
                      if (l2.template)
                        c4.push(B(t4));
                      else {
                        const r5 = l2.template = R(t4, e3, false);
                        if (r5.ast = t4, r5.attrs.functional) {
                          const e4 = new SyntaxError("<template functional> is no longer supported in Vue 3, since functional components no longer have significant performance difference from stateful ones. Just use a normal <template> instead.");
                          e4.loc = t4.props.find((e5) => e5.name === "functional").loc, c4.push(e4);
                        }
                      }
                      break;
                    case "script":
                      const r4 = R(t4, e3, s3), n3 = !!r4.attrs.setup;
                      if (n3 && !l2.scriptSetup) {
                        l2.scriptSetup = r4;
                        break;
                      }
                      if (!n3 && !l2.script) {
                        l2.script = r4;
                        break;
                      }
                      c4.push(B(t4, n3));
                      break;
                    case "style":
                      const i3 = R(t4, e3, s3);
                      i3.attrs.vars && c4.push(new SyntaxError("<style vars> has been replaced by a new proposal: https://github.com/vuejs/rfcs/pull/231")), l2.styles.push(i3);
                      break;
                    default:
                      l2.customBlocks.push(R(t4, e3, s3));
                  }
              }), l2.scriptSetup && (l2.scriptSetup.src && (c4.push(new SyntaxError('<script setup> cannot use the "src" attribute because its syntax will be ambiguous outside of the component.')), l2.scriptSetup = null), l2.script && l2.script.src && (c4.push(new SyntaxError('<script> cannot use the "src" attribute when <script setup> is also present because they must be processed together.')), l2.script = null)), t3) {
                const t4 = (t5) => {
                  t5 && !t5.src && (t5.map = q(r3, e3, t5.content, n2, s3 && t5.type !== "template" ? 0 : t5.loc.start.line - 1));
                };
                t4(l2.template), t4(l2.script), l2.styles.forEach(t4), l2.customBlocks.forEach(t4);
              }
              l2.cssVars = function(e4) {
                const t4 = [];
                return e4.styles.forEach((e5) => {
                  let r4;
                  for (; r4 = C.exec(e5.content); )
                    t4.push(r4[1] || r4[2] || r4[3]);
                }), t4;
              }(l2), l2.cssVars.length && L("v-bind() CSS variable injection", 231);
              const u2 = /(?:::v-|:)slotted\(/;
              l2.slotted = l2.styles.some((e4) => e4.scoped && u2.test(e4.content));
              const p3 = { descriptor: l2, errors: c4 };
              return M.set(o2, p3), p3;
            };
          }, (e2, t2, r2) => {
            "use strict";
            e2.exports = r2(314);
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = r2(83), s2 = r2(508), i = r2(27), o = r2(95);
            function a(e3) {
              throw e3;
            }
            function l(e3) {
            }
            function c(e3, t3, r3, n2) {
              const s3 = (r3 || u)[e3] + (n2 || ""), i2 = new SyntaxError(String(s3));
              return i2.code = e3, i2.loc = t3, i2;
            }
            const u = { 0: "Illegal comment.", 1: "CDATA section is allowed only in XML context.", 2: "Duplicate attribute.", 3: "End tag cannot have attributes.", 4: "Illegal '/' in tags.", 5: "Unexpected EOF in tag.", 6: "Unexpected EOF in CDATA section.", 7: "Unexpected EOF in comment.", 8: "Unexpected EOF in script.", 9: "Unexpected EOF in tag.", 10: "Incorrectly closed comment.", 11: "Incorrectly opened comment.", 12: "Illegal tag name. Use '&lt;' to print '<'.", 13: "Attribute value was expected.", 14: "End tag name was expected.", 15: "Whitespace was expected.", 16: "Unexpected '<!--' in comment.", 17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`, 18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).", 19: "Attribute name cannot start with '='.", 21: "'<?' is allowed only in XML context.", 20: "Unexpected null cahracter.", 22: "Illegal '/' in tags.", 23: "Invalid end tag.", 24: "Element is missing end tag.", 25: "Interpolation end sign was not found.", 26: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.", 27: "v-if/v-else-if is missing expression.", 28: "v-if/else branches must use unique keys.", 29: "v-else/v-else-if has no adjacent v-if.", 30: "v-for is missing expression.", 31: "v-for has invalid expression.", 32: "<template v-for> key should be placed on the <template> tag.", 33: "v-bind is missing expression.", 34: "v-on is missing expression.", 35: "Unexpected custom directive on <slot> outlet.", 36: "Mixed v-slot usage on both the component and nested <template>.When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.", 37: "Duplicate slot names found. ", 38: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.", 39: "v-slot can only be used on components or <template> tags.", 40: "v-model is missing expression.", 41: "v-model value must be a valid JavaScript member expression.", 42: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.", 43: "Error parsing JavaScript expression: ", 44: "<KeepAlive> expects exactly one child component.", 45: '"prefixIdentifiers" option is not supported in this build of compiler.', 46: "ES module mode is not supported in this build of compiler.", 47: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.', 48: '"scopeId" option is only supported in module mode.', 49: "" }, p2 = Symbol(""), f = Symbol(""), d = Symbol(""), h3 = Symbol(""), m = Symbol(""), y = Symbol(""), g = Symbol(""), b = Symbol(""), v = Symbol(""), E = Symbol(""), x = Symbol(""), S = Symbol(""), T = Symbol(""), w = Symbol(""), P = Symbol(""), A = Symbol(""), O = Symbol(""), C = Symbol(""), I = Symbol(""), k2 = Symbol(""), N = Symbol(""), _ = Symbol(""), j = Symbol(""), D = Symbol(""), L = Symbol(""), M = Symbol(""), B = Symbol(""), R = Symbol(""), F = Symbol(""), U = Symbol(""), $ = Symbol(""), q = Symbol(""), V = { [p2]: "Fragment", [f]: "Teleport", [d]: "Suspense", [h3]: "KeepAlive", [m]: "BaseTransition", [y]: "openBlock", [g]: "createBlock", [b]: "createVNode", [v]: "createCommentVNode", [E]: "createTextVNode", [x]: "createStaticVNode", [S]: "resolveComponent", [T]: "resolveDynamicComponent", [w]: "resolveDirective", [P]: "resolveFilter", [A]: "withDirectives", [O]: "renderList", [C]: "renderSlot", [I]: "createSlots", [k2]: "toDisplayString", [N]: "mergeProps", [_]: "toHandlers", [j]: "camelize", [D]: "capitalize", [L]: "toHandlerKey", [M]: "setBlockTracking", [B]: "pushScopeId", [R]: "popScopeId", [F]: "withScopeId", [U]: "withCtx", [$]: "unref", [q]: "isRef" }, W = { source: "", start: { line: 1, column: 1, offset: 0 }, end: { line: 1, column: 1, offset: 0 } };
            function K(e3, t3 = W) {
              return { type: 0, children: e3, helpers: [], components: [], directives: [], hoists: [], imports: [], cached: 0, temps: 0, codegenNode: void 0, loc: t3 };
            }
            function G(e3, t3, r3, n2, s3, i2, o2, a2 = false, l2 = false, c4 = W) {
              return e3 && (a2 ? (e3.helper(y), e3.helper(g)) : e3.helper(b), o2 && e3.helper(A)), { type: 13, tag: t3, props: r3, children: n2, patchFlag: s3, dynamicProps: i2, directives: o2, isBlock: a2, disableTracking: l2, loc: c4 };
            }
            function H(e3, t3 = W) {
              return { type: 17, loc: t3, elements: e3 };
            }
            function J(e3, t3 = W) {
              return { type: 15, loc: t3, properties: e3 };
            }
            function Y(e3, t3) {
              return { type: 16, loc: W, key: n.isString(e3) ? X(e3, true) : e3, value: t3 };
            }
            function X(e3, t3, r3 = W, n2 = 0) {
              return { type: 4, loc: r3, content: e3, isStatic: t3, constType: t3 ? 3 : n2 };
            }
            function z(e3, t3 = W) {
              return { type: 8, loc: t3, children: e3 };
            }
            function Q(e3, t3 = [], r3 = W) {
              return { type: 14, loc: r3, callee: e3, arguments: t3 };
            }
            function Z(e3, t3, r3 = false, n2 = false, s3 = W) {
              return { type: 18, params: e3, returns: t3, newline: r3, isSlot: n2, loc: s3 };
            }
            function ee(e3, t3, r3, n2 = true) {
              return { type: 19, test: e3, consequent: t3, alternate: r3, newline: n2, loc: W };
            }
            function te(e3, t3, r3 = false) {
              return { type: 20, index: e3, value: t3, isVNode: r3, loc: W };
            }
            const re = (e3) => e3.type === 4 && e3.isStatic, ne = (e3, t3) => e3 === t3 || e3 === n.hyphenate(t3);
            function se(e3) {
              return ne(e3, "Teleport") ? f : ne(e3, "Suspense") ? d : ne(e3, "KeepAlive") ? h3 : ne(e3, "BaseTransition") ? m : void 0;
            }
            const ie = /^\d|[^\$\w]/, oe = (e3) => !ie.test(e3), ae = /[A-Za-z_$\xA0-\uFFFF]/, le = /[\.\w$\xA0-\uFFFF]/, ce = /\s+[.[]\s*|\s*[.[]\s+/g, ue = (e3) => {
              e3 = e3.trim().replace(ce, (e4) => e4.trim());
              let t3 = 0, r3 = 0, n2 = 0, s3 = null;
              for (let i2 = 0; i2 < e3.length; i2++) {
                const o2 = e3.charAt(i2);
                switch (t3) {
                  case 0:
                    if (o2 === "[")
                      r3 = t3, t3 = 1, n2++;
                    else if (!(i2 === 0 ? ae : le).test(o2))
                      return false;
                    break;
                  case 1:
                    o2 === "'" || o2 === '"' || o2 === "`" ? (r3 = t3, t3 = 2, s3 = o2) : o2 === "[" ? n2++ : o2 === "]" && (--n2 || (t3 = r3));
                    break;
                  case 2:
                    o2 === s3 && (t3 = r3, s3 = null);
                }
              }
              return !n2;
            };
            function pe(e3, t3, r3) {
              const n2 = { source: e3.source.substr(t3, r3), start: fe(e3.start, e3.source, t3), end: e3.end };
              return r3 != null && (n2.end = fe(e3.start, e3.source, t3 + r3)), n2;
            }
            function fe(e3, t3, r3 = t3.length) {
              return de(n.extend({}, e3), t3, r3);
            }
            function de(e3, t3, r3 = t3.length) {
              let n2 = 0, s3 = -1;
              for (let e4 = 0; e4 < r3; e4++)
                t3.charCodeAt(e4) === 10 && (n2++, s3 = e4);
              return e3.offset += r3, e3.line += n2, e3.column = s3 === -1 ? e3.column + r3 : r3 - s3, e3;
            }
            function he(e3, t3, r3 = false) {
              for (let s3 = 0; s3 < e3.props.length; s3++) {
                const i2 = e3.props[s3];
                if (i2.type === 7 && (r3 || i2.exp) && (n.isString(t3) ? i2.name === t3 : t3.test(i2.name)))
                  return i2;
              }
            }
            function me(e3, t3, r3 = false, n2 = false) {
              for (let s3 = 0; s3 < e3.props.length; s3++) {
                const i2 = e3.props[s3];
                if (i2.type === 6) {
                  if (r3)
                    continue;
                  if (i2.name === t3 && (i2.value || n2))
                    return i2;
                } else if (i2.name === "bind" && (i2.exp || n2) && ye(i2.arg, t3))
                  return i2;
              }
            }
            function ye(e3, t3) {
              return !(!e3 || !re(e3) || e3.content !== t3);
            }
            function ge(e3) {
              return e3.type === 5 || e3.type === 2;
            }
            function be(e3) {
              return e3.type === 7 && e3.name === "slot";
            }
            function ve(e3) {
              return e3.type === 1 && e3.tagType === 3;
            }
            function Ee(e3) {
              return e3.type === 1 && e3.tagType === 2;
            }
            function xe(e3, t3, r3) {
              let s3;
              const i2 = e3.type === 13 ? e3.props : e3.arguments[2];
              if (i2 == null || n.isString(i2))
                s3 = J([t3]);
              else if (i2.type === 14) {
                const e4 = i2.arguments[0];
                n.isString(e4) || e4.type !== 15 ? i2.callee === _ ? s3 = Q(r3.helper(N), [J([t3]), i2]) : i2.arguments.unshift(J([t3])) : e4.properties.unshift(t3), !s3 && (s3 = i2);
              } else if (i2.type === 15) {
                let e4 = false;
                if (t3.key.type === 4) {
                  const r4 = t3.key.content;
                  e4 = i2.properties.some((e5) => e5.key.type === 4 && e5.key.content === r4);
                }
                e4 || i2.properties.unshift(t3), s3 = i2;
              } else
                s3 = Q(r3.helper(N), [J([t3]), i2]);
              e3.type === 13 ? e3.props = s3 : e3.arguments[2] = s3;
            }
            function Se(e3, t3) {
              return `_${t3}_${e3.replace(/[^\w]/g, "_")}`;
            }
            function Te(e3, t3) {
              if (!e3 || Object.keys(t3).length === 0)
                return false;
              switch (e3.type) {
                case 1:
                  for (let r3 = 0; r3 < e3.props.length; r3++) {
                    const n2 = e3.props[r3];
                    if (n2.type === 7 && (Te(n2.arg, t3) || Te(n2.exp, t3)))
                      return true;
                  }
                  return e3.children.some((e4) => Te(e4, t3));
                case 11:
                  return !!Te(e3.source, t3) || e3.children.some((e4) => Te(e4, t3));
                case 9:
                  return e3.branches.some((e4) => Te(e4, t3));
                case 10:
                  return !!Te(e3.condition, t3) || e3.children.some((e4) => Te(e4, t3));
                case 4:
                  return !e3.isStatic && oe(e3.content) && !!t3[e3.content];
                case 8:
                  return e3.children.some((e4) => n.isObject(e4) && Te(e4, t3));
                case 5:
                case 12:
                  return Te(e3.content, t3);
                case 2:
                case 3:
                default:
                  return false;
              }
            }
            const we = { COMPILER_IS_ON_ELEMENT: { message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".', link: "https://v3.vuejs.org/guide/migration/custom-elements-interop.html" }, COMPILER_V_BIND_SYNC: { message: (e3) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${e3}.sync\` should be changed to \`v-model:${e3}\`.`, link: "https://v3.vuejs.org/guide/migration/v-model.html" }, COMPILER_V_BIND_PROP: { message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate." }, COMPILER_V_BIND_OBJECT_ORDER: { message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.', link: "https://v3.vuejs.org/guide/migration/v-bind.html" }, COMPILER_V_ON_NATIVE: { message: ".native modifier for v-on has been removed as is no longer necessary.", link: "https://v3.vuejs.org/guide/migration/v-on-native-modifier-removed.html" }, COMPILER_V_IF_V_FOR_PRECEDENCE: { message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.", link: "https://v3.vuejs.org/guide/migration/v-if-v-for.html" }, COMPILER_V_FOR_REF: { message: "Ref usage on v-for no longer creates array ref values in Vue 3. Consider using function refs or refactor to avoid ref usage altogether.", link: "https://v3.vuejs.org/guide/migration/array-refs.html" }, COMPILER_NATIVE_TEMPLATE: { message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3." }, COMPILER_INLINE_TEMPLATE: { message: '"inline-template" has been removed in Vue 3.', link: "https://v3.vuejs.org/guide/migration/inline-template-attribute.html" }, COMPILER_FILTER: { message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.', link: "https://v3.vuejs.org/guide/migration/filters.html" } };
            function Pe(e3, t3) {
              const r3 = t3.options ? t3.options.compatConfig : t3.compatConfig, n2 = r3 && r3[e3];
              return e3 === "MODE" ? n2 || 3 : n2;
            }
            function Ae(e3, t3) {
              const r3 = Pe("MODE", t3), n2 = Pe(e3, t3);
              return r3 === 3 ? n2 === true : n2 !== false;
            }
            function Oe(e3, t3, r3, ...n2) {
              return Ae(e3, t3);
            }
            const Ce = /&(gt|lt|amp|apos|quot);/g, Ie = { gt: ">", lt: "<", amp: "&", apos: "'", quot: '"' }, ke = { delimiters: ["{{", "}}"], getNamespace: () => 0, getTextMode: () => 0, isVoidTag: n.NO, isPreTag: n.NO, isCustomElement: n.NO, decodeEntities: (e3) => e3.replace(Ce, (e4, t3) => Ie[t3]), onError: a, onWarn: l, comments: false };
            function Ne(e3, t3 = {}) {
              const r3 = function(e4, t4) {
                const r4 = n.extend({}, ke);
                for (const e5 in t4)
                  r4[e5] = t4[e5] || ke[e5];
                return { options: r4, column: 1, line: 1, offset: 0, originalSource: e4, source: e4, inPre: false, inVPre: false, onWarn: r4.onWarn };
              }(e3, t3), s3 = Ke(r3);
              return K(_e(r3, 0, []), Ge(r3, s3));
            }
            function _e(e3, t3, r3) {
              const s3 = He(r3), i2 = s3 ? s3.ns : 0, o2 = [];
              for (; !Ze(e3, t3, r3); ) {
                const a3 = e3.source;
                let l2;
                if (t3 === 0 || t3 === 1) {
                  if (!e3.inVPre && Je(a3, e3.options.delimiters[0]))
                    l2 = qe(e3, t3);
                  else if (t3 === 0 && a3[0] === "<")
                    if (a3.length === 1)
                      Qe(e3, 5, 1);
                    else if (a3[1] === "!")
                      Je(a3, "<!--") ? l2 = Le(e3) : Je(a3, "<!DOCTYPE") ? l2 = Me(e3) : Je(a3, "<![CDATA[") ? i2 !== 0 ? l2 = De(e3, r3) : (Qe(e3, 1), l2 = Me(e3)) : (Qe(e3, 11), l2 = Me(e3));
                    else if (a3[1] === "/")
                      if (a3.length === 2)
                        Qe(e3, 5, 2);
                      else {
                        if (a3[2] === ">") {
                          Qe(e3, 14, 2), Ye(e3, 3);
                          continue;
                        }
                        if (/[a-z]/i.test(a3[2])) {
                          Qe(e3, 23), Fe(e3, 1, s3);
                          continue;
                        }
                        Qe(e3, 12, 2), l2 = Me(e3);
                      }
                    else
                      /[a-z]/i.test(a3[1]) ? (l2 = Be(e3, r3), Ae("COMPILER_NATIVE_TEMPLATE", e3) && l2 && l2.tag === "template" && !l2.props.some((e4) => e4.type === 7 && Re(e4.name)) && (l2 = l2.children)) : a3[1] === "?" ? (Qe(e3, 21, 1), l2 = Me(e3)) : Qe(e3, 12, 1);
                }
                if (l2 || (l2 = Ve(e3, t3)), n.isArray(l2))
                  for (let e4 = 0; e4 < l2.length; e4++)
                    je(o2, l2[e4]);
                else
                  je(o2, l2);
              }
              let a2 = false;
              if (t3 !== 2 && t3 !== 1) {
                const t4 = e3.options.whitespace === "preserve";
                for (let r4 = 0; r4 < o2.length; r4++) {
                  const n2 = o2[r4];
                  if (!e3.inPre && n2.type === 2)
                    if (/[^\t\r\n\f ]/.test(n2.content))
                      t4 || (n2.content = n2.content.replace(/[\t\r\n\f ]+/g, " "));
                    else {
                      const e4 = o2[r4 - 1], s4 = o2[r4 + 1];
                      !e4 || !s4 || !t4 && (e4.type === 3 || s4.type === 3 || e4.type === 1 && s4.type === 1 && /[\r\n]/.test(n2.content)) ? (a2 = true, o2[r4] = null) : n2.content = " ";
                    }
                  n2.type !== 3 || e3.options.comments || (a2 = true, o2[r4] = null);
                }
                if (e3.inPre && s3 && e3.options.isPreTag(s3.tag)) {
                  const e4 = o2[0];
                  e4 && e4.type === 2 && (e4.content = e4.content.replace(/^\r?\n/, ""));
                }
              }
              return a2 ? o2.filter(Boolean) : o2;
            }
            function je(e3, t3) {
              if (t3.type === 2) {
                const r3 = He(e3);
                if (r3 && r3.type === 2 && r3.loc.end.offset === t3.loc.start.offset)
                  return r3.content += t3.content, r3.loc.end = t3.loc.end, void (r3.loc.source += t3.loc.source);
              }
              e3.push(t3);
            }
            function De(e3, t3) {
              Ye(e3, 9);
              const r3 = _e(e3, 3, t3);
              return e3.source.length === 0 ? Qe(e3, 6) : Ye(e3, 3), r3;
            }
            function Le(e3) {
              const t3 = Ke(e3);
              let r3;
              const n2 = /--(\!)?>/.exec(e3.source);
              if (n2) {
                n2.index <= 3 && Qe(e3, 0), n2[1] && Qe(e3, 10), r3 = e3.source.slice(4, n2.index);
                const t4 = e3.source.slice(0, n2.index);
                let s3 = 1, i2 = 0;
                for (; (i2 = t4.indexOf("<!--", s3)) !== -1; )
                  Ye(e3, i2 - s3 + 1), i2 + 4 < t4.length && Qe(e3, 16), s3 = i2 + 1;
                Ye(e3, n2.index + n2[0].length - s3 + 1);
              } else
                r3 = e3.source.slice(4), Ye(e3, e3.source.length), Qe(e3, 7);
              return { type: 3, content: r3, loc: Ge(e3, t3) };
            }
            function Me(e3) {
              const t3 = Ke(e3), r3 = e3.source[1] === "?" ? 1 : 2;
              let n2;
              const s3 = e3.source.indexOf(">");
              return s3 === -1 ? (n2 = e3.source.slice(r3), Ye(e3, e3.source.length)) : (n2 = e3.source.slice(r3, s3), Ye(e3, s3 + 1)), { type: 3, content: n2, loc: Ge(e3, t3) };
            }
            function Be(e3, t3) {
              const r3 = e3.inPre, n2 = e3.inVPre, s3 = He(t3), i2 = Fe(e3, 0, s3), o2 = e3.inPre && !r3, a2 = e3.inVPre && !n2;
              if (i2.isSelfClosing || e3.options.isVoidTag(i2.tag))
                return e3.options.isPreTag(i2.tag) && (e3.inPre = false), i2;
              t3.push(i2);
              const l2 = e3.options.getTextMode(i2, s3), c4 = _e(e3, l2, t3);
              t3.pop();
              {
                const t4 = i2.props.find((e4) => e4.type === 6 && e4.name === "inline-template");
                if (t4 && Oe("COMPILER_INLINE_TEMPLATE", e3, t4.loc)) {
                  const r4 = Ge(e3, i2.loc.end);
                  t4.value = { type: 2, content: r4.source, loc: r4 };
                }
              }
              if (i2.children = c4, et(e3.source, i2.tag))
                Fe(e3, 1, s3);
              else if (Qe(e3, 24, 0, i2.loc.start), e3.source.length === 0 && i2.tag.toLowerCase() === "script") {
                const t4 = c4[0];
                t4 && Je(t4.loc.source, "<!--") && Qe(e3, 8);
              }
              return i2.loc = Ge(e3, i2.loc.start), o2 && (e3.inPre = false), a2 && (e3.inVPre = false), i2;
            }
            const Re = n.makeMap("if,else,else-if,for,slot");
            function Fe(e3, t3, r3) {
              const s3 = Ke(e3), i2 = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(e3.source), o2 = i2[1], a2 = e3.options.getNamespace(o2, r3);
              Ye(e3, i2[0].length), Xe(e3);
              const l2 = Ke(e3), c4 = e3.source;
              e3.options.isPreTag(o2) && (e3.inPre = true);
              let u2 = Ue(e3, t3);
              t3 === 0 && !e3.inVPre && u2.some((e4) => e4.type === 7 && e4.name === "pre") && (e3.inVPre = true, n.extend(e3, l2), e3.source = c4, u2 = Ue(e3, t3).filter((e4) => e4.name !== "v-pre"));
              let p3 = false;
              if (e3.source.length === 0 ? Qe(e3, 9) : (p3 = Je(e3.source, "/>"), t3 === 1 && p3 && Qe(e3, 4), Ye(e3, p3 ? 2 : 1)), t3 === 1)
                return;
              let f2 = 0;
              return e3.inVPre || (o2 === "slot" ? f2 = 2 : o2 === "template" ? u2.some((e4) => e4.type === 7 && Re(e4.name)) && (f2 = 3) : function(e4, t4, r4) {
                const n2 = r4.options;
                if (n2.isCustomElement(e4))
                  return false;
                if (e4 === "component" || /^[A-Z]/.test(e4) || se(e4) || n2.isBuiltInComponent && n2.isBuiltInComponent(e4) || n2.isNativeTag && !n2.isNativeTag(e4))
                  return true;
                for (let e5 = 0; e5 < t4.length; e5++) {
                  const n3 = t4[e5];
                  if (n3.type === 6) {
                    if (n3.name === "is" && n3.value) {
                      if (n3.value.content.startsWith("vue:"))
                        return true;
                      if (Oe("COMPILER_IS_ON_ELEMENT", r4, n3.loc))
                        return true;
                    }
                  } else {
                    if (n3.name === "is")
                      return true;
                    if (n3.name === "bind" && ye(n3.arg, "is") && Oe("COMPILER_IS_ON_ELEMENT", r4, n3.loc))
                      return true;
                  }
                }
              }(o2, u2, e3) && (f2 = 1)), { type: 1, ns: a2, tag: o2, tagType: f2, props: u2, isSelfClosing: p3, children: [], loc: Ge(e3, s3), codegenNode: void 0 };
            }
            function Ue(e3, t3) {
              const r3 = [], n2 = new Set();
              for (; e3.source.length > 0 && !Je(e3.source, ">") && !Je(e3.source, "/>"); ) {
                if (Je(e3.source, "/")) {
                  Qe(e3, 22), Ye(e3, 1), Xe(e3);
                  continue;
                }
                t3 === 1 && Qe(e3, 3);
                const s3 = $e(e3, n2);
                t3 === 0 && r3.push(s3), /^[^\t\r\n\f />]/.test(e3.source) && Qe(e3, 15), Xe(e3);
              }
              return r3;
            }
            function $e(e3, t3) {
              const r3 = Ke(e3), n2 = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(e3.source)[0];
              t3.has(n2) && Qe(e3, 2), t3.add(n2), n2[0] === "=" && Qe(e3, 19);
              {
                const t4 = /["'<]/g;
                let r4;
                for (; r4 = t4.exec(n2); )
                  Qe(e3, 17, r4.index);
              }
              let s3;
              Ye(e3, n2.length), /^[\t\r\n\f ]*=/.test(e3.source) && (Xe(e3), Ye(e3, 1), Xe(e3), s3 = function(e4) {
                const t4 = Ke(e4);
                let r4;
                const n3 = e4.source[0], s4 = n3 === '"' || n3 === "'";
                if (s4) {
                  Ye(e4, 1);
                  const t5 = e4.source.indexOf(n3);
                  t5 === -1 ? r4 = We(e4, e4.source.length, 4) : (r4 = We(e4, t5, 4), Ye(e4, 1));
                } else {
                  const t5 = /^[^\t\r\n\f >]+/.exec(e4.source);
                  if (!t5)
                    return;
                  const n4 = /["'<=`]/g;
                  let s5;
                  for (; s5 = n4.exec(t5[0]); )
                    Qe(e4, 18, s5.index);
                  r4 = We(e4, t5[0].length, 4);
                }
                return { content: r4, isQuoted: s4, loc: Ge(e4, t4) };
              }(e3), s3 || Qe(e3, 13));
              const i2 = Ge(e3, r3);
              if (!e3.inVPre && /^(v-|:|@|#)/.test(n2)) {
                const t4 = /(?:^v-([a-z0-9-]+))?(?:(?::|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(n2);
                let o2, a2 = t4[1] || (Je(n2, ":") ? "bind" : Je(n2, "@") ? "on" : "slot");
                if (t4[2]) {
                  const s4 = a2 === "slot", i3 = n2.lastIndexOf(t4[2]), l3 = Ge(e3, ze(e3, r3, i3), ze(e3, r3, i3 + t4[2].length + (s4 && t4[3] || "").length));
                  let c4 = t4[2], u2 = true;
                  c4.startsWith("[") ? (u2 = false, c4.endsWith("]") || Qe(e3, 26), c4 = c4.substr(1, c4.length - 2)) : s4 && (c4 += t4[3] || ""), o2 = { type: 4, content: c4, isStatic: u2, constType: u2 ? 3 : 0, loc: l3 };
                }
                if (s3 && s3.isQuoted) {
                  const e4 = s3.loc;
                  e4.start.offset++, e4.start.column++, e4.end = fe(e4.start, s3.content), e4.source = e4.source.slice(1, -1);
                }
                const l2 = t4[3] ? t4[3].substr(1).split(".") : [];
                return a2 === "bind" && o2 && l2.includes("sync") && Oe("COMPILER_V_BIND_SYNC", e3, 0, o2.loc.source) && (a2 = "model", l2.splice(l2.indexOf("sync"), 1)), { type: 7, name: a2, exp: s3 && { type: 4, content: s3.content, isStatic: false, constType: 0, loc: s3.loc }, arg: o2, modifiers: l2, loc: i2 };
              }
              return { type: 6, name: n2, value: s3 && { type: 2, content: s3.content, loc: s3.loc }, loc: i2 };
            }
            function qe(e3, t3) {
              const [r3, n2] = e3.options.delimiters, s3 = e3.source.indexOf(n2, r3.length);
              if (s3 === -1)
                return void Qe(e3, 25);
              const i2 = Ke(e3);
              Ye(e3, r3.length);
              const o2 = Ke(e3), a2 = Ke(e3), l2 = s3 - r3.length, c4 = e3.source.slice(0, l2), u2 = We(e3, l2, t3), p3 = u2.trim(), f2 = u2.indexOf(p3);
              return f2 > 0 && de(o2, c4, f2), de(a2, c4, l2 - (u2.length - p3.length - f2)), Ye(e3, n2.length), { type: 5, content: { type: 4, isStatic: false, constType: 0, content: p3, loc: Ge(e3, o2, a2) }, loc: Ge(e3, i2) };
            }
            function Ve(e3, t3) {
              const r3 = ["<", e3.options.delimiters[0]];
              t3 === 3 && r3.push("]]>");
              let n2 = e3.source.length;
              for (let t4 = 0; t4 < r3.length; t4++) {
                const s4 = e3.source.indexOf(r3[t4], 1);
                s4 !== -1 && n2 > s4 && (n2 = s4);
              }
              const s3 = Ke(e3);
              return { type: 2, content: We(e3, n2, t3), loc: Ge(e3, s3) };
            }
            function We(e3, t3, r3) {
              const n2 = e3.source.slice(0, t3);
              return Ye(e3, t3), r3 === 2 || r3 === 3 || n2.indexOf("&") === -1 ? n2 : e3.options.decodeEntities(n2, r3 === 4);
            }
            function Ke(e3) {
              const { column: t3, line: r3, offset: n2 } = e3;
              return { column: t3, line: r3, offset: n2 };
            }
            function Ge(e3, t3, r3) {
              return { start: t3, end: r3 = r3 || Ke(e3), source: e3.originalSource.slice(t3.offset, r3.offset) };
            }
            function He(e3) {
              return e3[e3.length - 1];
            }
            function Je(e3, t3) {
              return e3.startsWith(t3);
            }
            function Ye(e3, t3) {
              const { source: r3 } = e3;
              de(e3, r3, t3), e3.source = r3.slice(t3);
            }
            function Xe(e3) {
              const t3 = /^[\t\r\n\f ]+/.exec(e3.source);
              t3 && Ye(e3, t3[0].length);
            }
            function ze(e3, t3, r3) {
              return fe(t3, e3.originalSource.slice(t3.offset, r3), r3);
            }
            function Qe(e3, t3, r3, n2 = Ke(e3)) {
              r3 && (n2.offset += r3, n2.column += r3), e3.options.onError(c(t3, { start: n2, end: n2, source: "" }));
            }
            function Ze(e3, t3, r3) {
              const n2 = e3.source;
              switch (t3) {
                case 0:
                  if (Je(n2, "</")) {
                    for (let e4 = r3.length - 1; e4 >= 0; --e4)
                      if (et(n2, r3[e4].tag))
                        return true;
                  }
                  break;
                case 1:
                case 2: {
                  const e4 = He(r3);
                  if (e4 && et(n2, e4.tag))
                    return true;
                  break;
                }
                case 3:
                  if (Je(n2, "]]>"))
                    return true;
              }
              return !n2;
            }
            function et(e3, t3) {
              return Je(e3, "</") && e3.substr(2, t3.length).toLowerCase() === t3.toLowerCase() && /[\t\r\n\f />]/.test(e3[2 + t3.length] || ">");
            }
            function tt(e3, t3) {
              nt(e3, t3, rt(e3, e3.children[0]));
            }
            function rt(e3, t3) {
              const { children: r3 } = e3;
              return r3.length === 1 && t3.type === 1 && !Ee(t3);
            }
            function nt(e3, t3, r3 = false) {
              let n2 = false, s3 = true;
              const { children: i2 } = e3;
              for (let e4 = 0; e4 < i2.length; e4++) {
                const o2 = i2[e4];
                if (o2.type === 1 && o2.tagType === 0) {
                  const e5 = r3 ? 0 : st(o2, t3);
                  if (e5 > 0) {
                    if (e5 < 3 && (s3 = false), e5 >= 2) {
                      o2.codegenNode.patchFlag = "-1", o2.codegenNode = t3.hoist(o2.codegenNode), n2 = true;
                      continue;
                    }
                  } else {
                    const e6 = o2.codegenNode;
                    if (e6.type === 13) {
                      const r4 = at(e6);
                      if ((!r4 || r4 === 512 || r4 === 1) && it(o2, t3) >= 2) {
                        const r5 = ot(o2);
                        r5 && (e6.props = t3.hoist(r5));
                      }
                    }
                  }
                } else if (o2.type === 12) {
                  const e5 = st(o2.content, t3);
                  e5 > 0 && (e5 < 3 && (s3 = false), e5 >= 2 && (o2.codegenNode = t3.hoist(o2.codegenNode), n2 = true));
                }
                if (o2.type === 1) {
                  const e5 = o2.tagType === 1;
                  e5 && t3.scopes.vSlot++, nt(o2, t3), e5 && t3.scopes.vSlot--;
                } else if (o2.type === 11)
                  nt(o2, t3, o2.children.length === 1);
                else if (o2.type === 9)
                  for (let e5 = 0; e5 < o2.branches.length; e5++)
                    nt(o2.branches[e5], t3, o2.branches[e5].children.length === 1);
              }
              s3 && n2 && t3.transformHoist && t3.transformHoist(i2, t3, e3);
            }
            function st(e3, t3) {
              const { constantCache: r3 } = t3;
              switch (e3.type) {
                case 1:
                  if (e3.tagType !== 0)
                    return 0;
                  const s3 = r3.get(e3);
                  if (s3 !== void 0)
                    return s3;
                  const i2 = e3.codegenNode;
                  if (i2.type !== 13)
                    return 0;
                  if (at(i2))
                    return r3.set(e3, 0), 0;
                  {
                    let n2 = 3;
                    const s4 = it(e3, t3);
                    if (s4 === 0)
                      return r3.set(e3, 0), 0;
                    s4 < n2 && (n2 = s4);
                    for (let s5 = 0; s5 < e3.children.length; s5++) {
                      const i3 = st(e3.children[s5], t3);
                      if (i3 === 0)
                        return r3.set(e3, 0), 0;
                      i3 < n2 && (n2 = i3);
                    }
                    if (n2 > 1)
                      for (let s5 = 0; s5 < e3.props.length; s5++) {
                        const i3 = e3.props[s5];
                        if (i3.type === 7 && i3.name === "bind" && i3.exp) {
                          const s6 = st(i3.exp, t3);
                          if (s6 === 0)
                            return r3.set(e3, 0), 0;
                          s6 < n2 && (n2 = s6);
                        }
                      }
                    return i2.isBlock && (t3.removeHelper(y), t3.removeHelper(g), i2.isBlock = false, t3.helper(b)), r3.set(e3, n2), n2;
                  }
                case 2:
                case 3:
                  return 3;
                case 9:
                case 11:
                case 10:
                  return 0;
                case 5:
                case 12:
                  return st(e3.content, t3);
                case 4:
                  return e3.constType;
                case 8:
                  let o2 = 3;
                  for (let r4 = 0; r4 < e3.children.length; r4++) {
                    const s4 = e3.children[r4];
                    if (n.isString(s4) || n.isSymbol(s4))
                      continue;
                    const i3 = st(s4, t3);
                    if (i3 === 0)
                      return 0;
                    i3 < o2 && (o2 = i3);
                  }
                  return o2;
                default:
                  return 0;
              }
            }
            function it(e3, t3) {
              let r3 = 3;
              const n2 = ot(e3);
              if (n2 && n2.type === 15) {
                const { properties: e4 } = n2;
                for (let n3 = 0; n3 < e4.length; n3++) {
                  const { key: s3, value: i2 } = e4[n3], o2 = st(s3, t3);
                  if (o2 === 0)
                    return o2;
                  if (o2 < r3 && (r3 = o2), i2.type !== 4)
                    return 0;
                  const a2 = st(i2, t3);
                  if (a2 === 0)
                    return a2;
                  a2 < r3 && (r3 = a2);
                }
              }
              return r3;
            }
            function ot(e3) {
              const t3 = e3.codegenNode;
              if (t3.type === 13)
                return t3.props;
            }
            function at(e3) {
              const t3 = e3.patchFlag;
              return t3 ? parseInt(t3, 10) : void 0;
            }
            function lt(e3, { filename: t3 = "", prefixIdentifiers: r3 = false, hoistStatic: s3 = false, cacheHandlers: i2 = false, nodeTransforms: o2 = [], directiveTransforms: c4 = {}, transformHoist: u2 = null, isBuiltInComponent: p3 = n.NOOP, isCustomElement: f2 = n.NOOP, expressionPlugins: d2 = [], scopeId: h4 = null, slotted: m2 = true, ssr: y2 = false, ssrCssVars: g2 = "", bindingMetadata: b2 = n.EMPTY_OBJ, inline: v2 = false, isTS: E2 = false, onError: x2 = a, onWarn: S2 = l, compatConfig: T2 }) {
              const w2 = t3.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), P2 = { selfName: w2 && n.capitalize(n.camelize(w2[1])), prefixIdentifiers: r3, hoistStatic: s3, cacheHandlers: i2, nodeTransforms: o2, directiveTransforms: c4, transformHoist: u2, isBuiltInComponent: p3, isCustomElement: f2, expressionPlugins: d2, scopeId: h4, slotted: m2, ssr: y2, ssrCssVars: g2, bindingMetadata: b2, inline: v2, isTS: E2, onError: x2, onWarn: S2, compatConfig: T2, root: e3, helpers: new Map(), components: new Set(), directives: new Set(), hoists: [], imports: [], constantCache: new Map(), temps: 0, cached: 0, identifiers: Object.create(null), scopes: { vFor: 0, vSlot: 0, vPre: 0, vOnce: 0 }, parent: null, currentNode: e3, childIndex: 0, helper(e4) {
                const t4 = P2.helpers.get(e4) || 0;
                return P2.helpers.set(e4, t4 + 1), e4;
              }, removeHelper(e4) {
                const t4 = P2.helpers.get(e4);
                if (t4) {
                  const r4 = t4 - 1;
                  r4 ? P2.helpers.set(e4, r4) : P2.helpers.delete(e4);
                }
              }, helperString: (e4) => `_${V[P2.helper(e4)]}`, replaceNode(e4) {
                P2.parent.children[P2.childIndex] = P2.currentNode = e4;
              }, removeNode(e4) {
                const t4 = P2.parent.children, r4 = e4 ? t4.indexOf(e4) : P2.currentNode ? P2.childIndex : -1;
                e4 && e4 !== P2.currentNode ? P2.childIndex > r4 && (P2.childIndex--, P2.onNodeRemoved()) : (P2.currentNode = null, P2.onNodeRemoved()), P2.parent.children.splice(r4, 1);
              }, onNodeRemoved: () => {
              }, addIdentifiers(e4) {
                n.isString(e4) ? A2(e4) : e4.identifiers ? e4.identifiers.forEach(A2) : e4.type === 4 && A2(e4.content);
              }, removeIdentifiers(e4) {
                n.isString(e4) ? O2(e4) : e4.identifiers ? e4.identifiers.forEach(O2) : e4.type === 4 && O2(e4.content);
              }, hoist(e4) {
                P2.hoists.push(e4);
                const t4 = X(`_hoisted_${P2.hoists.length}`, false, e4.loc, 2);
                return t4.hoisted = e4, t4;
              }, cache: (e4, t4 = false) => te(++P2.cached, e4, t4) };
              function A2(e4) {
                const { identifiers: t4 } = P2;
                t4[e4] === void 0 && (t4[e4] = 0), t4[e4]++;
              }
              function O2(e4) {
                P2.identifiers[e4]--;
              }
              return P2.filters = new Set(), P2;
            }
            function ct(e3, t3) {
              const r3 = lt(e3, t3);
              ut(e3, r3), t3.hoistStatic && tt(e3, r3), t3.ssr || function(e4, t4) {
                const { helper: r4, removeHelper: s3 } = t4, { children: i2 } = e4;
                if (i2.length === 1) {
                  const t5 = i2[0];
                  if (rt(e4, t5) && t5.codegenNode) {
                    const n2 = t5.codegenNode;
                    n2.type === 13 && (n2.isBlock || (s3(b), n2.isBlock = true, r4(y), r4(g))), e4.codegenNode = n2;
                  } else
                    e4.codegenNode = t5;
                } else if (i2.length > 1) {
                  let s4 = 64;
                  n.PatchFlagNames[64], e4.codegenNode = G(t4, r4(p2), void 0, e4.children, s4 + "", void 0, void 0, true);
                }
              }(e3, r3), e3.helpers = [...r3.helpers.keys()], e3.components = [...r3.components], e3.directives = [...r3.directives], e3.imports = r3.imports, e3.hoists = r3.hoists, e3.temps = r3.temps, e3.cached = r3.cached, e3.filters = [...r3.filters];
            }
            function ut(e3, t3) {
              t3.currentNode = e3;
              const { nodeTransforms: r3 } = t3, s3 = [];
              for (let i3 = 0; i3 < r3.length; i3++) {
                const o2 = r3[i3](e3, t3);
                if (o2 && (n.isArray(o2) ? s3.push(...o2) : s3.push(o2)), !t3.currentNode)
                  return;
                e3 = t3.currentNode;
              }
              switch (e3.type) {
                case 3:
                  t3.ssr || t3.helper(v);
                  break;
                case 5:
                  t3.ssr || t3.helper(k2);
                  break;
                case 9:
                  for (let r4 = 0; r4 < e3.branches.length; r4++)
                    ut(e3.branches[r4], t3);
                  break;
                case 10:
                case 11:
                case 1:
                case 0:
                  !function(e4, t4) {
                    let r4 = 0;
                    const s4 = () => {
                      r4--;
                    };
                    for (; r4 < e4.children.length; r4++) {
                      const i3 = e4.children[r4];
                      n.isString(i3) || (t4.parent = e4, t4.childIndex = r4, t4.onNodeRemoved = s4, ut(i3, t4));
                    }
                  }(e3, t3);
              }
              t3.currentNode = e3;
              let i2 = s3.length;
              for (; i2--; )
                s3[i2]();
            }
            function pt(e3, t3) {
              const r3 = n.isString(e3) ? (t4) => t4 === e3 : (t4) => e3.test(t4);
              return (e4, n2) => {
                if (e4.type === 1) {
                  const { props: s3 } = e4;
                  if (e4.tagType === 3 && s3.some(be))
                    return;
                  const i2 = [];
                  for (let o2 = 0; o2 < s3.length; o2++) {
                    const a2 = s3[o2];
                    if (a2.type === 7 && r3(a2.name)) {
                      s3.splice(o2, 1), o2--;
                      const r4 = t3(e4, a2, n2);
                      r4 && i2.push(r4);
                    }
                  }
                  return i2;
                }
              };
            }
            const ft = "/*#__PURE__*/";
            function dt(e3, { mode: t3 = "function", prefixIdentifiers: r3 = t3 === "module", sourceMap: n2 = false, filename: i2 = "template.vue.html", scopeId: o2 = null, optimizeImports: a2 = false, runtimeGlobalName: l2 = "Vue", runtimeModuleName: c4 = "vue", ssr: u2 = false, isTS: p3 = false }) {
              const f2 = { mode: t3, prefixIdentifiers: r3, sourceMap: n2, filename: i2, scopeId: o2, optimizeImports: a2, runtimeGlobalName: l2, runtimeModuleName: c4, ssr: u2, isTS: p3, source: e3.loc.source, code: "", column: 1, line: 1, offset: 0, indentLevel: 0, pure: false, map: void 0, helper: (e4) => `_${V[e4]}`, push(e4, t4) {
                if (f2.code += e4, f2.map) {
                  if (t4) {
                    let e5;
                    if (t4.type === 4 && !t4.isStatic) {
                      const r4 = t4.content.replace(/^_ctx\./, "");
                      r4 !== t4.content && oe(r4) && (e5 = r4);
                    }
                    h4(t4.loc.start, e5);
                  }
                  de(f2, e4), t4 && t4.loc !== W && h4(t4.loc.end);
                }
              }, indent() {
                d2(++f2.indentLevel);
              }, deindent(e4 = false) {
                e4 ? --f2.indentLevel : d2(--f2.indentLevel);
              }, newline() {
                d2(f2.indentLevel);
              } };
              function d2(e4) {
                f2.push("\n" + "  ".repeat(e4));
              }
              function h4(e4, t4) {
                f2.map.addMapping({ name: t4, source: f2.filename, original: { line: e4.line, column: e4.column - 1 }, generated: { line: f2.line, column: f2.column - 1 } });
              }
              return n2 && (f2.map = new s2.SourceMapGenerator(), f2.map.setSourceContent(i2, f2.source)), f2;
            }
            function ht(e3, t3 = {}) {
              const r3 = dt(e3, t3);
              t3.onContextCreated && t3.onContextCreated(r3);
              const { mode: n2, push: s3, prefixIdentifiers: i2, indent: o2, deindent: a2, newline: l2, scopeId: c4, ssr: u2 } = r3, p3 = e3.helpers.length > 0, f2 = !i2 && n2 !== "module", d2 = c4 != null && n2 === "module", h4 = !!t3.inline, m2 = h4 ? dt(e3, t3) : r3;
              n2 === "module" ? function(e4, t4, r4, n3) {
                const { push: s4, newline: i3, optimizeImports: o3, runtimeModuleName: a3, scopeId: l3, helper: c5 } = t4;
                r4 && (e4.helpers.push(F), e4.hoists.length && e4.helpers.push(B, R)), e4.helpers.length && (o3 ? (s4(`import { ${e4.helpers.map((e5) => V[e5]).join(", ")} } from ${JSON.stringify(a3)}
`), s4(`
// Binding optimization for webpack code-split
const ${e4.helpers.map((e5) => `_${V[e5]} = ${V[e5]}`).join(", ")}
`)) : s4(`import { ${e4.helpers.map((e5) => `${V[e5]} as _${V[e5]}`).join(", ")} } from ${JSON.stringify(a3)}
`)), e4.ssrHelpers && e4.ssrHelpers.length && s4(`import { ${e4.ssrHelpers.map((e5) => `${V[e5]} as _${V[e5]}`).join(", ")} } from "@vue/server-renderer"
`), e4.imports.length && (function(e5, t5) {
                  e5.length && e5.forEach((e6) => {
                    t5.push("import "), vt(e6.exp, t5), t5.push(` from '${e6.path}'`), t5.newline();
                  });
                }(e4.imports, t4), i3()), r4 && (s4(`const _withId = /*#__PURE__*/${c5(F)}("${l3}")`), i3()), yt(e4.hoists, t4), i3(), n3 || s4("export ");
              }(e3, m2, d2, h4) : function(e4, t4) {
                const { ssr: r4, prefixIdentifiers: n3, push: s4, newline: i3, runtimeModuleName: o3, runtimeGlobalName: a3 } = t4, l3 = r4 ? `require(${JSON.stringify(o3)})` : a3, c5 = (e5) => `${V[e5]}: _${V[e5]}`;
                e4.helpers.length > 0 && (n3 ? s4(`const { ${e4.helpers.map(c5).join(", ")} } = ${l3}
`) : (s4(`const _Vue = ${l3}
`), e4.hoists.length && s4(`const { ${[b, v, E, x].filter((t5) => e4.helpers.includes(t5)).map(c5).join(", ")} } = _Vue
`))), e4.ssrHelpers && e4.ssrHelpers.length && s4(`const { ${e4.ssrHelpers.map(c5).join(", ")} } = require("@vue/server-renderer")
`), yt(e4.hoists, t4), i3(), s4("return ");
              }(e3, m2);
              const y2 = u2 ? "ssrRender" : "render", g2 = u2 ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"];
              t3.bindingMetadata && !t3.inline && g2.push("$props", "$setup", "$data", "$options");
              const S2 = t3.isTS ? g2.map((e4) => `${e4}: any`).join(",") : g2.join(", ");
              if (d2 && !h4 && s3(`const ${y2} = /*#__PURE__*/_withId(`), s3(h4 || d2 ? `(${S2}) => {` : `function ${y2}(${S2}) {`), o2(), f2 && (s3("with (_ctx) {"), o2(), p3 && (s3(`const { ${e3.helpers.map((e4) => `${V[e4]}: _${V[e4]}`).join(", ")} } = _Vue`), s3("\n"), l2())), e3.components.length && (mt(e3.components, "component", r3), (e3.directives.length || e3.temps > 0) && l2()), e3.directives.length && (mt(e3.directives, "directive", r3), e3.temps > 0 && l2()), e3.filters && e3.filters.length && (l2(), mt(e3.filters, "filter", r3), l2()), e3.temps > 0) {
                s3("let ");
                for (let t4 = 0; t4 < e3.temps; t4++)
                  s3(`${t4 > 0 ? ", " : ""}_temp${t4}`);
              }
              return (e3.components.length || e3.directives.length || e3.temps) && (s3("\n"), l2()), u2 || s3("return "), e3.codegenNode ? vt(e3.codegenNode, r3) : s3("null"), f2 && (a2(), s3("}")), a2(), s3("}"), d2 && !h4 && s3(")"), { ast: e3, code: r3.code, preamble: h4 ? m2.code : "", map: r3.map ? r3.map.toJSON() : void 0 };
            }
            function mt(e3, t3, { helper: r3, push: n2, newline: s3, isTS: i2 }) {
              const o2 = r3(t3 === "filter" ? P : t3 === "component" ? S : w);
              for (let r4 = 0; r4 < e3.length; r4++) {
                let a2 = e3[r4];
                const l2 = a2.endsWith("__self");
                l2 && (a2 = a2.slice(0, -6)), n2(`const ${Se(a2, t3)} = ${o2}(${JSON.stringify(a2)}${l2 ? ", true" : ""})${i2 ? "!" : ""}`), r4 < e3.length - 1 && s3();
              }
            }
            function yt(e3, t3) {
              if (!e3.length)
                return;
              t3.pure = true;
              const { push: r3, newline: n2, helper: s3, scopeId: i2, mode: o2 } = t3, a2 = i2 != null && o2 !== "function";
              n2(), a2 && (r3(`${s3(B)}("${i2}")`), n2()), e3.forEach((e4, s4) => {
                e4 && (r3(`const _hoisted_${s4 + 1} = `), vt(e4, t3), n2());
              }), a2 && (r3(`${s3(R)}()`), n2()), t3.pure = false;
            }
            function gt(e3, t3) {
              const r3 = e3.length > 3 || e3.some((e4) => n.isArray(e4) || !function(e5) {
                return n.isString(e5) || e5.type === 4 || e5.type === 2 || e5.type === 5 || e5.type === 8;
              }(e4));
              t3.push("["), r3 && t3.indent(), bt(e3, t3, r3), r3 && t3.deindent(), t3.push("]");
            }
            function bt(e3, t3, r3 = false, s3 = true) {
              const { push: i2, newline: o2 } = t3;
              for (let a2 = 0; a2 < e3.length; a2++) {
                const l2 = e3[a2];
                n.isString(l2) ? i2(l2) : n.isArray(l2) ? gt(l2, t3) : vt(l2, t3), a2 < e3.length - 1 && (r3 ? (s3 && i2(","), o2()) : s3 && i2(", "));
              }
            }
            function vt(e3, t3) {
              if (n.isString(e3))
                t3.push(e3);
              else if (n.isSymbol(e3))
                t3.push(t3.helper(e3));
              else
                switch (e3.type) {
                  case 1:
                  case 9:
                  case 11:
                    vt(e3.codegenNode, t3);
                    break;
                  case 2:
                    !function(e4, t4) {
                      t4.push(JSON.stringify(e4.content), e4);
                    }(e3, t3);
                    break;
                  case 4:
                    Et(e3, t3);
                    break;
                  case 5:
                    !function(e4, t4) {
                      const { push: r3, helper: n2, pure: s3 } = t4;
                      s3 && r3(ft), r3(`${n2(k2)}(`), vt(e4.content, t4), r3(")");
                    }(e3, t3);
                    break;
                  case 12:
                    vt(e3.codegenNode, t3);
                    break;
                  case 8:
                    xt(e3, t3);
                    break;
                  case 3:
                    !function(e4, t4) {
                      const { push: r3, helper: n2, pure: s3 } = t4;
                      s3 && r3(ft), r3(`${n2(v)}(${JSON.stringify(e4.content)})`, e4);
                    }(e3, t3);
                    break;
                  case 13:
                    !function(e4, t4) {
                      const { push: r3, helper: n2, pure: s3 } = t4, { tag: i2, props: o2, children: a2, patchFlag: l2, dynamicProps: c4, directives: u2, isBlock: p3, disableTracking: f2 } = e4;
                      u2 && r3(n2(A) + "("), p3 && r3(`(${n2(y)}(${f2 ? "true" : ""}), `), s3 && r3(ft), r3(n2(p3 ? g : b) + "(", e4), bt(function(e5) {
                        let t5 = e5.length;
                        for (; t5-- && e5[t5] == null; )
                          ;
                        return e5.slice(0, t5 + 1).map((e6) => e6 || "null");
                      }([i2, o2, a2, l2, c4]), t4), r3(")"), p3 && r3(")"), u2 && (r3(", "), vt(u2, t4), r3(")"));
                    }(e3, t3);
                    break;
                  case 14:
                    !function(e4, t4) {
                      const { push: r3, helper: s3, pure: i2 } = t4, o2 = n.isString(e4.callee) ? e4.callee : s3(e4.callee);
                      i2 && r3(ft), r3(o2 + "(", e4), bt(e4.arguments, t4), r3(")");
                    }(e3, t3);
                    break;
                  case 15:
                    !function(e4, t4) {
                      const { push: r3, indent: n2, deindent: s3, newline: i2 } = t4, { properties: o2 } = e4;
                      if (!o2.length)
                        return void r3("{}", e4);
                      const a2 = o2.length > 1 || o2.some((e5) => e5.value.type !== 4);
                      r3(a2 ? "{" : "{ "), a2 && n2();
                      for (let e5 = 0; e5 < o2.length; e5++) {
                        const { key: n3, value: s4 } = o2[e5];
                        St(n3, t4), r3(": "), vt(s4, t4), e5 < o2.length - 1 && (r3(","), i2());
                      }
                      a2 && s3(), r3(a2 ? "}" : " }");
                    }(e3, t3);
                    break;
                  case 17:
                    !function(e4, t4) {
                      gt(e4.elements, t4);
                    }(e3, t3);
                    break;
                  case 18:
                    !function(e4, t4) {
                      const { push: r3, indent: s3, deindent: i2, scopeId: o2, mode: a2 } = t4, { params: l2, returns: c4, body: u2, newline: p3, isSlot: f2 } = e4;
                      f2 && r3(f2 && o2 != null && a2 !== "function" ? "_withId(" : `_${V[U]}(`), r3("(", e4), n.isArray(l2) ? bt(l2, t4) : l2 && vt(l2, t4), r3(") => "), (p3 || u2) && (r3("{"), s3()), c4 ? (p3 && r3("return "), n.isArray(c4) ? gt(c4, t4) : vt(c4, t4)) : u2 && vt(u2, t4), (p3 || u2) && (i2(), r3("}")), f2 && (e4.isNonScopedSlot && r3(", undefined, true"), r3(")"));
                    }(e3, t3);
                    break;
                  case 19:
                    !function(e4, t4) {
                      const { test: r3, consequent: n2, alternate: s3, newline: i2 } = e4, { push: o2, indent: a2, deindent: l2, newline: c4 } = t4;
                      if (r3.type === 4) {
                        const e5 = !oe(r3.content);
                        e5 && o2("("), Et(r3, t4), e5 && o2(")");
                      } else
                        o2("("), vt(r3, t4), o2(")");
                      i2 && a2(), t4.indentLevel++, i2 || o2(" "), o2("? "), vt(n2, t4), t4.indentLevel--, i2 && c4(), i2 || o2(" "), o2(": ");
                      const u2 = s3.type === 19;
                      u2 || t4.indentLevel++, vt(s3, t4), u2 || t4.indentLevel--, i2 && l2(true);
                    }(e3, t3);
                    break;
                  case 20:
                    !function(e4, t4) {
                      const { push: r3, helper: n2, indent: s3, deindent: i2, newline: o2 } = t4;
                      r3(`_cache[${e4.index}] || (`), e4.isVNode && (s3(), r3(`${n2(M)}(-1),`), o2()), r3(`_cache[${e4.index}] = `), vt(e4.value, t4), e4.isVNode && (r3(","), o2(), r3(`${n2(M)}(1),`), o2(), r3(`_cache[${e4.index}]`), i2()), r3(")");
                    }(e3, t3);
                    break;
                  case 21:
                    bt(e3.body, t3, true, false);
                    break;
                  case 22:
                    !function(e4, t4) {
                      const { push: r3, indent: s3, deindent: i2 } = t4;
                      r3("`");
                      const o2 = e4.elements.length, a2 = o2 > 3;
                      for (let l2 = 0; l2 < o2; l2++) {
                        const o3 = e4.elements[l2];
                        n.isString(o3) ? r3(o3.replace(/(`|\$|\\)/g, "\\$1")) : (r3("${"), a2 && s3(), vt(o3, t4), a2 && i2(), r3("}"));
                      }
                      r3("`");
                    }(e3, t3);
                    break;
                  case 23:
                    Tt(e3, t3);
                    break;
                  case 24:
                    !function(e4, t4) {
                      vt(e4.left, t4), t4.push(" = "), vt(e4.right, t4);
                    }(e3, t3);
                    break;
                  case 25:
                    !function(e4, t4) {
                      t4.push("("), bt(e4.expressions, t4), t4.push(")");
                    }(e3, t3);
                    break;
                  case 26:
                    !function({ returns: e4 }, t4) {
                      t4.push("return "), n.isArray(e4) ? gt(e4, t4) : vt(e4, t4);
                    }(e3, t3);
                }
            }
            function Et(e3, t3) {
              const { content: r3, isStatic: n2 } = e3;
              t3.push(n2 ? JSON.stringify(r3) : r3, e3);
            }
            function xt(e3, t3) {
              for (let r3 = 0; r3 < e3.children.length; r3++) {
                const s3 = e3.children[r3];
                n.isString(s3) ? t3.push(s3) : vt(s3, t3);
              }
            }
            function St(e3, t3) {
              const { push: r3 } = t3;
              e3.type === 8 ? (r3("["), xt(e3, t3), r3("]")) : e3.isStatic ? r3(oe(e3.content) ? e3.content : JSON.stringify(e3.content), e3) : r3(`[${e3.content}]`, e3);
            }
            function Tt(e3, t3) {
              const { push: r3, indent: n2, deindent: s3 } = t3, { test: i2, consequent: o2, alternate: a2 } = e3;
              r3("if ("), vt(i2, t3), r3(") {"), n2(), vt(o2, t3), s3(), r3("}"), a2 && (r3(" else "), a2.type === 23 ? Tt(a2, t3) : (r3("{"), n2(), vt(a2, t3), s3(), r3("}")));
            }
            const wt = n.makeMap("true,false,null,this"), Pt = (e3, t3) => {
              if (e3.type === 5)
                e3.content = At(e3.content, t3);
              else if (e3.type === 1)
                for (let r3 = 0; r3 < e3.props.length; r3++) {
                  const n2 = e3.props[r3];
                  if (n2.type === 7 && n2.name !== "for") {
                    const e4 = n2.exp, r4 = n2.arg;
                    !e4 || e4.type !== 4 || n2.name === "on" && r4 || (n2.exp = At(e4, t3, n2.name === "slot")), r4 && r4.type === 4 && !r4.isStatic && (n2.arg = At(r4, t3));
                  }
                }
            };
            function At(e3, t3, r3 = false, s3 = false) {
              if (!t3.prefixIdentifiers || !e3.content.trim())
                return e3;
              const { inline: a2, bindingMetadata: l2 } = t3, u2 = (e4, r4, s4) => {
                const i2 = n.hasOwn(l2, e4) && l2[e4];
                if (a2) {
                  const n2 = r4 && r4.type === "AssignmentExpression" && r4.left === s4, o2 = r4 && r4.type === "UpdateExpression" && r4.argument === s4, a3 = r4 && kt(r4, g2);
                  if (i2 === "setup-const")
                    return e4;
                  if (i2 === "setup-ref")
                    return `${e4}.value`;
                  if (i2 === "setup-maybe-ref")
                    return n2 || o2 || a3 ? `${e4}.value` : `${t3.helperString($)}(${e4})`;
                  if (i2 === "setup-let") {
                    if (n2) {
                      const { right: n3, operator: s5 } = r4, i3 = Nt(At(X(p3.slice(n3.start - 1, n3.end - 1), false), t3));
                      return `${t3.helperString(q)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${e4}.value ${s5} ${i3} : ${e4}`;
                    }
                    if (o2) {
                      s4.start = r4.start, s4.end = r4.end;
                      const { prefix: n3, operator: i3 } = r4, o3 = n3 ? i3 : "", a4 = n3 ? "" : i3;
                      return `${t3.helperString(q)}(${e4})${t3.isTS ? " //@ts-ignore\n" : ""} ? ${o3}${e4}.value${a4} : ${o3}${e4}${a4}`;
                    }
                    return a3 ? e4 : `${t3.helperString($)}(${e4})`;
                  }
                  if (i2 === "props")
                    return `__props.${e4}`;
                } else {
                  if (i2 && i2.startsWith("setup"))
                    return `$setup.${e4}`;
                  if (i2)
                    return `$${i2}.${e4}`;
                }
                return `_ctx.${e4}`;
              }, p3 = e3.content, f2 = p3.indexOf("(") > -1 || p3.indexOf(".") > 0;
              if (oe(p3)) {
                const s4 = t3.identifiers[p3], i2 = n.isGloballyWhitelisted(p3), o2 = wt(p3);
                return r3 || s4 || i2 || o2 ? s4 || (e3.constType = o2 ? 3 : 2) : (l2[e3.content] === "setup-const" && (e3.constType = 1), e3.content = u2(p3)), e3;
              }
              let d2;
              const h4 = s3 ? ` ${p3} ` : `(${p3})${r3 ? "=>{}" : ""}`;
              try {
                d2 = i.parse(h4, { plugins: [...t3.expressionPlugins, ...n.babelParserDefaultPlugins] }).program;
              } catch (r4) {
                return t3.onError(c(43, e3.loc, void 0, r4.message)), e3;
              }
              const m2 = [], y2 = Object.create(t3.identifiers), g2 = [];
              o.walk(d2, { enter(e4, t4) {
                if (t4 && g2.push(t4), e4.type === "Identifier") {
                  if (!((e5) => m2.some((t5) => t5.start === e5.start))(e4)) {
                    if (e4.name.startsWith("_filter_"))
                      return;
                    const r4 = function(e5, t5, r5) {
                      if ((t5.type === "VariableDeclarator" || t5.type === "ClassDeclaration") && t5.id === e5)
                        return false;
                      if (Ot(t5)) {
                        if (t5.id === e5)
                          return false;
                        if (t5.params.includes(e5))
                          return false;
                      }
                      return !It(e5, t5) && (!(t5.type === "ArrayPattern" && !kt(t5, r5)) && (!!(t5.type !== "MemberExpression" && t5.type !== "OptionalMemberExpression" || t5.property !== e5 || t5.computed) && (e5.name !== "arguments" && (!n.isGloballyWhitelisted(e5.name) && e5.name !== "require"))));
                    }(e4, t4, g2);
                    !y2[e4.name] && r4 ? (Ct(t4) && t4.shorthand && (e4.prefix = `${e4.name}: `), e4.name = u2(e4.name, t4, e4), m2.push(e4)) : It(e4, t4) || (r4 && y2[e4.name] || f2 || (e4.isConstant = true), m2.push(e4));
                  }
                } else
                  Ot(e4) && e4.params.forEach((t5) => o.walk(t5, { enter(t6, r4) {
                    if (!(t6.type !== "Identifier" || It(t6, r4) || r4 && r4.type === "AssignmentPattern" && r4.right === t6)) {
                      const { name: r5 } = t6;
                      if (e4.scopeIds && e4.scopeIds.has(r5))
                        return;
                      r5 in y2 ? y2[r5]++ : y2[r5] = 1, (e4.scopeIds || (e4.scopeIds = new Set())).add(r5);
                    }
                  } }));
              }, leave(e4, t4) {
                t4 && g2.pop(), e4 !== d2.body[0].expression && e4.scopeIds && e4.scopeIds.forEach((e5) => {
                  y2[e5]--, y2[e5] === 0 && delete y2[e5];
                });
              } });
              const b2 = [];
              let v2;
              return m2.sort((e4, t4) => e4.start - t4.start), m2.forEach((t4, r4) => {
                const n2 = t4.start - 1, s4 = t4.end - 1, i2 = m2[r4 - 1], o2 = p3.slice(i2 ? i2.end - 1 : 0, n2);
                (o2.length || t4.prefix) && b2.push(o2 + (t4.prefix || ""));
                const a3 = p3.slice(n2, s4);
                b2.push(X(t4.name, false, { source: a3, start: fe(e3.loc.start, a3, n2), end: fe(e3.loc.start, a3, s4) }, t4.isConstant ? 3 : 0)), r4 === m2.length - 1 && s4 < p3.length && b2.push(p3.slice(s4));
              }), b2.length ? v2 = z(b2, e3.loc) : (v2 = e3, v2.constType = f2 ? 0 : 3), v2.identifiers = Object.keys(y2), v2;
            }
            const Ot = (e3) => /Function(?:Expression|Declaration)$|Method$/.test(e3.type), Ct = (e3) => e3 && (e3.type === "ObjectProperty" || e3.type === "ObjectMethod") && !e3.computed, It = (e3, t3) => Ct(t3) && t3.key === e3;
            function kt(e3, t3) {
              if (e3 && (e3.type === "ObjectProperty" || e3.type === "ArrayPattern")) {
                let e4 = t3.length;
                for (; e4--; ) {
                  const r3 = t3[e4];
                  if (r3.type === "AssignmentExpression")
                    return true;
                  if (r3.type !== "ObjectProperty" && !r3.type.endsWith("Pattern"))
                    break;
                }
              }
              return false;
            }
            function Nt(e3) {
              return n.isString(e3) ? e3 : e3.type === 4 ? e3.content : e3.children.map(Nt).join("");
            }
            const _t = pt(/^(if|else|else-if)$/, (e3, t3, r3) => jt(e3, t3, r3, (e4, t4, n2) => {
              const s3 = r3.parent.children;
              let i2 = s3.indexOf(e4), o2 = 0;
              for (; i2-- >= 0; ) {
                const e5 = s3[i2];
                e5 && e5.type === 9 && (o2 += e5.branches.length);
              }
              return () => {
                n2 ? e4.codegenNode = Lt(t4, o2, r3) : function(e5) {
                  for (; ; )
                    if (e5.type === 19) {
                      if (e5.alternate.type !== 19)
                        return e5;
                      e5 = e5.alternate;
                    } else
                      e5.type === 20 && (e5 = e5.value);
                }(e4.codegenNode).alternate = Lt(t4, o2 + e4.branches.length - 1, r3);
              };
            }));
            function jt(e3, t3, r3, n2) {
              if (!(t3.name === "else" || t3.exp && t3.exp.content.trim())) {
                const n3 = t3.exp ? t3.exp.loc : e3.loc;
                r3.onError(c(27, t3.loc)), t3.exp = X("true", false, n3);
              }
              if (r3.prefixIdentifiers && t3.exp && (t3.exp = At(t3.exp, r3)), t3.name === "if") {
                const s3 = Dt(e3, t3), i2 = { type: 9, loc: e3.loc, branches: [s3] };
                if (r3.replaceNode(i2), n2)
                  return n2(i2, s3, true);
              } else {
                const s3 = r3.parent.children;
                let i2 = s3.indexOf(e3);
                for (; i2-- >= -1; ) {
                  const o2 = s3[i2];
                  if (!o2 || o2.type !== 2 || o2.content.trim().length) {
                    if (o2 && o2.type === 9) {
                      r3.removeNode();
                      const s4 = Dt(e3, t3);
                      {
                        const e4 = s4.userKey;
                        e4 && o2.branches.forEach(({ userKey: t4 }) => {
                          Bt(t4, e4) && r3.onError(c(28, s4.userKey.loc));
                        });
                      }
                      o2.branches.push(s4);
                      const i3 = n2 && n2(o2, s4, false);
                      ut(s4, r3), i3 && i3(), r3.currentNode = null;
                    } else
                      r3.onError(c(29, e3.loc));
                    break;
                  }
                  r3.removeNode(o2);
                }
              }
            }
            function Dt(e3, t3) {
              return { type: 10, loc: e3.loc, condition: t3.name === "else" ? void 0 : t3.exp, children: e3.tagType !== 3 || he(e3, "for") ? [e3] : e3.children, userKey: me(e3, "key") };
            }
            function Lt(e3, t3, r3) {
              return e3.condition ? ee(e3.condition, Mt(e3, t3, r3), Q(r3.helper(v), ['""', "true"])) : Mt(e3, t3, r3);
            }
            function Mt(e3, t3, r3) {
              const { helper: s3, removeHelper: i2 } = r3, o2 = Y("key", X(`${t3}`, false, W, 2)), { children: a2 } = e3, l2 = a2[0];
              if (a2.length !== 1 || l2.type !== 1) {
                if (a2.length === 1 && l2.type === 11) {
                  const e4 = l2.codegenNode;
                  return xe(e4, o2, r3), e4;
                }
                {
                  let t4 = 64;
                  return n.PatchFlagNames[64], G(r3, s3(p2), J([o2]), a2, t4 + "", void 0, void 0, true, false, e3.loc);
                }
              }
              {
                const e4 = l2.codegenNode;
                return e4.type !== 13 || e4.isBlock || (i2(b), e4.isBlock = true, s3(y), s3(g)), xe(e4, o2, r3), e4;
              }
            }
            function Bt(e3, t3) {
              if (!e3 || e3.type !== t3.type)
                return false;
              if (e3.type === 6) {
                if (e3.value.content !== t3.value.content)
                  return false;
              } else {
                const r3 = e3.exp, n2 = t3.exp;
                if (r3.type !== n2.type)
                  return false;
                if (r3.type !== 4 || r3.isStatic !== n2.isStatic || r3.content !== n2.content)
                  return false;
              }
              return true;
            }
            const Rt = pt("for", (e3, t3, r3) => {
              const { helper: n2, removeHelper: s3 } = r3;
              return Ft(e3, t3, r3, (t4) => {
                const i2 = Q(n2(O), [t4.source]), o2 = me(e3, "key"), a2 = o2 ? Y("key", o2.type === 6 ? X(o2.value.content, true) : o2.exp) : null;
                r3.prefixIdentifiers && a2 && (a2.value = At(a2.value, r3));
                const l2 = t4.source.type === 4 && t4.source.constType > 0, u2 = l2 ? 64 : o2 ? 128 : 256;
                return t4.codegenNode = G(r3, n2(p2), void 0, i2, u2 + "", void 0, void 0, true, !l2, e3.loc), () => {
                  let o3;
                  const u3 = ve(e3), { children: f2 } = t4;
                  u3 && e3.children.some((e4) => {
                    if (e4.type === 1) {
                      const t5 = me(e4, "key");
                      if (t5)
                        return r3.onError(c(32, t5.loc)), true;
                    }
                  });
                  const d2 = f2.length !== 1 || f2[0].type !== 1, h4 = Ee(e3) ? e3 : u3 && e3.children.length === 1 && Ee(e3.children[0]) ? e3.children[0] : null;
                  h4 ? (o3 = h4.codegenNode, u3 && a2 && xe(o3, a2, r3)) : d2 ? o3 = G(r3, n2(p2), a2 ? J([a2]) : void 0, e3.children, "64", void 0, void 0, true) : (o3 = f2[0].codegenNode, u3 && a2 && xe(o3, a2, r3), o3.isBlock !== !l2 && (o3.isBlock ? (s3(y), s3(g)) : s3(b)), o3.isBlock = !l2, o3.isBlock ? (n2(y), n2(g)) : n2(b)), i2.arguments.push(Z(Kt(t4.parseResult), o3, true));
                };
              });
            });
            function Ft(e3, t3, r3, n2) {
              if (!t3.exp)
                return void r3.onError(c(30, t3.loc));
              const s3 = Vt(t3.exp, r3);
              if (!s3)
                return void r3.onError(c(31, t3.loc));
              const { addIdentifiers: i2, removeIdentifiers: o2, scopes: a2 } = r3, { source: l2, value: u2, key: p3, index: f2 } = s3, d2 = { type: 11, loc: t3.loc, source: l2, valueAlias: u2, keyAlias: p3, objectIndexAlias: f2, parseResult: s3, children: ve(e3) ? e3.children : [e3] };
              r3.replaceNode(d2), a2.vFor++, r3.prefixIdentifiers && (u2 && i2(u2), p3 && i2(p3), f2 && i2(f2));
              const h4 = n2 && n2(d2);
              return () => {
                a2.vFor--, r3.prefixIdentifiers && (u2 && o2(u2), p3 && o2(p3), f2 && o2(f2)), h4 && h4();
              };
            }
            const Ut = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, $t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, qt = /^\(|\)$/g;
            function Vt(e3, t3) {
              const r3 = e3.loc, n2 = e3.content, s3 = n2.match(Ut);
              if (!s3)
                return;
              const [, i2, o2] = s3, a2 = { source: Wt(r3, o2.trim(), n2.indexOf(o2, i2.length)), value: void 0, key: void 0, index: void 0 };
              t3.prefixIdentifiers && (a2.source = At(a2.source, t3));
              let l2 = i2.trim().replace(qt, "").trim();
              const c4 = i2.indexOf(l2), u2 = l2.match($t);
              if (u2) {
                l2 = l2.replace($t, "").trim();
                const e4 = u2[1].trim();
                let s4;
                if (e4 && (s4 = n2.indexOf(e4, c4 + l2.length), a2.key = Wt(r3, e4, s4), t3.prefixIdentifiers && (a2.key = At(a2.key, t3, true))), u2[2]) {
                  const i3 = u2[2].trim();
                  i3 && (a2.index = Wt(r3, i3, n2.indexOf(i3, a2.key ? s4 + e4.length : c4 + l2.length)), t3.prefixIdentifiers && (a2.index = At(a2.index, t3, true)));
                }
              }
              return l2 && (a2.value = Wt(r3, l2, c4), t3.prefixIdentifiers && (a2.value = At(a2.value, t3, true))), a2;
            }
            function Wt(e3, t3, r3) {
              return X(t3, false, pe(e3, r3, t3.length));
            }
            function Kt({ value: e3, key: t3, index: r3 }) {
              const n2 = [];
              return e3 && n2.push(e3), t3 && (e3 || n2.push(X("_", false)), n2.push(t3)), r3 && (t3 || (e3 || n2.push(X("_", false)), n2.push(X("__", false))), n2.push(r3)), n2;
            }
            const Gt = X("undefined", false), Ht = (e3, t3) => {
              if (e3.type === 1 && (e3.tagType === 1 || e3.tagType === 3)) {
                const r3 = he(e3, "slot");
                if (r3) {
                  const e4 = r3.exp;
                  return t3.prefixIdentifiers && e4 && t3.addIdentifiers(e4), t3.scopes.vSlot++, () => {
                    t3.prefixIdentifiers && e4 && t3.removeIdentifiers(e4), t3.scopes.vSlot--;
                  };
                }
              }
            }, Jt = (e3, t3) => {
              let r3;
              if (ve(e3) && e3.props.some(be) && (r3 = he(e3, "for"))) {
                const e4 = r3.parseResult = Vt(r3.exp, t3);
                if (e4) {
                  const { value: r4, key: n2, index: s3 } = e4, { addIdentifiers: i2, removeIdentifiers: o2 } = t3;
                  return r4 && i2(r4), n2 && i2(n2), s3 && i2(s3), () => {
                    r4 && o2(r4), n2 && o2(n2), s3 && o2(s3);
                  };
                }
              }
            }, Yt = (e3, t3, r3) => Z(e3, t3, false, true, t3.length ? t3[0].loc : r3);
            function Xt(e3, t3, r3 = Yt) {
              t3.helper(U);
              const { children: n2, loc: s3 } = e3, i2 = [], o2 = [];
              let a2 = t3.scopes.vSlot > 0 || t3.scopes.vFor > 0;
              !t3.ssr && t3.prefixIdentifiers && (a2 = Te(e3, t3.identifiers));
              const l2 = he(e3, "slot", true);
              if (l2) {
                const { arg: e4, exp: t4 } = l2;
                e4 && !re(e4) && (a2 = true), i2.push(Y(e4 || X("default", true), r3(t4, n2, s3)));
              }
              let u2 = false, p3 = false;
              const f2 = [], d2 = new Set();
              for (let e4 = 0; e4 < n2.length; e4++) {
                const s4 = n2[e4];
                let h5;
                if (!ve(s4) || !(h5 = he(s4, "slot", true))) {
                  s4.type !== 3 && f2.push(s4);
                  continue;
                }
                if (l2) {
                  t3.onError(c(36, h5.loc));
                  break;
                }
                u2 = true;
                const { children: m3, loc: y2 } = s4, { arg: g2 = X("default", true), exp: b2, loc: v2 } = h5;
                let E2;
                re(g2) ? E2 = g2 ? g2.content : "default" : a2 = true;
                const x2 = r3(b2, m3, y2);
                let S2, T2, w2;
                if (S2 = he(s4, "if"))
                  a2 = true, o2.push(ee(S2.exp, zt(g2, x2), Gt));
                else if (T2 = he(s4, /^else(-if)?$/, true)) {
                  let r4, s5 = e4;
                  for (; s5-- && (r4 = n2[s5], r4.type === 3); )
                    ;
                  if (r4 && ve(r4) && he(r4, "if")) {
                    n2.splice(e4, 1), e4--;
                    let t4 = o2[o2.length - 1];
                    for (; t4.alternate.type === 19; )
                      t4 = t4.alternate;
                    t4.alternate = T2.exp ? ee(T2.exp, zt(g2, x2), Gt) : zt(g2, x2);
                  } else
                    t3.onError(c(29, T2.loc));
                } else if (w2 = he(s4, "for")) {
                  a2 = true;
                  const e5 = w2.parseResult || Vt(w2.exp, t3);
                  e5 ? o2.push(Q(t3.helper(O), [e5.source, Z(Kt(e5), zt(g2, x2), true)])) : t3.onError(c(31, w2.loc));
                } else {
                  if (E2) {
                    if (d2.has(E2)) {
                      t3.onError(c(37, v2));
                      continue;
                    }
                    d2.add(E2), E2 === "default" && (p3 = true);
                  }
                  i2.push(Y(g2, x2));
                }
              }
              if (!l2) {
                const e4 = (e5, n3) => {
                  const i3 = r3(e5, n3, s3);
                  return t3.compatConfig && (i3.isNonScopedSlot = true), Y("default", i3);
                };
                u2 ? f2.length && f2.some((e5) => Zt(e5)) && (p3 ? t3.onError(c(38, f2[0].loc)) : i2.push(e4(void 0, f2))) : i2.push(e4(void 0, n2));
              }
              const h4 = a2 ? 2 : Qt(e3.children) ? 3 : 1;
              let m2 = J(i2.concat(Y("_", X(h4 + "", false))), s3);
              return o2.length && (m2 = Q(t3.helper(I), [m2, H(o2)])), { slots: m2, hasDynamicSlots: a2 };
            }
            function zt(e3, t3) {
              return J([Y("name", e3), Y("fn", t3)]);
            }
            function Qt(e3) {
              for (let t3 = 0; t3 < e3.length; t3++) {
                const r3 = e3[t3];
                switch (r3.type) {
                  case 1:
                    if (r3.tagType === 2 || r3.tagType === 0 && Qt(r3.children))
                      return true;
                    break;
                  case 9:
                    if (Qt(r3.branches))
                      return true;
                    break;
                  case 10:
                  case 11:
                    if (Qt(r3.children))
                      return true;
                }
              }
              return false;
            }
            function Zt(e3) {
              return e3.type !== 2 && e3.type !== 12 || (e3.type === 2 ? !!e3.content.trim() : Zt(e3.content));
            }
            const er = new WeakMap(), tr = (e3, t3) => function() {
              if ((e3 = t3.currentNode).type !== 1 || e3.tagType !== 0 && e3.tagType !== 1)
                return;
              const { tag: r3, props: s3 } = e3, i2 = e3.tagType === 1;
              let o2, a2, l2, c4, u2, p3, m2 = i2 ? rr(e3, t3) : `"${r3}"`, y2 = 0, g2 = n.isObject(m2) && m2.callee === T || m2 === f || m2 === d || !i2 && (r3 === "svg" || r3 === "foreignObject" || me(e3, "key", true));
              if (s3.length > 0) {
                const r4 = sr(e3, t3);
                o2 = r4.props, y2 = r4.patchFlag, u2 = r4.dynamicPropNames;
                const n2 = r4.directives;
                p3 = n2 && n2.length ? H(n2.map((e4) => function(e5, t4) {
                  const r5 = [], n3 = er.get(e5);
                  if (n3)
                    r5.push(t4.helperString(n3));
                  else {
                    const n4 = nr("v-" + e5.name, t4);
                    n4 ? r5.push(n4) : (t4.helper(w), t4.directives.add(e5.name), r5.push(Se(e5.name, "directive")));
                  }
                  const { loc: s4 } = e5;
                  if (e5.exp && r5.push(e5.exp), e5.arg && (e5.exp || r5.push("void 0"), r5.push(e5.arg)), Object.keys(e5.modifiers).length) {
                    e5.arg || (e5.exp || r5.push("void 0"), r5.push("void 0"));
                    const t5 = X("true", false, s4);
                    r5.push(J(e5.modifiers.map((e6) => Y(e6, t5)), s4));
                  }
                  return H(r5, e5.loc);
                }(e4, t3))) : void 0;
              }
              if (e3.children.length > 0)
                if (m2 === h3 && (g2 = true, y2 |= 1024), i2 && m2 !== f && m2 !== h3) {
                  const { slots: r4, hasDynamicSlots: n2 } = Xt(e3, t3);
                  a2 = r4, n2 && (y2 |= 1024);
                } else if (e3.children.length === 1 && m2 !== f) {
                  const r4 = e3.children[0], n2 = r4.type, s4 = n2 === 5 || n2 === 8;
                  s4 && st(r4, t3) === 0 && (y2 |= 1), a2 = s4 || n2 === 2 ? r4 : e3.children;
                } else
                  a2 = e3.children;
              y2 !== 0 && (l2 = String(y2), u2 && u2.length && (c4 = function(e4) {
                let t4 = "[";
                for (let r4 = 0, n2 = e4.length; r4 < n2; r4++)
                  t4 += JSON.stringify(e4[r4]), r4 < n2 - 1 && (t4 += ", ");
                return t4 + "]";
              }(u2))), e3.codegenNode = G(t3, m2, o2, a2, l2, c4, p3, !!g2, false, e3.loc);
            };
            function rr(e3, t3, r3 = false) {
              let { tag: s3 } = e3;
              const i2 = ar(s3), o2 = me(e3, "is");
              if (o2)
                if (i2 || Ae("COMPILER_IS_ON_ELEMENT", t3)) {
                  const e4 = o2.type === 6 ? o2.value && X(o2.value.content, true) : o2.exp;
                  if (e4)
                    return Q(t3.helper(T), [e4]);
                } else
                  o2.type === 6 && o2.value.content.startsWith("vue:") && (s3 = o2.value.content.slice(4));
              const a2 = !i2 && he(e3, "is");
              if (a2 && a2.exp)
                return Q(t3.helper(T), [a2.exp]);
              const l2 = se(s3) || t3.isBuiltInComponent(s3);
              if (l2)
                return r3 || t3.helper(l2), l2;
              {
                const e4 = nr(s3, t3);
                if (e4)
                  return e4;
              }
              return t3.selfName && n.capitalize(n.camelize(s3)) === t3.selfName ? (t3.helper(S), t3.components.add(s3 + "__self"), Se(s3, "component")) : (t3.helper(S), t3.components.add(s3), Se(s3, "component"));
            }
            function nr(e3, t3) {
              const r3 = t3.bindingMetadata;
              if (!r3 || r3.__isScriptSetup === false)
                return;
              const s3 = n.camelize(e3), i2 = n.capitalize(s3), o2 = (t4) => r3[e3] === t4 ? e3 : r3[s3] === t4 ? s3 : r3[i2] === t4 ? i2 : void 0, a2 = o2("setup-const");
              if (a2)
                return t3.inline ? a2 : `$setup[${JSON.stringify(a2)}]`;
              const l2 = o2("setup-let") || o2("setup-ref") || o2("setup-maybe-ref");
              return l2 ? t3.inline ? `${t3.helperString($)}(${l2})` : `$setup[${JSON.stringify(l2)}]` : void 0;
            }
            function sr(e3, t3, r3 = e3.props, s3 = false) {
              const { tag: i2, loc: o2 } = e3, a2 = e3.tagType === 1;
              let l2 = [];
              const u2 = [], p3 = [];
              let f2 = 0, d2 = false, h4 = false, m2 = false, y2 = false, g2 = false, b2 = false;
              const v2 = [], E2 = ({ key: e4, value: r4 }) => {
                if (re(e4)) {
                  const s4 = e4.content, i3 = n.isOn(s4);
                  if (a2 || !i3 || s4.toLowerCase() === "onclick" || s4 === "onUpdate:modelValue" || n.isReservedProp(s4) || (y2 = true), i3 && n.isReservedProp(s4) && (b2 = true), r4.type === 20 || (r4.type === 4 || r4.type === 8) && st(r4, t3) > 0)
                    return;
                  s4 === "ref" ? d2 = true : s4 !== "class" || a2 ? s4 !== "style" || a2 ? s4 === "key" || v2.includes(s4) || v2.push(s4) : m2 = true : h4 = true;
                } else
                  g2 = true;
              };
              for (let f3 = 0; f3 < r3.length; f3++) {
                const h5 = r3[f3];
                if (h5.type === 6) {
                  const { loc: e4, name: r4, value: n2 } = h5;
                  let s4 = true;
                  if (r4 === "ref" && (d2 = true, t3.inline && (s4 = false)), r4 === "is" && (ar(i2) || n2 && n2.content.startsWith("vue:") || Ae("COMPILER_IS_ON_ELEMENT", t3)))
                    continue;
                  l2.push(Y(X(r4, true, pe(e4, 0, r4.length)), X(n2 ? n2.content : "", s4, n2 ? n2.loc : e4)));
                } else {
                  const { name: r4, arg: f4, exp: d3, loc: m3 } = h5, y3 = r4 === "bind", b3 = r4 === "on";
                  if (r4 === "slot") {
                    a2 || t3.onError(c(39, m3));
                    continue;
                  }
                  if (r4 === "once")
                    continue;
                  if (r4 === "is" || y3 && ye(f4, "is") && (ar(i2) || Ae("COMPILER_IS_ON_ELEMENT", t3)))
                    continue;
                  if (b3 && s3)
                    continue;
                  if (!f4 && (y3 || b3)) {
                    if (g2 = true, d3)
                      if (l2.length && (u2.push(J(ir(l2), o2)), l2 = []), y3) {
                        if (Ae("COMPILER_V_BIND_OBJECT_ORDER", t3)) {
                          u2.unshift(d3);
                          continue;
                        }
                        u2.push(d3);
                      } else
                        u2.push({ type: 14, loc: m3, callee: t3.helper(_), arguments: [d3] });
                    else
                      t3.onError(c(y3 ? 33 : 34, m3));
                    continue;
                  }
                  const v3 = t3.directiveTransforms[r4];
                  if (v3) {
                    const { props: r5, needRuntime: i3 } = v3(h5, e3, t3);
                    !s3 && r5.forEach(E2), l2.push(...r5), i3 && (p3.push(h5), n.isSymbol(i3) && er.set(h5, i3));
                  } else
                    p3.push(h5);
                }
                h5.type === 6 && h5.name === "ref" && t3.scopes.vFor > 0 && Oe("COMPILER_V_FOR_REF", t3, h5.loc) && l2.push(Y(X("refInFor", true), X("true", false)));
              }
              let x2;
              return u2.length ? (l2.length && u2.push(J(ir(l2), o2)), x2 = u2.length > 1 ? Q(t3.helper(N), u2, o2) : u2[0]) : l2.length && (x2 = J(ir(l2), o2)), g2 ? f2 |= 16 : (h4 && (f2 |= 2), m2 && (f2 |= 4), v2.length && (f2 |= 8), y2 && (f2 |= 32)), f2 !== 0 && f2 !== 32 || !(d2 || b2 || p3.length > 0) || (f2 |= 512), { props: x2, directives: p3, patchFlag: f2, dynamicPropNames: v2 };
            }
            function ir(e3) {
              const t3 = new Map(), r3 = [];
              for (let n2 = 0; n2 < e3.length; n2++) {
                const s3 = e3[n2];
                if (s3.key.type === 8 || !s3.key.isStatic) {
                  r3.push(s3);
                  continue;
                }
                const i2 = s3.key.content, o2 = t3.get(i2);
                o2 ? (i2 === "style" || i2 === "class" || i2.startsWith("on")) && or(o2, s3) : (t3.set(i2, s3), r3.push(s3));
              }
              return r3;
            }
            function or(e3, t3) {
              e3.value.type === 17 ? e3.value.elements.push(t3.value) : e3.value = H([e3.value, t3.value], e3.loc);
            }
            function ar(e3) {
              return e3[0].toLowerCase() + e3.slice(1) === "component";
            }
            const lr = /-(\w)/g, cr = ((e3) => {
              const t3 = Object.create(null);
              return (e4) => t3[e4] || (t3[e4] = ((e5) => e5.replace(lr, (e6, t4) => t4 ? t4.toUpperCase() : ""))(e4));
            })(), ur = (e3, t3) => {
              if (Ee(e3)) {
                const { children: r3, loc: n2 } = e3, { slotName: s3, slotProps: i2 } = pr(e3, t3), o2 = [t3.prefixIdentifiers ? "_ctx.$slots" : "$slots", s3];
                i2 && o2.push(i2), r3.length && (i2 || o2.push("{}"), o2.push(Z([], r3, false, false, n2))), t3.scopeId && !t3.slotted && (i2 || o2.push("{}"), r3.length || o2.push("undefined"), o2.push("true")), e3.codegenNode = Q(t3.helper(C), o2, n2);
              }
            };
            function pr(e3, t3) {
              let r3, n2 = '"default"';
              const s3 = [];
              for (let t4 = 0; t4 < e3.props.length; t4++) {
                const r4 = e3.props[t4];
                r4.type === 6 ? r4.value && (r4.name === "name" ? n2 = JSON.stringify(r4.value.content) : (r4.name = cr(r4.name), s3.push(r4))) : r4.name === "bind" && ye(r4.arg, "name") ? r4.exp && (n2 = r4.exp) : (r4.name === "bind" && r4.arg && re(r4.arg) && (r4.arg.content = cr(r4.arg.content)), s3.push(r4));
              }
              if (s3.length > 0) {
                const { props: n3, directives: i2 } = sr(e3, t3, s3);
                r3 = n3, i2.length && t3.onError(c(35, i2[0].loc));
              }
              return { slotName: n2, slotProps: r3 };
            }
            const fr = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^\s*function(?:\s+[\w$]+)?\s*\(/, dr = (e3, t3, r3, s3) => {
              const { loc: i2, modifiers: o2, arg: a2 } = e3;
              let l2;
              if (e3.exp || o2.length || r3.onError(c(34, i2)), a2.type === 4)
                if (a2.isStatic) {
                  const e4 = a2.content;
                  l2 = X(n.toHandlerKey(n.camelize(e4)), true, a2.loc);
                } else
                  l2 = z([`${r3.helperString(L)}(`, a2, ")"]);
              else
                l2 = a2, l2.children.unshift(`${r3.helperString(L)}(`), l2.children.push(")");
              let u2 = e3.exp;
              u2 && !u2.content.trim() && (u2 = void 0);
              let p3 = r3.cacheHandlers && !u2;
              if (u2) {
                const n2 = ue(u2.content), s4 = !(n2 || fr.test(u2.content)), i3 = u2.content.includes(";");
                r3.prefixIdentifiers && (s4 && r3.addIdentifiers("$event"), u2 = e3.exp = At(u2, r3, false, i3), s4 && r3.removeIdentifiers("$event"), p3 = r3.cacheHandlers && !(u2.type === 4 && u2.constType > 0) && !(n2 && t3.tagType === 1) && !Te(u2, r3.identifiers), p3 && n2 && (u2.type === 4 ? u2.content = `${u2.content} && ${u2.content}(...args)` : u2.children = [...u2.children, " && ", ...u2.children, "(...args)"])), (s4 || p3 && n2) && (u2 = z([`${s4 ? r3.isTS ? "($event: any)" : "$event" : (r3.isTS ? "\n//@ts-ignore\n" : "") + "(...args)"} => ${i3 ? "{" : "("}`, u2, i3 ? "}" : ")"]));
              }
              let f2 = { props: [Y(l2, u2 || X("() => {}", false, i2))] };
              return s3 && (f2 = s3(f2)), p3 && (f2.props[0].value = r3.cache(f2.props[0].value)), f2;
            }, hr = (e3, t3, r3) => {
              const { exp: s3, modifiers: i2, loc: o2 } = e3, a2 = e3.arg;
              return a2.type !== 4 ? (a2.children.unshift("("), a2.children.push(') || ""')) : a2.isStatic || (a2.content = `${a2.content} || ""`), i2.includes("camel") && (a2.type === 4 ? a2.isStatic ? a2.content = n.camelize(a2.content) : a2.content = `${r3.helperString(j)}(${a2.content})` : (a2.children.unshift(`${r3.helperString(j)}(`), a2.children.push(")"))), !s3 || s3.type === 4 && !s3.content.trim() ? (r3.onError(c(33, o2)), { props: [Y(a2, X("", true, o2))] }) : { props: [Y(a2, s3)] };
            }, mr = (e3, t3) => {
              if (e3.type === 0 || e3.type === 1 || e3.type === 11 || e3.type === 10)
                return () => {
                  const r3 = e3.children;
                  let n2, s3 = false;
                  for (let e4 = 0; e4 < r3.length; e4++) {
                    const t4 = r3[e4];
                    if (ge(t4)) {
                      s3 = true;
                      for (let s4 = e4 + 1; s4 < r3.length; s4++) {
                        const i2 = r3[s4];
                        if (!ge(i2)) {
                          n2 = void 0;
                          break;
                        }
                        n2 || (n2 = r3[e4] = { type: 8, loc: t4.loc, children: [t4] }), n2.children.push(" + ", i2), r3.splice(s4, 1), s4--;
                      }
                    }
                  }
                  if (s3 && (r3.length !== 1 || e3.type !== 0 && (e3.type !== 1 || e3.tagType !== 0 || e3.props.find((e4) => e4.type === 7 && !t3.directiveTransforms[e4.name]) || e3.tag === "template")))
                    for (let e4 = 0; e4 < r3.length; e4++) {
                      const n3 = r3[e4];
                      if (ge(n3) || n3.type === 8) {
                        const s4 = [];
                        n3.type === 2 && n3.content === " " || s4.push(n3), t3.ssr || st(n3, t3) !== 0 || s4.push("1"), r3[e4] = { type: 12, content: n3, loc: n3.loc, codegenNode: Q(t3.helper(E), s4) };
                      }
                    }
                };
            }, yr = new WeakSet(), gr = (e3, t3) => {
              if (e3.type === 1 && he(e3, "once", true)) {
                if (yr.has(e3))
                  return;
                return yr.add(e3), t3.helper(M), () => {
                  const e4 = t3.currentNode;
                  e4.codegenNode && (e4.codegenNode = t3.cache(e4.codegenNode, true));
                };
              }
            }, br = (e3, t3, r3) => {
              const { exp: n2, arg: s3 } = e3;
              if (!n2)
                return r3.onError(c(40, e3.loc)), vr();
              const i2 = n2.loc.source, o2 = n2.type === 4 ? n2.content : i2, a2 = r3.bindingMetadata[i2], l2 = r3.inline && a2 && a2 !== "setup-const";
              if (!o2.trim() || !ue(o2) && !l2)
                return r3.onError(c(41, n2.loc)), vr();
              if (r3.prefixIdentifiers && oe(o2) && r3.identifiers[o2])
                return r3.onError(c(42, n2.loc)), vr();
              const u2 = s3 || X("modelValue", true), p3 = s3 ? re(s3) ? `onUpdate:${s3.content}` : z(['"onUpdate:" + ', s3]) : "onUpdate:modelValue";
              let f2;
              const d2 = r3.isTS ? "($event: any)" : "$event";
              if (l2)
                if (a2 === "setup-ref")
                  f2 = z([`${d2} => (`, X(i2, false, n2.loc), ".value = $event)"]);
                else {
                  const e4 = a2 === "setup-let" ? `${i2} = $event` : "null";
                  f2 = z([`${d2} => (${r3.helperString(q)}(${i2}) ? `, X(i2, false, n2.loc), `.value = $event : ${e4})`]);
                }
              else
                f2 = z([`${d2} => (`, n2, " = $event)"]);
              const h4 = [Y(u2, e3.exp), Y(p3, f2)];
              if (r3.prefixIdentifiers && r3.cacheHandlers && !Te(n2, r3.identifiers) && (h4[1].value = r3.cache(h4[1].value)), e3.modifiers.length && t3.tagType === 1) {
                const t4 = e3.modifiers.map((e4) => (oe(e4) ? e4 : JSON.stringify(e4)) + ": true").join(", "), r4 = s3 ? re(s3) ? `${s3.content}Modifiers` : z([s3, ' + "Modifiers"']) : "modelModifiers";
                h4.push(Y(r4, X(`{ ${t4} }`, false, e3.loc, 2)));
              }
              return vr(h4);
            };
            function vr(e3 = []) {
              return { props: e3 };
            }
            const Er = /[\w).+\-_$\]]/, xr = (e3, t3) => {
              Ae("COMPILER_FILTER", t3) && (e3.type === 5 && Sr(e3.content, t3), e3.type === 1 && e3.props.forEach((e4) => {
                e4.type === 7 && e4.name !== "for" && e4.exp && Sr(e4.exp, t3);
              }));
            };
            function Sr(e3, t3) {
              if (e3.type === 4)
                Tr(e3, t3);
              else
                for (let r3 = 0; r3 < e3.children.length; r3++) {
                  const n2 = e3.children[r3];
                  typeof n2 == "object" && (n2.type === 4 ? Tr(n2, t3) : n2.type === 8 ? Sr(e3, t3) : n2.type === 5 && Sr(n2.content, t3));
                }
            }
            function Tr(e3, t3) {
              const r3 = e3.content;
              let n2, s3, i2, o2, a2 = false, l2 = false, c4 = false, u2 = false, p3 = 0, f2 = 0, d2 = 0, h4 = 0, m2 = [];
              for (i2 = 0; i2 < r3.length; i2++)
                if (s3 = n2, n2 = r3.charCodeAt(i2), a2)
                  n2 === 39 && s3 !== 92 && (a2 = false);
                else if (l2)
                  n2 === 34 && s3 !== 92 && (l2 = false);
                else if (c4)
                  n2 === 96 && s3 !== 92 && (c4 = false);
                else if (u2)
                  n2 === 47 && s3 !== 92 && (u2 = false);
                else if (n2 !== 124 || r3.charCodeAt(i2 + 1) === 124 || r3.charCodeAt(i2 - 1) === 124 || p3 || f2 || d2) {
                  switch (n2) {
                    case 34:
                      l2 = true;
                      break;
                    case 39:
                      a2 = true;
                      break;
                    case 96:
                      c4 = true;
                      break;
                    case 40:
                      d2++;
                      break;
                    case 41:
                      d2--;
                      break;
                    case 91:
                      f2++;
                      break;
                    case 93:
                      f2--;
                      break;
                    case 123:
                      p3++;
                      break;
                    case 125:
                      p3--;
                  }
                  if (n2 === 47) {
                    let e4, t4 = i2 - 1;
                    for (; t4 >= 0 && (e4 = r3.charAt(t4), e4 === " "); t4--)
                      ;
                    e4 && Er.test(e4) || (u2 = true);
                  }
                } else
                  o2 === void 0 ? (h4 = i2 + 1, o2 = r3.slice(0, i2).trim()) : y2();
              function y2() {
                m2.push(r3.slice(h4, i2).trim()), h4 = i2 + 1;
              }
              if (o2 === void 0 ? o2 = r3.slice(0, i2).trim() : h4 !== 0 && y2(), m2.length) {
                for (i2 = 0; i2 < m2.length; i2++)
                  o2 = wr(o2, m2[i2], t3);
                e3.content = o2;
              }
            }
            function wr(e3, t3, r3) {
              r3.helper(P);
              const n2 = t3.indexOf("(");
              if (n2 < 0)
                return r3.filters.add(t3), `${Se(t3, "filter")}(${e3})`;
              {
                const s3 = t3.slice(0, n2), i2 = t3.slice(n2 + 1);
                return r3.filters.add(s3), `${Se(s3, "filter")}(${e3}${i2 !== ")" ? "," + i2 : i2}`;
              }
            }
            function Pr(e3) {
              return [[gr, _t, Rt, xr, ...e3 ? [Jt, Pt] : [], ur, tr, Ht, mr], { on: dr, bind: hr, model: br }];
            }
            t2.generateCodeFrame = n.generateCodeFrame, t2.BASE_TRANSITION = m, t2.CAMELIZE = j, t2.CAPITALIZE = D, t2.CREATE_BLOCK = g, t2.CREATE_COMMENT = v, t2.CREATE_SLOTS = I, t2.CREATE_STATIC = x, t2.CREATE_TEXT = E, t2.CREATE_VNODE = b, t2.FRAGMENT = p2, t2.IS_REF = q, t2.KEEP_ALIVE = h3, t2.MERGE_PROPS = N, t2.OPEN_BLOCK = y, t2.POP_SCOPE_ID = R, t2.PUSH_SCOPE_ID = B, t2.RENDER_LIST = O, t2.RENDER_SLOT = C, t2.RESOLVE_COMPONENT = S, t2.RESOLVE_DIRECTIVE = w, t2.RESOLVE_DYNAMIC_COMPONENT = T, t2.RESOLVE_FILTER = P, t2.SET_BLOCK_TRACKING = M, t2.SUSPENSE = d, t2.TELEPORT = f, t2.TO_DISPLAY_STRING = k2, t2.TO_HANDLERS = _, t2.TO_HANDLER_KEY = L, t2.UNREF = $, t2.WITH_CTX = U, t2.WITH_DIRECTIVES = A, t2.WITH_SCOPE_ID = F, t2.advancePositionWithClone = fe, t2.advancePositionWithMutation = de, t2.assert = function(e3, t3) {
              if (!e3)
                throw new Error(t3 || "unexpected compiler condition");
            }, t2.baseCompile = function(e3, t3 = {}) {
              const r3 = t3.onError || a, s3 = t3.mode === "module", i2 = t3.prefixIdentifiers === true || s3;
              !i2 && t3.cacheHandlers && r3(c(47)), t3.scopeId && !s3 && r3(c(48));
              const o2 = n.isString(e3) ? Ne(e3, t3) : e3, [l2, u2] = Pr(i2);
              return ct(o2, n.extend({}, t3, { prefixIdentifiers: i2, nodeTransforms: [...l2, ...t3.nodeTransforms || []], directiveTransforms: n.extend({}, u2, t3.directiveTransforms || {}) })), ht(o2, n.extend({}, t3, { prefixIdentifiers: i2 }));
            }, t2.baseParse = Ne, t2.buildProps = sr, t2.buildSlots = Xt, t2.checkCompatEnabled = Oe, t2.createArrayExpression = H, t2.createAssignmentExpression = function(e3, t3) {
              return { type: 24, left: e3, right: t3, loc: W };
            }, t2.createBlockStatement = function(e3) {
              return { type: 21, body: e3, loc: W };
            }, t2.createCacheExpression = te, t2.createCallExpression = Q, t2.createCompilerError = c, t2.createCompoundExpression = z, t2.createConditionalExpression = ee, t2.createForLoopParams = Kt, t2.createFunctionExpression = Z, t2.createIfStatement = function(e3, t3, r3) {
              return { type: 23, test: e3, consequent: t3, alternate: r3, loc: W };
            }, t2.createInterpolation = function(e3, t3) {
              return { type: 5, loc: t3, content: n.isString(e3) ? X(e3, false, t3) : e3 };
            }, t2.createObjectExpression = J, t2.createObjectProperty = Y, t2.createReturnStatement = function(e3) {
              return { type: 26, returns: e3, loc: W };
            }, t2.createRoot = K, t2.createSequenceExpression = function(e3) {
              return { type: 25, expressions: e3, loc: W };
            }, t2.createSimpleExpression = X, t2.createStructuralDirectiveTransform = pt, t2.createTemplateLiteral = function(e3) {
              return { type: 22, elements: e3, loc: W };
            }, t2.createTransformContext = lt, t2.createVNodeCall = G, t2.findDir = he, t2.findProp = me, t2.generate = ht, t2.getBaseTransformPreset = Pr, t2.getInnerRange = pe, t2.hasDynamicKeyVBind = function(e3) {
              return e3.props.some((e4) => !(e4.type !== 7 || e4.name !== "bind" || e4.arg && e4.arg.type === 4 && e4.arg.isStatic));
            }, t2.hasScopeRef = Te, t2.helperNameMap = V, t2.injectProp = xe, t2.isBindKey = ye, t2.isBuiltInType = ne, t2.isCoreComponent = se, t2.isMemberExpression = ue, t2.isSimpleIdentifier = oe, t2.isSlotOutlet = Ee, t2.isStaticExp = re, t2.isTemplateNode = ve, t2.isText = ge, t2.isVSlot = be, t2.locStub = W, t2.noopDirectiveTransform = () => ({ props: [] }), t2.processExpression = At, t2.processFor = Ft, t2.processIf = jt, t2.processSlotOutlet = pr, t2.registerRuntimeHelpers = function(e3) {
              Object.getOwnPropertySymbols(e3).forEach((t3) => {
                V[t3] = e3[t3];
              });
            }, t2.resolveComponentType = rr, t2.toValidAssetId = Se, t2.trackSlotScopes = Ht, t2.trackVForSlotScopes = Jt, t2.transform = ct, t2.transformBind = hr, t2.transformElement = tr, t2.transformExpression = Pt, t2.transformModel = br, t2.transformOn = dr, t2.traverseNode = ut, t2.warnDeprecation = function(e3, t3, r3, ...n2) {
              if (Pe(e3, t3) === "suppress-warning")
                return;
              const { message: s3, link: i2 } = we[e3], o2 = `(deprecation ${e3}) ${typeof s3 == "function" ? s3(...n2) : s3}${i2 ? `
  Details: ${i2}` : ""}`, a2 = new SyntaxError(o2);
              a2.code = e3, r3 && (a2.loc = r3), t3.onWarn(a2);
            };
          }, (e2, t2, r2) => {
            "use strict";
            function n(e3, t3) {
              const r3 = Object.create(null), n2 = e3.split(",");
              for (let e4 = 0; e4 < n2.length; e4++)
                r3[n2[e4]] = true;
              return t3 ? (e4) => !!r3[e4.toLowerCase()] : (e4) => !!r3[e4];
            }
            Object.defineProperty(t2, "__esModule", { value: true });
            const s2 = { 1: "TEXT", 2: "CLASS", 4: "STYLE", 8: "PROPS", 16: "FULL_PROPS", 32: "HYDRATE_EVENTS", 64: "STABLE_FRAGMENT", 128: "KEYED_FRAGMENT", 256: "UNKEYED_FRAGMENT", 512: "NEED_PATCH", 1024: "DYNAMIC_SLOTS", 2048: "DEV_ROOT_FRAGMENT", [-1]: "HOISTED", [-2]: "BAIL" }, i = n("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt"), o = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", a = n(o), l = n(o + ",async,autofocus,autoplay,controls,default,defer,disabled,hidden,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected"), c = /[>/="'\u0009\u000a\u000c\u0020]/, u = {}, p2 = n("animation-iteration-count,border-image-outset,border-image-slice,border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,stroke-miterlimit,stroke-opacity,stroke-width"), f = n("accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap"), d = /;(?![^(]*\))/g, h3 = /:(.+)/;
            function m(e3) {
              const t3 = {};
              return e3.split(d).forEach((e4) => {
                if (e4) {
                  const r3 = e4.split(h3);
                  r3.length > 1 && (t3[r3[0].trim()] = r3[1].trim());
                }
              }), t3;
            }
            const y = n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot"), g = n("svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view"), b = n("area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr"), v = /["'&<>]/, E = /^-?>|<!--|-->|--!>|<!-$/g;
            function x(e3, t3) {
              if (e3 === t3)
                return true;
              let r3 = I(e3), n2 = I(t3);
              if (r3 || n2)
                return !(!r3 || !n2) && e3.getTime() === t3.getTime();
              if (r3 = A(e3), n2 = A(t3), r3 || n2)
                return !(!r3 || !n2) && function(e4, t4) {
                  if (e4.length !== t4.length)
                    return false;
                  let r4 = true;
                  for (let n3 = 0; r4 && n3 < e4.length; n3++)
                    r4 = x(e4[n3], t4[n3]);
                  return r4;
                }(e3, t3);
              if (r3 = _(e3), n2 = _(t3), r3 || n2) {
                if (!r3 || !n2)
                  return false;
                if (Object.keys(e3).length !== Object.keys(t3).length)
                  return false;
                for (const r4 in e3) {
                  const n3 = e3.hasOwnProperty(r4), s3 = t3.hasOwnProperty(r4);
                  if (n3 && !s3 || !n3 && s3 || !x(e3[r4], t3[r4]))
                    return false;
                }
              }
              return String(e3) === String(t3);
            }
            const S = (e3, t3) => O(t3) ? { [`Map(${t3.size})`]: [...t3.entries()].reduce((e4, [t4, r3]) => (e4[`${t4} =>`] = r3, e4), {}) } : C(t3) ? { [`Set(${t3.size})`]: [...t3.values()] } : !_(t3) || A(t3) || L(t3) ? t3 : String(t3), T = /^on[^a-z]/, w = Object.assign, P = Object.prototype.hasOwnProperty, A = Array.isArray, O = (e3) => D(e3) === "[object Map]", C = (e3) => D(e3) === "[object Set]", I = (e3) => e3 instanceof Date, k2 = (e3) => typeof e3 == "function", N = (e3) => typeof e3 == "string", _ = (e3) => e3 !== null && typeof e3 == "object", j = Object.prototype.toString, D = (e3) => j.call(e3), L = (e3) => D(e3) === "[object Object]", M = n(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), B = (e3) => {
              const t3 = Object.create(null);
              return (r3) => t3[r3] || (t3[r3] = e3(r3));
            }, R = /-(\w)/g, F = B((e3) => e3.replace(R, (e4, t3) => t3 ? t3.toUpperCase() : "")), U = /\B([A-Z])/g, $ = B((e3) => e3.replace(U, "-$1").toLowerCase()), q = B((e3) => e3.charAt(0).toUpperCase() + e3.slice(1)), V = B((e3) => e3 ? `on${q(e3)}` : "");
            let W;
            t2.EMPTY_ARR = [], t2.EMPTY_OBJ = {}, t2.NO = () => false, t2.NOOP = () => {
            }, t2.PatchFlagNames = s2, t2.babelParserDefaultPlugins = ["bigInt", "optionalChaining", "nullishCoalescingOperator"], t2.camelize = F, t2.capitalize = q, t2.def = (e3, t3, r3) => {
              Object.defineProperty(e3, t3, { configurable: true, enumerable: false, value: r3 });
            }, t2.escapeHtml = function(e3) {
              const t3 = "" + e3, r3 = v.exec(t3);
              if (!r3)
                return t3;
              let n2, s3, i2 = "", o2 = 0;
              for (s3 = r3.index; s3 < t3.length; s3++) {
                switch (t3.charCodeAt(s3)) {
                  case 34:
                    n2 = "&quot;";
                    break;
                  case 38:
                    n2 = "&amp;";
                    break;
                  case 39:
                    n2 = "&#39;";
                    break;
                  case 60:
                    n2 = "&lt;";
                    break;
                  case 62:
                    n2 = "&gt;";
                    break;
                  default:
                    continue;
                }
                o2 !== s3 && (i2 += t3.substring(o2, s3)), o2 = s3 + 1, i2 += n2;
              }
              return o2 !== s3 ? i2 + t3.substring(o2, s3) : i2;
            }, t2.escapeHtmlComment = function(e3) {
              return e3.replace(E, "");
            }, t2.extend = w, t2.generateCodeFrame = function(e3, t3 = 0, r3 = e3.length) {
              const n2 = e3.split(/\r?\n/);
              let s3 = 0;
              const i2 = [];
              for (let e4 = 0; e4 < n2.length; e4++)
                if (s3 += n2[e4].length + 1, s3 >= t3) {
                  for (let o2 = e4 - 2; o2 <= e4 + 2 || r3 > s3; o2++) {
                    if (o2 < 0 || o2 >= n2.length)
                      continue;
                    const a2 = o2 + 1;
                    i2.push(`${a2}${" ".repeat(Math.max(3 - String(a2).length, 0))}|  ${n2[o2]}`);
                    const l2 = n2[o2].length;
                    if (o2 === e4) {
                      const e5 = t3 - (s3 - l2) + 1, n3 = Math.max(1, r3 > s3 ? l2 - e5 : r3 - t3);
                      i2.push("   |  " + " ".repeat(e5) + "^".repeat(n3));
                    } else if (o2 > e4) {
                      if (r3 > s3) {
                        const e5 = Math.max(Math.min(r3 - s3, l2), 1);
                        i2.push("   |  " + "^".repeat(e5));
                      }
                      s3 += l2 + 1;
                    }
                  }
                  break;
                }
              return i2.join("\n");
            }, t2.getGlobalThis = () => W || (W = typeof globalThis != "undefined" ? globalThis : typeof self != "undefined" ? self : typeof window != "undefined" ? window : r2.g !== void 0 ? r2.g : {}), t2.hasChanged = (e3, t3) => e3 !== t3 && (e3 == e3 || t3 == t3), t2.hasOwn = (e3, t3) => P.call(e3, t3), t2.hyphenate = $, t2.invokeArrayFns = (e3, t3) => {
              for (let r3 = 0; r3 < e3.length; r3++)
                e3[r3](t3);
            }, t2.isArray = A, t2.isBooleanAttr = l, t2.isDate = I, t2.isFunction = k2, t2.isGloballyWhitelisted = i, t2.isHTMLTag = y, t2.isIntegerKey = (e3) => N(e3) && e3 !== "NaN" && e3[0] !== "-" && "" + parseInt(e3, 10) === e3, t2.isKnownAttr = f, t2.isMap = O, t2.isModelListener = (e3) => e3.startsWith("onUpdate:"), t2.isNoUnitNumericStyleProp = p2, t2.isObject = _, t2.isOn = (e3) => T.test(e3), t2.isPlainObject = L, t2.isPromise = (e3) => _(e3) && k2(e3.then) && k2(e3.catch), t2.isReservedProp = M, t2.isSSRSafeAttrName = function(e3) {
              if (u.hasOwnProperty(e3))
                return u[e3];
              const t3 = c.test(e3);
              return u[e3] = !t3;
            }, t2.isSVGTag = g, t2.isSet = C, t2.isSpecialBooleanAttr = a, t2.isString = N, t2.isSymbol = (e3) => typeof e3 == "symbol", t2.isVoidTag = b, t2.looseEqual = x, t2.looseIndexOf = function(e3, t3) {
              return e3.findIndex((e4) => x(e4, t3));
            }, t2.makeMap = n, t2.normalizeClass = function e3(t3) {
              let r3 = "";
              if (N(t3))
                r3 = t3;
              else if (A(t3))
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const s3 = e3(t3[n2]);
                  s3 && (r3 += s3 + " ");
                }
              else if (_(t3))
                for (const e4 in t3)
                  t3[e4] && (r3 += e4 + " ");
              return r3.trim();
            }, t2.normalizeStyle = function e3(t3) {
              if (A(t3)) {
                const r3 = {};
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const s3 = t3[n2], i2 = e3(N(s3) ? m(s3) : s3);
                  if (i2)
                    for (const e4 in i2)
                      r3[e4] = i2[e4];
                }
                return r3;
              }
              if (_(t3))
                return t3;
            }, t2.objectToString = j, t2.parseStringStyle = m, t2.propsToAttrMap = { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, t2.remove = (e3, t3) => {
              const r3 = e3.indexOf(t3);
              r3 > -1 && e3.splice(r3, 1);
            }, t2.slotFlagsText = { 1: "STABLE", 2: "DYNAMIC", 3: "FORWARDED" }, t2.stringifyStyle = function(e3) {
              let t3 = "";
              if (!e3)
                return t3;
              for (const r3 in e3) {
                const n2 = e3[r3], s3 = r3.startsWith("--") ? r3 : $(r3);
                (N(n2) || typeof n2 == "number" && p2(s3)) && (t3 += `${s3}:${n2};`);
              }
              return t3;
            }, t2.toDisplayString = (e3) => e3 == null ? "" : _(e3) ? JSON.stringify(e3, S, 2) : String(e3), t2.toHandlerKey = V, t2.toNumber = (e3) => {
              const t3 = parseFloat(e3);
              return isNaN(t3) ? e3 : t3;
            }, t2.toRawType = (e3) => D(e3).slice(8, -1), t2.toTypeString = D;
          }, () => {
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            var n = r2(168), s2 = r2(307);
            function i() {
              this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
            }
            t2.parse = v, t2.resolve = function(e3, t3) {
              return v(e3, false, true).resolve(t3);
            }, t2.resolveObject = function(e3, t3) {
              return e3 ? v(e3, false, true).resolveObject(t3) : t3;
            }, t2.format = function(e3) {
              return s2.isString(e3) && (e3 = v(e3)), e3 instanceof i ? e3.format() : i.prototype.format.call(e3);
            }, t2.Url = i;
            var o = /^([a-z0-9.+-]+:)/i, a = /:[0-9]*$/, l = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, c = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]), u = ["'"].concat(c), p2 = ["%", "/", "?", ";", "#"].concat(u), f = ["/", "?", "#"], d = /^[+a-z0-9A-Z_-]{0,63}$/, h3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, m = { javascript: true, "javascript:": true }, y = { javascript: true, "javascript:": true }, g = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true }, b = r2(511);
            function v(e3, t3, r3) {
              if (e3 && s2.isObject(e3) && e3 instanceof i)
                return e3;
              var n2 = new i();
              return n2.parse(e3, t3, r3), n2;
            }
            i.prototype.parse = function(e3, t3, r3) {
              if (!s2.isString(e3))
                throw new TypeError("Parameter 'url' must be a string, not " + typeof e3);
              var i2 = e3.indexOf("?"), a2 = i2 !== -1 && i2 < e3.indexOf("#") ? "?" : "#", c4 = e3.split(a2);
              c4[0] = c4[0].replace(/\\/g, "/");
              var v2 = e3 = c4.join(a2);
              if (v2 = v2.trim(), !r3 && e3.split("#").length === 1) {
                var E = l.exec(v2);
                if (E)
                  return this.path = v2, this.href = v2, this.pathname = E[1], E[2] ? (this.search = E[2], this.query = t3 ? b.parse(this.search.substr(1)) : this.search.substr(1)) : t3 && (this.search = "", this.query = {}), this;
              }
              var x = o.exec(v2);
              if (x) {
                var S = (x = x[0]).toLowerCase();
                this.protocol = S, v2 = v2.substr(x.length);
              }
              if (r3 || x || v2.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var T = v2.substr(0, 2) === "//";
                !T || x && y[x] || (v2 = v2.substr(2), this.slashes = true);
              }
              if (!y[x] && (T || x && !g[x])) {
                for (var w, P, A = -1, O = 0; O < f.length; O++)
                  (C = v2.indexOf(f[O])) !== -1 && (A === -1 || C < A) && (A = C);
                for ((P = A === -1 ? v2.lastIndexOf("@") : v2.lastIndexOf("@", A)) !== -1 && (w = v2.slice(0, P), v2 = v2.slice(P + 1), this.auth = decodeURIComponent(w)), A = -1, O = 0; O < p2.length; O++) {
                  var C;
                  (C = v2.indexOf(p2[O])) !== -1 && (A === -1 || C < A) && (A = C);
                }
                A === -1 && (A = v2.length), this.host = v2.slice(0, A), v2 = v2.slice(A), this.parseHost(), this.hostname = this.hostname || "";
                var I = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
                if (!I)
                  for (var k2 = this.hostname.split(/\./), N = (O = 0, k2.length); O < N; O++) {
                    var _ = k2[O];
                    if (_ && !_.match(d)) {
                      for (var j = "", D = 0, L = _.length; D < L; D++)
                        _.charCodeAt(D) > 127 ? j += "x" : j += _[D];
                      if (!j.match(d)) {
                        var M = k2.slice(0, O), B = k2.slice(O + 1), R = _.match(h3);
                        R && (M.push(R[1]), B.unshift(R[2])), B.length && (v2 = "/" + B.join(".") + v2), this.hostname = M.join(".");
                        break;
                      }
                    }
                  }
                this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), I || (this.hostname = n.toASCII(this.hostname));
                var F = this.port ? ":" + this.port : "", U = this.hostname || "";
                this.host = U + F, this.href += this.host, I && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), v2[0] !== "/" && (v2 = "/" + v2));
              }
              if (!m[S])
                for (O = 0, N = u.length; O < N; O++) {
                  var $ = u[O];
                  if (v2.indexOf($) !== -1) {
                    var q = encodeURIComponent($);
                    q === $ && (q = escape($)), v2 = v2.split($).join(q);
                  }
                }
              var V = v2.indexOf("#");
              V !== -1 && (this.hash = v2.substr(V), v2 = v2.slice(0, V));
              var W = v2.indexOf("?");
              if (W !== -1 ? (this.search = v2.substr(W), this.query = v2.substr(W + 1), t3 && (this.query = b.parse(this.query)), v2 = v2.slice(0, W)) : t3 && (this.search = "", this.query = {}), v2 && (this.pathname = v2), g[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
                F = this.pathname || "";
                var K = this.search || "";
                this.path = F + K;
              }
              return this.href = this.format(), this;
            }, i.prototype.format = function() {
              var e3 = this.auth || "";
              e3 && (e3 = (e3 = encodeURIComponent(e3)).replace(/%3A/i, ":"), e3 += "@");
              var t3 = this.protocol || "", r3 = this.pathname || "", n2 = this.hash || "", i2 = false, o2 = "";
              this.host ? i2 = e3 + this.host : this.hostname && (i2 = e3 + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (i2 += ":" + this.port)), this.query && s2.isObject(this.query) && Object.keys(this.query).length && (o2 = b.stringify(this.query));
              var a2 = this.search || o2 && "?" + o2 || "";
              return t3 && t3.substr(-1) !== ":" && (t3 += ":"), this.slashes || (!t3 || g[t3]) && i2 !== false ? (i2 = "//" + (i2 || ""), r3 && r3.charAt(0) !== "/" && (r3 = "/" + r3)) : i2 || (i2 = ""), n2 && n2.charAt(0) !== "#" && (n2 = "#" + n2), a2 && a2.charAt(0) !== "?" && (a2 = "?" + a2), t3 + i2 + (r3 = r3.replace(/[?#]/g, function(e4) {
                return encodeURIComponent(e4);
              })) + (a2 = a2.replace("#", "%23")) + n2;
            }, i.prototype.resolve = function(e3) {
              return this.resolveObject(v(e3, false, true)).format();
            }, i.prototype.resolveObject = function(e3) {
              if (s2.isString(e3)) {
                var t3 = new i();
                t3.parse(e3, false, true), e3 = t3;
              }
              for (var r3 = new i(), n2 = Object.keys(this), o2 = 0; o2 < n2.length; o2++) {
                var a2 = n2[o2];
                r3[a2] = this[a2];
              }
              if (r3.hash = e3.hash, e3.href === "")
                return r3.href = r3.format(), r3;
              if (e3.slashes && !e3.protocol) {
                for (var l2 = Object.keys(e3), c4 = 0; c4 < l2.length; c4++) {
                  var u2 = l2[c4];
                  u2 !== "protocol" && (r3[u2] = e3[u2]);
                }
                return g[r3.protocol] && r3.hostname && !r3.pathname && (r3.path = r3.pathname = "/"), r3.href = r3.format(), r3;
              }
              if (e3.protocol && e3.protocol !== r3.protocol) {
                if (!g[e3.protocol]) {
                  for (var p3 = Object.keys(e3), f2 = 0; f2 < p3.length; f2++) {
                    var d2 = p3[f2];
                    r3[d2] = e3[d2];
                  }
                  return r3.href = r3.format(), r3;
                }
                if (r3.protocol = e3.protocol, e3.host || y[e3.protocol])
                  r3.pathname = e3.pathname;
                else {
                  for (var h4 = (e3.pathname || "").split("/"); h4.length && !(e3.host = h4.shift()); )
                    ;
                  e3.host || (e3.host = ""), e3.hostname || (e3.hostname = ""), h4[0] !== "" && h4.unshift(""), h4.length < 2 && h4.unshift(""), r3.pathname = h4.join("/");
                }
                if (r3.search = e3.search, r3.query = e3.query, r3.host = e3.host || "", r3.auth = e3.auth, r3.hostname = e3.hostname || e3.host, r3.port = e3.port, r3.pathname || r3.search) {
                  var m2 = r3.pathname || "", b2 = r3.search || "";
                  r3.path = m2 + b2;
                }
                return r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
              }
              var v2 = r3.pathname && r3.pathname.charAt(0) === "/", E = e3.host || e3.pathname && e3.pathname.charAt(0) === "/", x = E || v2 || r3.host && e3.pathname, S = x, T = r3.pathname && r3.pathname.split("/") || [], w = (h4 = e3.pathname && e3.pathname.split("/") || [], r3.protocol && !g[r3.protocol]);
              if (w && (r3.hostname = "", r3.port = null, r3.host && (T[0] === "" ? T[0] = r3.host : T.unshift(r3.host)), r3.host = "", e3.protocol && (e3.hostname = null, e3.port = null, e3.host && (h4[0] === "" ? h4[0] = e3.host : h4.unshift(e3.host)), e3.host = null), x = x && (h4[0] === "" || T[0] === "")), E)
                r3.host = e3.host || e3.host === "" ? e3.host : r3.host, r3.hostname = e3.hostname || e3.hostname === "" ? e3.hostname : r3.hostname, r3.search = e3.search, r3.query = e3.query, T = h4;
              else if (h4.length)
                T || (T = []), T.pop(), T = T.concat(h4), r3.search = e3.search, r3.query = e3.query;
              else if (!s2.isNullOrUndefined(e3.search))
                return w && (r3.hostname = r3.host = T.shift(), (I = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = I.shift(), r3.host = r3.hostname = I.shift())), r3.search = e3.search, r3.query = e3.query, s2.isNull(r3.pathname) && s2.isNull(r3.search) || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.href = r3.format(), r3;
              if (!T.length)
                return r3.pathname = null, r3.search ? r3.path = "/" + r3.search : r3.path = null, r3.href = r3.format(), r3;
              for (var P = T.slice(-1)[0], A = (r3.host || e3.host || T.length > 1) && (P === "." || P === "..") || P === "", O = 0, C = T.length; C >= 0; C--)
                (P = T[C]) === "." ? T.splice(C, 1) : P === ".." ? (T.splice(C, 1), O++) : O && (T.splice(C, 1), O--);
              if (!x && !S)
                for (; O--; O)
                  T.unshift("..");
              !x || T[0] === "" || T[0] && T[0].charAt(0) === "/" || T.unshift(""), A && T.join("/").substr(-1) !== "/" && T.push("");
              var I, k2 = T[0] === "" || T[0] && T[0].charAt(0) === "/";
              return w && (r3.hostname = r3.host = k2 ? "" : T.length ? T.shift() : "", (I = !!(r3.host && r3.host.indexOf("@") > 0) && r3.host.split("@")) && (r3.auth = I.shift(), r3.host = r3.hostname = I.shift())), (x = x || r3.host && T.length) && !k2 && T.unshift(""), T.length ? r3.pathname = T.join("/") : (r3.pathname = null, r3.path = null), s2.isNull(r3.pathname) && s2.isNull(r3.search) || (r3.path = (r3.pathname ? r3.pathname : "") + (r3.search ? r3.search : "")), r3.auth = e3.auth || r3.auth, r3.slashes = r3.slashes || e3.slashes, r3.href = r3.format(), r3;
            }, i.prototype.parseHost = function() {
              var e3 = this.host, t3 = a.exec(e3);
              t3 && ((t3 = t3[0]) !== ":" && (this.port = t3.substr(1)), e3 = e3.substr(0, e3.length - t3.length)), e3 && (this.hostname = e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            t2.decode = t2.parse = r2(317), t2.encode = t2.stringify = r2(318);
          }, () => {
          }, () => {
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.default = function(e3) {
              var t3, r3, n2, s3, o2, a2, l2, c4, u2, p3, d2, h3, m = [], y = e3.css.valueOf(), g = y.length, b = -1, v = 1, E = 0, x = 0;
              function S(t4, r4) {
                if (!e3.safe)
                  throw e3.error("Unclosed " + t4, v, E - b, E);
                c4 = (y += r4).length - 1;
              }
              for (; E < g; ) {
                switch ((t3 = y.charCodeAt(E)) === i.newline && (b = E, v += 1), t3) {
                  case i.space:
                  case i.tab:
                  case i.newline:
                  case i.cr:
                  case i.feed:
                    c4 = E;
                    do {
                      c4 += 1, (t3 = y.charCodeAt(c4)) === i.newline && (b = c4, v += 1);
                    } while (t3 === i.space || t3 === i.newline || t3 === i.tab || t3 === i.cr || t3 === i.feed);
                    h3 = i.space, n2 = v, r3 = c4 - b - 1, x = c4;
                    break;
                  case i.plus:
                  case i.greaterThan:
                  case i.tilde:
                  case i.pipe:
                    c4 = E;
                    do {
                      c4 += 1, t3 = y.charCodeAt(c4);
                    } while (t3 === i.plus || t3 === i.greaterThan || t3 === i.tilde || t3 === i.pipe);
                    h3 = i.combinator, n2 = v, r3 = E - b, x = c4;
                    break;
                  case i.asterisk:
                  case i.ampersand:
                  case i.bang:
                  case i.comma:
                  case i.equals:
                  case i.dollar:
                  case i.caret:
                  case i.openSquare:
                  case i.closeSquare:
                  case i.colon:
                  case i.semicolon:
                  case i.openParenthesis:
                  case i.closeParenthesis:
                    h3 = t3, n2 = v, r3 = E - b, x = (c4 = E) + 1;
                    break;
                  case i.singleQuote:
                  case i.doubleQuote:
                    d2 = t3 === i.singleQuote ? "'" : '"', c4 = E;
                    do {
                      for (s3 = false, (c4 = y.indexOf(d2, c4 + 1)) === -1 && S("quote", d2), o2 = c4; y.charCodeAt(o2 - 1) === i.backslash; )
                        o2 -= 1, s3 = !s3;
                    } while (s3);
                    h3 = i.str, n2 = v, r3 = E - b, x = c4 + 1;
                    break;
                  default:
                    t3 === i.slash && y.charCodeAt(E + 1) === i.asterisk ? ((c4 = y.indexOf("*/", E + 2) + 1) === 0 && S("comment", "*/"), (a2 = (l2 = y.slice(E, c4 + 1).split("\n")).length - 1) > 0 ? (u2 = v + a2, p3 = c4 - l2[a2].length) : (u2 = v, p3 = b), h3 = i.comment, v = u2, n2 = u2, r3 = c4 - p3) : t3 === i.slash ? (h3 = t3, n2 = v, r3 = E - b, x = (c4 = E) + 1) : (c4 = f(y, E), h3 = i.word, n2 = v, r3 = c4 - b), x = c4 + 1;
                }
                m.push([h3, v, E - b, n2, r3, E, x]), p3 && (b = p3, p3 = null), E = x;
              }
              return m;
            }, t2.FIELDS = void 0;
            var n, s2, i = function(e3) {
              if (e3 && e3.__esModule)
                return e3;
              if (e3 === null || typeof e3 != "object" && typeof e3 != "function")
                return { default: e3 };
              var t3 = o();
              if (t3 && t3.has(e3))
                return t3.get(e3);
              var r3 = {}, n2 = Object.defineProperty && Object.getOwnPropertyDescriptor;
              for (var s3 in e3)
                if (Object.prototype.hasOwnProperty.call(e3, s3)) {
                  var i2 = n2 ? Object.getOwnPropertyDescriptor(e3, s3) : null;
                  i2 && (i2.get || i2.set) ? Object.defineProperty(r3, s3, i2) : r3[s3] = e3[s3];
                }
              return r3.default = e3, t3 && t3.set(e3, r3), r3;
            }(r2(328));
            function o() {
              if (typeof WeakMap != "function")
                return null;
              var e3 = new WeakMap();
              return o = function() {
                return e3;
              }, e3;
            }
            for (var a = ((n = {})[i.tab] = true, n[i.newline] = true, n[i.cr] = true, n[i.feed] = true, n), l = ((s2 = {})[i.space] = true, s2[i.tab] = true, s2[i.newline] = true, s2[i.cr] = true, s2[i.feed] = true, s2[i.ampersand] = true, s2[i.asterisk] = true, s2[i.bang] = true, s2[i.comma] = true, s2[i.colon] = true, s2[i.semicolon] = true, s2[i.openParenthesis] = true, s2[i.closeParenthesis] = true, s2[i.openSquare] = true, s2[i.closeSquare] = true, s2[i.singleQuote] = true, s2[i.doubleQuote] = true, s2[i.plus] = true, s2[i.pipe] = true, s2[i.tilde] = true, s2[i.greaterThan] = true, s2[i.equals] = true, s2[i.dollar] = true, s2[i.caret] = true, s2[i.slash] = true, s2), c = {}, u = "0123456789abcdefABCDEF", p2 = 0; p2 < u.length; p2++)
              c[u.charCodeAt(p2)] = true;
            function f(e3, t3) {
              var r3, n2 = t3;
              do {
                if (r3 = e3.charCodeAt(n2), l[r3])
                  return n2 - 1;
                r3 === i.backslash ? n2 = d(e3, n2) + 1 : n2++;
              } while (n2 < e3.length);
              return n2 - 1;
            }
            function d(e3, t3) {
              var r3 = t3, n2 = e3.charCodeAt(r3 + 1);
              if (a[n2])
                ;
              else if (c[n2]) {
                var s3 = 0;
                do {
                  r3++, s3++, n2 = e3.charCodeAt(r3 + 1);
                } while (c[n2] && s3 < 6);
                s3 < 6 && n2 === i.space && r3++;
              } else
                r3++;
              return r3;
            }
            t2.FIELDS = { TYPE: 0, START_LINE: 1, START_COL: 2, END_LINE: 3, END_COL: 4, START_POS: 5, END_POS: 6 };
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.universal = t2.tag = t2.string = t2.selector = t2.root = t2.pseudo = t2.nesting = t2.id = t2.comment = t2.combinator = t2.className = t2.attribute = void 0;
            var n = m(r2(326)), s2 = m(r2(100)), i = m(r2(107)), o = m(r2(101)), a = m(r2(102)), l = m(r2(108)), c = m(r2(105)), u = m(r2(97)), p2 = m(r2(99)), f = m(r2(104)), d = m(r2(103)), h3 = m(r2(106));
            function m(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            t2.attribute = function(e3) {
              return new n.default(e3);
            }, t2.className = function(e3) {
              return new s2.default(e3);
            }, t2.combinator = function(e3) {
              return new i.default(e3);
            }, t2.comment = function(e3) {
              return new o.default(e3);
            }, t2.id = function(e3) {
              return new a.default(e3);
            }, t2.nesting = function(e3) {
              return new l.default(e3);
            }, t2.pseudo = function(e3) {
              return new c.default(e3);
            }, t2.root = function(e3) {
              return new u.default(e3);
            }, t2.selector = function(e3) {
              return new p2.default(e3);
            }, t2.string = function(e3) {
              return new f.default(e3);
            }, t2.tag = function(e3) {
              return new d.default(e3);
            }, t2.universal = function(e3) {
              return new h3.default(e3);
            };
          }, (e2, t2, r2) => {
            "use strict";
            t2.__esModule = true, t2.isNode = o, t2.isPseudoElement = E, t2.isPseudoClass = function(e3) {
              return h3(e3) && !E(e3);
            }, t2.isContainer = function(e3) {
              return !(!o(e3) || !e3.walk);
            }, t2.isNamespace = function(e3) {
              return l(e3) || b(e3);
            }, t2.isUniversal = t2.isTag = t2.isString = t2.isSelector = t2.isRoot = t2.isPseudo = t2.isNesting = t2.isIdentifier = t2.isComment = t2.isCombinator = t2.isClassName = t2.isAttribute = void 0;
            var n, s2 = r2(5), i = ((n = {})[s2.ATTRIBUTE] = true, n[s2.CLASS] = true, n[s2.COMBINATOR] = true, n[s2.COMMENT] = true, n[s2.ID] = true, n[s2.NESTING] = true, n[s2.PSEUDO] = true, n[s2.ROOT] = true, n[s2.SELECTOR] = true, n[s2.STRING] = true, n[s2.TAG] = true, n[s2.UNIVERSAL] = true, n);
            function o(e3) {
              return typeof e3 == "object" && i[e3.type];
            }
            function a(e3, t3) {
              return o(t3) && t3.type === e3;
            }
            var l = a.bind(null, s2.ATTRIBUTE);
            t2.isAttribute = l;
            var c = a.bind(null, s2.CLASS);
            t2.isClassName = c;
            var u = a.bind(null, s2.COMBINATOR);
            t2.isCombinator = u;
            var p2 = a.bind(null, s2.COMMENT);
            t2.isComment = p2;
            var f = a.bind(null, s2.ID);
            t2.isIdentifier = f;
            var d = a.bind(null, s2.NESTING);
            t2.isNesting = d;
            var h3 = a.bind(null, s2.PSEUDO);
            t2.isPseudo = h3;
            var m = a.bind(null, s2.ROOT);
            t2.isRoot = m;
            var y = a.bind(null, s2.SELECTOR);
            t2.isSelector = y;
            var g = a.bind(null, s2.STRING);
            t2.isString = g;
            var b = a.bind(null, s2.TAG);
            t2.isTag = b;
            var v = a.bind(null, s2.UNIVERSAL);
            function E(e3) {
              return h3(e3) && e3.value && (e3.value.startsWith("::") || e3.value.toLowerCase() === ":before" || e3.value.toLowerCase() === ":after");
            }
            t2.isUniversal = v;
          }, () => {
          }, () => {
          }, () => {
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.replaceAll = n;
            var r2 = /[$#]?[\w-\.]+/g;
            function n(e3, t3) {
              for (var n2 = void 0; n2 = r2.exec(t3); ) {
                var s2 = e3[n2[0]];
                s2 && (t3 = t3.slice(0, n2.index) + s2 + t3.slice(r2.lastIndex), r2.lastIndex -= n2[0].length - s2.length);
              }
              return t3;
            }
            t2.default = function(e3, t3) {
              e3.walkDecls(function(e4) {
                return e4.value = n(t3, e4.value);
              }), e3.walkAtRules("media", function(e4) {
                return e4.params = n(t3, e4.params);
              });
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true });
            var n = a(r2(84)), s2 = a(r2(523)), i = a(r2(8)), o = a(r2(332));
            function a(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            class l {
              constructor(e3) {
                this.plugins = e3 || l.defaultPlugins;
              }
              load(e3, t3, r3, s3) {
                let i2 = new o.default(s3, r3);
                return (0, n.default)(this.plugins.concat([i2.plugin()])).process(e3, { from: "/" + t3 }).then((e4) => ({ injectableSource: e4.css, exportTokens: i2.exportTokens }));
              }
            }
            const c = (e3, t3) => e3.length < t3.length ? e3 < t3.substring(0, e3.length) ? -1 : 1 : e3.length > t3.length ? e3.substring(0, t3.length) <= t3 ? -1 : 1 : e3 < t3 ? -1 : 1;
            t2.default = class {
              constructor(e3, t3) {
                this.root = e3, this.sources = {}, this.traces = {}, this.importNr = 0, this.core = new l(t3), this.tokensByFile = {};
              }
              fetch(e3, t3, n2) {
                let o2 = e3.replace(/^["']|["']$/g, ""), a2 = n2 || String.fromCharCode(this.importNr++);
                return new Promise((e4, n3) => {
                  let l2 = i.default.dirname(t3), c4 = i.default.resolve(l2, o2), u = i.default.resolve(i.default.join(this.root, l2), o2);
                  if (o2[0] !== "." && o2[0] !== "/")
                    try {
                      u = r2(524).resolve(o2);
                    } catch (e5) {
                    }
                  const p2 = this.tokensByFile[u];
                  if (p2)
                    return e4(p2);
                  s2.default.readFile(u, "utf-8", (t4, r3) => {
                    t4 && n3(t4), this.core.load(r3, c4, a2, this.fetch.bind(this)).then(({ injectableSource: t5, exportTokens: r4 }) => {
                      this.sources[u] = t5, this.traces[a2] = u, this.tokensByFile[u] = r4, e4(r4);
                    }, n3);
                  });
                });
              }
              get finalSource() {
                const e3 = this.traces, t3 = this.sources;
                let r3 = new Set();
                return Object.keys(e3).sort(c).map((n2) => {
                  const s3 = e3[n2];
                  return r3.has(s3) ? null : (r3.add(s3), t3[s3]);
                }).join("");
              }
            };
          }, () => {
          }, (e2) => {
            function t2(e3) {
              var t3 = new Error("Cannot find module '" + e3 + "'");
              throw t3.code = "MODULE_NOT_FOUND", t3;
            }
            t2.keys = () => [], t2.resolve = t2, t2.id = 524, e2.exports = t2;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3, r3) {
              const n2 = r3.indexOf(`.${e3}`), i = r3.substr(0, n2).split(/[\r\n]/).length;
              return `_${e3}_${(0, s2.default)(r3).toString(36).substr(0, 5)}_${i}`;
            };
            var n, s2 = (n = r2(333)) && n.__esModule ? n : { default: n };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = function(e3, t3) {
              return new Promise((r3, s2) => {
                (0, n.writeFile)(`${e3}.json`, JSON.stringify(t3), (e4) => e4 ? s2(e4) : r3(t3));
              });
            };
            var n = r2(527);
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.behaviours = void 0, t2.getDefaultPlugins = function({ behaviour: e3, generateScopedName: t3, exportGlobals: r3 }) {
              const a2 = (0, i.default)({ generateScopedName: t3, exportGlobals: r3 });
              return { [l.LOCAL]: [o.default, n.default, s2.default, a2], [l.GLOBAL]: [o.default, s2.default, a2] }[e3];
            }, t2.isValidBehaviour = function(e3) {
              return Object.keys(l).map((e4) => l[e4]).indexOf(e3) > -1;
            };
            var n = a(r2(334)), s2 = a(r2(344)), i = a(r2(529)), o = a(r2(530));
            function a(e3) {
              return e3 && e3.__esModule ? e3 : { default: e3 };
            }
            const l = t2.behaviours = { LOCAL: "local", GLOBAL: "global" };
          }, () => {
          }, () => {
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-jsx", manipulateOptions(e4, t3) {
              t3.plugins.some((e5) => (Array.isArray(e5) ? e5[0] : e5) === "typescript") || t3.plugins.push("jsx");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            e2.exports = r2(533);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","label","legend","li","link","main","map","mark","math","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rb","rp","rt","rtc","ruby","s","samp","script","section","select","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr"]');
          }, (e2, t2, r2) => {
            e2.exports = r2(535);
          }, (e2) => {
            "use strict";
            e2.exports = JSON.parse('["a","altGlyph","altGlyphDef","altGlyphItem","animate","animateColor","animateMotion","animateTransform","circle","clipPath","color-profile","cursor","defs","desc","ellipse","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","filter","font","font-face","font-face-format","font-face-name","font-face-src","font-face-uri","foreignObject","g","glyph","glyphRef","hkern","image","line","linearGradient","marker","mask","metadata","missing-glyph","mpath","path","pattern","polygon","polyline","radialGradient","rect","script","set","stop","style","svg","switch","symbol","text","textPath","title","tref","tspan","use","view","vkern"]');
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-class-static-block", manipulateOptions(e4, t3) {
              t3.plugins.push("classStaticBlock");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.buildPrivateNamesMap = function(e3) {
              const t3 = new Map();
              for (const r3 of e3) {
                const e4 = r3.isPrivate(), n2 = !r3.isProperty(), s3 = !r3.node.static;
                if (e4) {
                  const { name: e5 } = r3.node.key.id, i2 = t3.has(e5) ? t3.get(e5) : { id: r3.scope.generateUidIdentifier(e5), static: !s3, method: n2 };
                  r3.node.kind === "get" ? i2.getId = r3.scope.generateUidIdentifier(`get_${e5}`) : r3.node.kind === "set" ? i2.setId = r3.scope.generateUidIdentifier(`set_${e5}`) : r3.node.kind === "method" && (i2.methodId = r3.scope.generateUidIdentifier(e5)), t3.set(e5, i2);
                }
              }
              return t3;
            }, t2.buildPrivateNamesNodes = function(e3, t3, r3) {
              const s3 = [];
              for (const [i2, o2] of e3) {
                const { static: e4, method: l2, getId: c4, setId: u2 } = o2, p3 = c4 || u2, f2 = n.types.cloneNode(o2.id);
                let d2;
                t3 ? d2 = n.types.callExpression(r3.addHelper("classPrivateFieldLooseKey"), [n.types.stringLiteral(i2)]) : e4 || (d2 = n.types.newExpression(n.types.identifier(!l2 || p3 ? "WeakMap" : "WeakSet"), [])), d2 && ((0, a.default)(d2), s3.push(n.template.statement.ast`var ${f2} = ${d2}`));
              }
              return s3;
            }, t2.transformPrivateNamesUsage = function(e3, t3, r3, { privateFieldsAsProperties: n2, noDocumentAll: s3 }, o2) {
              if (!r3.size)
                return;
              const a2 = t3.get("body"), l2 = n2 ? d : f;
              (0, i.default)(a2, u, Object.assign({ privateNamesMap: r3, classRef: e3, file: o2 }, l2, { noDocumentAll: s3 })), a2.traverse(p2, { privateNamesMap: r3, classRef: e3, file: o2, privateFieldsAsProperties: n2 });
            }, t2.buildFieldsInitNodes = function(e3, t3, r3, s3, i2, o2, a2, c4, u2) {
              let p3, f2 = false;
              const d2 = [], T2 = [], w2 = [], A = n.types.isIdentifier(t3) ? () => t3 : () => (p3 != null || (p3 = r3[0].scope.generateUidIdentifierBasedOnNode(t3)), p3);
              for (const t4 of r3) {
                l.assertFieldTransformed(t4);
                const r4 = t4.node.static, p4 = !r4, O = t4.isPrivate(), C = !O, I = t4.isProperty(), k2 = !I, N = t4.isStaticBlock == null ? void 0 : t4.isStaticBlock();
                if (r4 || k2 && O || N) {
                  const r5 = P(t4, e3, A, i2, N, c4, u2);
                  f2 = f2 || r5;
                }
                switch (true) {
                  case N:
                    d2.push(n.template.statement.ast`(() => ${n.types.blockStatement(t4.node.body)})()`);
                    break;
                  case (r4 && O && I && a2):
                    f2 = true, d2.push(h3(n.types.cloneNode(e3), t4, s3));
                    break;
                  case (r4 && O && I && !a2):
                    f2 = true, d2.push(y(t4, s3));
                    break;
                  case (r4 && C && I && o2):
                    f2 = true, d2.push(v(n.types.cloneNode(e3), t4));
                    break;
                  case (r4 && C && I && !o2):
                    f2 = true, d2.push(E(n.types.cloneNode(e3), t4, i2));
                    break;
                  case (p4 && O && I && a2):
                    T2.push(h3(n.types.thisExpression(), t4, s3));
                    break;
                  case (p4 && O && I && !a2):
                    T2.push(m(n.types.thisExpression(), t4, s3));
                    break;
                  case (p4 && O && k2 && a2):
                    T2.unshift(g(n.types.thisExpression(), t4, s3)), w2.push(S(t4, s3, a2));
                    break;
                  case (p4 && O && k2 && !a2):
                    T2.unshift(b(n.types.thisExpression(), t4, s3)), w2.push(S(t4, s3, a2));
                    break;
                  case (r4 && O && k2 && !a2):
                    f2 = true, d2.unshift(y(t4, s3)), w2.push(S(t4, s3, a2));
                    break;
                  case (r4 && O && k2 && a2):
                    f2 = true, d2.unshift(x(n.types.cloneNode(e3), t4, 0, s3)), w2.push(S(t4, s3, a2));
                    break;
                  case (p4 && C && I && o2):
                    T2.push(v(n.types.thisExpression(), t4));
                    break;
                  case (p4 && C && I && !o2):
                    T2.push(E(n.types.thisExpression(), t4, i2));
                    break;
                  default:
                    throw new Error("Unreachable.");
                }
              }
              return { staticNodes: d2.filter(Boolean), instanceNodes: T2.filter(Boolean), pureStaticNodes: w2.filter(Boolean), wrapClass(t4) {
                for (const e4 of r3)
                  e4.remove();
                return p3 && (t4.scope.push({ id: n.types.cloneNode(p3) }), t4.set("superClass", n.types.assignmentExpression("=", p3, t4.node.superClass))), f2 ? (t4.isClassExpression() ? (t4.scope.push({ id: e3 }), t4.replaceWith(n.types.assignmentExpression("=", n.types.cloneNode(e3), t4.node))) : t4.node.id || (t4.node.id = e3), t4) : t4;
              } };
            };
            var n = r2(9), s2 = r2(70), i = r2(258), o = r2(259), a = r2(347), l = r2(538);
            function c(e3) {
              const t3 = Object.assign({}, e3, { Class(e4) {
                const { privateNamesMap: n2 } = this, s3 = e4.get("body.body"), i2 = new Map(n2), o2 = [];
                for (const e5 of s3) {
                  if (!e5.isPrivate())
                    continue;
                  const { name: t4 } = e5.node.key.id;
                  i2.delete(t4), o2.push(t4);
                }
                o2.length && (e4.get("body").traverse(r3, Object.assign({}, this, { redeclared: o2 })), e4.traverse(t3, Object.assign({}, this, { privateNamesMap: i2 })), e4.skipKey("body"));
              } }), r3 = n.traverse.visitors.merge([Object.assign({}, e3), s2.environmentVisitor]);
              return t3;
            }
            const u = c({ PrivateName(e3, { noDocumentAll: t3 }) {
              const { privateNamesMap: r3, redeclared: n2 } = this, { node: s3, parentPath: i2 } = e3;
              if (!i2.isMemberExpression({ property: s3 }) && !i2.isOptionalMemberExpression({ property: s3 }))
                return;
              const { name: o2 } = s3.id;
              r3.has(o2) && (n2 && n2.includes(o2) || this.handle(i2, t3));
            } }), p2 = c({ BinaryExpression(e3) {
              const { operator: t3, left: r3, right: s3 } = e3.node;
              if (t3 !== "in")
                return;
              if (!e3.get("left").isPrivateName())
                return;
              const { privateFieldsAsProperties: i2, privateNamesMap: o2, redeclared: a2 } = this, { name: l2 } = r3.id;
              if (!o2.has(l2))
                return;
              if (a2 && a2.includes(l2))
                return;
              if (i2) {
                const { id: t4 } = o2.get(l2);
                return void e3.replaceWith(n.template.expression.ast`
        Object.prototype.hasOwnProperty.call(${s3}, ${n.types.cloneNode(t4)})
      `);
              }
              const { id: c4, static: u2 } = o2.get(l2);
              u2 ? e3.replaceWith(n.template.expression.ast`${s3} === ${this.classRef}`) : e3.replaceWith(n.template.expression.ast`${n.types.cloneNode(c4)}.has(${s3})`);
            } }), f = { memoise(e3, t3) {
              const { scope: r3 } = e3, { object: n2 } = e3.node, s3 = r3.maybeGenerateMemoised(n2);
              s3 && this.memoiser.set(n2, s3, t3);
            }, receiver(e3) {
              const { object: t3 } = e3.node;
              return this.memoiser.has(t3) ? n.types.cloneNode(this.memoiser.get(t3)) : n.types.cloneNode(t3);
            }, get(e3) {
              const { classRef: t3, privateNamesMap: r3, file: s3 } = this, { name: i2 } = e3.node.property.id, { id: o2, static: a2, method: l2, methodId: c4, getId: u2, setId: p3 } = r3.get(i2), f2 = u2 || p3;
              if (a2) {
                const r4 = l2 && !f2 ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
                return n.types.callExpression(s3.addHelper(r4), [this.receiver(e3), n.types.cloneNode(t3), n.types.cloneNode(o2)]);
              }
              return l2 ? f2 ? !u2 && p3 && s3.availableHelper("writeOnlyError") ? n.types.sequenceExpression([this.receiver(e3), n.types.callExpression(s3.addHelper("writeOnlyError"), [n.types.stringLiteral(`#${i2}`)])]) : n.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n.types.cloneNode(o2)]) : n.types.callExpression(s3.addHelper("classPrivateMethodGet"), [this.receiver(e3), n.types.cloneNode(o2), n.types.cloneNode(c4)]) : n.types.callExpression(s3.addHelper("classPrivateFieldGet"), [this.receiver(e3), n.types.cloneNode(o2)]);
            }, boundGet(e3) {
              return this.memoise(e3, 1), n.types.callExpression(n.types.memberExpression(this.get(e3), n.types.identifier("bind")), [this.receiver(e3)]);
            }, set(e3, t3) {
              const { classRef: r3, privateNamesMap: s3, file: i2 } = this, { name: o2 } = e3.node.property.id, { id: a2, static: l2, method: c4, setId: u2, getId: p3 } = s3.get(o2);
              if (l2) {
                const s4 = !c4 || p3 || u2 ? "classStaticPrivateFieldSpecSet" : "classStaticPrivateMethodSet";
                return n.types.callExpression(i2.addHelper(s4), [this.receiver(e3), n.types.cloneNode(r3), n.types.cloneNode(a2), t3]);
              }
              return c4 ? u2 ? n.types.callExpression(i2.addHelper("classPrivateFieldSet"), [this.receiver(e3), n.types.cloneNode(a2), t3]) : n.types.sequenceExpression([this.receiver(e3), t3, n.types.callExpression(i2.addHelper("readOnlyError"), [n.types.stringLiteral(`#${o2}`)])]) : n.types.callExpression(i2.addHelper("classPrivateFieldSet"), [this.receiver(e3), n.types.cloneNode(a2), t3]);
            }, destructureSet(e3) {
              const { classRef: t3, privateNamesMap: r3, file: s3 } = this, { name: i2 } = e3.node.property.id, { id: o2, static: a2 } = r3.get(i2);
              if (a2) {
                try {
                  var l2 = s3.addHelper("classStaticPrivateFieldDestructureSet");
                } catch (e4) {
                  throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \nplease update @babel/helpers to the latest version.");
                }
                return n.types.memberExpression(n.types.callExpression(l2, [this.receiver(e3), n.types.cloneNode(t3), n.types.cloneNode(o2)]), n.types.identifier("value"));
              }
              return n.types.memberExpression(n.types.callExpression(s3.addHelper("classPrivateFieldDestructureSet"), [this.receiver(e3), n.types.cloneNode(o2)]), n.types.identifier("value"));
            }, call(e3, t3) {
              return this.memoise(e3, 1), (0, o.default)(this.get(e3), this.receiver(e3), t3, false);
            }, optionalCall(e3, t3) {
              return this.memoise(e3, 1), (0, o.default)(this.get(e3), this.receiver(e3), t3, true);
            } }, d = { get(e3) {
              const { privateNamesMap: t3, file: r3 } = this, { object: s3 } = e3.node, { name: i2 } = e3.node.property.id;
              return n.template.expression`BASE(REF, PROP)[PROP]`({ BASE: r3.addHelper("classPrivateFieldLooseBase"), REF: n.types.cloneNode(s3), PROP: n.types.cloneNode(t3.get(i2).id) });
            }, boundGet(e3) {
              return n.types.callExpression(n.types.memberExpression(this.get(e3), n.types.identifier("bind")), [n.types.cloneNode(e3.node.object)]);
            }, simpleSet(e3) {
              return this.get(e3);
            }, destructureSet(e3) {
              return this.get(e3);
            }, call(e3, t3) {
              return n.types.callExpression(this.get(e3), t3);
            }, optionalCall(e3, t3) {
              return n.types.optionalCallExpression(this.get(e3), t3, true);
            } };
            function h3(e3, t3, r3) {
              const { id: s3 } = r3.get(t3.node.key.id.name), i2 = t3.node.value || t3.scope.buildUndefinedNode();
              return n.template.statement.ast`
    Object.defineProperty(${e3}, ${n.types.cloneNode(s3)}, {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${i2}
    });
  `;
            }
            function m(e3, t3, r3) {
              const { id: s3 } = r3.get(t3.node.key.id.name), i2 = t3.node.value || t3.scope.buildUndefinedNode();
              return n.template.statement.ast`${n.types.cloneNode(s3)}.set(${e3}, {
    // configurable is always false for private elements
    // enumerable is always false for private elements
    writable: true,
    value: ${i2},
  })`;
            }
            function y(e3, t3) {
              const r3 = t3.get(e3.node.key.id.name), { id: s3, getId: i2, setId: o2, initAdded: a2 } = r3, l2 = i2 || o2;
              if (!e3.isProperty() && (a2 || !l2))
                return;
              if (l2)
                return t3.set(e3.node.key.id.name, Object.assign({}, r3, { initAdded: true })), n.template.statement.ast`
      var ${n.types.cloneNode(s3)} = {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${i2 ? i2.name : e3.scope.buildUndefinedNode()},
        set: ${o2 ? o2.name : e3.scope.buildUndefinedNode()}
      }
    `;
              const c4 = e3.node.value || e3.scope.buildUndefinedNode();
              return n.template.statement.ast`
    var ${n.types.cloneNode(s3)} = {
      // configurable is false by default
      // enumerable is false by default
      writable: true,
      value: ${c4}
    };
  `;
            }
            function g(e3, t3, r3) {
              const s3 = r3.get(t3.node.key.id.name), { methodId: i2, id: o2, getId: a2, setId: l2, initAdded: c4 } = s3;
              if (!c4)
                return i2 ? n.template.statement.ast`
        Object.defineProperty(${e3}, ${o2}, {
          // configurable is false by default
          // enumerable is false by default
          // writable is false by default
          value: ${i2.name}
        });
      ` : a2 || l2 ? (r3.set(t3.node.key.id.name, Object.assign({}, s3, { initAdded: true })), n.template.statement.ast`
      Object.defineProperty(${e3}, ${o2}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${a2 ? a2.name : t3.scope.buildUndefinedNode()},
        set: ${l2 ? l2.name : t3.scope.buildUndefinedNode()}
      });
    `) : void 0;
            }
            function b(e3, t3, r3) {
              const s3 = r3.get(t3.node.key.id.name), { id: i2, getId: o2, setId: a2, initAdded: l2 } = s3;
              if (!l2)
                return o2 || a2 ? (r3.set(t3.node.key.id.name, Object.assign({}, s3, { initAdded: true })), n.template.statement.ast`
      ${i2}.set(${e3}, {
        get: ${o2 ? o2.name : t3.scope.buildUndefinedNode()},
        set: ${a2 ? a2.name : t3.scope.buildUndefinedNode()}
      });
    `) : n.template.statement.ast`${i2}.add(${e3})`;
            }
            function v(e3, t3) {
              const { key: r3, computed: s3 } = t3.node, i2 = t3.node.value || t3.scope.buildUndefinedNode();
              return n.types.expressionStatement(n.types.assignmentExpression("=", n.types.memberExpression(e3, r3, s3 || n.types.isLiteral(r3)), i2));
            }
            function E(e3, t3, r3) {
              const { key: s3, computed: i2 } = t3.node, o2 = t3.node.value || t3.scope.buildUndefinedNode();
              return n.types.expressionStatement(n.types.callExpression(r3.addHelper("defineProperty"), [e3, i2 || n.types.isLiteral(s3) ? s3 : n.types.stringLiteral(s3.name), o2]));
            }
            function x(e3, t3, r3, s3) {
              const i2 = s3.get(t3.node.key.id.name), { id: o2, methodId: a2, getId: l2, setId: c4, initAdded: u2 } = i2;
              if (!u2)
                return l2 || c4 ? (s3.set(t3.node.key.id.name, Object.assign({}, i2, { initAdded: true })), n.template.statement.ast`
      Object.defineProperty(${e3}, ${o2}, {
        // configurable is false by default
        // enumerable is false by default
        // writable is false by default
        get: ${l2 ? l2.name : t3.scope.buildUndefinedNode()},
        set: ${c4 ? c4.name : t3.scope.buildUndefinedNode()}
      })
    `) : n.template.statement.ast`
    Object.defineProperty(${e3}, ${o2}, {
      // configurable is false by default
      // enumerable is false by default
      // writable is false by default
      value: ${a2.name}
    });
  `;
            }
            function S(e3, t3, r3 = false) {
              const s3 = t3.get(e3.node.key.id.name), { id: i2, methodId: o2, getId: a2, setId: l2, getterDeclared: c4, setterDeclared: u2, static: p3 } = s3, { params: f2, body: d2, generator: h4, async: m2 } = e3.node, y2 = a2 && !c4 && f2.length === 0, g2 = l2 && !u2 && f2.length > 0;
              let b2 = o2;
              return y2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { getterDeclared: true })), b2 = a2) : g2 ? (t3.set(e3.node.key.id.name, Object.assign({}, s3, { setterDeclared: true })), b2 = l2) : p3 && !r3 && (b2 = i2), n.types.functionDeclaration(n.types.cloneNode(b2), f2, d2, h4, m2);
            }
            const T = n.traverse.visitors.merge([{ ThisExpression(e3, t3) {
              t3.needsClassRef = true, e3.replaceWith(n.types.cloneNode(t3.classRef));
            } }, s2.environmentVisitor]), w = { ReferencedIdentifier(e3, t3) {
              e3.scope.bindingIdentifierEquals(e3.node.name, t3.innerBinding) && (t3.needsClassRef = true, e3.node.name = t3.classRef.name);
            } };
            function P(e3, t3, r3, i2, o2, a2, l2) {
              var c4;
              const u2 = { classRef: t3, needsClassRef: false, innerBinding: l2 };
              return new s2.default({ methodPath: e3, constantSuper: a2, file: i2, refToPreserve: t3, getSuperRef: r3, getObjectRef: () => (u2.needsClassRef = true, o2 || e3.node.static ? t3 : n.types.memberExpression(t3, n.types.identifier("prototype"))) }).replace(), (o2 || e3.isProperty()) && e3.traverse(T, u2), (c4 = u2.classRef) != null && c4.name && u2.classRef.name !== (l2 == null ? void 0 : l2.name) && e3.traverse(w, u2), u2.needsClassRef;
            }
          }, (e2, t2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.assertFieldTransformed = function(e3) {
              if (e3.node.declare)
                throw e3.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by @babel/plugin-transform-typescript.\nIf you have already enabled that plugin (or '@babel/preset-typescript'), make sure that it runs before any plugin related to additional class features:\n - @babel/plugin-proposal-class-properties\n - @babel/plugin-proposal-private-methods\n - @babel/plugin-proposal-decorators");
            };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.injectInitialization = function(e3, t3, r3, s3) {
              if (!r3.length)
                return;
              const a2 = !!e3.node.superClass;
              if (!t3) {
                const r4 = n.types.classMethod("constructor", n.types.identifier("constructor"), [], n.types.blockStatement([]));
                a2 && (r4.params = [n.types.restElement(n.types.identifier("args"))], r4.body.body.push(n.template.statement.ast`super(...args)`)), [t3] = e3.get("body").unshiftContainer("body", r4);
              }
              if (s3 && s3(o, { scope: t3.scope }), a2) {
                const e4 = [];
                t3.traverse(i, e4);
                let s4 = true;
                for (const t4 of e4)
                  s4 ? (t4.insertAfter(r3), s4 = false) : t4.insertAfter(r3.map((e5) => n.types.cloneNode(e5)));
              } else
                t3.get("body").unshiftContainer("body", r3);
            }, t2.extractComputedKeys = function(e3, t3, r3, s3) {
              const i2 = [], o2 = { classBinding: t3.node.id && t3.scope.getBinding(t3.node.id.name), file: s3 };
              for (const e4 of r3) {
                const r4 = e4.get("key");
                r4.isReferencedIdentifier() ? a(r4, o2) : r4.traverse(l, o2);
                const s4 = e4.node;
                if (!r4.isConstantExpression()) {
                  const e5 = t3.scope.generateUidIdentifierBasedOnNode(s4.key);
                  t3.scope.push({ id: e5, kind: "let" }), i2.push(n.types.expressionStatement(n.types.assignmentExpression("=", n.types.cloneNode(e5), s4.key))), s4.key = n.types.cloneNode(e5);
                }
              }
              return i2;
            };
            var n = r2(9), s2 = r2(70);
            const i = n.traverse.visitors.merge([{ Super(e3) {
              const { node: t3, parentPath: r3 } = e3;
              r3.isCallExpression({ callee: t3 }) && this.push(r3);
            } }, s2.environmentVisitor]), o = { "TSTypeAnnotation|TypeAnnotation"(e3) {
              e3.skip();
            }, ReferencedIdentifier(e3) {
              this.scope.hasOwnBinding(e3.node.name) && (this.scope.rename(e3.node.name), e3.skip());
            } };
            function a(e3, t3) {
              if (t3.classBinding && t3.classBinding === e3.scope.getBinding(e3.node.name)) {
                const r3 = t3.file.addHelper("classNameTDZError"), s3 = n.types.callExpression(r3, [n.types.stringLiteral(e3.node.name)]);
                e3.replaceWith(n.types.sequenceExpression([s3, e3.node])), e3.skip();
              }
            }
            const l = { ReferencedIdentifier: a };
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.enableFeature = function(e3, t3, r3) {
              let n2, s3;
              c(e3, t3) && !f(e3, t3) || (e3.set(o, e3.get(o) | t3), r3 === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" ? (p2(e3, t3, true), e3.set(l, e3.get(l) | t3)) : r3 === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error" ? (p2(e3, t3, false), e3.set(l, e3.get(l) | t3)) : p2(e3, t3, r3));
              for (const [t4, r4] of i) {
                if (!c(e3, t4))
                  continue;
                const i2 = u(e3, t4);
                if (!f(e3, t4)) {
                  if (n2 === !i2)
                    throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods and @babel/plugin-proposal-private-property-in-object (when they are enabled).");
                  n2 = i2, s3 = r4;
                }
              }
              if (n2 !== void 0)
                for (const [t4, r4] of i)
                  c(e3, t4) && u(e3, t4) !== n2 && p2(e3, t4, n2);
            }, t2.isLoose = u, t2.verifyUsedFeatures = function(e3, t3) {
              if ((0, n.hasOwnDecorators)(e3.node)) {
                if (!c(t3, s2.decorators))
                  throw e3.buildCodeFrameError('Decorators are not enabled.\nIf you are using ["@babel/plugin-proposal-decorators", { "legacy": true }], make sure it comes *before* "@babel/plugin-proposal-class-properties" and enable loose mode, like so:\n	["@babel/plugin-proposal-decorators", { "legacy": true }]\n	["@babel/plugin-proposal-class-properties", { "loose": true }]');
                if (e3.isPrivate())
                  throw e3.buildCodeFrameError(`Private ${e3.isClassMethod() ? "methods" : "fields"} in decorated classes are not supported yet.`);
              }
              if (e3.isPrivateMethod != null && e3.isPrivateMethod() && !c(t3, s2.privateMethods))
                throw e3.buildCodeFrameError("Class private methods are not enabled.");
              if (e3.isPrivateName() && e3.parentPath.isBinaryExpression({ operator: "in", left: e3.node }) && !c(t3, s2.privateIn))
                throw e3.buildCodeFrameError("Private property in checks are not enabled.");
              if (e3.isProperty() && !c(t3, s2.fields))
                throw e3.buildCodeFrameError("Class fields are not enabled.");
              if (e3.isStaticBlock != null && e3.isStaticBlock() && !c(t3, s2.staticBlocks))
                throw e3.buildCodeFrameError("Static class blocks are not enabled. Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
            }, t2.FEATURES = void 0;
            var n = r2(311);
            const s2 = Object.freeze({ fields: 2, privateMethods: 4, decorators: 8, privateIn: 16, staticBlocks: 32 });
            t2.FEATURES = s2;
            const i = new Map([[s2.fields, "@babel/plugin-proposal-class-properties"], [s2.privateMethods, "@babel/plugin-proposal-private-methods"], [s2.privateIn, "@babel/plugin-proposal-private-property-in-object"]]), o = "@babel/plugin-class-features/featuresKey", a = "@babel/plugin-class-features/looseKey", l = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
            function c(e3, t3) {
              return !!(e3.get(o) & t3);
            }
            function u(e3, t3) {
              return !!(e3.get(a) & t3);
            }
            function p2(e3, t3, r3) {
              r3 ? e3.set(a, e3.get(a) | t3) : e3.set(a, e3.get(a) & ~t3), e3.set(l, e3.get(l) & ~t3);
            }
            function f(e3, t3) {
              return !!(e3.get(l) & t3);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-private-property-in-object", manipulateOptions(e4, t3) {
              t3.plugins.push("privateIn");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-logical-assignment-operators", manipulateOptions(e4, t3) {
              t3.plugins.push("logicalAssignment");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-nullish-coalescing-operator", manipulateOptions(e4, t3) {
              t3.plugins.push("nullishCoalescingOperator");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-optional-chaining", manipulateOptions(e4, t3) {
              t3.plugins.push("optionalChaining");
            } }));
            t2.default = n;
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.isTransparentExprWrapper = s2, t2.skipTransparentExprWrappers = function(e3) {
              for (; s2(e3.node); )
                e3 = e3.get("expression");
              return e3;
            };
            var n = r2(0);
            function s2(e3) {
              return n.isTSAsExpression(e3) || n.isTSTypeAssertion(e3) || n.isTSNonNullExpression(e3) || n.isTypeCastExpression(e3) || n.isParenthesizedExpression(e3);
            }
          }, (e2, t2, r2) => {
            "use strict";
            Object.defineProperty(t2, "__esModule", { value: true }), t2.default = void 0;
            var n = (0, r2(4).declare)((e3) => (e3.assertVersion(7), { name: "syntax-export-namespace-from", manipulateOptions(e4, t3) {
              t3.plugins.push("exportNamespaceFrom");
            } }));
            t2.default = n;
          }], t = {};
          function r(n) {
            var s2 = t[n];
            if (s2 !== void 0)
              return s2.exports;
            var i = t[n] = { id: n, loaded: false, exports: {} };
            return e[n].call(i.exports, i, i.exports, r), i.loaded = true, i.exports;
          }
          return r.n = (e2) => {
            var t2 = e2 && e2.__esModule ? () => e2.default : () => e2;
            return r.d(t2, { a: t2 }), t2;
          }, r.d = (e2, t2) => {
            for (var n in t2)
              r.o(t2, n) && !r.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t2[n] });
          }, r.g = function() {
            if (typeof globalThis == "object")
              return globalThis;
            try {
              return this || new Function("return this")();
            } catch (e2) {
              if (typeof window == "object")
                return window;
            }
          }(), r.o = (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r.r = (e2) => {
            typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
          }, r.nmd = (e2) => (e2.paths = [], e2.children || (e2.children = []), e2), r(355), r(361);
        })();
      });
    }
  });

  // yehat/basics0/loader.js
  var import_pako;
  var init_loader = __esm({
    "yehat/basics0/loader.js"() {
      import_pako = __toModule(require_pako());
      init_basics0();
    }
  });

  // yehat/basics0/cargo.js
  var import_pako, Cargo;
  var init_cargo = __esm({
    "yehat/basics0/cargo.js"() {
      import_pako = __toModule(require_pako());
      init_basics0();
      Cargo = ecs.define("cargo", {
        cursor: null
      }, { details: `Memory Cell for [Cargo]. "cursor" is index of a stored item to show.` });
    }
  });

  // yehat/basics0/story0.js
  var import_pako, Story, StoryFrame;
  var init_story0 = __esm({
    "yehat/basics0/story0.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      init_basics0();
      Story = Component("story", {
        frames: [],
        stage: 0,
        done: false,
        duration: null
      });
      StoryFrame = Component("storyFrame", {
        caption: "- No caption -",
        done: false,
        dtDone: null,
        dtStart: null,
        duration: null
      });
    }
  });

  // yehat/basics0/navigation0.js
  var import_pako, NavConfig;
  var init_navigation0 = __esm({
    "yehat/basics0/navigation0.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      init_basics0();
      NavConfig = Component("config", {
        showJSON: false
      });
    }
  });

  // yehat/basics0/entityEdit.js
  var import_pako, EntityEditConfig;
  var init_entityEdit = __esm({
    "yehat/basics0/entityEdit.js"() {
      import_pako = __toModule(require_pako());
      init_basics0();
      EntityEditConfig = ecs.define("entEditConf0", {
        compoCursor: 0,
        compoEditing: null,
        showSlot: false,
        showEntityScheme: true
      }, { details: `Memory Cell for [Entity Editor]. "compoCursor" is a currently active component index within 
an Entity being browsed.` });
    }
  });

  // yehat/basics0/user2.js
  var import_pako, makeUser2;
  var init_user2 = __esm({
    "yehat/basics0/user2.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      ecs2.define("user2", {
        eventID: null,
        refID: null,
        name: "Unknown",
        deviceIDs: []
      });
      makeUser2 = ({ id: id2, user2, ...a }) => {
        const entity = ecs2.loadEntity([
          ecs2.compo.user2(user2),
          ecs2.compo.meta({
            type: "User2",
            name: "Promotion-Aquired User"
          }),
          ecs2.compo.saveRemote({
            user2: true
          })
        ])({ id: id2 });
        return entity;
      };
      ecs2.declareType("User2", makeUser2, { details: "Promotion-Aquired User" });
    }
  });

  // yehat/basics0/index.js
  var import_pako, loadEntity3, define3, Meta2, Located, Item, Drag, Activity;
  var init_basics0 = __esm({
    "yehat/basics0/index.js"() {
      import_pako = __toModule(require_pako());
      init_loader();
      init_cargo();
      init_story0();
      init_navigation0();
      init_entityEdit();
      init_user2();
      ({ loadEntity: loadEntity3, define: define3 } = ecs);
      Meta2 = define3("meta", {
        type: "Unknown",
        name: "No name",
        tags: []
      }, { details: `General meta-information about an Entity, such its "type" (archetype, classification of the Entity Class 
  amongst other Entity Classes), and its "name" (Entity Class name, arbitrary).` });
      Located = define3("located", {
        rel: null,
        pos: [0, 0, 0],
        size: [0, 0]
      }, { details: `Entity's parent container ID and Vector3 position inside of it.` });
      Item = define3("item", {
        baseComponent: "IAbstract",
        inventoryComponent: null,
        cargoStyle: null,
        style: null,
        show: false,
        opened: false,
        baseIcon: null,
        baseImage: null,
        name: ""
      }, { details: `Makes entity renderable on ZII Table3.` });
      Drag = define3("drag", {
        active: false,
        pos: [0, 0],
        onDrop: (item2) => () => {
        }
      }, { details: `Keep information about how an Entity is being dragged.` });
      Activity = define3("activity", {
        dtLastTouched: null,
        count: 0,
        z: 0
      }, { details: `Used to track activity of ZII Table 3 items, namely for maintain their z-order.`, tags: ["zt3"] });
      ecs.declareCompoSet("AbstractItem", [
        Located(),
        Item(),
        Drag(),
        Activity(),
        ecs.compo.saveLocal({
          located: true
        })
      ], { details: "Mix it in to add all Item components: Located, Item, Drag, Activity, saveLocal = { located: true }" });
      ecs.define("we", {
        solid: false,
        portPickRequested: false
      }, { details: "World Entity." });
      ecs.define("password0", {
        password: null,
        valid: true
      }, { details: "A password" });
      ecs.declareType("Password0", [
        ecs.compo.meta({ name: "Linking Password", type: "Password0" }),
        ecs.compo.password0(),
        ecs.compo.connections({
          owner: null
        })
      ]);
      ecs.define("sync0", {
        status: "local",
        mode: "passive"
      }, { details: "Workshop Entity synchronization." });
      ecs.define("owner0", {
        memberID: null,
        access: "private"
      }, { details: "Entity Ownership" });
    }
  });

  // yehat/presentation/image3.js
  var import_pako;
  var init_image3 = __esm({
    "yehat/presentation/image3.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      ecs2.define("image3", {
        urls: [],
        size: [0, 0],
        pos: [0, 0, 0],
        isoPos: [0, 0, 0],
        shift: [0, 0],
        origin: [0, 0, 0],
        images: [],
        index: 0,
        opacity: 1,
        drawOpacity: 1,
        opacitySpeed: 0.04,
        log: false,
        load: (item2) => async () => {
          if (item2.image3.log)
            console.log("}image3{ loading.", item2.image3.urls);
          item2.image3.images = [];
          for (let index in item2.image3.urls) {
            let url = item2.image3.urls[index];
            let image = new Image();
            await new Promise((resolve2, reject) => {
              image.onload = resolve2;
              if (item2.image3.log)
                console.log("}image3{ loading SRC set", url, index);
              image.src = url;
            });
            if (item2.image3.log)
              console.log("}image3{ Loaded image", url, index);
            item2.image3.images.push(image);
          }
          if (item2.embeddings) {
            for (let key2 in item2.embeddings) {
              let embedding = item2.embeddings[key2];
              let image = new Image();
              image.onload = () => {
                embedding.image = image;
              };
              image.src = embedding.url;
            }
          }
        },
        render: (item2) => ({ ctx, camera, mouse, canvas0, now }) => {
          const index = item2.image3.index;
          if (!item2.image3.images.length) {
            if (item2.image3.log)
              console.log(`}image3{ ${item2.id.slice(0, 8)} No images loaded.`);
            return;
          }
          if (!item2.image3.images[index]) {
            if (item2.image3.log)
              console.log(`}image3{ ${item2.id.slice(0, 8)} No active image loaded.`);
            return;
          }
          let { size: size3, shift } = item2.image3;
          let origin = [
            item2.image3.origin[0] * 12,
            item2.image3.origin[1] * 12,
            item2.image3.origin[2] * 12
          ];
          let pos = [
            item2.located.pos[0] * 12,
            item2.located.pos[1] * 12,
            0
          ];
          const player = ecs2.root["bd387635-71ac-4faa-b7a2-a5e2ddb5e123"];
          if (player.wield0.entityID && player.wield0.entityID == item2.id) {
            const duration2 = 300;
            const n = core.ease.inCubic(Math.min((now - player.wield0.dtStart) / duration2, 1));
            const { lerp } = core;
            pos = [
              lerp(pos[0], player.unit0.pos[0], n),
              lerp(pos[1], player.unit0.pos[1], n),
              lerp(pos[2], player.unit0.pos[2], n)
            ];
            shift = [
              0,
              lerp(shift[1], -24, n)
            ];
          } else if (player.throw0.entityID && player.throw0.entityID == item2.id) {
            const duration2 = 300;
            const n = core.ease.outCubic(Math.min((now - player.throw0.dtStart) / duration2, 1));
            const { lerp } = core;
            pos = [
              lerp(player.unit0.pos[0], pos[0], n),
              lerp(player.unit0.pos[1], pos[1], n),
              lerp(player.unit0.pos[2], pos[2], n)
            ];
            shift = [
              0,
              lerp(-24, shift[1], n)
            ];
          }
          const isoPadPos3 = ([ix, iy, w = 0, h3 = 0]) => {
            return [
              ix * 2 - iy * 2 + 288 - Math.floor(w / 2),
              ix + iy + 240 - Math.floor(h3 / 2)
            ];
          };
          const p0 = isoPadPos3([
            origin[0] + pos[0],
            origin[1] + pos[1],
            size3[0],
            size3[1]
          ]);
          const p1 = [
            p0[0] + shift[0] - camera.pos[0] * 2 + camera.pos[1] * 2,
            p0[1] + shift[1] - camera.pos[0] - camera.pos[1]
          ];
          ctx.globalAlpha = item2.image3.drawOpacity;
          ctx.drawImage(item2.image3.images[index], p1[0], p1[1]);
          if (item2.embeddings) {
            const sortedEmbeddings = Object.values(item2.embeddings).sort((a, b) => a.order - b.order);
            for (let embedding of sortedEmbeddings) {
              if (embedding.image) {
                if (embedding.crop) {
                  ctx.drawImage(embedding.image, ...embedding.crop, p1[0] + embedding.shift2D[0], p1[1] + embedding.shift2D[1], embedding.crop[2], embedding.crop[3]);
                } else {
                  ctx.drawImage(embedding.image, p1[0] + embedding.shift2D[0], p1[1] + embedding.shift2D[1]);
                }
              }
            }
          }
          if (player.preconnect0 && player.preconnect0.entityAID == item2.id && player.preconnect0.entityAPort !== null) {
            const emb = player.embeddings[player.preconnect0.entityAPort];
            if (emb && emb.image) {
              ctx.drawImage(emb.image, ...emb.crop, p1[0] + emb.shift2D[0], p1[1] + emb.shift2D[1], emb.crop[2], emb.crop[3]);
            }
          }
          ctx.globalAlpha = 1;
          const m = [
            Math.round((mouse.mouse0.pos[0] - canvas0[0]) / canvas0[4]),
            Math.round((mouse.mouse0.pos[1] - canvas0[1]) / canvas0[4])
          ];
          return {
            isPointed: p1[0] <= m[0] && p1[0] + size3[0] > m[0] && p1[1] <= m[1] && p1[1] + size3[1] > m[1]
          };
        },
        update: (item2) => ({}) => {
          if (item2.image3.opacity > item2.image3.drawOpacity) {
            item2.image3.drawOpacity = Math.min(item2.image3.drawOpacity + item2.image3.opacitySpeed, item2.image3.opacity);
          } else if (item2.image3.opacity < item2.image3.drawOpacity) {
            item2.image3.drawOpacity = Math.max(item2.image3.drawOpacity - item2.image3.opacitySpeed, item2.image3.opacity);
          }
        }
      }, { details: "A world-positioned image." });
    }
  });

  // yehat/presentation/presentation0.js
  var import_pako, Timer, k, Stage0, Line0, Poly0, Image0, Image2, Camera0, Image1, Background0, TimeLine0, Scene0, Playback0, PresentationDash0;
  var init_presentation0 = __esm({
    "yehat/presentation/presentation0.js"() {
      import_pako = __toModule(require_pako());
      init_basics0();
      init_image3();
      Timer = ecs.compo.timer;
      k = 0.5;
      Stage0 = ecs.define("stage0", {
        items: [],
        equip: (presentation) => () => {
          for (let item2 of presentation.stage0.items) {
            let type2 = Object.keys(item2)[0];
            item2.render = item2[type2].render(item2);
            if (item2[type2].load)
              item2[type2].load(item2)();
            if (item2[type2].init)
              item2.init = item2[type2].init(item2);
            if (item2[type2].update)
              item2.update = item2[type2].update(item2);
          }
        }
      }, { details: "" });
      Line0 = ecs.define("line0", {
        origin: [0, 0],
        p0: [0, 0],
        p1: [0, 0],
        render: (item2) => ({ ctx }) => {
          const { origin, p0, p1 } = item2.line0;
          ctx.beginPath();
          ctx.lineWidth = 1;
          ctx.lineCap = "square";
          ctx.lineJoin = "round";
          ctx.strokeStyle = "#ffffff";
          ctx.imageSmoothingEnabled = false;
          ctx.moveTo(origin[0] + p0[0] + k, origin[1] + p0[1] + k);
          ctx.lineTo(origin[0] + p1[0] + k, origin[1] + p1[1] + k);
          ctx.lineCap = "square";
          ctx.stroke();
        }
      }, { details: "" });
      Poly0 = ecs.define("poly0", {
        origin: [0, 0],
        points: [],
        render: (item2) => ({ ctx }) => {
          const { origin, points } = item2.poly0;
          ctx.beginPath();
          ctx.lineWidth = 1;
          ctx.lineCap = "square";
          ctx.lineJoin = "round";
          ctx.strokeStyle = "#ffffff";
          ctx.imageSmoothingEnabled = false;
          for (let i = 0; i < points.length; i++) {
            let p2 = points[i];
            if (i == 0) {
              ctx.moveTo(origin[0] + p2[0] + k, origin[1] + p2[1] + k);
            } else {
              ctx.lineTo(origin[0] + p2[0] + k, origin[1] + p2[1] + k);
            }
          }
          ctx.stroke();
        }
      }, { details: "" });
      Image0 = ecs.define("image0", {
        url: "",
        size: [0, 0],
        pos: [0, 0, 0],
        origin: [0, 0, 0],
        image: null,
        flag: false,
        atWorld: false,
        load: (item2) => () => {
          if (item2.image0.flag)
            console.log("image0 loading!!", item2.image0.url);
          const image = new Image();
          return new Promise((resolve2, reject) => {
            image.onload = () => {
              item2.image0.image = image;
              resolve2();
            };
            image.src = item2.image0.url;
          });
        },
        render: (item2) => ({ ctx, camera }) => {
          if (!item2.image0.image)
            return;
          const { origin, pos } = item2.image0;
          if (item2.image0.atWorld) {
            ctx.drawImage(item2.image0.image, origin[0] + pos[0] - camera.pos[0] * 2 + camera.pos[1] * 2, origin[1] + pos[1] - camera.pos[0] - camera.pos[1]);
          } else {
            ctx.drawImage(item2.image0.image, origin[0] + pos[0], origin[1] + pos[1]);
          }
        }
      }, { details: "" });
      Image2 = ecs.define("image2", {
        urls: [],
        size: [0, 0],
        pos: [0, 0, 0],
        isoPos: [0, 0, 0],
        origin: [0, 0, 0],
        images: [],
        atWorld: true,
        index: 0,
        tags: [],
        opacity: 1,
        drawOpacity: 0,
        opacitySpeed: 0.04,
        flag: false,
        load: (item2) => async () => {
          if (item2.image2.flag)
            console.log("image0 loading!!", item2.image2.urls);
          item2.image2.images = [];
          for (let index in item2.image2.urls) {
            let url = item2.image2.urls[index];
            let image = new Image();
            await new Promise((resolve2, reject) => {
              image.onload = resolve2;
              if (item2.image2.flag)
                console.log("image0 loading SRC set", url, index);
              image.src = url;
            });
            if (item2.image2.flag)
              console.log("Loaded image", url, index);
            item2.image2.images.push(image);
          }
        },
        render: (item2) => ({ ctx, camera }) => {
          const index = item2.image2.index;
          if (!item2.image2.images.length)
            return;
          if (!item2.image2.images[index])
            return;
          const { origin, pos } = item2.image2;
          ctx.globalAlpha = item2.image2.drawOpacity;
          if (item2.image2.atWorld) {
            ctx.drawImage(item2.image2.images[index], origin[0] + pos[0] - camera.pos[0] * 2 + camera.pos[1] * 2, origin[1] + pos[1] - camera.pos[0] - camera.pos[1]);
          } else {
            ctx.drawImage(item2.image2.images[index], origin[0] + pos[0], origin[1] + pos[1]);
          }
          ctx.globalAlpha = 1;
        },
        update: (item2) => ({}) => {
          if (item2.image2.opacity > item2.image2.drawOpacity) {
            item2.image2.drawOpacity = Math.min(item2.image2.drawOpacity + item2.image2.opacitySpeed, 1);
          } else if (item2.image2.opacity < item2.image2.drawOpacity) {
            item2.image2.drawOpacity = Math.max(item2.image2.drawOpacity - item2.image2.opacitySpeed, 0);
          }
        }
      }, { details: "A world-positioned image." });
      Camera0 = ecs.define("camera0", {
        pos: [0, 0, 0]
      }, { details: "" });
      Image1 = ecs.define("image1", {
        url: "",
        size: [0, 0],
        pos: [0, 0, 0],
        rotation: [0, 0, 0],
        origin: [0, 0, 0],
        image: null,
        load: (item2) => () => {
          const image = new Image();
          return new Promise((resolve2, reject) => {
            image.onload = () => {
              item2.image1.image = image;
              resolve2();
            };
            image.src = item2.image1.url;
          });
        },
        render: (item2) => ({ ctx, presentation, camera }) => {
          if (!item2.image1 || !item2.image1.image || !item2.image1.pos)
            return;
          const { origin, pos } = item2.image1;
          const project = ({ p: p2, origin: origin2, camera: camera2 }) => {
            const [ix, iy, iz] = item2.image1.pos;
            const p0 = [
              ix - camera2.pos[0],
              iy - camera2.pos[1],
              iz - camera2.pos[2]
            ];
            const scaleF0 = (p0[0] / 2 + p0[1] / 2) / 4;
            const dist = 32 - scaleF0;
            if (dist <= 0 || dist > 64) {
              return;
            }
            const scale = 32 / dist;
            const p1 = [
              Math.floor((p0[0] - p0[1]) * scale + presentation.scene0.size[0] / 2 - item2.image1.size[0] / 2 * scale),
              Math.floor((p0[0] / 2 + p0[1] / 2 - p0[2] - item2.image1.size[1] / 2) * scale) + 192 + 64 - 32
            ];
            return [
              p1[0],
              p1[1],
              scale
            ];
          };
          try {
            const a = project({ p: pos, origin, camera });
            if (!a)
              return;
            const [x, y, s2] = a;
            ctx.drawImage(item2.image1.image, 0, 0, item2.image1.size[0], item2.image1.size[1], x, y, item2.image1.size[0] * s2, item2.image1.size[1] * s2);
          } catch (e) {
            console.log("error", e);
          }
        }
      }, { details: "" });
      Background0 = ecs.define("background0", {
        color: "transparent",
        render: (item2) => ({ ctx, presentation, camera, scene }) => {
        }
      });
      TimeLine0 = ecs.define("timeline0", {
        duration: 0,
        events: []
      }, { details: "" });
      Scene0 = ecs.define("scene0", {
        size: [576, 320],
        stages: [],
        currentStage: null,
        initStage: (pre) => ({ scene, stageIndex }) => {
          console.log(`[Presentation] Init stage ${stageIndex}`);
          pre.stage0.items = [...pre.scene0.stages[stageIndex]];
          pre.stage0.equip();
          for (let item2 of pre.stage0.items) {
            if (item2.init)
              item2.init({ scene });
          }
          pre.scene0.currentStage = stageIndex;
        },
        disposeStage: (pre) => ({ scene }) => {
          console.log(`[Presentation] Dispose stage ${pre.scene0.currentStage}`);
          for (let item2 of pre.stage0.items) {
            if (item2.dispose)
              item2.dispose({ scene });
          }
          pre.stage0.items = [];
        },
        render: (pre) => ({ ctx, scene, camera, units: units2, mouse, canvas0 }) => {
          const now = +new Date();
          const items = [...pre.stage0.items.map((item2) => {
            const key2 = Object.keys(item2)[0];
            const pos = item2[key2].pos;
            const origin = item2[key2].origin;
            return {
              pos,
              origin,
              render: item2.render,
              update: item2.update
            };
          }), ...units2];
          items.map((item2) => {
            if (item2.update)
              item2.update({ now });
          });
          items.sort((a, b) => {
            if (!a.pos || !b.pos)
              return 0;
            if (a.pos[2] != b.pos[2])
              return a.pos[2] - b.pos[2];
            return a.pos[0] + a.pos[1] - b.pos[0] - b.pos[1];
          });
          let topmost = null, c = 0;
          for (let { id: id2, render: render3 } of items) {
            if (render3) {
              let v = render3({ ctx, presentation: pre, scene, camera, mouse, canvas0, now });
              if (id2 && v && v.isPointed)
                topmost = id2;
              c++;
            }
          }
          if (mouse) {
            mouse.connections.picked = topmost;
            const p0 = [
              (mouse.mouse0.pos[0] - canvas0[0]) / canvas0[4] - 288,
              (mouse.mouse0.pos[1] - canvas0[1]) / canvas0[4] - 240 - 18
            ];
            const p1 = [
              Math.floor(p0[0] + p0[1] * 2) + camera.pos[0] * 4,
              Math.floor(-p0[0] + p0[1] * 2) + camera.pos[1] * 4,
              0
            ];
            const p2 = [
              Math.floor(p1[0] / 48),
              Math.floor(p1[1] / 48),
              Math.floor(p1[2] / 48)
            ];
            mouse.mouse0.isoPos0 = p2;
            if (pre.c && pre.c.worldCursor) {
              pre.c.worldCursor.located.pos = [
                p2[0],
                p2[1],
                10
              ];
            }
          }
          if (pre.connections.actor) {
            const unit = ecs.root[pre.connections.actor];
            const pos = unit.unit0.pos;
            pre.stage0.items.filter((item2) => {
              return !!item2.image2 && ~item2.image2.tags.indexOf("pad0");
            }).map((item2) => {
              if (item2.image2.isoPos[0] == Math.floor(pos[0] / 12) && item2.image2.isoPos[1] == Math.floor(pos[1] / 12)) {
                item2.image2.index = 1;
              } else {
                item2.image2.index = 0;
              }
            });
            const table = ecs.root["27df4209-e8d8-41ca-8a48-951ae9d077c6"];
            pre.stage0.items.filter((item2) => {
              return !!item2.image2 && ~item2.image2.tags.indexOf("code");
            }).map((item2) => {
              item2.image2.opacity = Math.floor(pos[0] / 12) == -4 && Math.floor(pos[1] / 12) == -4 ? 1 : 0;
            });
            pre.stage0.items.filter((item2) => {
              return !!item2.image2 && ~item2.image2.tags.indexOf("wasd");
            }).map((item2) => {
              item2.image2.opacity = Math.floor(pos[0] / 12) == 0 && Math.floor(pos[1] / 12) == 0 ? 1 : 0;
            });
            pre.stage0.items.filter((item2) => {
              return !!item2.image2 && ~item2.image2.tags.indexOf("connectivity");
            }).map((item2) => {
              item2.image2.opacity = Math.floor(pos[0] / 12) == -3 && Math.floor(pos[1] / 12) == -6 ? 1 : 0;
            });
            const meID = pre.connections.me;
            if (meID && pre.playback0.frame % 4 == 0) {
              core.yehat.outbound.push({
                cmd: "events0.move",
                id: meID,
                d: [
                  pos[0],
                  pos[1],
                  pos[2],
                  unit.unit0.dir
                ]
              });
              core.yehat.transmitOutbound({ socket: core.socket });
            }
            const x = Math.floor(pos[0] / 12);
            const y = Math.floor(pos[1] / 12);
            if (x == 12 && y == -17) {
              pre.stage0.items.filter((item2) => {
                return !!item2.image2 && !!~item2.image2.tags.indexOf("captionActive");
              }).map((item2) => {
                item2.image2.index = 0;
              });
            }
            if (x == 15 && y == -18) {
              pre.stage0.items.filter((item2) => {
                return !!item2.image2 && !!~item2.image2.tags.indexOf("captionActive");
              }).map((item2) => {
                item2.image2.index = 1;
              });
            }
          }
          if (pre.c && pre.c.dash0) {
            pre.c.dash0.presentationDash0.itemsLastFrame = c;
            pre.c.dash0.presentationDash0.unitsCount = units2.length;
          }
        }
      }, { details: "Presentation Scene parameters." });
      Playback0 = ecs.define("playback0", {
        fps: 24,
        dtLastFrame: null,
        frame: 0,
        tick: (item2) => ({ now }) => {
          const frameLength = 1e3 / item2.playback0.fps;
          if (!item2.playback0.dtLastFrame)
            item2.playback0.dtLastFrame = now - frameLength;
          let passed = now - item2.playback0.dtLastFrame;
          while (passed > frameLength) {
            item2.playback0.frame++;
            item2.playback0.dtLastFrame += frameLength;
            passed -= frameLength;
          }
          if (item2.timeline0.duration !== null && item2.playback0.frame >= item2.timeline0.duration - 1) {
            item2.timer.stop();
            console.log("Playback: Finished.");
          }
        },
        start: (item2) => () => {
          const now = performance.now();
          item2.playback0.dtLastFrame = now - 1e3 / item2.playback0.fps;
          item2.playback0.frame = 0;
          item2.timer.start();
        }
      }, { details: "" });
      PresentationDash0 = ecs.define("presentationDash0", {
        itemsLastFrame: 0,
        unitsCount: 0
      }, { details: "" });
    }
  });

  // yehat/basics0/embeddings.js
  var import_pako;
  var init_embeddings = __esm({
    "yehat/basics0/embeddings.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      define2("embedding", {
        shift2D: [0, 0],
        shift3D: [0, 0, 0],
        crop: null,
        order: 1,
        url: "",
        image: null
      }, { details: "" });
      define2("embeddings", {
        loadEmbeddings: (item2) => () => {
          if (item2.embeddings) {
            for (let key2 in item2.embeddings) {
              let embedding = item2.embeddings[key2];
              let image = new Image();
              image.onload = () => {
                embedding.image = image;
              };
              image.src = embedding.url;
            }
          }
        }
      }, { details: "Addons that are to be renderred in a World Entity Space." });
    }
  });

  // yehat/basics0/lang.js
  var import_pako;
  var init_lang = __esm({
    "yehat/basics0/lang.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      init_vue_esm_bundler();
      console.log("baSICS0/LANG");
      ecs2.define("lang", {
        en: {},
        ru: {},
        enchantI: (item2) => {
          item2.i = computed2(() => item2.lang[core.yehat.lang]);
          return () => {
          };
        }
      }, { details: "Multilingual Content Container" });
    }
  });

  // yehat/assets/project-00.png
  var project_00_default;
  var init_project_00 = __esm({
    "yehat/assets/project-00.png"() {
      project_00_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAACJlJREFUeJztnb1qW1kQgMfLFkZFijQuDC5tcOfCkEpGT+ByQXVA+xKLMfsA28bg2rBlnkBYzRpSuDPYpSFFIKQU6bxFMspodP5/Z671gSGR7j061qc5Z86cq2uALVu2bNkilJ3eHZDK+OjkxXfM4vFe/Pv3e+8OSIJKvbmYeI+fXsLqeKmyRXaqNSg2RKqN6eUcAOSJFtWZHoyPTl5yxHKml3NRksV0pAel5SKSJP/WuwNb6jJoweOjk5eQbHjIDDKL5kkTZrumYXN6Oc9KrkztufrkosawLmKeKIUvG+aZ7vjo5OV0bxc+ffkOrvNC4GIXj/c78cuuX22Ukj0IwbHLHPpGomAqOrQtW7TGtOFrO1e0asG561d8E7ncUE73dgEANs6VtOxSKbhEYYLii0SERjvCo1/asktVklVaLPIrGbOL5kM5Sk6N/laoEFxLLMcl2iSXPy4R0UN0K7E2XMkYl0ypsexKHaJFCu4tlsOTMVcE11x2pbQjaoiWJvafD/+t/h07B5/u7a5Jil122ZZvsYiIYMliAWAjOn0RTM+JgbbLX1tlBEsXS4mJ4NDIM31gUtpx0UWwJrFITBYdK9cmuUR23lSwRrFI6Qj2yQ1tx0cTwZrFItsINjAEscg2ggnaxPI30JbNvvoI1i6WP07f9FcdwdrEAtjlmqKT/ltbBGcVOjSKBTDLdUURPh9Si46pQMVEcNNCh1axAG65o+ODtceXD89r52mM4CjBmsXaoHKnb74CAMD13RJGxwcwOj6AU3jeEDG4OXgoYm3ZMsq9vluunls+PK9F9CAjeChiXXC5a2/ol6eNSB1EBL8Gsa6dm6vzt6vHZh+/rZ4bVARLkFuiQBHL6d7u2lDtko3Hq4vg3pQsUIRAhfI2TLJnH78ZEy9EUgQb11a9hugaBQrbuXxphEuikDXy+3cjAPgh2iZXyjrYKRipLbpWgcIlmT5nWv+GvNbo+ABu509rMmnly0VIBNN2qgpGSouuWaCIiWLTMbZKFT8PJdPn1EUwJ1d06n4sxVWgAEiTbJvDfdFMJauOYE6s6BYFCnzcJdjXLm+LDsOm4dh3nA2xtWgEL/P0ie5ZoHDhOoYO+2eTQ6O8nOxXRBYdCxddSqwt+0XBrgIFPccHn8s5KJn3Cz8AlEFEMId+A8BFrwKF7XV8YhEayfR18TFTVu3qr7oIRnwJQ855NIJNa1dTG3TdyttIgUrm83GqZBMlIrjZTVhcBQr8if20oiA+bOIPcn23hOu7JVydv4Wr87fw6cv3ZLkAPyLZ19fYCHYdk0OTCJZaoDibHFp+Azez8T4AbH6XiLfvQ90cbCK2QBHSHp7Pj7cVKPiHY/nwvJpPUyRfLT4DwPr3iX1LMk6rObj5fbJ4Fjx983UlanR8YP2lXJUl25LlbHK4JpCeRyWncrX4vJIdS8xuUg5VIzimQMGvoDBBExtXYsXbQcm386eNEcAVyTgUp0p00SqCm28X1ixQ+D4gKNMXGSiW/98kGj8cdCQIGRViIjhHcrMh2pU4YXaLGS59LgS8QC4EjFTMpFHG7fwJZuP9DbkU/jyXS+f6073dtbU4p1UW3X3Dv0WBwva6vECRAt9JouDSbPbxG9xcTNay7sFFMIVfQWFas/J1Kz0mJmJN3FxMjAlX6P2yXFHOob/rzcVkrZzbIoK7CO5VoCjJbLy/kZiZZJgeo6JrZ9HVCx0SCxTI9HJuLFDEbINeLT57h3dfe64aftf9YBu2NWvoJ9W1GZErGWCzEsXryD3vy8XfB/G16KEVKGqA/eE1bjVZ9JAKFCUx9c92cUEqTbcLbYQkTvyaJ9NQbctufQUKvvUHUPdK0pAPHt9yFDsHu4jNiFEyH6JDZeAba6o+0T6/fzdarV1LEjuiUMli52ATOetYWqDISbRCChSh62IfqXN+yL6zj6aCcwsU/BduVaBIpUQyl/MhBmiUZJUqTszG+1nZM7YBsB7Bpkw+J3JKJ3c/Jb+kDNNV5+CSYilSChSmNmtyO3+KnourRHCLcmJuGc+3cxRDq+VYSiR3300KAd/AUkJK0WOdHSu5iuDcUqINKYWL3v2IkVwtgmMk88hMWS+2oLdYSqjkKkmWoSNGfENu6CUylBoVKEliOb7Eq7pggE3JsXNprwqUZLEUl+QmggF+SE5Nkqhgiu1rKrmStYil2CQ3q2TlzJOtKlDSthFjOJscGgOz6TIp9PvEJmIqUNIKFD3psg5OFW2TTImtZg0B11d+ms3BLlpfIjNUsaZtRRGVrJyhO4ahinUhQjBSS/RrFIuIEoyUEv2axSIiBSOpordifyFaMBIqeit2ExWCEZvorVg7qgQjKLrGlmQPaohFulxVWYpW24S1WD48G9eyuVdSUlQLBtApuYVYRL1gAD2SW4pFBiEYQLZkl9jF4z0sHu+rvbbKJMtGrWvBUjElT+S7Rk36MCjBADIkSxCLGIfo1C86SaHXcN1zKLZhjWCU3HrrsBQtI1lSxHK8Q7Rm0bUlSxaLBM/BWkXXkKxBLBKdZGkUXUqyZLG2tXRyFq1NdI5kX624p1zfLR6yl0maRMdKrrkJkEvovTuKrYO1iA6RPASxSPFChwbRNslDEotUq2RJF00lSxBL7wlGqXIbpRpIFZ17s0+sUqXy159/bDz294d/YXx0AgD5VcVmtWjpEe3DdFPVHGxi4WfQlcrMm282aBNNxZbYt/WJLU233STpoltHbC26bxdKFl1Cbi+xSHfBiGTRKfQWi4gRjGgXLUUsIk4wok20NLGIWMGIBtFcrgSxiHjBiAbRksQiagQjEkVLFIuovS568Xi/I+jiQCn92EBdBHNaRbTpL8bQ15eKesFILdG8oqVFLKKikymEinb9sS76vDaxiKrOpuAT7StHahWLqOx0CjbRvgjWKhZR3fkUuGjbH+PQLhYZxC+RAorWPsdueeX8DyTRpBUW/HNCAAAAAElFTkSuQmCC";
    }
  });

  // yehat/basics0/project.js
  var import_pako;
  var init_project = __esm({
    "yehat/basics0/project.js"() {
      import_pako = __toModule(require_pako());
      init_project_00();
      ecs.define("project0", {
        name: ""
      }, { details: "A Project" });
      ecs.define("project0status", {
        dtRegistered: null,
        founderID: null
      }, { details: "Server-side status?" });
      ecs.define("project0members", {
        roster: {},
        isMember: (item2) => (id2) => {
          return !!item2.project0members.roster[id2];
        },
        add: (item2) => (id2) => {
          if (item2.project0members.isMember(id2))
            return false;
          item2.project0members.roster[id2] = {
            memberCardID: id2,
            memberName: ecs.root[id2].memberCard0.name || "- No name -",
            roles: [],
            effects: []
          };
          item2.saveLocal.save();
          item2.saveRemote.save();
          return true;
        },
        banish: (item2) => (id2) => {
          if (!item2.project0members.isMember(id2))
            return false;
          delete item2.project0members.roster[id2];
          item2.saveLocal.save();
          item2.saveRemote.save();
          return true;
        },
        hasRole: (item2) => (id2, role) => {
          if (!item2.project0members.isMember(id2))
            return false;
          return !!~item2.project0members.roster[id2].roles.indexOf(role);
        },
        toggleRole: (item2) => async (id2, role) => {
          if (!item2.project0members.isMember(id2))
            return false;
          if (item2.project0members.hasRole(id2, role)) {
            const { code, details } = await core.yehat.ex({ cmd: "project0.removeRole", projectID: item2.id, memberCardID: id2, role });
            if (code === "ok") {
              const index = item2.project0members.roster[id2].roles.indexOf(role);
              item2.project0members.roster[id2].roles.splice(index, 1);
            } else {
              return details;
            }
          } else {
            const { code, details } = await core.yehat.ex({ cmd: "project0.addRole", projectID: item2.id, memberCardID: id2, role });
            if (code === "ok") {
              item2.project0members.roster[id2].roles.push(role);
            } else {
              return details;
            }
          }
          item2.saveLocal.save();
          return true;
        }
      }, { details: "Project Members" });
      ecs.declareType("Project", [
        ecs.compo.project0(),
        ecs.compo.project0status(),
        ecs.compo.project0members(),
        ecs.compo.fav0(),
        ecs.compo.meta({ type: "Project", name: "A Project" }),
        ecs.compo.connections({
          owner: null
        }),
        ecs.compo.dialog0(),
        ecs.compo.saveLocal({
          self: true,
          type: "Project",
          project0: true,
          project0members: true,
          owner0: true,
          connections: true,
          saveLocal: true,
          tier: true,
          fav0: true
        }),
        ecs.compo.saveRemote({
          project0: true,
          project0members: true
        }),
        ecs.compo.tier({ base: "proto" }),
        ecs.compo.item({
          baseIcon: project_00_default,
          iconClasses: { "bg-contain": true },
          baseComponent: "IProject",
          inventoryComponent: "ProjectCard0"
        }),
        ecs.compo.grid0user({ defaultRecord: { size: [16, 16] } })
      ], { details: "Project" });
    }
  });

  // yehat/assets/cat0-std-00.png
  var cat0_std_00_default;
  var init_cat0_std_00 = __esm({
    "yehat/assets/cat0-std-00.png"() {
      cat0_std_00_default = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAhtJREFUaIHt2j1KA0EAhuHPxQtYWWhjKzhHECFnsEgv4kmsbfUCW3gCCyHkBhI2oNgZQ4yFWMdlLeSTMCTZ+d8ZMm8lJK77MLOzk6xALpfL5XK5XKB2uj4Bm4QQDQDM6woAMKvqVk/h+Zy8JIRohBDNvK4wrytcD66Uf3fX43k5Tx5RQstyqHyMJMAuoCxqsEsoixKsA+33TwEAo9ux0rGjAptAdYsCbAMty6EWvlOw7jW6Dhb9Km0yonxNd0TlgoJtr1Gb1ZkFAdtMXdsRlfMKtr2PuhhROS9g0xFdNZouRxdwDCa0KArMFiPjVXf59SinNKF7+4cAgO/PKYDNU1JefU0WqeB7aRmqmoyVf24r+F7aFBpDWmAXUJPrcd2I3p0PAACX92fKx1IChxhRLlBs07QldPzyqv13WsFCiEYXOluMtN4vbzTWZQNlTm9Lz9MHAHobjFULmJwLKHMC1oEu31flaSznEsqswCYjqvI+H1BmBDaFtuUTypTAXx+T/30xkCaUKYF/jt5w0jtWWmB0CgllWlPa9ce1kFCW5KMWm7YOHMXXtKbdPF0AUP8SHkgULENVHpOypMA2UJYE2AWURQ12CWVRgn1AWVRgn1AWBTgElHUKDgllnYJDQlkn4C6gLCi4SygLAo4ByryCY4IyL+AYocwpOGYocwJOAcqswClBmTL4/XGCg97fM6YUoUzphPm/ySxF6Nb2C+PSnLjRkUNKAAAAAElFTkSuQmCC";
    }
  });

  // yehat/basics0/cats.js
  var import_pako;
  var init_cats = __esm({
    "yehat/basics0/cats.js"() {
      import_pako = __toModule(require_pako());
      init_cat0_std_00();
      ecs.define("cat0", {
        name: ""
      }, { details: "Category settings" });
      ecs.declareType("Cat0", [
        ecs.compo.cat0(),
        ecs.compo.meta({ name: "Category", type: "Cat0" }),
        ecs.compo.lang({
          en: {
            name: ""
          },
          ru: {
            name: ""
          }
        }),
        ecs.compo.located(),
        ecs.compo.connections({
          project: null,
          webapp: null
        }),
        ecs.compo.saveLocal({
          self: true,
          type: "Cat0",
          cat0: true,
          lang: true,
          located: true,
          connections: true
        }),
        ecs.compo.saveRemote({
          cat0: true,
          lang: true,
          located: true,
          connections: true
        }),
        ecs.compo.dialog0(),
        ecs.compo.item({
          baseComponent: "ICat0",
          baseIcon: cat0_std_00_default
        }),
        ecs.compo.tier({ base: "standard" })
      ]);
      ecs.declareType("CatDia0", [
        ecs.compo.meta({ name: "Category Dia Lang", type: "CatDia0" }),
        ecs.compo.lang({
          en: {
            title: "Category",
            noName: "- No Name -"
          },
          ru: {
            title: "\u041A\u0430\u0442\u0435\u0433\u043E\u0440\u0438\u044F",
            noName: "- \u041D\u0435\u0442 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u044F -"
          }
        })
      ]);
      ecs.create("CatDia0", { id: "SkjCl8KvOsKTQMKiwr9hGg" });
    }
  });

  // yehat/khon/index.js
  var import_pako, task0, work0, Session0, makeSession0;
  var init_khon = __esm({
    "yehat/khon/index.js"() {
      import_pako = __toModule(require_pako());
      task0 = ecs.define("task0", {
        details: "",
        remarks: "",
        head: null,
        sysop: null,
        executives: [],
        priority: 1
      }, { details: "A task, a wish, a to-do item." });
      work0 = ecs.define("work0", {
        dtStart: null,
        dtEnd: null,
        breaks: [],
        details: "",
        status: "planned"
      });
      Session0 = ecs.define("session0", {
        users: [],
        tasks: [],
        work: []
      });
      makeSession0 = ({ id: id2, users, tasks = [], work = [] }) => {
        return loadEntity([
          ecs.compo.meta({
            type: "Session0",
            name: "Katka"
          }),
          Session0({ users, tasks, work }),
          ecs.compo.timer(),
          ecs.compo.saveLocal({
            session0: true,
            timer0: true
          })
        ])({ id: id2 });
      };
      ecs.declareType("Session0", makeSession0, { details: "A KATKA session." });
      ecs.define("member0", {
        memberID: null,
        name: "",
        status: "",
        level: 0
      }, { details: "A basic member record, counterpart to user0 on the server side." });
      ecs.declareType("Member", [
        ecs.compo.member0(),
        ecs.compo.meta({ type: "Member", name: "A Member" }),
        ecs.compo.saveLocal({
          member0: true
        })
      ], { details: "A basic member record." });
    }
  });

  // yehat/basics0/camera0.js
  var import_pako;
  var init_camera0 = __esm({
    "yehat/basics0/camera0.js"() {
      import_pako = __toModule(require_pako());
      ecs.define("camera0", {
        x: 0,
        y: 0,
        px: 0,
        py: 0,
        cx: 0,
        cy: 0,
        startMove: 0,
        dragged: false,
        start: [null, null],
        point: [null, null],
        speed: 4
      }, { details: "ZIITable4 Camera rebranded." });
      ecs.define("camera", {
        x: 0,
        y: 0,
        px: 0,
        py: 0,
        cx: 0,
        cy: 0,
        startMove: 0,
        dragged: false,
        start: [null, null],
        point: [null, null],
        speed: 4
      }, { details: "ZIITable4 Standard Camera." });
    }
  });

  // yehat/basics0/mouse0.js
  var import_pako;
  var init_mouse0 = __esm({
    "yehat/basics0/mouse0.js"() {
      import_pako = __toModule(require_pako());
      init_ecs();
      ecs2.define("mouse0", {
        pos: [0, 0],
        isoPos0: [0, 0, 0],
        btns: [false, false, false],
        handlers: null,
        init: (item2) => () => {
          const handlers2 = {
            mouseMove: ({ clientX, clientY }) => {
              item2.mouse0.pos = [clientX, clientY];
            }
          };
          document.addEventListener("mousemove", handlers2.mouseMove);
          item2.mouse0.handlers = handlers2;
        },
        dispose: (item2) => () => {
          document.removeEventListener("mousemove", item2.mouse0.handlers.mouseMove);
        }
      });
      ecs2.declareType("Mouse", [
        ecs2.compo.mouse0(),
        ecs2.compo.connections({
          picked: null
        }),
        ecs2.compo.meta({ name: "Mouse", type: "Controller" })
      ], { details: "Mouse controller (?)" });
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/env.js
  function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
  }
  function getTarget() {
    return typeof navigator !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  }
  var import_pako;
  var init_env = __esm({
    "node_modules/@vue/devtools-api/lib/esm/env.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/const.js
  var import_pako, HOOK_SETUP;
  var init_const = __esm({
    "node_modules/@vue/devtools-api/lib/esm/const.js"() {
      import_pako = __toModule(require_pako());
      HOOK_SETUP = "devtools-plugin:setup";
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/api.js
  var import_pako;
  var init_api = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/api.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/app.js
  var import_pako;
  var init_app = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/app.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/component.js
  var import_pako;
  var init_component = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/component.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/context.js
  var import_pako;
  var init_context = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/context.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/hooks.js
  var import_pako;
  var init_hooks = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/hooks.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/util.js
  var import_pako;
  var init_util = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/util.js"() {
      import_pako = __toModule(require_pako());
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/api/index.js
  var import_pako;
  var init_api2 = __esm({
    "node_modules/@vue/devtools-api/lib/esm/api/index.js"() {
      import_pako = __toModule(require_pako());
      init_api();
      init_app();
      init_component();
      init_context();
      init_hooks();
      init_util();
    }
  });

  // node_modules/@vue/devtools-api/lib/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    setupDevtoolsPlugin: () => setupDevtoolsPlugin
  });
  function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const hook = getDevtoolsGlobalHook();
    if (hook) {
      hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    } else {
      const target2 = getTarget();
      const list = target2.__VUE_DEVTOOLS_PLUGINS__ = target2.__VUE_DEVTOOLS_PLUGINS__ || [];
      list.push({
        pluginDescriptor,
        setupFn
      });
    }
  }
  var import_pako;
  var init_esm = __esm({
    "node_modules/@vue/devtools-api/lib/esm/index.js"() {
      import_pako = __toModule(require_pako());
      init_env();
      init_const();
      init_api2();
    }
  });

  // node_modules/vue-router/dist/vue-router.cjs.js
  var require_vue_router_cjs = __commonJS({
    "node_modules/vue-router/dist/vue-router.cjs.js"(exports) {
      var import_pako = __toModule(require_pako());
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var vue = (init_vue_esm_bundler(), vue_esm_bundler_exports);
      var devtoolsApi = (init_esm(), esm_exports);
      var hasSymbol = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
      var PolySymbol = (name) => hasSymbol ? Symbol("[vue-router]: " + name) : "[vue-router]: " + name;
      var matchedRouteKey = /* @__PURE__ */ PolySymbol("router view location matched");
      var viewDepthKey = /* @__PURE__ */ PolySymbol("router view depth");
      var routerKey = /* @__PURE__ */ PolySymbol("router");
      var routeLocationKey = /* @__PURE__ */ PolySymbol("route location");
      var routerViewLocationKey = /* @__PURE__ */ PolySymbol("router view location");
      var isBrowser = typeof window !== "undefined";
      function isESModule(obj) {
        return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === "Module";
      }
      var assign = Object.assign;
      function applyToParams(fn, params) {
        const newParams = {};
        for (const key2 in params) {
          const value2 = params[key2];
          newParams[key2] = Array.isArray(value2) ? value2.map(fn) : fn(value2);
        }
        return newParams;
      }
      var noop2 = () => {
      };
      function warn3(msg) {
        const args = Array.from(arguments).slice(1);
        console.warn.apply(console, ["[Vue Router warn]: " + msg].concat(args));
      }
      var TRAILING_SLASH_RE = /\/$/;
      var removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, "");
      function parseURL(parseQuery2, location2, currentLocation = "/") {
        let path, query = {}, searchString = "", hash = "";
        const searchPos = location2.indexOf("?");
        const hashPos = location2.indexOf("#", searchPos > -1 ? searchPos : 0);
        if (searchPos > -1) {
          path = location2.slice(0, searchPos);
          searchString = location2.slice(searchPos + 1, hashPos > -1 ? hashPos : location2.length);
          query = parseQuery2(searchString);
        }
        if (hashPos > -1) {
          path = path || location2.slice(0, hashPos);
          hash = location2.slice(hashPos, location2.length);
        }
        path = resolveRelativePath(path != null ? path : location2, currentLocation);
        return {
          fullPath: path + (searchString && "?") + searchString + hash,
          path,
          query,
          hash
        };
      }
      function stringifyURL(stringifyQuery2, location2) {
        const query = location2.query ? stringifyQuery2(location2.query) : "";
        return location2.path + (query && "?") + query + (location2.hash || "");
      }
      function stripBase(pathname, base) {
        if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))
          return pathname;
        return pathname.slice(base.length) || "/";
      }
      function isSameRouteLocation(stringifyQuery2, a, b) {
        const aLastIndex = a.matched.length - 1;
        const bLastIndex = b.matched.length - 1;
        return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord2(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery2(a.query) === stringifyQuery2(b.query) && a.hash === b.hash;
      }
      function isSameRouteRecord2(a, b) {
        return (a.aliasOf || a) === (b.aliasOf || b);
      }
      function isSameRouteLocationParams(a, b) {
        if (Object.keys(a).length !== Object.keys(b).length)
          return false;
        for (const key2 in a) {
          if (!isSameRouteLocationParamsValue(a[key2], b[key2]))
            return false;
        }
        return true;
      }
      function isSameRouteLocationParamsValue(a, b) {
        return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;
      }
      function isEquivalentArray(a, b) {
        return Array.isArray(b) ? a.length === b.length && a.every((value2, i) => value2 === b[i]) : a.length === 1 && a[0] === b;
      }
      function resolveRelativePath(to, from) {
        if (to.startsWith("/"))
          return to;
        if (!from.startsWith("/")) {
          warn3(`Cannot resolve a relative location without an absolute path. Trying to resolve "${to}" from "${from}". It should look like "/${from}".`);
          return to;
        }
        if (!to)
          return from;
        const fromSegments = from.split("/");
        const toSegments = to.split("/");
        let position2 = fromSegments.length - 1;
        let toPosition;
        let segment;
        for (toPosition = 0; toPosition < toSegments.length; toPosition++) {
          segment = toSegments[toPosition];
          if (position2 === 1 || segment === ".")
            continue;
          if (segment === "..")
            position2--;
          else
            break;
        }
        return fromSegments.slice(0, position2).join("/") + "/" + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join("/");
      }
      var NavigationType;
      (function(NavigationType2) {
        NavigationType2["pop"] = "pop";
        NavigationType2["push"] = "push";
      })(NavigationType || (NavigationType = {}));
      var NavigationDirection;
      (function(NavigationDirection2) {
        NavigationDirection2["back"] = "back";
        NavigationDirection2["forward"] = "forward";
        NavigationDirection2["unknown"] = "";
      })(NavigationDirection || (NavigationDirection = {}));
      var START = "";
      function normalizeBase(base) {
        if (!base) {
          if (isBrowser) {
            const baseEl = document.querySelector("base");
            base = baseEl && baseEl.getAttribute("href") || "/";
            base = base.replace(/^\w+:\/\/[^\/]+/, "");
          } else {
            base = "/";
          }
        }
        if (base[0] !== "/" && base[0] !== "#")
          base = "/" + base;
        return removeTrailingSlash(base);
      }
      var BEFORE_HASH_RE = /^[^#]+#/;
      function createHref(base, location2) {
        return base.replace(BEFORE_HASH_RE, "#") + location2;
      }
      function getElementPosition(el, offset2) {
        const docRect = document.documentElement.getBoundingClientRect();
        const elRect = el.getBoundingClientRect();
        return {
          behavior: offset2.behavior,
          left: elRect.left - docRect.left - (offset2.left || 0),
          top: elRect.top - docRect.top - (offset2.top || 0)
        };
      }
      var computeScrollPosition = () => ({
        left: window.pageXOffset,
        top: window.pageYOffset
      });
      function scrollToPosition(position2) {
        let scrollToOptions;
        if ("el" in position2) {
          const positionEl = position2.el;
          const isIdSelector = typeof positionEl === "string" && positionEl.startsWith("#");
          if (typeof position2.el === "string") {
            if (!isIdSelector || !document.getElementById(position2.el.slice(1))) {
              try {
                const foundEl = document.querySelector(position2.el);
                if (isIdSelector && foundEl) {
                  warn3(`The selector "${position2.el}" should be passed as "el: document.querySelector('${position2.el}')" because it starts with "#".`);
                  return;
                }
              } catch (err) {
                warn3(`The selector "${position2.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
                return;
              }
            }
          }
          const el = typeof positionEl === "string" ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;
          if (!el) {
            warn3(`Couldn't find element using selector "${position2.el}" returned by scrollBehavior.`);
            return;
          }
          scrollToOptions = getElementPosition(el, position2);
        } else {
          scrollToOptions = position2;
        }
        if ("scrollBehavior" in document.documentElement.style)
          window.scrollTo(scrollToOptions);
        else {
          window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);
        }
      }
      function getScrollKey(path, delta) {
        const position2 = history.state ? history.state.position - delta : -1;
        return position2 + path;
      }
      var scrollPositions = new Map();
      function saveScrollPosition(key2, scrollPosition) {
        scrollPositions.set(key2, scrollPosition);
      }
      function getSavedScrollPosition(key2) {
        const scroll2 = scrollPositions.get(key2);
        scrollPositions.delete(key2);
        return scroll2;
      }
      var createBaseLocation = () => location.protocol + "//" + location.host;
      function createCurrentLocation(base, location2) {
        const { pathname, search, hash } = location2;
        const hashPos = base.indexOf("#");
        if (hashPos > -1) {
          let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;
          let pathFromHash = hash.slice(slicePos);
          if (pathFromHash[0] !== "/")
            pathFromHash = "/" + pathFromHash;
          return stripBase(pathFromHash, "");
        }
        const path = stripBase(pathname, base);
        return path + search + hash;
      }
      function useHistoryListeners(base, historyState, currentLocation, replace) {
        let listeners = [];
        let teardowns = [];
        let pauseState = null;
        const popStateHandler = ({ state }) => {
          const to = createCurrentLocation(base, location);
          const from = currentLocation.value;
          const fromState = historyState.value;
          let delta = 0;
          if (state) {
            currentLocation.value = to;
            historyState.value = state;
            if (pauseState && pauseState === from) {
              pauseState = null;
              return;
            }
            delta = fromState ? state.position - fromState.position : 0;
          } else {
            replace(to);
          }
          listeners.forEach((listener) => {
            listener(currentLocation.value, from, {
              delta,
              type: NavigationType.pop,
              direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown
            });
          });
        };
        function pauseListeners() {
          pauseState = currentLocation.value;
        }
        function listen(callback) {
          listeners.push(callback);
          const teardown = () => {
            const index = listeners.indexOf(callback);
            if (index > -1)
              listeners.splice(index, 1);
          };
          teardowns.push(teardown);
          return teardown;
        }
        function beforeUnloadListener() {
          const { history: history2 } = window;
          if (!history2.state)
            return;
          history2.replaceState(assign({}, history2.state, { scroll: computeScrollPosition() }), "");
        }
        function destroy2() {
          for (const teardown of teardowns)
            teardown();
          teardowns = [];
          window.removeEventListener("popstate", popStateHandler);
          window.removeEventListener("beforeunload", beforeUnloadListener);
        }
        window.addEventListener("popstate", popStateHandler);
        window.addEventListener("beforeunload", beforeUnloadListener);
        return {
          pauseListeners,
          listen,
          destroy: destroy2
        };
      }
      function buildState(back, current, forward, replaced = false, computeScroll = false) {
        return {
          back,
          current,
          forward,
          replaced,
          position: window.history.length,
          scroll: computeScroll ? computeScrollPosition() : null
        };
      }
      function useHistoryStateNavigation(base) {
        const { history: history2, location: location2 } = window;
        const currentLocation = {
          value: createCurrentLocation(base, location2)
        };
        const historyState = { value: history2.state };
        if (!historyState.value) {
          changeLocation(currentLocation.value, {
            back: null,
            current: currentLocation.value,
            forward: null,
            position: history2.length - 1,
            replaced: true,
            scroll: null
          }, true);
        }
        function changeLocation(to, state, replace2) {
          const hashIndex = base.indexOf("#");
          const url = hashIndex > -1 ? (location2.host && document.querySelector("base") ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;
          try {
            history2[replace2 ? "replaceState" : "pushState"](state, "", url);
            historyState.value = state;
          } catch (err) {
            {
              warn3("Error with push/replace State", err);
            }
            location2[replace2 ? "replace" : "assign"](url);
          }
        }
        function replace(to, data) {
          const state = assign({}, history2.state, buildState(historyState.value.back, to, historyState.value.forward, true), data, { position: historyState.value.position });
          changeLocation(to, state, true);
          currentLocation.value = to;
        }
        function push(to, data) {
          const currentState = assign({}, historyState.value, history2.state, {
            forward: to,
            scroll: computeScrollPosition()
          });
          if (!history2.state) {
            warn3(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);
          }
          changeLocation(currentState.current, currentState, true);
          const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);
          changeLocation(to, state, false);
          currentLocation.value = to;
        }
        return {
          location: currentLocation,
          state: historyState,
          push,
          replace
        };
      }
      function createWebHistory2(base) {
        base = normalizeBase(base);
        const historyNavigation = useHistoryStateNavigation(base);
        const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);
        function go(delta, triggerListeners = true) {
          if (!triggerListeners)
            historyListeners.pauseListeners();
          history.go(delta);
        }
        const routerHistory = assign({
          location: "",
          base,
          go,
          createHref: createHref.bind(null, base)
        }, historyNavigation, historyListeners);
        Object.defineProperty(routerHistory, "location", {
          enumerable: true,
          get: () => historyNavigation.location.value
        });
        Object.defineProperty(routerHistory, "state", {
          enumerable: true,
          get: () => historyNavigation.state.value
        });
        return routerHistory;
      }
      function createMemoryHistory(base = "") {
        let listeners = [];
        let queue3 = [START];
        let position2 = 0;
        function setLocation(location2) {
          position2++;
          if (position2 === queue3.length) {
            queue3.push(location2);
          } else {
            queue3.splice(position2);
            queue3.push(location2);
          }
        }
        function triggerListeners(to, from, { direction, delta }) {
          const info = {
            direction,
            delta,
            type: NavigationType.pop
          };
          for (const callback of listeners) {
            callback(to, from, info);
          }
        }
        const routerHistory = {
          location: START,
          state: {},
          base,
          createHref: createHref.bind(null, base),
          replace(to) {
            queue3.splice(position2--, 1);
            setLocation(to);
          },
          push(to, data) {
            setLocation(to);
          },
          listen(callback) {
            listeners.push(callback);
            return () => {
              const index = listeners.indexOf(callback);
              if (index > -1)
                listeners.splice(index, 1);
            };
          },
          destroy() {
            listeners = [];
            queue3 = [START];
            position2 = 0;
          },
          go(delta, shouldTrigger = true) {
            const from = this.location;
            const direction = delta < 0 ? NavigationDirection.back : NavigationDirection.forward;
            position2 = Math.max(0, Math.min(position2 + delta, queue3.length - 1));
            if (shouldTrigger) {
              triggerListeners(this.location, from, {
                direction,
                delta
              });
            }
          }
        };
        Object.defineProperty(routerHistory, "location", {
          enumerable: true,
          get: () => queue3[position2]
        });
        return routerHistory;
      }
      function createWebHashHistory(base) {
        base = location.host ? base || location.pathname + location.search : "";
        if (!base.includes("#"))
          base += "#";
        if (!base.endsWith("#/") && !base.endsWith("#")) {
          warn3(`A hash base must end with a "#":
"${base}" should be "${base.replace(/#.*$/, "#")}".`);
        }
        return createWebHistory2(base);
      }
      function isRouteLocation(route) {
        return typeof route === "string" || route && typeof route === "object";
      }
      function isRouteName(name) {
        return typeof name === "string" || typeof name === "symbol";
      }
      var START_LOCATION_NORMALIZED = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
      };
      var NavigationFailureSymbol = /* @__PURE__ */ PolySymbol("navigation failure");
      exports.NavigationFailureType = void 0;
      (function(NavigationFailureType) {
        NavigationFailureType[NavigationFailureType["aborted"] = 4] = "aborted";
        NavigationFailureType[NavigationFailureType["cancelled"] = 8] = "cancelled";
        NavigationFailureType[NavigationFailureType["duplicated"] = 16] = "duplicated";
      })(exports.NavigationFailureType || (exports.NavigationFailureType = {}));
      var ErrorTypeMessages = {
        [1]({ location: location2, currentLocation }) {
          return `No match for
 ${JSON.stringify(location2)}${currentLocation ? "\nwhile being at\n" + JSON.stringify(currentLocation) : ""}`;
        },
        [2]({ from, to }) {
          return `Redirected from "${from.fullPath}" to "${stringifyRoute(to)}" via a navigation guard.`;
        },
        [4]({ from, to }) {
          return `Navigation aborted from "${from.fullPath}" to "${to.fullPath}" via a navigation guard.`;
        },
        [8]({ from, to }) {
          return `Navigation cancelled from "${from.fullPath}" to "${to.fullPath}" with a new navigation.`;
        },
        [16]({ from, to }) {
          return `Avoided redundant navigation to current location: "${from.fullPath}".`;
        }
      };
      function createRouterError(type2, params) {
        {
          return assign(new Error(ErrorTypeMessages[type2](params)), {
            type: type2,
            [NavigationFailureSymbol]: true
          }, params);
        }
      }
      function isNavigationFailure(error, type2) {
        return error instanceof Error && NavigationFailureSymbol in error && (type2 == null || !!(error.type & type2));
      }
      var propertiesToLog = ["params", "query", "hash"];
      function stringifyRoute(to) {
        if (typeof to === "string")
          return to;
        if ("path" in to)
          return to.path;
        const location2 = {};
        for (const key2 of propertiesToLog) {
          if (key2 in to)
            location2[key2] = to[key2];
        }
        return JSON.stringify(location2, null, 2);
      }
      var BASE_PARAM_PATTERN = "[^/]+?";
      var BASE_PATH_PARSER_OPTIONS = {
        sensitive: false,
        strict: false,
        start: true,
        end: true
      };
      var REGEX_CHARS_RE = /[.+*?^${}()[\]/\\]/g;
      function tokensToParser(segments, extraOptions) {
        const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);
        const score = [];
        let pattern = options.start ? "^" : "";
        const keys = [];
        for (const segment of segments) {
          const segmentScores = segment.length ? [] : [90];
          if (options.strict && !segment.length)
            pattern += "/";
          for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {
            const token2 = segment[tokenIndex];
            let subSegmentScore = 40 + (options.sensitive ? 0.25 : 0);
            if (token2.type === 0) {
              if (!tokenIndex)
                pattern += "/";
              pattern += token2.value.replace(REGEX_CHARS_RE, "\\$&");
              subSegmentScore += 40;
            } else if (token2.type === 1) {
              const { value: value2, repeatable, optional, regexp } = token2;
              keys.push({
                name: value2,
                repeatable,
                optional
              });
              const re2 = regexp ? regexp : BASE_PARAM_PATTERN;
              if (re2 !== BASE_PARAM_PATTERN) {
                subSegmentScore += 10;
                try {
                  new RegExp(`(${re2})`);
                } catch (err) {
                  throw new Error(`Invalid custom RegExp for param "${value2}" (${re2}): ` + err.message);
                }
              }
              let subPattern = repeatable ? `((?:${re2})(?:/(?:${re2}))*)` : `(${re2})`;
              if (!tokenIndex)
                subPattern = optional && segment.length < 2 ? `(?:/${subPattern})` : "/" + subPattern;
              if (optional)
                subPattern += "?";
              pattern += subPattern;
              subSegmentScore += 20;
              if (optional)
                subSegmentScore += -8;
              if (repeatable)
                subSegmentScore += -20;
              if (re2 === ".*")
                subSegmentScore += -50;
            }
            segmentScores.push(subSegmentScore);
          }
          score.push(segmentScores);
        }
        if (options.strict && options.end) {
          const i = score.length - 1;
          score[i][score[i].length - 1] += 0.7000000000000001;
        }
        if (!options.strict)
          pattern += "/?";
        if (options.end)
          pattern += "$";
        else if (options.strict)
          pattern += "(?:/|$)";
        const re = new RegExp(pattern, options.sensitive ? "" : "i");
        function parse2(path) {
          const match = path.match(re);
          const params = {};
          if (!match)
            return null;
          for (let i = 1; i < match.length; i++) {
            const value2 = match[i] || "";
            const key2 = keys[i - 1];
            params[key2.name] = value2 && key2.repeatable ? value2.split("/") : value2;
          }
          return params;
        }
        function stringify(params) {
          let path = "";
          let avoidDuplicatedSlash = false;
          for (const segment of segments) {
            if (!avoidDuplicatedSlash || !path.endsWith("/"))
              path += "/";
            avoidDuplicatedSlash = false;
            for (const token2 of segment) {
              if (token2.type === 0) {
                path += token2.value;
              } else if (token2.type === 1) {
                const { value: value2, repeatable, optional } = token2;
                const param = value2 in params ? params[value2] : "";
                if (Array.isArray(param) && !repeatable)
                  throw new Error(`Provided param "${value2}" is an array but it is not repeatable (* or + modifiers)`);
                const text = Array.isArray(param) ? param.join("/") : param;
                if (!text) {
                  if (optional) {
                    if (segment.length < 2) {
                      if (path.endsWith("/"))
                        path = path.slice(0, -1);
                      else
                        avoidDuplicatedSlash = true;
                    }
                  } else
                    throw new Error(`Missing required param "${value2}"`);
                }
                path += text;
              }
            }
          }
          return path;
        }
        return {
          re,
          score,
          keys,
          parse: parse2,
          stringify
        };
      }
      function compareScoreArray(a, b) {
        let i = 0;
        while (i < a.length && i < b.length) {
          const diff2 = b[i] - a[i];
          if (diff2)
            return diff2;
          i++;
        }
        if (a.length < b.length) {
          return a.length === 1 && a[0] === 40 + 40 ? -1 : 1;
        } else if (a.length > b.length) {
          return b.length === 1 && b[0] === 40 + 40 ? 1 : -1;
        }
        return 0;
      }
      function comparePathParserScore(a, b) {
        let i = 0;
        const aScore = a.score;
        const bScore = b.score;
        while (i < aScore.length && i < bScore.length) {
          const comp = compareScoreArray(aScore[i], bScore[i]);
          if (comp)
            return comp;
          i++;
        }
        return bScore.length - aScore.length;
      }
      var ROOT_TOKEN = {
        type: 0,
        value: ""
      };
      var VALID_PARAM_RE = /[a-zA-Z0-9_]/;
      function tokenizePath(path) {
        if (!path)
          return [[]];
        if (path === "/")
          return [[ROOT_TOKEN]];
        if (!path.startsWith("/")) {
          throw new Error(`Route paths should start with a "/": "${path}" should be "/${path}".`);
        }
        function crash(message) {
          throw new Error(`ERR (${state})/"${buffer}": ${message}`);
        }
        let state = 0;
        let previousState = state;
        const tokens = [];
        let segment;
        function finalizeSegment() {
          if (segment)
            tokens.push(segment);
          segment = [];
        }
        let i = 0;
        let char;
        let buffer = "";
        let customRe = "";
        function consumeBuffer() {
          if (!buffer)
            return;
          if (state === 0) {
            segment.push({
              type: 0,
              value: buffer
            });
          } else if (state === 1 || state === 2 || state === 3) {
            if (segment.length > 1 && (char === "*" || char === "+"))
              crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);
            segment.push({
              type: 1,
              value: buffer,
              regexp: customRe,
              repeatable: char === "*" || char === "+",
              optional: char === "*" || char === "?"
            });
          } else {
            crash("Invalid state to consume buffer");
          }
          buffer = "";
        }
        function addCharToBuffer() {
          buffer += char;
        }
        while (i < path.length) {
          char = path[i++];
          if (char === "\\" && state !== 2) {
            previousState = state;
            state = 4;
            continue;
          }
          switch (state) {
            case 0:
              if (char === "/") {
                if (buffer) {
                  consumeBuffer();
                }
                finalizeSegment();
              } else if (char === ":") {
                consumeBuffer();
                state = 1;
              } else {
                addCharToBuffer();
              }
              break;
            case 4:
              addCharToBuffer();
              state = previousState;
              break;
            case 1:
              if (char === "(") {
                state = 2;
              } else if (VALID_PARAM_RE.test(char)) {
                addCharToBuffer();
              } else {
                consumeBuffer();
                state = 0;
                if (char !== "*" && char !== "?" && char !== "+")
                  i--;
              }
              break;
            case 2:
              if (char === ")") {
                if (customRe[customRe.length - 1] == "\\")
                  customRe = customRe.slice(0, -1) + char;
                else
                  state = 3;
              } else {
                customRe += char;
              }
              break;
            case 3:
              consumeBuffer();
              state = 0;
              if (char !== "*" && char !== "?" && char !== "+")
                i--;
              customRe = "";
              break;
            default:
              crash("Unknown state");
              break;
          }
        }
        if (state === 2)
          crash(`Unfinished custom RegExp for param "${buffer}"`);
        consumeBuffer();
        finalizeSegment();
        return tokens;
      }
      function createRouteRecordMatcher(record, parent, options) {
        const parser = tokensToParser(tokenizePath(record.path), options);
        {
          const existingKeys = new Set();
          for (const key2 of parser.keys) {
            if (existingKeys.has(key2.name))
              warn3(`Found duplicated params with name "${key2.name}" for path "${record.path}". Only the last one will be available on "$route.params".`);
            existingKeys.add(key2.name);
          }
        }
        const matcher = assign(parser, {
          record,
          parent,
          children: [],
          alias: []
        });
        if (parent) {
          if (!matcher.record.aliasOf === !parent.record.aliasOf)
            parent.children.push(matcher);
        }
        return matcher;
      }
      function createRouterMatcher(routes2, globalOptions) {
        const matchers = [];
        const matcherMap = new Map();
        globalOptions = mergeOptions2({ strict: false, end: true, sensitive: false }, globalOptions);
        function getRecordMatcher(name) {
          return matcherMap.get(name);
        }
        function addRoute(record, parent, originalRecord) {
          const isRootAdd = !originalRecord;
          const mainNormalizedRecord = normalizeRouteRecord(record);
          mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;
          const options = mergeOptions2(globalOptions, record);
          const normalizedRecords = [
            mainNormalizedRecord
          ];
          if ("alias" in record) {
            const aliases = typeof record.alias === "string" ? [record.alias] : record.alias;
            for (const alias of aliases) {
              normalizedRecords.push(assign({}, mainNormalizedRecord, {
                components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,
                path: alias,
                aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord
              }));
            }
          }
          let matcher;
          let originalMatcher;
          for (const normalizedRecord of normalizedRecords) {
            const { path } = normalizedRecord;
            if (parent && path[0] !== "/") {
              const parentPath = parent.record.path;
              const connectingSlash = parentPath[parentPath.length - 1] === "/" ? "" : "/";
              normalizedRecord.path = parent.record.path + (path && connectingSlash + path);
            }
            if (normalizedRecord.path === "*") {
              throw new Error('Catch all routes ("*") must now be defined using a param with a custom regexp.\nSee more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');
            }
            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);
            if (parent && path[0] === "/")
              checkMissingParamsInAbsolutePath(matcher, parent);
            if (originalRecord) {
              originalRecord.alias.push(matcher);
              {
                checkSameParams(originalRecord, matcher);
              }
            } else {
              originalMatcher = originalMatcher || matcher;
              if (originalMatcher !== matcher)
                originalMatcher.alias.push(matcher);
              if (isRootAdd && record.name && !isAliasRecord(matcher))
                removeRoute(record.name);
            }
            if ("children" in mainNormalizedRecord) {
              const children = mainNormalizedRecord.children;
              for (let i = 0; i < children.length; i++) {
                addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);
              }
            }
            originalRecord = originalRecord || matcher;
            insertMatcher(matcher);
          }
          return originalMatcher ? () => {
            removeRoute(originalMatcher);
          } : noop2;
        }
        function removeRoute(matcherRef) {
          if (isRouteName(matcherRef)) {
            const matcher = matcherMap.get(matcherRef);
            if (matcher) {
              matcherMap.delete(matcherRef);
              matchers.splice(matchers.indexOf(matcher), 1);
              matcher.children.forEach(removeRoute);
              matcher.alias.forEach(removeRoute);
            }
          } else {
            const index = matchers.indexOf(matcherRef);
            if (index > -1) {
              matchers.splice(index, 1);
              if (matcherRef.record.name)
                matcherMap.delete(matcherRef.record.name);
              matcherRef.children.forEach(removeRoute);
              matcherRef.alias.forEach(removeRoute);
            }
          }
        }
        function getRoutes() {
          return matchers;
        }
        function insertMatcher(matcher) {
          let i = 0;
          while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0)
            i++;
          matchers.splice(i, 0, matcher);
          if (matcher.record.name && !isAliasRecord(matcher))
            matcherMap.set(matcher.record.name, matcher);
        }
        function resolve2(location2, currentLocation) {
          let matcher;
          let params = {};
          let path;
          let name;
          if ("name" in location2 && location2.name) {
            matcher = matcherMap.get(location2.name);
            if (!matcher)
              throw createRouterError(1, {
                location: location2
              });
            name = matcher.record.name;
            params = assign(paramsFromLocation(currentLocation.params, matcher.keys.filter((k2) => !k2.optional).map((k2) => k2.name)), location2.params);
            path = matcher.stringify(params);
          } else if ("path" in location2) {
            path = location2.path;
            if (!path.startsWith("/")) {
              warn3(`The Matcher cannot resolve relative paths but received "${path}". Unless you directly called \`matcher.resolve("${path}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/vue-router-next.`);
            }
            matcher = matchers.find((m) => m.re.test(path));
            if (matcher) {
              params = matcher.parse(path);
              name = matcher.record.name;
            }
          } else {
            matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find((m) => m.re.test(currentLocation.path));
            if (!matcher)
              throw createRouterError(1, {
                location: location2,
                currentLocation
              });
            name = matcher.record.name;
            params = assign({}, currentLocation.params, location2.params);
            path = matcher.stringify(params);
          }
          const matched = [];
          let parentMatcher = matcher;
          while (parentMatcher) {
            matched.unshift(parentMatcher.record);
            parentMatcher = parentMatcher.parent;
          }
          return {
            name,
            path,
            params,
            matched,
            meta: mergeMetaFields(matched)
          };
        }
        routes2.forEach((route) => addRoute(route));
        return { addRoute, resolve: resolve2, removeRoute, getRoutes, getRecordMatcher };
      }
      function paramsFromLocation(params, keys) {
        const newParams = {};
        for (const key2 of keys) {
          if (key2 in params)
            newParams[key2] = params[key2];
        }
        return newParams;
      }
      function normalizeRouteRecord(record) {
        return {
          path: record.path,
          redirect: record.redirect,
          name: record.name,
          meta: record.meta || {},
          aliasOf: void 0,
          beforeEnter: record.beforeEnter,
          props: normalizeRecordProps(record),
          children: record.children || [],
          instances: {},
          leaveGuards: new Set(),
          updateGuards: new Set(),
          enterCallbacks: {},
          components: "components" in record ? record.components || {} : { default: record.component }
        };
      }
      function normalizeRecordProps(record) {
        const propsObject = {};
        const props2 = record.props || false;
        if ("component" in record) {
          propsObject.default = props2;
        } else {
          for (const name in record.components)
            propsObject[name] = typeof props2 === "boolean" ? props2 : props2[name];
        }
        return propsObject;
      }
      function isAliasRecord(record) {
        while (record) {
          if (record.record.aliasOf)
            return true;
          record = record.parent;
        }
        return false;
      }
      function mergeMetaFields(matched) {
        return matched.reduce((meta, record) => assign(meta, record.meta), {});
      }
      function mergeOptions2(defaults2, partialOptions) {
        const options = {};
        for (const key2 in defaults2) {
          options[key2] = key2 in partialOptions ? partialOptions[key2] : defaults2[key2];
        }
        return options;
      }
      function isSameParam(a, b) {
        return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;
      }
      function checkSameParams(a, b) {
        for (const key2 of a.keys) {
          if (!key2.optional && !b.keys.find(isSameParam.bind(null, key2)))
            return warn3(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key2.name}"`);
        }
        for (const key2 of b.keys) {
          if (!key2.optional && !a.keys.find(isSameParam.bind(null, key2)))
            return warn3(`Alias "${b.record.path}" and the original record: "${a.record.path}" should have the exact same param named "${key2.name}"`);
        }
      }
      function checkMissingParamsInAbsolutePath(record, parent) {
        for (const key2 of parent.keys) {
          if (!record.keys.find(isSameParam.bind(null, key2)))
            return warn3(`Absolute path "${record.record.path}" should have the exact same param named "${key2.name}" as its parent "${parent.record.path}".`);
        }
      }
      var HASH_RE = /#/g;
      var AMPERSAND_RE = /&/g;
      var SLASH_RE = /\//g;
      var EQUAL_RE = /=/g;
      var IM_RE = /\?/g;
      var PLUS_RE = /\+/g;
      var ENC_BRACKET_OPEN_RE = /%5B/g;
      var ENC_BRACKET_CLOSE_RE = /%5D/g;
      var ENC_CARET_RE = /%5E/g;
      var ENC_BACKTICK_RE = /%60/g;
      var ENC_CURLY_OPEN_RE = /%7B/g;
      var ENC_PIPE_RE = /%7C/g;
      var ENC_CURLY_CLOSE_RE = /%7D/g;
      var ENC_SPACE_RE = /%20/g;
      function commonEncode(text) {
        return encodeURI("" + text).replace(ENC_PIPE_RE, "|").replace(ENC_BRACKET_OPEN_RE, "[").replace(ENC_BRACKET_CLOSE_RE, "]");
      }
      function encodeHash(text) {
        return commonEncode(text).replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
      }
      function encodeQueryValue(text) {
        return commonEncode(text).replace(PLUS_RE, "%2B").replace(ENC_SPACE_RE, "+").replace(HASH_RE, "%23").replace(AMPERSAND_RE, "%26").replace(ENC_BACKTICK_RE, "`").replace(ENC_CURLY_OPEN_RE, "{").replace(ENC_CURLY_CLOSE_RE, "}").replace(ENC_CARET_RE, "^");
      }
      function encodeQueryKey(text) {
        return encodeQueryValue(text).replace(EQUAL_RE, "%3D");
      }
      function encodePath(text) {
        return commonEncode(text).replace(HASH_RE, "%23").replace(IM_RE, "%3F");
      }
      function encodeParam(text) {
        return text == null ? "" : encodePath(text).replace(SLASH_RE, "%2F");
      }
      function decode2(text) {
        try {
          return decodeURIComponent("" + text);
        } catch (err) {
          warn3(`Error decoding "${text}". Using original value`);
        }
        return "" + text;
      }
      function parseQuery(search) {
        const query = {};
        if (search === "" || search === "?")
          return query;
        const hasLeadingIM = search[0] === "?";
        const searchParams = (hasLeadingIM ? search.slice(1) : search).split("&");
        for (let i = 0; i < searchParams.length; ++i) {
          const searchParam = searchParams[i].replace(PLUS_RE, " ");
          const eqPos = searchParam.indexOf("=");
          const key2 = decode2(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));
          const value2 = eqPos < 0 ? null : decode2(searchParam.slice(eqPos + 1));
          if (key2 in query) {
            let currentValue = query[key2];
            if (!Array.isArray(currentValue)) {
              currentValue = query[key2] = [currentValue];
            }
            currentValue.push(value2);
          } else {
            query[key2] = value2;
          }
        }
        return query;
      }
      function stringifyQuery(query) {
        let search = "";
        for (let key2 in query) {
          const value2 = query[key2];
          key2 = encodeQueryKey(key2);
          if (value2 == null) {
            if (value2 !== void 0) {
              search += (search.length ? "&" : "") + key2;
            }
            continue;
          }
          const values = Array.isArray(value2) ? value2.map((v) => v && encodeQueryValue(v)) : [value2 && encodeQueryValue(value2)];
          values.forEach((value3) => {
            if (value3 !== void 0) {
              search += (search.length ? "&" : "") + key2;
              if (value3 != null)
                search += "=" + value3;
            }
          });
        }
        return search;
      }
      function normalizeQuery(query) {
        const normalizedQuery = {};
        for (const key2 in query) {
          const value2 = query[key2];
          if (value2 !== void 0) {
            normalizedQuery[key2] = Array.isArray(value2) ? value2.map((v) => v == null ? null : "" + v) : value2 == null ? value2 : "" + value2;
          }
        }
        return normalizedQuery;
      }
      function useCallbacks() {
        let handlers2 = [];
        function add2(handler) {
          handlers2.push(handler);
          return () => {
            const i = handlers2.indexOf(handler);
            if (i > -1)
              handlers2.splice(i, 1);
          };
        }
        function reset2() {
          handlers2 = [];
        }
        return {
          add: add2,
          list: () => handlers2,
          reset: reset2
        };
      }
      function registerGuard(record, name, guard) {
        const removeFromList = () => {
          record[name].delete(guard);
        };
        vue.onUnmounted(removeFromList);
        vue.onDeactivated(removeFromList);
        vue.onActivated(() => {
          record[name].add(guard);
        });
        record[name].add(guard);
      }
      function onBeforeRouteLeave(leaveGuard) {
        if (!vue.getCurrentInstance()) {
          warn3("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");
          return;
        }
        const activeRecord = vue.inject(matchedRouteKey, {}).value;
        if (!activeRecord) {
          warn3("No active route record was found. Are you missing a <router-view> component?");
          return;
        }
        registerGuard(activeRecord, "leaveGuards", leaveGuard);
      }
      function onBeforeRouteUpdate(updateGuard) {
        if (!vue.getCurrentInstance()) {
          warn3("getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function");
          return;
        }
        const activeRecord = vue.inject(matchedRouteKey, {}).value;
        if (!activeRecord) {
          warn3("No active route record was found. Are you missing a <router-view> component?");
          return;
        }
        registerGuard(activeRecord, "updateGuards", updateGuard);
      }
      function guardToPromiseFn(guard, to, from, record, name) {
        const enterCallbackArray = record && (record.enterCallbacks[name] = record.enterCallbacks[name] || []);
        return () => new Promise((resolve2, reject) => {
          const next = (valid) => {
            if (valid === false)
              reject(createRouterError(4, {
                from,
                to
              }));
            else if (valid instanceof Error) {
              reject(valid);
            } else if (isRouteLocation(valid)) {
              reject(createRouterError(2, {
                from: to,
                to: valid
              }));
            } else {
              if (enterCallbackArray && record.enterCallbacks[name] === enterCallbackArray && typeof valid === "function")
                enterCallbackArray.push(valid);
              resolve2();
            }
          };
          const guardReturn = guard.call(record && record.instances[name], to, from, canOnlyBeCalledOnce(next, to, from));
          let guardCall = Promise.resolve(guardReturn);
          if (guard.length < 3)
            guardCall = guardCall.then(next);
          if (guard.length > 2) {
            const message = `The "next" callback was never called inside of ${guard.name ? '"' + guard.name + '"' : ""}:
${guard.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof guardReturn === "object" && "then" in guardReturn) {
              guardCall = guardCall.then((resolvedValue) => {
                if (!next._called) {
                  warn3(message);
                  return Promise.reject(new Error("Invalid navigation guard"));
                }
                return resolvedValue;
              });
            } else if (guardReturn !== void 0) {
              if (!next._called) {
                warn3(message);
                reject(new Error("Invalid navigation guard"));
                return;
              }
            }
          }
          guardCall.catch((err) => reject(err));
        });
      }
      function canOnlyBeCalledOnce(next, to, from) {
        let called = 0;
        return function() {
          if (called++ === 1)
            warn3(`The "next" callback was called more than once in one navigation guard when going from "${from.fullPath}" to "${to.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`);
          next._called = true;
          if (called === 1)
            next.apply(null, arguments);
        };
      }
      function extractComponentsGuards(matched, guardType, to, from) {
        const guards = [];
        for (const record of matched) {
          for (const name in record.components) {
            let rawComponent = record.components[name];
            {
              if (!rawComponent || typeof rawComponent !== "object" && typeof rawComponent !== "function") {
                warn3(`Component "${name}" in record with path "${record.path}" is not a valid component. Received "${String(rawComponent)}".`);
                throw new Error("Invalid route component");
              } else if ("then" in rawComponent) {
                warn3(`Component "${name}" in record with path "${record.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
                const promise = rawComponent;
                rawComponent = () => promise;
              } else if (rawComponent.__asyncLoader && !rawComponent.__warnedDefineAsync) {
                rawComponent.__warnedDefineAsync = true;
                warn3(`Component "${name}" in record with path "${record.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`);
              }
            }
            if (guardType !== "beforeRouteEnter" && !record.instances[name])
              continue;
            if (isRouteComponent(rawComponent)) {
              const options = rawComponent.__vccOpts || rawComponent;
              const guard = options[guardType];
              guard && guards.push(guardToPromiseFn(guard, to, from, record, name));
            } else {
              let componentPromise = rawComponent();
              if (!("catch" in componentPromise)) {
                warn3(`Component "${name}" in record with path "${record.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`);
                componentPromise = Promise.resolve(componentPromise);
              }
              guards.push(() => componentPromise.then((resolved) => {
                if (!resolved)
                  return Promise.reject(new Error(`Couldn't resolve component "${name}" at "${record.path}"`));
                const resolvedComponent = isESModule(resolved) ? resolved.default : resolved;
                record.components[name] = resolvedComponent;
                const options = resolvedComponent.__vccOpts || resolvedComponent;
                const guard = options[guardType];
                return guard && guardToPromiseFn(guard, to, from, record, name)();
              }));
            }
          }
        }
        return guards;
      }
      function isRouteComponent(component) {
        return typeof component === "object" || "displayName" in component || "props" in component || "__vccOpts" in component;
      }
      function useLink(props2) {
        const router = vue.inject(routerKey);
        const currentRoute = vue.inject(routeLocationKey);
        const route = vue.computed(() => router.resolve(vue.unref(props2.to)));
        const activeRecordIndex = vue.computed(() => {
          const { matched } = route.value;
          const { length } = matched;
          const routeMatched = matched[length - 1];
          const currentMatched = currentRoute.matched;
          if (!routeMatched || !currentMatched.length)
            return -1;
          const index = currentMatched.findIndex(isSameRouteRecord2.bind(null, routeMatched));
          if (index > -1)
            return index;
          const parentRecordPath = getOriginalPath2(matched[length - 2]);
          return length > 1 && getOriginalPath2(routeMatched) === parentRecordPath && currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord2.bind(null, matched[length - 2])) : index;
        });
        const isActive = vue.computed(() => activeRecordIndex.value > -1 && includesParams2(currentRoute.params, route.value.params));
        const isExactActive = vue.computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));
        function navigate(e = {}) {
          if (guardEvent(e)) {
            return router[vue.unref(props2.replace) ? "replace" : "push"](vue.unref(props2.to)).catch(noop2);
          }
          return Promise.resolve();
        }
        if (isBrowser) {
          const instance = vue.getCurrentInstance();
          if (instance) {
            const linkContextDevtools = {
              route: route.value,
              isActive: isActive.value,
              isExactActive: isExactActive.value
            };
            instance.__vrl_devtools = instance.__vrl_devtools || [];
            instance.__vrl_devtools.push(linkContextDevtools);
            vue.watchEffect(() => {
              linkContextDevtools.route = route.value;
              linkContextDevtools.isActive = isActive.value;
              linkContextDevtools.isExactActive = isExactActive.value;
            }, { flush: "post" });
          }
        }
        return {
          route,
          href: vue.computed(() => route.value.href),
          isActive,
          isExactActive,
          navigate
        };
      }
      var RouterLinkImpl = /* @__PURE__ */ vue.defineComponent({
        name: "RouterLink",
        props: {
          to: {
            type: [String, Object],
            required: true
          },
          replace: Boolean,
          activeClass: String,
          exactActiveClass: String,
          custom: Boolean,
          ariaCurrentValue: {
            type: String,
            default: "page"
          }
        },
        useLink,
        setup(props2, { slots }) {
          const link = vue.reactive(useLink(props2));
          const { options } = vue.inject(routerKey);
          const elClass = vue.computed(() => ({
            [getLinkClass(props2.activeClass, options.linkActiveClass, "router-link-active")]: link.isActive,
            [getLinkClass(props2.exactActiveClass, options.linkExactActiveClass, "router-link-exact-active")]: link.isExactActive
          }));
          return () => {
            const children = slots.default && slots.default(link);
            return props2.custom ? children : vue.h("a", {
              "aria-current": link.isExactActive ? props2.ariaCurrentValue : null,
              href: link.href,
              onClick: link.navigate,
              class: elClass.value
            }, children);
          };
        }
      });
      var RouterLink = RouterLinkImpl;
      function guardEvent(e) {
        if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)
          return;
        if (e.defaultPrevented)
          return;
        if (e.button !== void 0 && e.button !== 0)
          return;
        if (e.currentTarget && e.currentTarget.getAttribute) {
          const target2 = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(target2))
            return;
        }
        if (e.preventDefault)
          e.preventDefault();
        return true;
      }
      function includesParams2(outer, inner) {
        for (const key2 in inner) {
          const innerValue = inner[key2];
          const outerValue = outer[key2];
          if (typeof innerValue === "string") {
            if (innerValue !== outerValue)
              return false;
          } else {
            if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value2, i) => value2 !== outerValue[i]))
              return false;
          }
        }
        return true;
      }
      function getOriginalPath2(record) {
        return record ? record.aliasOf ? record.aliasOf.path : record.path : "";
      }
      var getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;
      var RouterViewImpl = /* @__PURE__ */ vue.defineComponent({
        name: "RouterView",
        inheritAttrs: false,
        props: {
          name: {
            type: String,
            default: "default"
          },
          route: Object
        },
        setup(props2, { attrs, slots }) {
          warnDeprecatedUsage();
          const injectedRoute = vue.inject(routerViewLocationKey);
          const routeToDisplay = vue.computed(() => props2.route || injectedRoute.value);
          const depth = vue.inject(viewDepthKey, 0);
          const matchedRouteRef = vue.computed(() => routeToDisplay.value.matched[depth]);
          vue.provide(viewDepthKey, depth + 1);
          vue.provide(matchedRouteKey, matchedRouteRef);
          vue.provide(routerViewLocationKey, routeToDisplay);
          const viewRef = vue.ref();
          vue.watch(() => [viewRef.value, matchedRouteRef.value, props2.name], ([instance, to, name], [oldInstance, from, oldName]) => {
            if (to) {
              to.instances[name] = instance;
              if (from && from !== to && instance && instance === oldInstance) {
                if (!to.leaveGuards.size) {
                  to.leaveGuards = from.leaveGuards;
                }
                if (!to.updateGuards.size) {
                  to.updateGuards = from.updateGuards;
                }
              }
            }
            if (instance && to && (!from || !isSameRouteRecord2(to, from) || !oldInstance)) {
              (to.enterCallbacks[name] || []).forEach((callback) => callback(instance));
            }
          }, { flush: "post" });
          return () => {
            const route = routeToDisplay.value;
            const matchedRoute = matchedRouteRef.value;
            const ViewComponent = matchedRoute && matchedRoute.components[props2.name];
            const currentName = props2.name;
            if (!ViewComponent) {
              return normalizeSlot2(slots.default, { Component: ViewComponent, route });
            }
            const routePropsOption = matchedRoute.props[props2.name];
            const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === "function" ? routePropsOption(route) : routePropsOption : null;
            const onVnodeUnmounted = (vnode) => {
              if (vnode.component.isUnmounted) {
                matchedRoute.instances[currentName] = null;
              }
            };
            const component = vue.h(ViewComponent, assign({}, routeProps, attrs, {
              onVnodeUnmounted,
              ref: viewRef
            }));
            return normalizeSlot2(slots.default, { Component: component, route }) || component;
          };
        }
      });
      function normalizeSlot2(slot, data) {
        if (!slot)
          return null;
        const slotContent = slot(data);
        return slotContent.length === 1 ? slotContent[0] : slotContent;
      }
      var RouterView = RouterViewImpl;
      function warnDeprecatedUsage() {
        const instance = vue.getCurrentInstance();
        const parentName = instance.parent && instance.parent.type.name;
        if (parentName && (parentName === "KeepAlive" || parentName.includes("Transition"))) {
          const comp = parentName === "KeepAlive" ? "keep-alive" : "transition";
          warn3(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${comp}>
    <component :is="Component" />
  </${comp}>
</router-view>`);
        }
      }
      function formatRouteLocation(routeLocation, tooltip) {
        const copy = assign({}, routeLocation, {
          matched: routeLocation.matched.map((matched) => omit(matched, ["instances", "children", "aliasOf"]))
        });
        return {
          _custom: {
            type: null,
            readOnly: true,
            display: routeLocation.fullPath,
            tooltip,
            value: copy
          }
        };
      }
      function formatDisplay(display) {
        return {
          _custom: {
            display
          }
        };
      }
      var routerId = 0;
      function addDevtools(app2, router, matcher) {
        if (router.__hasDevtools)
          return;
        router.__hasDevtools = true;
        const id2 = routerId++;
        devtoolsApi.setupDevtoolsPlugin({
          id: "org.vuejs.router" + (id2 ? "." + id2 : ""),
          label: "Vue Router",
          packageName: "vue-router",
          homepage: "https://next.router.vuejs.org/",
          logo: "https://vuejs.org/images/icons/favicon-96x96.png",
          componentStateTypes: ["Routing"],
          app: app2
        }, (api) => {
          api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
              payload.instanceData.state.push({
                type: "Routing",
                key: "$route",
                editable: false,
                value: formatRouteLocation(router.currentRoute.value, "Current Route")
              });
            }
          });
          api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {
            if (Array.isArray(componentInstance.__vrl_devtools)) {
              componentInstance.__devtoolsApi = api;
              componentInstance.__vrl_devtools.forEach((devtoolsData) => {
                let backgroundColor = ORANGE_400;
                let tooltip = "";
                if (devtoolsData.isExactActive) {
                  backgroundColor = LIME_500;
                  tooltip = "This is exactly active";
                } else if (devtoolsData.isActive) {
                  backgroundColor = BLUE_600;
                  tooltip = "This link is active";
                }
                node.tags.push({
                  label: devtoolsData.route.path,
                  textColor: 0,
                  tooltip,
                  backgroundColor
                });
              });
            }
          });
          vue.watch(router.currentRoute, () => {
            refreshRoutesView();
            api.notifyComponentUpdate();
            api.sendInspectorTree(routerInspectorId);
            api.sendInspectorState(routerInspectorId);
          });
          const navigationsLayerId = "router:navigations:" + id2;
          api.addTimelineLayer({
            id: navigationsLayerId,
            label: `Router${id2 ? " " + id2 : ""} Navigations`,
            color: 4237508
          });
          router.onError((error, to) => {
            api.addTimelineEvent({
              layerId: navigationsLayerId,
              event: {
                title: "Error during Navigation",
                subtitle: to.fullPath,
                logType: "error",
                time: Date.now(),
                data: { error },
                groupId: to.meta.__navigationId
              }
            });
          });
          let navigationId = 0;
          router.beforeEach((to, from) => {
            const data = {
              guard: formatDisplay("beforeEach"),
              from: formatRouteLocation(from, "Current Location during this navigation"),
              to: formatRouteLocation(to, "Target location")
            };
            Object.defineProperty(to.meta, "__navigationId", {
              value: navigationId++
            });
            api.addTimelineEvent({
              layerId: navigationsLayerId,
              event: {
                time: Date.now(),
                title: "Start of navigation",
                subtitle: to.fullPath,
                data,
                groupId: to.meta.__navigationId
              }
            });
          });
          router.afterEach((to, from, failure) => {
            const data = {
              guard: formatDisplay("afterEach")
            };
            if (failure) {
              data.failure = {
                _custom: {
                  type: Error,
                  readOnly: true,
                  display: failure ? failure.message : "",
                  tooltip: "Navigation Failure",
                  value: failure
                }
              };
              data.status = formatDisplay("\u274C");
            } else {
              data.status = formatDisplay("\u2705");
            }
            data.from = formatRouteLocation(from, "Current Location during this navigation");
            data.to = formatRouteLocation(to, "Target location");
            api.addTimelineEvent({
              layerId: navigationsLayerId,
              event: {
                title: "End of navigation",
                subtitle: to.fullPath,
                time: Date.now(),
                data,
                logType: failure ? "warning" : "default",
                groupId: to.meta.__navigationId
              }
            });
          });
          const routerInspectorId = "router-inspector:" + id2;
          api.addInspector({
            id: routerInspectorId,
            label: "Routes" + (id2 ? " " + id2 : ""),
            icon: "book",
            treeFilterPlaceholder: "Search routes"
          });
          function refreshRoutesView() {
            if (!activeRoutesPayload)
              return;
            const payload = activeRoutesPayload;
            let routes2 = matcher.getRoutes().filter((route) => !route.parent);
            routes2.forEach(resetMatchStateOnRouteRecord);
            if (payload.filter) {
              routes2 = routes2.filter((route) => isRouteMatching(route, payload.filter.toLowerCase()));
            }
            routes2.forEach((route) => markRouteRecordActive(route, router.currentRoute.value));
            payload.rootNodes = routes2.map(formatRouteRecordForInspector);
          }
          let activeRoutesPayload;
          api.on.getInspectorTree((payload) => {
            activeRoutesPayload = payload;
            if (payload.app === app2 && payload.inspectorId === routerInspectorId) {
              refreshRoutesView();
            }
          });
          api.on.getInspectorState((payload) => {
            if (payload.app === app2 && payload.inspectorId === routerInspectorId) {
              const routes2 = matcher.getRoutes();
              const route = routes2.find((route2) => route2.record.__vd_id === payload.nodeId);
              if (route) {
                payload.state = {
                  options: formatRouteRecordMatcherForStateInspector(route)
                };
              }
            }
          });
          api.sendInspectorTree(routerInspectorId);
          api.sendInspectorState(routerInspectorId);
        });
      }
      function modifierForKey(key2) {
        if (key2.optional) {
          return key2.repeatable ? "*" : "?";
        } else {
          return key2.repeatable ? "+" : "";
        }
      }
      function formatRouteRecordMatcherForStateInspector(route) {
        const { record } = route;
        const fields = [
          { editable: false, key: "path", value: record.path }
        ];
        if (record.name != null) {
          fields.push({
            editable: false,
            key: "name",
            value: record.name
          });
        }
        fields.push({ editable: false, key: "regexp", value: route.re });
        if (route.keys.length) {
          fields.push({
            editable: false,
            key: "keys",
            value: {
              _custom: {
                type: null,
                readOnly: true,
                display: route.keys.map((key2) => `${key2.name}${modifierForKey(key2)}`).join(" "),
                tooltip: "Param keys",
                value: route.keys
              }
            }
          });
        }
        if (record.redirect != null) {
          fields.push({
            editable: false,
            key: "redirect",
            value: record.redirect
          });
        }
        if (route.alias.length) {
          fields.push({
            editable: false,
            key: "aliases",
            value: route.alias.map((alias) => alias.record.path)
          });
        }
        fields.push({
          key: "score",
          editable: false,
          value: {
            _custom: {
              type: null,
              readOnly: true,
              display: route.score.map((score) => score.join(", ")).join(" | "),
              tooltip: "Score used to sort routes",
              value: route.score
            }
          }
        });
        return fields;
      }
      var PINK_500 = 15485081;
      var BLUE_600 = 2450411;
      var LIME_500 = 8702998;
      var CYAN_400 = 2282478;
      var ORANGE_400 = 16486972;
      var DARK = 6710886;
      function formatRouteRecordForInspector(route) {
        const tags = [];
        const { record } = route;
        if (record.name != null) {
          tags.push({
            label: String(record.name),
            textColor: 0,
            backgroundColor: CYAN_400
          });
        }
        if (record.aliasOf) {
          tags.push({
            label: "alias",
            textColor: 0,
            backgroundColor: ORANGE_400
          });
        }
        if (route.__vd_match) {
          tags.push({
            label: "matches",
            textColor: 0,
            backgroundColor: PINK_500
          });
        }
        if (route.__vd_exactActive) {
          tags.push({
            label: "exact",
            textColor: 0,
            backgroundColor: LIME_500
          });
        }
        if (route.__vd_active) {
          tags.push({
            label: "active",
            textColor: 0,
            backgroundColor: BLUE_600
          });
        }
        if (record.redirect) {
          tags.push({
            label: "redirect: " + (typeof record.redirect === "string" ? record.redirect : "Object"),
            textColor: 16777215,
            backgroundColor: DARK
          });
        }
        let id2 = record.__vd_id;
        if (id2 == null) {
          id2 = String(routeRecordId++);
          record.__vd_id = id2;
        }
        return {
          id: id2,
          label: record.path,
          tags,
          children: route.children.map(formatRouteRecordForInspector)
        };
      }
      var routeRecordId = 0;
      var EXTRACT_REGEXP_RE = /^\/(.*)\/([a-z]*)$/;
      function markRouteRecordActive(route, currentRoute) {
        const isExactActive = currentRoute.matched.length && isSameRouteRecord2(currentRoute.matched[currentRoute.matched.length - 1], route.record);
        route.__vd_exactActive = route.__vd_active = isExactActive;
        if (!isExactActive) {
          route.__vd_active = currentRoute.matched.some((match) => isSameRouteRecord2(match, route.record));
        }
        route.children.forEach((childRoute) => markRouteRecordActive(childRoute, currentRoute));
      }
      function resetMatchStateOnRouteRecord(route) {
        route.__vd_match = false;
        route.children.forEach(resetMatchStateOnRouteRecord);
      }
      function isRouteMatching(route, filter) {
        const found = String(route.re).match(EXTRACT_REGEXP_RE);
        route.__vd_match = false;
        if (!found || found.length < 3) {
          return false;
        }
        const nonEndingRE = new RegExp(found[1].replace(/\$$/, ""), found[2]);
        if (nonEndingRE.test(filter)) {
          route.children.forEach((child) => isRouteMatching(child, filter));
          if (route.record.path !== "/" || filter === "/") {
            route.__vd_match = route.re.test(filter);
            return true;
          }
          return false;
        }
        const path = route.record.path.toLowerCase();
        const decodedPath = decode2(path);
        if (!filter.startsWith("/") && (decodedPath.includes(filter) || path.includes(filter)))
          return true;
        if (decodedPath.startsWith(filter) || path.startsWith(filter))
          return true;
        if (route.record.name && String(route.record.name).includes(filter))
          return true;
        return route.children.some((child) => isRouteMatching(child, filter));
      }
      function omit(obj, keys) {
        const ret = {};
        for (const key2 in obj) {
          if (!keys.includes(key2)) {
            ret[key2] = obj[key2];
          }
        }
        return ret;
      }
      function createRouter2(options) {
        const matcher = createRouterMatcher(options.routes, options);
        const parseQuery$1 = options.parseQuery || parseQuery;
        const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;
        const routerHistory = options.history;
        if (!routerHistory)
          throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
        const beforeGuards = useCallbacks();
        const beforeResolveGuards = useCallbacks();
        const afterGuards = useCallbacks();
        const currentRoute = vue.shallowRef(START_LOCATION_NORMALIZED);
        let pendingLocation = START_LOCATION_NORMALIZED;
        if (isBrowser && options.scrollBehavior && "scrollRestoration" in history) {
          history.scrollRestoration = "manual";
        }
        const normalizeParams = applyToParams.bind(null, (paramValue) => "" + paramValue);
        const encodeParams = applyToParams.bind(null, encodeParam);
        const decodeParams = applyToParams.bind(null, decode2);
        function addRoute(parentOrRoute, route) {
          let parent;
          let record;
          if (isRouteName(parentOrRoute)) {
            parent = matcher.getRecordMatcher(parentOrRoute);
            record = route;
          } else {
            record = parentOrRoute;
          }
          return matcher.addRoute(record, parent);
        }
        function removeRoute(name) {
          const recordMatcher = matcher.getRecordMatcher(name);
          if (recordMatcher) {
            matcher.removeRoute(recordMatcher);
          } else {
            warn3(`Cannot remove non-existent route "${String(name)}"`);
          }
        }
        function getRoutes() {
          return matcher.getRoutes().map((routeMatcher) => routeMatcher.record);
        }
        function hasRoute(name) {
          return !!matcher.getRecordMatcher(name);
        }
        function resolve2(rawLocation, currentLocation) {
          currentLocation = assign({}, currentLocation || currentRoute.value);
          if (typeof rawLocation === "string") {
            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);
            const matchedRoute2 = matcher.resolve({ path: locationNormalized.path }, currentLocation);
            const href2 = routerHistory.createHref(locationNormalized.fullPath);
            {
              if (href2.startsWith("//"))
                warn3(`Location "${rawLocation}" resolved to "${href2}". A resolved location cannot start with multiple slashes.`);
              else if (!matchedRoute2.matched.length) {
                warn3(`No match found for location with path "${rawLocation}"`);
              }
            }
            return assign(locationNormalized, matchedRoute2, {
              params: decodeParams(matchedRoute2.params),
              hash: decode2(locationNormalized.hash),
              redirectedFrom: void 0,
              href: href2
            });
          }
          let matcherLocation;
          if ("path" in rawLocation) {
            if ("params" in rawLocation && !("name" in rawLocation) && Object.keys(rawLocation.params).length) {
              warn3(`Path "${rawLocation.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`);
            }
            matcherLocation = assign({}, rawLocation, {
              path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path
            });
          } else {
            const targetParams = assign({}, rawLocation.params);
            for (const key2 in targetParams) {
              if (targetParams[key2] == null) {
                delete targetParams[key2];
              }
            }
            matcherLocation = assign({}, rawLocation, {
              params: encodeParams(rawLocation.params)
            });
            currentLocation.params = encodeParams(currentLocation.params);
          }
          const matchedRoute = matcher.resolve(matcherLocation, currentLocation);
          const hash = rawLocation.hash || "";
          if (hash && !hash.startsWith("#")) {
            warn3(`A \`hash\` should always start with the character "#". Replace "${hash}" with "#${hash}".`);
          }
          matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));
          const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {
            hash: encodeHash(hash),
            path: matchedRoute.path
          }));
          const href = routerHistory.createHref(fullPath);
          {
            if (href.startsWith("//")) {
              warn3(`Location "${rawLocation}" resolved to "${href}". A resolved location cannot start with multiple slashes.`);
            } else if (!matchedRoute.matched.length) {
              warn3(`No match found for location with path "${"path" in rawLocation ? rawLocation.path : rawLocation}"`);
            }
          }
          return assign({
            fullPath,
            hash,
            query: stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}
          }, matchedRoute, {
            redirectedFrom: void 0,
            href
          });
        }
        function locationAsObject(to) {
          return typeof to === "string" ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);
        }
        function checkCanceledNavigation(to, from) {
          if (pendingLocation !== to) {
            return createRouterError(8, {
              from,
              to
            });
          }
        }
        function push(to) {
          return pushWithRedirect(to);
        }
        function replace(to) {
          return push(assign(locationAsObject(to), { replace: true }));
        }
        function handleRedirectRecord(to) {
          const lastMatched = to.matched[to.matched.length - 1];
          if (lastMatched && lastMatched.redirect) {
            const { redirect } = lastMatched;
            let newTargetLocation = typeof redirect === "function" ? redirect(to) : redirect;
            if (typeof newTargetLocation === "string") {
              newTargetLocation = newTargetLocation.includes("?") || newTargetLocation.includes("#") ? newTargetLocation = locationAsObject(newTargetLocation) : { path: newTargetLocation };
              newTargetLocation.params = {};
            }
            if (!("path" in newTargetLocation) && !("name" in newTargetLocation)) {
              warn3(`Invalid redirect found:
${JSON.stringify(newTargetLocation, null, 2)}
 when navigating to "${to.fullPath}". A redirect must contain a name or path. This will break in production.`);
              throw new Error("Invalid redirect");
            }
            return assign({
              query: to.query,
              hash: to.hash,
              params: to.params
            }, newTargetLocation);
          }
        }
        function pushWithRedirect(to, redirectedFrom) {
          const targetLocation = pendingLocation = resolve2(to);
          const from = currentRoute.value;
          const data = to.state;
          const force = to.force;
          const replace2 = to.replace === true;
          const shouldRedirect = handleRedirectRecord(targetLocation);
          if (shouldRedirect)
            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {
              state: data,
              force,
              replace: replace2
            }), redirectedFrom || targetLocation);
          const toLocation = targetLocation;
          toLocation.redirectedFrom = redirectedFrom;
          let failure;
          if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {
            failure = createRouterError(16, { to: toLocation, from });
            handleScroll(from, from, true, false);
          }
          return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch((error) => isNavigationFailure(error) ? error : triggerError(error, toLocation, from)).then((failure2) => {
            if (failure2) {
              if (isNavigationFailure(failure2, 2)) {
                if (isSameRouteLocation(stringifyQuery$1, resolve2(failure2.to), toLocation) && redirectedFrom && (redirectedFrom._count = redirectedFrom._count ? redirectedFrom._count + 1 : 1) > 10) {
                  warn3(`Detected an infinite redirection in a navigation guard when going from "${from.fullPath}" to "${toLocation.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);
                  return Promise.reject(new Error("Infinite redirect in navigation guard"));
                }
                return pushWithRedirect(assign(locationAsObject(failure2.to), {
                  state: data,
                  force,
                  replace: replace2
                }), redirectedFrom || toLocation);
              }
            } else {
              failure2 = finalizeNavigation(toLocation, from, true, replace2, data);
            }
            triggerAfterEach(toLocation, from, failure2);
            return failure2;
          });
        }
        function checkCanceledNavigationAndReject(to, from) {
          const error = checkCanceledNavigation(to, from);
          return error ? Promise.reject(error) : Promise.resolve();
        }
        function navigate(to, from) {
          let guards;
          const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);
          guards = extractComponentsGuards(leavingRecords.reverse(), "beforeRouteLeave", to, from);
          for (const record of leavingRecords) {
            record.leaveGuards.forEach((guard) => {
              guards.push(guardToPromiseFn(guard, to, from));
            });
          }
          const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);
          guards.push(canceledNavigationCheck);
          return runGuardQueue(guards).then(() => {
            guards = [];
            for (const guard of beforeGuards.list()) {
              guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
          }).then(() => {
            guards = extractComponentsGuards(updatingRecords, "beforeRouteUpdate", to, from);
            for (const record of updatingRecords) {
              record.updateGuards.forEach((guard) => {
                guards.push(guardToPromiseFn(guard, to, from));
              });
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
          }).then(() => {
            guards = [];
            for (const record of to.matched) {
              if (record.beforeEnter && !from.matched.includes(record)) {
                if (Array.isArray(record.beforeEnter)) {
                  for (const beforeEnter of record.beforeEnter)
                    guards.push(guardToPromiseFn(beforeEnter, to, from));
                } else {
                  guards.push(guardToPromiseFn(record.beforeEnter, to, from));
                }
              }
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
          }).then(() => {
            to.matched.forEach((record) => record.enterCallbacks = {});
            guards = extractComponentsGuards(enteringRecords, "beforeRouteEnter", to, from);
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
          }).then(() => {
            guards = [];
            for (const guard of beforeResolveGuards.list()) {
              guards.push(guardToPromiseFn(guard, to, from));
            }
            guards.push(canceledNavigationCheck);
            return runGuardQueue(guards);
          }).catch((err) => isNavigationFailure(err, 8) ? err : Promise.reject(err));
        }
        function triggerAfterEach(to, from, failure) {
          for (const guard of afterGuards.list())
            guard(to, from, failure);
        }
        function finalizeNavigation(toLocation, from, isPush, replace2, data) {
          const error = checkCanceledNavigation(toLocation, from);
          if (error)
            return error;
          const isFirstNavigation = from === START_LOCATION_NORMALIZED;
          const state = !isBrowser ? {} : history.state;
          if (isPush) {
            if (replace2 || isFirstNavigation)
              routerHistory.replace(toLocation.fullPath, assign({
                scroll: isFirstNavigation && state && state.scroll
              }, data));
            else
              routerHistory.push(toLocation.fullPath, data);
          }
          currentRoute.value = toLocation;
          handleScroll(toLocation, from, isPush, isFirstNavigation);
          markAsReady();
        }
        let removeHistoryListener;
        function setupListeners() {
          removeHistoryListener = routerHistory.listen((to, _from, info) => {
            const toLocation = resolve2(to);
            const shouldRedirect = handleRedirectRecord(toLocation);
            if (shouldRedirect) {
              pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop2);
              return;
            }
            pendingLocation = toLocation;
            const from = currentRoute.value;
            if (isBrowser) {
              saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());
            }
            navigate(toLocation, from).catch((error) => {
              if (isNavigationFailure(error, 4 | 8)) {
                return error;
              }
              if (isNavigationFailure(error, 2)) {
                pushWithRedirect(error.to, toLocation).then((failure) => {
                  if (isNavigationFailure(failure, 4 | 16) && !info.delta && info.type === NavigationType.pop) {
                    routerHistory.go(-1, false);
                  }
                }).catch(noop2);
                return Promise.reject();
              }
              if (info.delta)
                routerHistory.go(-info.delta, false);
              return triggerError(error, toLocation, from);
            }).then((failure) => {
              failure = failure || finalizeNavigation(toLocation, from, false);
              if (failure) {
                if (info.delta) {
                  routerHistory.go(-info.delta, false);
                } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4 | 16)) {
                  routerHistory.go(-1, false);
                }
              }
              triggerAfterEach(toLocation, from, failure);
            }).catch(noop2);
          });
        }
        let readyHandlers = useCallbacks();
        let errorHandlers = useCallbacks();
        let ready2;
        function triggerError(error, to, from) {
          markAsReady(error);
          const list = errorHandlers.list();
          if (list.length) {
            list.forEach((handler) => handler(error, to, from));
          } else {
            {
              warn3("uncaught error during route navigation:");
            }
            console.error(error);
          }
          return Promise.reject(error);
        }
        function isReady() {
          if (ready2 && currentRoute.value !== START_LOCATION_NORMALIZED)
            return Promise.resolve();
          return new Promise((resolve3, reject) => {
            readyHandlers.add([resolve3, reject]);
          });
        }
        function markAsReady(err) {
          if (ready2)
            return;
          ready2 = true;
          setupListeners();
          readyHandlers.list().forEach(([resolve3, reject]) => err ? reject(err) : resolve3());
          readyHandlers.reset();
        }
        function handleScroll(to, from, isPush, isFirstNavigation) {
          const { scrollBehavior } = options;
          if (!isBrowser || !scrollBehavior)
            return Promise.resolve();
          const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;
          return vue.nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then((position2) => position2 && scrollToPosition(position2)).catch((err) => triggerError(err, to, from));
        }
        const go = (delta) => routerHistory.go(delta);
        let started;
        const installedApps = new Set();
        const router = {
          currentRoute,
          addRoute,
          removeRoute,
          hasRoute,
          getRoutes,
          resolve: resolve2,
          options,
          push,
          replace,
          go,
          back: () => go(-1),
          forward: () => go(1),
          beforeEach: beforeGuards.add,
          beforeResolve: beforeResolveGuards.add,
          afterEach: afterGuards.add,
          onError: errorHandlers.add,
          isReady,
          install(app2) {
            const router2 = this;
            app2.component("RouterLink", RouterLink);
            app2.component("RouterView", RouterView);
            app2.config.globalProperties.$router = router2;
            Object.defineProperty(app2.config.globalProperties, "$route", {
              enumerable: true,
              get: () => vue.unref(currentRoute)
            });
            if (isBrowser && !started && currentRoute.value === START_LOCATION_NORMALIZED) {
              started = true;
              push(routerHistory.location).catch((err) => {
                warn3("Unexpected error when starting the router:", err);
              });
            }
            const reactiveRoute = {};
            for (const key2 in START_LOCATION_NORMALIZED) {
              reactiveRoute[key2] = vue.computed(() => currentRoute.value[key2]);
            }
            app2.provide(routerKey, router2);
            app2.provide(routeLocationKey, vue.reactive(reactiveRoute));
            app2.provide(routerViewLocationKey, currentRoute);
            const unmountApp = app2.unmount;
            installedApps.add(app2);
            app2.unmount = function() {
              installedApps.delete(app2);
              if (installedApps.size < 1) {
                pendingLocation = START_LOCATION_NORMALIZED;
                removeHistoryListener && removeHistoryListener();
                currentRoute.value = START_LOCATION_NORMALIZED;
                started = false;
                ready2 = false;
              }
              unmountApp();
            };
            if (isBrowser) {
              addDevtools(app2, router2, matcher);
            }
          }
        };
        return router;
      }
      function runGuardQueue(guards) {
        return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());
      }
      function extractChangingRecords(to, from) {
        const leavingRecords = [];
        const updatingRecords = [];
        const enteringRecords = [];
        const len = Math.max(from.matched.length, to.matched.length);
        for (let i = 0; i < len; i++) {
          const recordFrom = from.matched[i];
          if (recordFrom) {
            if (to.matched.find((record) => isSameRouteRecord2(record, recordFrom)))
              updatingRecords.push(recordFrom);
            else
              leavingRecords.push(recordFrom);
          }
          const recordTo = to.matched[i];
          if (recordTo) {
            if (!from.matched.find((record) => isSameRouteRecord2(record, recordTo))) {
              enteringRecords.push(recordTo);
            }
          }
        }
        return [leavingRecords, updatingRecords, enteringRecords];
      }
      function useRouter() {
        return vue.inject(routerKey);
      }
      function useRoute() {
        return vue.inject(routeLocationKey);
      }
      exports.RouterLink = RouterLink;
      exports.RouterView = RouterView;
      exports.START_LOCATION = START_LOCATION_NORMALIZED;
      exports.createMemoryHistory = createMemoryHistory;
      exports.createRouter = createRouter2;
      exports.createRouterMatcher = createRouterMatcher;
      exports.createWebHashHistory = createWebHashHistory;
      exports.createWebHistory = createWebHistory2;
      exports.isNavigationFailure = isNavigationFailure;
      exports.matchedRouteKey = matchedRouteKey;
      exports.onBeforeRouteLeave = onBeforeRouteLeave;
      exports.onBeforeRouteUpdate = onBeforeRouteUpdate;
      exports.parseQuery = parseQuery;
      exports.routeLocationKey = routeLocationKey;
      exports.routerKey = routerKey;
      exports.routerViewLocationKey = routerViewLocationKey;
      exports.stringifyQuery = stringifyQuery;
      exports.useLink = useLink;
      exports.useRoute = useRoute;
      exports.useRouter = useRouter;
      exports.viewDepthKey = viewDepthKey;
    }
  });

  // sfc-script:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=script
  var import_pako, Sunlight1_default;
  var init_Sunlight1 = __esm({
    "sfc-script:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=script"() {
      import_pako = __toModule(require_pako());
      Sunlight1_default = {
        components: {
          sunlight0: defineComponent({ template: `<div>There's a lot of <span class="highlight">SUNLIGHT</span> here, however, nothing else yet.</div>`, setup: () => {
          } })
        },
        setup() {
          const app2 = inject("app");
          const mouse = ecs.create("Mouse", { id: "mouse0" });
          const drNorton0 = ecs.create("DRNorton0", {
            id: "YykawqvDqjBOYcKCw4VmQS",
            grid0user: {
              gridID: "QMKZwr3DrsODTkbDrsKOwr"
            },
            connections: {
              grid: "QMKZwr3DrsODTkbDrsKOwr"
            },
            dialog0: { show: true }
          });
          Object.entries(app2.grid.grid0.roster).map(([id2, record]) => {
            const item2 = ecs.root[id2];
            if (!item2) {
              delete app2.grid.grid0.roster[id2];
              return;
            }
            if (item2.dialog0)
              item2.dialog0.show = true;
            if (item2.grid0user && !item2.grid0user.gridID)
              item2.grid0user.gridID = "QMKZwr3DrsODTkbDrsKOwr";
          });
          app2.grid.grid0.deploy(drNorton0);
          console.log("stage2 DRNorton0 instance", drNorton0);
          const entityToComponentRecord = (item2) => {
            let component = item2.item ? item2.item.baseComponent : "GridItem0";
            if (component === "IAbstract")
              component = "GridItem0";
            if (item2.type === "Inventory0")
              component = "Inventory1";
            return { component, item: item2 };
          };
          const visible = ecs.by((v) => v.grid0user && app2.grid.grid0.roster[v.id] || app2.app0.renderItems[v.id], { map: entityToComponentRecord });
          const levels = computed(() => {
            return app2.towerGrids.map((grid) => {
              const components2 = ecs.find((v) => grid.grid0.roster[v.id]).map(entityToComponentRecord);
              core.log(`[Sunlight1] Level ${grid.grid0.level}`, components2);
              return {
                level: grid.grid0.level,
                zIndex: grid.grid0.level * 100,
                components: components2
              };
            });
          });
          const renderLevels = computed(() => levels.value.filter((lvl) => !!lvl.components.length));
          const unwatches = [];
          const passThrough = [
            { keyExpression: (v) => v.code.slice(0, 5) === "Arrow" && !v.ctrlKey && !v.altKey && !v.metaKey },
            { keyExpression: (v) => v.code === "KeyI" && v.ctrlKey === true && v.shiftKey === true },
            { keyExpression: (v) => v.code === "KeyR" && v.ctrlKey === true },
            { keyExpression: (v) => v.code.slice(0, 3) === "Key" && !v.ctrlKey && !v.altKey && !v.metaKey },
            { keyExpression: (v) => v.code.slice(0, 5) === "Digit" && !v.ctrlKey && !v.altKey && !v.metaKey },
            { keyExpression: (v) => v.code.slice(0, 6) === "Numpad" && !v.ctrlKey && !v.altKey && !v.metaKey },
            {
              keyExpression: (v) => ~[
                "Delete",
                "Backspace",
                "Space",
                "Tab",
                "Insert",
                "Home",
                "End",
                "PageUp",
                "PageDown",
                "Comma",
                "Period",
                "Slash",
                "Semicolon",
                "Quote",
                "BracketLeft",
                "BracketRight",
                "Minus",
                "Equal",
                "Backslash",
                "Backquote",
                "Enter"
              ].indexOf(v.code) && !v.ctrlKey && !v.altKey && !v.metaKey
            },
            {
              keyExpression: (v) => ~[
                "KeyA",
                "KeyZ",
                "KeyX",
                "KeyC",
                "KeyV",
                "Insert",
                "Delete"
              ].indexOf(v.code) && v.ctrlKey && !v.altKey && !v.metaKey && !v.shiftKey
            }
          ];
          const useWhenInput = [
            (v) => v.code === "Escape",
            (v) => v.code === "Enter" && v.ctrlKey,
            (v) => v.code === "KeyS" && v.ctrlKey
          ];
          const complyAny = (item2, predicates) => {
            for (let p2 of predicates) {
              if (p2(item2))
                return true;
            }
            return false;
          };
          const globalKeyDown = (e) => {
            core.log(`[Sunlight1] globalKeyDown e.target.tagName`, e.target.tagName);
            if (~["INPUT", "TEXTAREA"].indexOf(e.target.tagName) && !complyAny(e, useWhenInput)) {
              return true;
            }
            const a = ecs.find((v) => v.keyboardUser0 && v.attention0 && v.attention0.present);
            for (let item2 of a) {
              try {
                item2.keyboardUser0.conduct("keyDown")(e);
              } catch (e2) {
                core.log(`[Sunlight1]Failure while dispatching a keyboardUser0 event to ${pure.itemToken(item2)}: ${e2.message}`);
              }
            }
            if (!e.defaultPrevented && event.eventPhase === 3) {
              if (!passThrough.filter((item2) => item2.keyExpression(e)).length) {
                console.log(e.code);
                e.preventDefault();
                e.stopPropagation();
                return false;
              }
            }
          };
          const globalKeyUp = (e) => {
            const a = ecs.find((v) => v.keyboardUser0 && v.attention0 && v.attention0.present);
            for (let item2 of a) {
              item2.keyboardUser0.conduct("keyUp")(e);
            }
          };
          onMounted(() => {
            document.body.addEventListener("keyup", globalKeyUp);
            document.body.addEventListener("keydown", globalKeyDown);
            unwatches.push(() => {
              document.body.removeEventListener("keyup", globalKeyUp);
              document.body.removeEventListener("keydown", globalKeyDown);
            });
            mouse.mouse0.init();
          });
          onBeforeUnmount(() => {
            mouse.mouse0.dispose();
          });
          return { drNorton0, visible, levels, renderLevels };
        }
      };
    }
  });

  // sfc-style:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=style&index=0
  var init_ = __esm({
    "sfc-style:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=style&index=0"() {
    }
  });

  // sfc-template:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=template
  function render2(_ctx, _cache, $props, $setup, $data, $options) {
    const _component_sunlight0 = resolveComponent("sunlight0");
    const _component_Paste0 = resolveComponent("Paste0");
    return openBlock(), createElementBlock("div", _hoisted_1, [
      createBaseVNode("div", _hoisted_2, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($setup.visible, (record, key2) => {
          return openBlock(), createBlock(resolveDynamicComponent(record.component), {
            key: key2,
            item: record.item
          }, null, 8, ["item"]);
        }), 128))
      ]),
      (openBlock(true), createElementBlock(Fragment, null, renderList($setup.renderLevels, (level, key2) => {
        return openBlock(), createElementBlock("div", {
          key: key2,
          style: normalizeStyle({ zIndex: level.zIndex }),
          class: normalizeClass({ [`level-${level.level}`]: true })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(level.components, (record, key22) => {
            return openBlock(), createBlock(resolveDynamicComponent(record.component), {
              key: key22,
              item: record.item
            }, null, 8, ["item"]);
          }), 128))
        ], 6);
      }), 128)),
      !$setup.visible.length ? (openBlock(), createBlock(_component_sunlight0, {
        key: 0,
        class: "sunlight-0"
      })) : createCommentVNode("v-if", true),
      createVNode(_component_Paste0)
    ]);
  }
  var import_pako, _hoisted_1, _hoisted_2;
  var init_Sunlight12 = __esm({
    "sfc-template:/mnt/c/yehat/sunlight0/yehat/Sunlight1.vue?type=template"() {
      import_pako = __toModule(require_pako());
      init_vue_esm_bundler();
      _hoisted_1 = { id: "sunlight-table" };
      _hoisted_2 = { class: "level-0" };
    }
  });

  // yehat/Sunlight1.vue
  var import_pako, Sunlight1_default2;
  var init_Sunlight13 = __esm({
    "yehat/Sunlight1.vue"() {
      import_pako = __toModule(require_pako());
      init_Sunlight1();
      init_();
      init_Sunlight12();
      Sunlight1_default.render = render2;
      Sunlight1_default.__file = "yehat/Sunlight1.vue";
      Sunlight1_default.__scopeId = "data-v-8f2e212d";
      Sunlight1_default2 = Sunlight1_default;
    }
  });

  // fed:router.js
  var import_pako, import_vue_router, routes, router_default;
  var init_router = __esm({
    "fed:router.js"() {
      import_pako = __toModule(require_pako());
      import_vue_router = __toModule(require_vue_router_cjs());
      init_Sunlight13();
      routes = [
        { path: "/:locID?", name: "SunlightApp", component: Sunlight1_default2, props: true }
      ];
      ecs.root.router = (0, import_vue_router.createRouter)({
        routes,
        history: (0, import_vue_router.createWebHistory)()
      });
      router_default = ecs.root.router;
    }
  });

  // import-glob:./yehat/items/**/*
  var import_pako, modules, __default;
  var init__ = __esm({
    "import-glob:./yehat/items/**/*"() {
      import_pako = __toModule(require_pako());
      modules = [];
      __default = modules;
    }
  });

  // fed:stage2.js
  var stage2_exports = {};
  __export(stage2_exports, {
    default: () => stage2_default
  });
  var import_pako, ID_BOOT, stage2_default;
  var init_stage2 = __esm({
    "fed:stage2.js"() {
      import_pako = __toModule(require_pako());
      init_basics0();
      init_presentation0();
      init_embeddings();
      init_lang();
      init_project();
      init_cats();
      init_khon();
      init_camera0();
      init_mouse0();
      init_router();
      init__();
      ID_BOOT = "AVFZFAofQlnCk8OdYsOewo";
      (async () => {
        const app2 = reactive({
          app0: {
            renderItems: {},
            gridStack: ["QMKZwr3DrsODTkbDrsKOwr"],
            gridTower: ["LMOFwoZldRZJwoHChmHDuc", "R8K_HMKUwpzCrEjCrMKBTE", "OxjClsK0HkdDw57CgEcAMM"],
            gridTowerAttention: null
          },
          grid: computed({ get: () => {
            const g = ecs.root[app2.app0.gridStack[0]];
            if (g)
              return g;
            return ecs.create("Grid0", {
              id: app2.app0.gridStack[0]
            });
          }, set: (v) => {
            if (typeof v === "object" && v.id) {
              if (v.id === app2.app0.gridStack[0]) {
                core.log(`[App0]Navigation to [Grid0 ${v.id}], which is the current stack head. Ignored.`);
                return;
              }
              app2.app0.gridStack.unshift(v.id);
              core.log(`[App0]Navigated to ${pure.itemToken(v)}`);
            }
          } }),
          towerGrids: computed(() => {
            return app2.app0.gridTower.map((id2, index) => {
              if (ecs.root[id2])
                return ecs.root[id2];
              let grid = null;
              if (index === 0) {
                grid = ecs.create("Grid0", {
                  id: id2,
                  grid0: { level: index + 1, scale: "normal" }
                });
                grid.grid0.resizeToScreen();
              } else {
                grid = ecs.create("Grid0", {
                  id: id2,
                  grid0: { level: index + 1, scale: "screen0" },
                  space2: { dims: [41, 22] }
                });
              }
              return grid;
            });
          }),
          back: () => {
            if (app2.app0.gridStack.length <= 1) {
              core.log(`[App0]Back at the top of Grid Stack. Ignored.`);
              return;
            }
            app2.app0.gridStack = app2.app0.gridStack.slice(1);
            const v = ecs.root[app2.app0.gridStack[0]];
            if (v) {
              core.log(`[App0]Navigated BACK to ${pure.itemToken(v)}`);
            } else {
              core.log(`[App0]Navigated BACK to an unknown node, probably a failure.`, v);
            }
          },
          close: (id2) => {
            delete app2.app0.renderItems[id2];
          },
          theApp: null
        });
        ecs.root["app"] = app2;
        const theApp = createApp({
          template: `<router-view />`,
          setup() {
            console.log("App setup.");
            provide("app", app2);
            onMounted(() => {
              const loader = ecs.root.AkjDtDXCoS5Dw7jCjsKJw7;
              app2.towerGrids[1].grid0.deploy(loader);
              app2.towerGrids[1].grid0.manage({ id: loader.id, center: true });
              ecs.loadLocalInstance(ID_BOOT);
              if (ecs.root[ID_BOOT]) {
                for (let id2 of ecs.root[ID_BOOT].code1seq.stack)
                  ecs.loadLocalInstance(id2);
                ecs.root[ID_BOOT].code1.run();
              } else {
                core.log(`[App]No boot record.`);
              }
              ecs.loadLocalInstances();
            });
            return {};
          }
        });
        app2.theApp = theApp;
        core.appComponents = {};
        for (let key2 in __default) {
          let name = __default[key2].default.__file.split("/").pop().replace(".ce.vue", "").replace(".vue", "");
          console.log("Registering Component", name, __default[key2]);
          let definedComponent = defineComponent(__default[key2].default);
          core.appComponents[name] = definedComponent;
          theApp.component(name, definedComponent);
        }
        ecs.create("WebSocket0", { id: core.yehat.websocketID });
        theApp.use(Quasar.Quasar, {
          config: {
            brand: {
              primary: "#F26338",
              sunshine: "#FEBE2A",
              whiteField: "#E2E1E1",
              darkBG: "#1D2F37"
            },
            dark: true
          },
          plugins: {
            Notify: Quasar.Notify,
            Dialog: Quasar.Dialog
          }
        });
        theApp.use(router_default);
        theApp.mount("#q-app");
        console.log("Stage 2 - TheApp mounted.");
      })();
      stage2_default = () => {
        console.log("Stage 2 default called.");
      };
    }
  });

  // fed:index-file.js
  var import_pako = __toModule(require_pako());

  // boot/vue.js
  var import_pako = __toModule(require_pako());
  init_vue_esm_bundler();
  init_ecs();
  var {
    reactive: reactive3,
    computed: computed3,
    ref: ref2,
    onMounted: onMounted3,
    onBeforeUnmount: onBeforeUnmount3,
    createApp: createApp3,
    defineComponent: defineComponent3,
    watch: watch2,
    provide: provide3,
    inject: inject3,
    h: h2,
    nextTick: nextTick3,
    defineAsyncComponent: defineAsyncComponent2
  } = vue_esm_bundler_exports;
  window.vue = vue_esm_bundler_exports;
  window.ecs = ecs2;
  Object.assign(window, {
    reactive: reactive3,
    computed: computed3,
    ref: ref2,
    onMounted: onMounted3,
    onBeforeUnmount: onBeforeUnmount3,
    createApp: createApp3,
    defineComponent: defineComponent3,
    watch: watch2,
    provide: provide3,
    inject: inject3,
    ecs: ecs2,
    nextTick: nextTick3,
    defineAsyncComponent: defineAsyncComponent2
  });

  // boot/quasar.js
  var import_pako = __toModule(require_pako());

  // node_modules/quasar/dist/quasar.esm.prod.js
  var quasar_esm_prod_exports = {};
  __export(quasar_esm_prod_exports, {
    AddressbarColor: () => AddressbarColor,
    AppFullscreen: () => Plugin$5,
    AppVisibility: () => Plugin$4,
    BottomSheet: () => BottomSheet,
    ClosePopup: () => ClosePopup,
    Cookies: () => Plugin$3,
    Dark: () => Plugin$8,
    Dialog: () => Dialog,
    Intersection: () => Intersection,
    Loading: () => Plugin$2,
    LoadingBar: () => LoadingBar,
    LocalStorage: () => Plugin$1,
    Meta: () => Meta,
    Morph: () => Morph,
    Mutation: () => Mutation,
    Notify: () => Notify,
    Platform: () => Platform,
    QAjaxBar: () => QAjaxBar,
    QAvatar: () => QAvatar,
    QBadge: () => QBadge,
    QBanner: () => QBanner,
    QBar: () => QBar,
    QBreadcrumbs: () => QBreadcrumbs,
    QBreadcrumbsEl: () => QBreadcrumbsEl,
    QBtn: () => QBtn,
    QBtnDropdown: () => QBtnDropdown,
    QBtnGroup: () => QBtnGroup,
    QBtnToggle: () => QBtnToggle,
    QCard: () => QCard,
    QCardActions: () => QCardActions,
    QCardSection: () => QCardSection,
    QCarousel: () => QCarousel,
    QCarouselControl: () => QCarouselControl,
    QCarouselSlide: () => QCarouselSlide,
    QChatMessage: () => QChatMessage,
    QCheckbox: () => QCheckbox,
    QChip: () => QChip,
    QCircularProgress: () => QCircularProgress,
    QColor: () => QColor,
    QDate: () => QDate,
    QDialog: () => QDialog,
    QDrawer: () => QDrawer,
    QEditor: () => QEditor,
    QExpansionItem: () => QExpansionItem,
    QFab: () => QFab,
    QFabAction: () => QFabAction,
    QField: () => QField,
    QFile: () => QFile,
    QFooter: () => QFooter,
    QForm: () => QForm,
    QFormChildMixin: () => QFormChildMixin,
    QHeader: () => QHeader,
    QIcon: () => QIcon,
    QImg: () => QImg,
    QInfiniteScroll: () => QInfiniteScroll,
    QInnerLoading: () => QInnerLoading,
    QInput: () => QInput,
    QIntersection: () => QIntersection,
    QItem: () => QItem,
    QItemLabel: () => QItemLabel,
    QItemSection: () => QItemSection,
    QKnob: () => QKnob,
    QLayout: () => QLayout,
    QLinearProgress: () => QLinearProgress,
    QList: () => QList,
    QMarkupTable: () => QMarkupTable,
    QMenu: () => QMenu,
    QNoSsr: () => QNoSsr,
    QOptionGroup: () => QOptionGroup,
    QPage: () => QPage,
    QPageContainer: () => QPageContainer,
    QPageScroller: () => QPageScroller,
    QPageSticky: () => QPageSticky,
    QPagination: () => QPagination,
    QParallax: () => QParallax,
    QPopupEdit: () => QPopupEdit,
    QPopupProxy: () => QPopupProxy,
    QPullToRefresh: () => QPullToRefresh,
    QRadio: () => QRadio,
    QRange: () => QRange,
    QRating: () => QRating,
    QResizeObserver: () => QResizeObserver,
    QResponsive: () => QResponsive,
    QRouteTab: () => QRouteTab,
    QScrollArea: () => QScrollArea,
    QScrollObserver: () => QScrollObserver,
    QSelect: () => QSelect,
    QSeparator: () => QSeparator,
    QSkeleton: () => QSkeleton,
    QSlideItem: () => QSlideItem,
    QSlideTransition: () => QSlideTransition,
    QSlider: () => QSlider,
    QSpace: () => QSpace,
    QSpinner: () => QSpinner,
    QSpinnerAudio: () => QSpinnerAudio,
    QSpinnerBall: () => QSpinnerBall,
    QSpinnerBars: () => QSpinnerBars,
    QSpinnerBox: () => QSpinnerBox,
    QSpinnerClock: () => QSpinnerClock,
    QSpinnerComment: () => QSpinnerComment,
    QSpinnerCube: () => QSpinnerCube,
    QSpinnerDots: () => QSpinnerDots,
    QSpinnerFacebook: () => QSpinnerFacebook,
    QSpinnerGears: () => QSpinnerGears,
    QSpinnerGrid: () => QSpinnerGrid,
    QSpinnerHearts: () => QSpinnerHearts,
    QSpinnerHourglass: () => QSpinnerHourglass,
    QSpinnerInfinity: () => QSpinnerInfinity,
    QSpinnerIos: () => QSpinnerIos,
    QSpinnerOrbit: () => QSpinnerOrbit,
    QSpinnerOval: () => QSpinnerOval,
    QSpinnerPie: () => QSpinnerPie,
    QSpinnerPuff: () => QSpinnerPuff,
    QSpinnerRadio: () => QSpinnerRadio,
    QSpinnerRings: () => QSpinnerRings,
    QSpinnerTail: () => QSpinnerTail,
    QSplitter: () => QSplitter,
    QStep: () => QStep,
    QStepper: () => QStepper,
    QStepperNavigation: () => QStepperNavigation,
    QTab: () => QTab,
    QTabPanel: () => QTabPanel,
    QTabPanels: () => QTabPanels,
    QTable: () => QTable,
    QTabs: () => QTabs,
    QTd: () => QTd,
    QTh: () => QTh,
    QTime: () => QTime,
    QTimeline: () => QTimeline,
    QTimelineEntry: () => QTimelineEntry,
    QToggle: () => QToggle,
    QToolbar: () => QToolbar,
    QToolbarTitle: () => QToolbarTitle,
    QTooltip: () => QTooltip,
    QTr: () => QTr,
    QTree: () => QTree,
    QUploader: () => QUploader,
    QUploaderAddTrigger: () => QUploaderAddTrigger,
    QVideo: () => QVideo,
    QVirtualScroll: () => QVirtualScroll,
    Quasar: () => Quasar2,
    Ripple: () => Ripple,
    Screen: () => Screen2,
    Scroll: () => Scroll,
    ScrollFire: () => ScrollFire,
    SessionStorage: () => Plugin,
    TouchHold: () => TouchHold,
    TouchPan: () => TouchPan,
    TouchRepeat: () => TouchRepeat,
    TouchSwipe: () => TouchSwipe,
    clone: () => clone,
    colors: () => colors,
    copyToClipboard: () => copyToClipboard,
    createMetaMixin: () => createMetaMixin,
    createUploaderComponent: () => createUploaderComponent,
    date: () => date,
    debounce: () => debounce,
    dom: () => dom,
    event: () => event2,
    exportFile: () => exportFile,
    extend: () => extend2,
    format: () => format,
    frameDebounce: () => frameDebounce,
    getCssVar: () => getCssVar,
    morph: () => morph,
    noop: () => noop,
    openURL: () => openUrl,
    patterns: () => patterns,
    scroll: () => scroll,
    setCssVar: () => setCssVar,
    throttle: () => throttle,
    uid: () => uid$2,
    useDialogPluginComponent: () => useDialogPluginComponent,
    useFormChild: () => useFormChild,
    useMeta: () => useMeta,
    useQuasar: () => useQuasar
  });
  var import_pako = __toModule(require_pako());
  init_vue_esm_bundler();
  var iosCorrection;
  var isRuntimeSsrPreHydration = ref(false);
  function getMatch(e, t) {
    const o = /(edge|edga|edgios)\/([\w.]+)/.exec(e) || /(opr)[\/]([\w.]+)/.exec(e) || /(vivaldi)[\/]([\w.]+)/.exec(e) || /(chrome|crios)[\/]([\w.]+)/.exec(e) || /(iemobile)[\/]([\w.]+)/.exec(e) || /(version)(applewebkit)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+).*(version)[\/]([\w.]+).*(safari)[\/]([\w.]+)/.exec(e) || /(firefox|fxios)[\/]([\w.]+)/.exec(e) || /(webkit)[\/]([\w.]+)/.exec(e) || /(opera)(?:.*version|)[\/]([\w.]+)/.exec(e) || /(msie) ([\w.]+)/.exec(e) || e.indexOf("trident") >= 0 && /(rv)(?::| )([\w.]+)/.exec(e) || e.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e) || [];
    return { browser: o[5] || o[3] || o[1] || "", version: o[2] || o[4] || "0", versionNumber: o[4] || o[2] || "0", platform: t[0] || "" };
  }
  function getPlatformMatch(e) {
    return /(ipad)/.exec(e) || /(ipod)/.exec(e) || /(windows phone)/.exec(e) || /(iphone)/.exec(e) || /(kindle)/.exec(e) || /(silk)/.exec(e) || /(android)/.exec(e) || /(win)/.exec(e) || /(mac)/.exec(e) || /(linux)/.exec(e) || /(cros)/.exec(e) || /(playbook)/.exec(e) || /(bb)/.exec(e) || /(blackberry)/.exec(e) || [];
  }
  var hasTouch = "ontouchstart" in window || window.navigator.maxTouchPoints > 0;
  function applyIosCorrection(e) {
    iosCorrection = { is: { ...e } }, delete e.mac, delete e.desktop;
    const t = Math.min(window.innerHeight, window.innerWidth) > 414 ? "ipad" : "iphone";
    Object.assign(e, { mobile: true, ios: true, platform: t, [t]: true });
  }
  function getPlatform(e) {
    const t = e.toLowerCase(), o = getPlatformMatch(t), n = getMatch(t, o), a = {};
    n.browser && (a[n.browser] = true, a.version = n.version, a.versionNumber = parseInt(n.versionNumber, 10)), n.platform && (a[n.platform] = true);
    const l = a.android || a.ios || a.bb || a.blackberry || a.ipad || a.iphone || a.ipod || a.kindle || a.playbook || a.silk || a["windows phone"];
    return l === true || t.indexOf("mobile") > -1 ? (a.mobile = true, a.edga || a.edgios ? (a.edge = true, n.browser = "edge") : a.crios ? (a.chrome = true, n.browser = "chrome") : a.fxios && (a.firefox = true, n.browser = "firefox")) : a.desktop = true, (a.ipod || a.ipad || a.iphone) && (a.ios = true), a["windows phone"] && (a.winphone = true, delete a["windows phone"]), (a.chrome || a.opr || a.safari || a.vivaldi || a.mobile === true && a.ios !== true && l !== true) && (a.webkit = true), (a.safari && a.blackberry || a.bb) && (n.browser = "blackberry", a.blackberry = true), a.safari && a.playbook && (n.browser = "playbook", a.playbook = true), a.opr && (n.browser = "opera", a.opera = true), a.safari && a.android && (n.browser = "android", a.android = true), a.safari && a.kindle && (n.browser = "kindle", a.kindle = true), a.safari && a.silk && (n.browser = "silk", a.silk = true), a.vivaldi && (n.browser = "vivaldi", a.vivaldi = true), a.name = n.browser, a.platform = n.platform, t.indexOf("electron") > -1 ? a.electron = true : document.location.href.indexOf("-extension://") > -1 ? a.bex = true : (window.Capacitor !== void 0 ? (a.capacitor = true, a.nativeMobile = true, a.nativeMobileWrapper = "capacitor") : window._cordovaNative === void 0 && window.cordova === void 0 || (a.cordova = true, a.nativeMobile = true, a.nativeMobileWrapper = "cordova"), hasTouch === true && a.mac === true && (a.desktop === true && a.safari === true || a.nativeMobile === true && a.android !== true && a.ios !== true && a.ipad !== true) && applyIosCorrection(a)), a;
  }
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  var ssrClient = { has: { touch: false, webStorage: false }, within: { iframe: false } };
  var client2 = { userAgent, is: getPlatform(userAgent), has: { touch: hasTouch, webStorage: (() => {
    try {
      if (window.localStorage)
        return true;
    } catch (e) {
    }
    return false;
  })() }, within: { iframe: window.self !== window.top } };
  var Platform = { install(e) {
    const { $q: t } = e;
    isRuntimeSsrPreHydration.value === true ? (e.onSSRHydrated.push(() => {
      isRuntimeSsrPreHydration.value = false, Object.assign(t.platform, client2), iosCorrection = void 0;
    }), t.platform = reactive2(this)) : t.platform = this;
  } };
  client2.is.ios === true && window.navigator.vendor.toLowerCase().indexOf("apple"), isRuntimeSsrPreHydration.value === true ? Object.assign(Platform, client2, iosCorrection, ssrClient) : Object.assign(Platform, client2);
  var defineReactivePlugin = (e, t) => {
    const o = {}, n = reactive2(e);
    return Object.keys(e).forEach((e2) => {
      o[e2] = { get: () => n[e2], set: (t2) => {
        n[e2] = t2;
      } };
    }), Object.defineProperties(t, o), t;
  };
  var listenOpts = { hasPassive: false, passiveCapture: true, notPassiveCapture: true };
  try {
    const e = Object.defineProperty({}, "passive", { get() {
      Object.assign(listenOpts, { hasPassive: true, passive: { passive: true }, notPassive: { passive: false }, passiveCapture: { passive: true, capture: true }, notPassiveCapture: { passive: false, capture: true } });
    } });
    window.addEventListener("qtest", null, e), window.removeEventListener("qtest", null, e);
  } catch (e) {
  }
  function noop() {
  }
  function leftClick(e) {
    return e.button === 0;
  }
  function middleClick(e) {
    return e.button === 1;
  }
  function rightClick(e) {
    return e.button === 2;
  }
  function position(e) {
    return e.touches && e.touches[0] ? e = e.touches[0] : e.changedTouches && e.changedTouches[0] ? e = e.changedTouches[0] : e.targetTouches && e.targetTouches[0] && (e = e.targetTouches[0]), { top: e.clientY, left: e.clientX };
  }
  function getEventPath(e) {
    if (e.path)
      return e.path;
    if (e.composedPath)
      return e.composedPath();
    const t = [];
    let o = e.target;
    while (o) {
      if (t.push(o), o.tagName === "HTML")
        return t.push(document), t.push(window), t;
      o = o.parentElement;
    }
  }
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;
  function getMouseWheelDistance(e) {
    let t = e.deltaX, o = e.deltaY;
    if ((t || o) && e.deltaMode) {
      const n = e.deltaMode === 1 ? LINE_HEIGHT : PAGE_HEIGHT;
      t *= n, o *= n;
    }
    return e.shiftKey && !t && ([o, t] = [t, o]), { x: t, y: o };
  }
  function stop2(e) {
    e.stopPropagation();
  }
  function prevent(e) {
    e.cancelable !== false && e.preventDefault();
  }
  function stopAndPrevent(e) {
    e.cancelable !== false && e.preventDefault(), e.stopPropagation();
  }
  function preventDraggable(e, t) {
    if (e === void 0 || t === true && e.__dragPrevented === true)
      return;
    const o = t === true ? (e2) => {
      e2.__dragPrevented = true, e2.addEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
    } : (e2) => {
      delete e2.__dragPrevented, e2.removeEventListener("dragstart", prevent, listenOpts.notPassiveCapture);
    };
    e.querySelectorAll("a, img").forEach(o);
  }
  function addEvt(e, t, o) {
    const n = `__q_${t}_evt`;
    e[n] = e[n] !== void 0 ? e[n].concat(o) : o, o.forEach((t2) => {
      t2[0].addEventListener(t2[1], e[t2[2]], listenOpts[t2[3]]);
    });
  }
  function cleanEvt(e, t) {
    const o = `__q_${t}_evt`;
    e[o] !== void 0 && (e[o].forEach((t2) => {
      t2[0].removeEventListener(t2[1], e[t2[2]], listenOpts[t2[3]]);
    }), e[o] = void 0);
  }
  var event2 = { listenOpts, leftClick, middleClick, rightClick, position, getEventPath, getMouseWheelDistance, stop: stop2, prevent, stopAndPrevent, preventDraggable };
  function debounce(e, t = 250, o) {
    let n;
    function a() {
      const a2 = arguments, l = () => {
        n = void 0, o !== true && e.apply(this, a2);
      };
      clearTimeout(n), o === true && n === void 0 && e.apply(this, a2), n = setTimeout(l, t);
    }
    return a.cancel = () => {
      clearTimeout(n);
    }, a;
  }
  var SIZE_LIST = ["sm", "md", "lg", "xl"];
  var { passive: passive$3 } = listenOpts;
  var Screen2 = defineReactivePlugin({ width: 0, height: 0, name: "xs", sizes: { sm: 600, md: 1024, lg: 1440, xl: 1920 }, lt: { sm: true, md: true, lg: true, xl: true }, gt: { xs: false, sm: false, md: false, lg: false }, xs: true, sm: false, md: false, lg: false, xl: false }, { setSizes: noop, setDebounce: noop, install({ $q: e, onSSRHydrated: t }) {
    if (e.screen = this, this.__installed === true)
      return void (e.config.screen !== void 0 && (e.config.screen.bodyClasses === false ? document.body.classList.remove(`screen--${this.name}`) : this.__update(true)));
    const o = e.config.screen !== void 0 && e.config.screen.bodyClasses === true;
    this.__update = (e2) => {
      const t2 = window.innerWidth, n2 = window.innerHeight;
      if (n2 !== this.height && (this.height = n2), t2 !== this.width)
        this.width = t2;
      else if (e2 !== true)
        return;
      let a2 = this.sizes;
      this.gt.xs = t2 >= a2.sm, this.gt.sm = t2 >= a2.md, this.gt.md = t2 >= a2.lg, this.gt.lg = t2 >= a2.xl, this.lt.sm = t2 < a2.sm, this.lt.md = t2 < a2.md, this.lt.lg = t2 < a2.lg, this.lt.xl = t2 < a2.xl, this.xs = this.lt.sm, this.sm = this.gt.xs === true && this.lt.md === true, this.md = this.gt.sm === true && this.lt.lg === true, this.lg = this.gt.md === true && this.lt.xl === true, this.xl = this.gt.lg, a2 = (this.xs === true ? "xs" : this.sm === true && "sm") || this.md === true && "md" || this.lg === true && "lg" || "xl", a2 !== this.name && (o === true && (document.body.classList.remove(`screen--${this.name}`), document.body.classList.add(`screen--${a2}`)), this.name = a2);
    };
    let n, a = {}, l = 16;
    this.setSizes = (e2) => {
      SIZE_LIST.forEach((t2) => {
        e2[t2] !== void 0 && (a[t2] = e2[t2]);
      });
    }, this.setDebounce = (e2) => {
      l = e2;
    };
    const i = () => {
      const e2 = getComputedStyle(document.body), t2 = window.visualViewport !== void 0 ? window.visualViewport : window;
      e2.getPropertyValue("--q-size-sm") && SIZE_LIST.forEach((t3) => {
        this.sizes[t3] = parseInt(e2.getPropertyValue(`--q-size-${t3}`), 10);
      }), this.setSizes = (e3) => {
        SIZE_LIST.forEach((t3) => {
          e3[t3] && (this.sizes[t3] = e3[t3]);
        }), this.__update(true);
      }, this.setDebounce = (e3) => {
        n !== void 0 && t2.removeEventListener("resize", n, passive$3), n = e3 > 0 ? debounce(this.__update, e3) : this.__update, t2.addEventListener("resize", n, passive$3);
      }, this.setDebounce(l), Object.keys(a).length > 0 ? (this.setSizes(a), a = void 0) : this.__update(), o === true && this.name === "xs" && document.body.classList.add("screen--xs");
    };
    isRuntimeSsrPreHydration.value === true ? t.push(i) : i();
  } });
  var Plugin$8 = defineReactivePlugin({ isActive: false, mode: false }, { __media: void 0, set(e) {
    Plugin$8.mode = e, e === "auto" ? (Plugin$8.__media === void 0 && (Plugin$8.__media = window.matchMedia("(prefers-color-scheme: dark)"), Plugin$8.__updateMedia = () => {
      Plugin$8.set("auto");
    }, Plugin$8.__media.addListener(Plugin$8.__updateMedia)), e = Plugin$8.__media.matches) : Plugin$8.__media !== void 0 && (Plugin$8.__media.removeListener(Plugin$8.__updateMedia), Plugin$8.__media = void 0), Plugin$8.isActive = e === true, document.body.classList.remove(`body--${e === true ? "light" : "dark"}`), document.body.classList.add(`body--${e === true ? "dark" : "light"}`);
  }, toggle() {
    Plugin$8.set(Plugin$8.isActive === false);
  }, install({ $q: e, onSSRHydrated: t, ssrContext: o }) {
    const { dark: n } = e.config;
    if (e.dark = this, this.__installed === true && n === void 0)
      return;
    this.isActive = n === true;
    const a = n !== void 0 && n;
    if (isRuntimeSsrPreHydration.value === true) {
      const e2 = (e3) => {
        this.__fromSSR = e3;
      }, o2 = this.set;
      this.set = e2, e2(a), t.push(() => {
        this.set = o2, this.set(this.__fromSSR);
      });
    } else
      this.set(a);
  } });
  var getTrue = () => true;
  function filterInvalidPath(e) {
    return typeof e === "string" && e !== "" && e !== "/" && e !== "#/";
  }
  function normalizeExitPath(e) {
    return e.startsWith("#") === true && (e = e.substr(1)), e.startsWith("/") === false && (e = "/" + e), e.endsWith("/") === true && (e = e.substr(0, e.length - 1)), "#" + e;
  }
  function getShouldExitFn(e) {
    if (e.backButtonExit === false)
      return () => false;
    if (e.backButtonExit === "*")
      return getTrue;
    const t = ["#/"];
    return Array.isArray(e.backButtonExit) === true && t.push(...e.backButtonExit.filter(filterInvalidPath).map(normalizeExitPath)), () => t.includes(window.location.hash);
  }
  var History = { __history: [], add: noop, remove: noop, install({ $q: e }) {
    if (this.__installed === true)
      return;
    const { cordova: t, capacitor: o } = client2.is;
    if (t !== true && o !== true)
      return;
    const n = e.config[t === true ? "cordova" : "capacitor"];
    if (n !== void 0 && n.backButton === false)
      return;
    if (o === true && (window.Capacitor === void 0 || window.Capacitor.Plugins.App === void 0))
      return;
    this.add = (e2) => {
      e2.condition === void 0 && (e2.condition = getTrue), this.__history.push(e2);
    }, this.remove = (e2) => {
      const t2 = this.__history.indexOf(e2);
      t2 >= 0 && this.__history.splice(t2, 1);
    };
    const a = getShouldExitFn(Object.assign({ backButtonExit: true }, n)), l = () => {
      if (this.__history.length) {
        const e2 = this.__history[this.__history.length - 1];
        e2.condition() === true && (this.__history.pop(), e2.handler());
      } else
        a() === true ? navigator.app.exitApp() : window.history.back();
    };
    t === true ? document.addEventListener("deviceready", () => {
      document.addEventListener("backbutton", l, false);
    }) : window.Capacitor.Plugins.App.addListener("backButton", l);
  } };
  var langEn = { isoName: "en-US", nativeName: "English (US)", label: { clear: "Clear", ok: "OK", cancel: "Cancel", close: "Close", set: "Set", select: "Select", reset: "Reset", remove: "Remove", update: "Update", create: "Create", search: "Search", filter: "Filter", refresh: "Refresh" }, date: { days: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), daysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), firstDayOfWeek: 0, format24h: false, pluralDay: "days" }, table: { noData: "No data available", noResults: "No matching records found", loading: "Loading...", selectedRecords: (e) => e === 1 ? "1 record selected." : (e === 0 ? "No" : e) + " records selected.", recordsPerPage: "Records per page:", allRows: "All", pagination: (e, t, o) => e + "-" + t + " of " + o, columns: "Columns" }, editor: { url: "URL", bold: "Bold", italic: "Italic", strikethrough: "Strikethrough", underline: "Underline", unorderedList: "Unordered List", orderedList: "Ordered List", subscript: "Subscript", superscript: "Superscript", hyperlink: "Hyperlink", toggleFullscreen: "Toggle Fullscreen", quote: "Quote", left: "Left align", center: "Center align", right: "Right align", justify: "Justify align", print: "Print", outdent: "Decrease indentation", indent: "Increase indentation", removeFormat: "Remove formatting", formatting: "Formatting", fontSize: "Font Size", align: "Align", hr: "Insert Horizontal Rule", undo: "Undo", redo: "Redo", heading1: "Heading 1", heading2: "Heading 2", heading3: "Heading 3", heading4: "Heading 4", heading5: "Heading 5", heading6: "Heading 6", paragraph: "Paragraph", code: "Code", size1: "Very small", size2: "A bit small", size3: "Normal", size4: "Medium-large", size5: "Big", size6: "Very big", size7: "Maximum", defaultFont: "Default Font", viewSource: "View Source" }, tree: { noNodes: "No nodes available", noResults: "No matching nodes found" } };
  function getLocale() {
    const e = Array.isArray(navigator.languages) === true && navigator.languages.length > 0 ? navigator.languages[0] : navigator.language;
    if (typeof e === "string")
      return e.split(/[-_]/).map((e2, t) => t === 0 ? e2.toLowerCase() : t > 1 || e2.length < 4 ? e2.toUpperCase() : e2[0].toUpperCase() + e2.slice(1).toLowerCase()).join("-");
  }
  var Plugin$7 = defineReactivePlugin({ __langPack: {} }, { getLocale, set(e = langEn, t) {
    const o = { ...e, rtl: e.rtl === true, getLocale };
    {
      const e2 = document.documentElement;
      e2.setAttribute("dir", o.rtl === true ? "rtl" : "ltr"), e2.setAttribute("lang", o.isoName), o.set = Plugin$7.set, Object.assign(Plugin$7.__langPack, o), Plugin$7.props = o, Plugin$7.isoName = o.isoName, Plugin$7.nativeName = o.nativeName;
    }
  }, install({ $q: e, lang: t, ssrContext: o }) {
    e.lang = Plugin$7.__langPack, this.__installed === true ? t !== void 0 && this.set(t) : this.set(t || langEn);
  } });
  function setCssVar(e, t, o = document.body) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string as propName");
    if (typeof t !== "string")
      throw new TypeError("Expected a string as value");
    if (!(o instanceof Element))
      throw new TypeError("Expected a DOM element");
    o.style.setProperty(`--q-${e}`, t);
  }
  var lastKeyCompositionStatus = false;
  function onKeyDownComposition(e) {
    lastKeyCompositionStatus = e.isComposing === true;
  }
  function shouldIgnoreKey(e) {
    return lastKeyCompositionStatus === true || e !== Object(e) || e.isComposing === true || e.qKeyEvent === true;
  }
  function isKeyCode(e, t) {
    return shouldIgnoreKey(e) !== true && [].concat(t).includes(e.keyCode);
  }
  function getMobilePlatform(e) {
    return e.ios === true ? "ios" : e.android === true ? "android" : void 0;
  }
  function getBodyClasses({ is: e, has: t, within: o }, n) {
    const a = [e.desktop === true ? "desktop" : "mobile", `${t.touch === false ? "no-" : ""}touch`];
    if (e.mobile === true) {
      const t2 = getMobilePlatform(e);
      t2 !== void 0 && a.push("platform-" + t2);
    }
    if (e.nativeMobile === true) {
      const t2 = e.nativeMobileWrapper;
      a.push(t2), a.push("native-mobile"), e.ios !== true || n[t2] !== void 0 && n[t2].iosStatusBarPadding === false || a.push("q-ios-padding");
    } else
      e.electron === true ? a.push("electron") : e.bex === true && a.push("bex");
    return o.iframe === true && a.push("within-iframe"), a;
  }
  function applyClientSsrCorrections() {
    const e = document.body.className;
    let t = e;
    iosCorrection !== void 0 && (t = t.replace("desktop", "platform-ios mobile")), client2.has.touch === true && (t = t.replace("no-touch", "touch")), client2.within.iframe === true && (t += " within-iframe"), e !== t && (document.body.className = t);
  }
  function setColors(e) {
    for (const t in e)
      setCssVar(t, e[t]);
  }
  var Body = { install(e) {
    const { $q: t } = e;
    if (t.config.brand !== void 0 && setColors(t.config.brand), this.__installed !== true) {
      if (isRuntimeSsrPreHydration.value === true)
        applyClientSsrCorrections();
      else {
        const e2 = getBodyClasses(client2, t.config);
        document.body.classList.add.apply(document.body.classList, e2);
      }
      client2.is.ios === true && document.body.addEventListener("touchstart", noop), window.addEventListener("keydown", onKeyDownComposition, true);
    }
  } };
  var materialIcons = { name: "material-icons", type: { positive: "check_circle", negative: "warning", info: "info", warning: "priority_high" }, arrow: { up: "arrow_upward", right: "arrow_forward", down: "arrow_downward", left: "arrow_back", dropdown: "arrow_drop_down" }, chevron: { left: "chevron_left", right: "chevron_right" }, colorPicker: { spectrum: "gradient", tune: "tune", palette: "style" }, pullToRefresh: { icon: "refresh" }, carousel: { left: "chevron_left", right: "chevron_right", up: "keyboard_arrow_up", down: "keyboard_arrow_down", navigationIcon: "lens" }, chip: { remove: "cancel", selected: "check" }, datetime: { arrowLeft: "chevron_left", arrowRight: "chevron_right", now: "access_time", today: "today" }, editor: { bold: "format_bold", italic: "format_italic", strikethrough: "strikethrough_s", underline: "format_underlined", unorderedList: "format_list_bulleted", orderedList: "format_list_numbered", subscript: "vertical_align_bottom", superscript: "vertical_align_top", hyperlink: "link", toggleFullscreen: "fullscreen", quote: "format_quote", left: "format_align_left", center: "format_align_center", right: "format_align_right", justify: "format_align_justify", print: "print", outdent: "format_indent_decrease", indent: "format_indent_increase", removeFormat: "format_clear", formatting: "text_format", fontSize: "format_size", align: "format_align_left", hr: "remove", undo: "undo", redo: "redo", heading: "format_size", code: "code", size: "format_size", font: "font_download", viewSource: "code" }, expansionItem: { icon: "keyboard_arrow_down", denseIcon: "arrow_drop_down" }, fab: { icon: "add", activeIcon: "close" }, field: { clear: "cancel", error: "error" }, pagination: { first: "first_page", prev: "keyboard_arrow_left", next: "keyboard_arrow_right", last: "last_page" }, rating: { icon: "grade" }, stepper: { done: "check", active: "edit", error: "warning" }, tabs: { left: "chevron_left", right: "chevron_right", up: "keyboard_arrow_up", down: "keyboard_arrow_down" }, table: { arrowUp: "arrow_upward", warning: "warning", firstPage: "first_page", prevPage: "chevron_left", nextPage: "chevron_right", lastPage: "last_page" }, tree: { icon: "play_arrow" }, uploader: { done: "done", clear: "clear", add: "add_box", upload: "cloud_upload", removeQueue: "clear_all", removeUploaded: "done_all" } };
  var Plugin$6 = defineReactivePlugin({ iconMapFn: null, __icons: {} }, { set(e, t) {
    const o = { ...e, rtl: e.rtl === true };
    o.set = Plugin$6.set, Object.assign(Plugin$6.__icons, o);
  }, install({ $q: e, iconSet: t, ssrContext: o }) {
    e.config.iconMapFn !== void 0 && (this.iconMapFn = e.config.iconMapFn), e.iconSet = this.__icons, Object.defineProperty(e, "iconMapFn", { get: () => this.iconMapFn, set: (e2) => {
      this.iconMapFn = e2;
    } }), this.__installed === true ? t !== void 0 && this.set(t) : this.set(t || materialIcons);
  } });
  var quasarKey = "_q_";
  var timelineKey = "_q_t_";
  var stepperKey = "_q_s_";
  var layoutKey = "_q_l_";
  var pageContainerKey = "_q_pc_";
  var fabKey = "_q_f_";
  var formKey = "_q_fo_";
  var tabsKey = "_q_tabs_";
  var uploaderKey = "_q_u_";
  var globalConfig = {};
  var globalConfigIsFrozen = false;
  function freezeGlobalConfig() {
    globalConfigIsFrozen = true;
  }
  var autoInstalledPlugins = [Platform, Body, Plugin$8, Screen2, History, Plugin$7, Plugin$6];
  function createChildApp(e, t) {
    const o = createApp2(e);
    o.config.globalProperties = t.config.globalProperties;
    const { reload: n, ...a } = t._context;
    return Object.assign(o._context, a), o;
  }
  function installPlugins(e, t) {
    t.forEach((t2) => {
      t2.install(e), t2.__installed = true;
    });
  }
  function prepareApp(e, t, o) {
    e.config.globalProperties.$q = o.$q, e.provide(quasarKey, o.$q), installPlugins(o, autoInstalledPlugins), t.components !== void 0 && Object.values(t.components).forEach((t2) => {
      Object(t2) === t2 && t2.name !== void 0 && e.component(t2.name, t2);
    }), t.directives !== void 0 && Object.values(t.directives).forEach((t2) => {
      Object(t2) === t2 && t2.name !== void 0 && e.directive(t2.name, t2);
    }), t.plugins !== void 0 && installPlugins(o, Object.values(t.plugins).filter((e2) => typeof e2.install === "function" && autoInstalledPlugins.includes(e2) === false)), isRuntimeSsrPreHydration.value === true && (o.$q.onSSRHydrated = () => {
      o.onSSRHydrated.forEach((e2) => {
        e2();
      }), o.$q.onSSRHydrated = () => {
      };
    });
  }
  var installQuasar = function(e, t = {}) {
    const o = { version: "2.0.0-rc.3" };
    globalConfigIsFrozen === false ? (t.config !== void 0 && Object.assign(globalConfig, t.config), o.config = { ...globalConfig }, freezeGlobalConfig()) : o.config = t.config || {}, prepareApp(e, t, { parentApp: e, $q: o, lang: t.lang, iconSet: t.iconSet, onSSRHydrated: [] });
  };
  var units = ["B", "KB", "MB", "GB", "TB", "PB"];
  function humanStorageSize(e) {
    let t = 0;
    while (parseInt(e, 10) >= 1024 && t < units.length - 1)
      e /= 1024, ++t;
    return `${e.toFixed(1)}${units[t]}`;
  }
  function capitalize2(e) {
    return e.charAt(0).toUpperCase() + e.slice(1);
  }
  function between(e, t, o) {
    return o <= t ? t : Math.min(o, Math.max(t, e));
  }
  function normalizeToInterval(e, t, o) {
    if (o <= t)
      return t;
    const n = o - t + 1;
    let a = t + (e - t) % n;
    return a < t && (a = n + a), a === 0 ? 0 : a;
  }
  function pad(e, t = 2, o = "0") {
    if (e === void 0 || e === null)
      return e;
    const n = "" + e;
    return n.length >= t ? n : new Array(t - n.length + 1).join(o) + n;
  }
  var format = { humanStorageSize, capitalize: capitalize2, between, normalizeToInterval, pad };
  var xhr = XMLHttpRequest;
  var send = xhr.prototype.send;
  var stackStart = [];
  var stackStop = [];
  var highjackCount = 0;
  function translate({ p: e, pos: t, active: o, horiz: n, reverse: a, dir: l }) {
    let i = 1, r = 1;
    return n ? (a && (i = -1), t === "bottom" && (r = -1), { transform: `translate3d(${i * (e - 100)}%,${o ? 0 : -200 * r}%,0)` }) : (a && (r = -1), t === "right" && (i = -1), { transform: `translate3d(${o ? 0 : l * i * -200}%,${r * (e - 100)}%,0)` });
  }
  function inc(e, t) {
    return typeof t !== "number" && (t = e < 25 ? 3 * Math.random() + 3 : e < 65 ? 3 * Math.random() : e < 85 ? 2 * Math.random() : e < 99 ? 0.6 : 0), between(e + t, 0, 100);
  }
  function highjackAjax(e, t) {
    function o() {
      stackStop.forEach((e2) => {
        e2();
      });
    }
    stackStart.push(e), stackStop.push(t), highjackCount++, highjackCount > 1 || (xhr.prototype.send = function() {
      stackStart.forEach((e2) => {
        e2();
      }), this.addEventListener("loadend", o, false), send.apply(this, arguments);
    });
  }
  function restoreAjax(e, t) {
    stackStart.splice(stackStart.indexOf(e), 1), stackStop.splice(stackStop.indexOf(t), 1), highjackCount = Math.max(0, highjackCount - 1), highjackCount === 0 && (xhr.prototype.send = send);
  }
  var QAjaxBar = defineComponent2({ name: "QAjaxBar", props: { position: { type: String, default: "top", validator: (e) => ["top", "right", "bottom", "left"].includes(e) }, size: { type: String, default: "2px" }, color: String, skipHijack: Boolean, reverse: Boolean }, emits: ["start", "stop"], setup(e, { emit: t }) {
    const { proxy: o } = getCurrentInstance(), n = ref(0), a = ref(false), l = ref(true);
    let i, r, s2 = 0;
    const u = computed2(() => `q-loading-bar q-loading-bar--${e.position}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (l.value === true ? "" : " no-transition")), c = computed2(() => e.position === "top" || e.position === "bottom"), d = computed2(() => c.value === true ? "height" : "width"), p2 = computed2(() => {
      const t2 = a.value, l2 = translate({ p: n.value, pos: e.position, active: t2, horiz: c.value, reverse: o.$q.lang.rtl === true && ["top", "bottom"].includes(e.position) ? !e.reverse : e.reverse, dir: o.$q.lang.rtl === true ? -1 : 1 });
      return l2[d.value] = e.size, l2.opacity = t2 ? 1 : 0, l2;
    }), v = computed2(() => a.value === true ? { role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": n.value } : { "aria-hidden": "true" });
    function m(e2 = 300) {
      const o2 = r;
      r = Math.max(0, e2) || 0, s2++, s2 > 1 ? o2 === 0 && e2 > 0 ? b() : o2 > 0 && e2 <= 0 && clearTimeout(i) : (clearTimeout(i), t("start"), n.value = 0, a.value !== true && (a.value = true, l.value = false, i = setTimeout(() => {
        l.value = true, e2 > 0 && b();
      }, 100)));
    }
    function f(e2) {
      s2 > 0 && (n.value = inc(n.value, e2));
    }
    function g() {
      if (s2 = Math.max(0, s2 - 1), s2 > 0)
        return;
      clearTimeout(i), t("stop");
      const e2 = () => {
        l.value = true, n.value = 100, i = setTimeout(() => {
          a.value = false;
        }, 1e3);
      };
      n.value === 0 ? i = setTimeout(e2, 1) : e2();
    }
    function b() {
      n.value < 100 && (i = setTimeout(() => {
        f(), b();
      }, r));
    }
    let y;
    return onMounted2(() => {
      e.skipHijack !== true && (y = true, highjackAjax(m, g));
    }), onBeforeUnmount2(() => {
      clearTimeout(i), y === true && restoreAjax(m, g);
    }), Object.assign(o, { start: m, stop: g, increment: f }), () => h("div", { class: u.value, style: p2.value, ...v.value });
  } });
  var useSizeDefaults = { xs: 18, sm: 24, md: 32, lg: 38, xl: 46 };
  var useSizeProps = { size: String };
  function useSize(e, t = useSizeDefaults) {
    return computed2(() => e.size !== void 0 ? { fontSize: e.size in t ? `${t[e.size]}px` : e.size } : null);
  }
  function hSlot(e, t) {
    return e !== void 0 ? e() : t;
  }
  function hUniqueSlot(e, t) {
    return e !== void 0 ? e().slice() : t;
  }
  function hMergeSlot(e, t) {
    return e !== void 0 ? t.concat(e()) : t;
  }
  function hMergeSlotSafely(e, t) {
    return e === void 0 ? t : t !== void 0 ? t.concat(e()) : e();
  }
  function hDir(e, t, o, n, a, l) {
    t.key = n + a;
    const i = h(e, t, o);
    return a === true ? withDirectives(i, l()) : i;
  }
  var sameFn = (e) => e;
  var ionFn = (e) => `ionicons ${e}`;
  var libMap = { "icon-": sameFn, "bt-": (e) => `bt ${e}`, "eva-": (e) => `eva ${e}`, "ion-md": ionFn, "ion-ios": ionFn, "ion-logo": ionFn, "mdi-": (e) => `mdi ${e}`, "iconfont ": sameFn, "ti-": (e) => `themify-icon ${e}`, "bi-": (e) => `bootstrap-icons ${e}` };
  var matMap = { o_: "-outlined", r_: "-round", s_: "-sharp" };
  var libRE = new RegExp("^(" + Object.keys(libMap).join("|") + ")");
  var matRE = new RegExp("^(" + Object.keys(matMap).join("|") + ")");
  var mRE = /^M/;
  var imgRE = /^img:/;
  var svgUseRE = /^svguse:/;
  var ionRE = /^ion-/;
  var faLaRE = /^[l|f]a[s|r|l|b|d]? /;
  var QIcon = defineComponent2({ name: "QIcon", props: { ...useSizeProps, tag: { type: String, default: "i" }, name: String, color: String, left: Boolean, right: Boolean }, setup(e, { slots: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = useSize(e), a = computed2(() => "q-icon" + (e.left === true ? " on-left" : "") + (e.right === true ? " on-right" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")), l = computed2(() => {
      let t2, n2 = e.name;
      if (!n2)
        return { none: true, cls: a.value };
      if (o.iconMapFn !== null) {
        const e2 = o.iconMapFn(n2);
        if (e2 !== void 0) {
          if (e2.icon === void 0)
            return { cls: e2.cls + " " + a.value, content: e2.content !== void 0 ? e2.content : " " };
          n2 = e2.icon;
        }
      }
      if (mRE.test(n2) === true) {
        const [e2, t3] = n2.split("|");
        return { svg: true, cls: a.value, nodes: e2.split("&&").map((e3) => {
          const [t4, o2, n3] = e3.split("@@");
          return h("path", { style: o2, d: t4, transform: n3 });
        }), viewBox: t3 !== void 0 ? t3 : "0 0 24 24" };
      }
      if (imgRE.test(n2) === true)
        return { img: true, cls: a.value, src: n2.substring(4) };
      if (svgUseRE.test(n2) === true) {
        const [e2, t3] = n2.split("|");
        return { svguse: true, cls: a.value, src: e2.substring(7), viewBox: t3 !== void 0 ? t3 : "0 0 24 24" };
      }
      let l2 = " ";
      const i = n2.match(libRE);
      if (i !== null)
        t2 = libMap[i[1]](n2);
      else if (faLaRE.test(n2) === true)
        t2 = n2;
      else if (ionRE.test(n2) === true)
        t2 = `ionicons ion-${o.platform.is.ios === true ? "ios" : "md"}${n2.substr(3)}`;
      else {
        t2 = "notranslate material-icons";
        const e2 = n2.match(matRE);
        e2 !== null && (n2 = n2.substring(2), t2 += matMap[e2[1]]), l2 = n2;
      }
      return { cls: t2 + " " + a.value, content: l2 };
    });
    return () => {
      const o2 = { class: l.value.cls, style: n.value, "aria-hidden": "true", role: "presentation" };
      return l.value.none === true ? h(e.tag, o2, hSlot(t.default)) : l.value.img === true ? (o2.src = l.value.src, h("img", o2)) : l.value.svg === true ? (o2.viewBox = l.value.viewBox, h("svg", o2, hMergeSlot(t.default, l.value.nodes))) : l.value.svguse === true ? (o2.viewBox = l.value.viewBox, h("svg", o2, hMergeSlot(t.default, [h("use", { "xlink:href": l.value.src })]))) : h(e.tag, o2, hMergeSlot(t.default, [l.value.content]));
    };
  } });
  var QAvatar = defineComponent2({ name: "QAvatar", props: { ...useSizeProps, fontSize: String, color: String, textColor: String, icon: String, square: Boolean, rounded: Boolean }, setup(e, { slots: t }) {
    const o = useSize(e), n = computed2(() => "q-avatar" + (e.color ? ` bg-${e.color}` : "") + (e.textColor ? ` text-${e.textColor} q-chip--colored` : "") + (e.square === true ? " q-avatar--square" : e.rounded === true ? " rounded-borders" : "")), a = computed2(() => e.fontSize ? { fontSize: e.fontSize } : null);
    return () => {
      const l = e.icon !== void 0 ? [h(QIcon, { name: e.icon })] : void 0;
      return h("div", { class: n.value, style: o.value }, [h("div", { class: "q-avatar__content row flex-center overflow-hidden", style: a.value }, hMergeSlotSafely(t.default, l))]);
    };
  } });
  var alignValues$3 = ["top", "middle", "bottom"];
  var QBadge = defineComponent2({ name: "QBadge", props: { color: String, textColor: String, floating: Boolean, transparent: Boolean, multiLine: Boolean, outline: Boolean, rounded: Boolean, label: [Number, String], align: { type: String, validator: (e) => alignValues$3.includes(e) } }, setup(e, { slots: t }) {
    const o = computed2(() => {
      return e.align !== void 0 ? { verticalAlign: e.align } : null;
    }), n = computed2(() => {
      const t2 = e.outline === true && e.color || e.textColor;
      return `q-badge flex inline items-center no-wrap q-badge--${e.multiLine === true ? "multi" : "single"}-line` + (e.outline === true ? " q-badge--outline" : e.color !== void 0 ? ` bg-${e.color}` : "") + (t2 !== void 0 ? ` text-${t2}` : "") + (e.floating === true ? " q-badge--floating" : "") + (e.rounded === true ? " q-badge--rounded" : "") + (e.transparent === true ? " q-badge--transparent" : "");
    });
    return () => h("div", { class: n.value, style: o.value, role: "alert", "aria-label": e.label }, e.label !== void 0 ? e.label : hSlot(t.default));
  } });
  var useDarkProps = { dark: { type: Boolean, default: null } };
  function useDark(e, t) {
    return computed2(() => e.dark === null ? t.dark.isActive : e.dark);
  }
  var QBanner = defineComponent2({ name: "QBanner", props: { ...useDarkProps, inlineActions: Boolean, dense: Boolean, rounded: Boolean }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => "q-banner row items-center" + (e.dense === true ? " q-banner--dense" : "") + (n.value === true ? " q-banner--dark q-dark" : "") + (e.rounded === true ? " rounded-borders" : "")), l = computed2(() => `q-banner__actions row items-center justify-end col-${e.inlineActions === true ? "auto" : "all"}`);
    return () => {
      const o2 = [h("div", { class: "q-banner__avatar col-auto row items-center self-start" }, hSlot(t.avatar)), h("div", { class: "q-banner__content col text-body2" }, hSlot(t.default))], n2 = hSlot(t.action);
      return n2 !== void 0 && o2.push(h("div", { class: l.value }, n2)), h("div", { class: a.value + (e.inlineActions === false && n2 !== void 0 ? " q-banner--top-padding" : ""), role: "alert" }, o2);
    };
  } });
  var QBar = defineComponent2({ name: "QBar", props: { ...useDarkProps, dense: Boolean }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => `q-bar row no-wrap items-center q-bar--${e.dense === true ? "dense" : "standard"}  q-bar--${n.value === true ? "dark" : "light"}`);
    return () => h("div", { class: a.value, role: "toolbar" }, hSlot(t.default));
  } });
  var alignMap = { left: "start", center: "center", right: "end", between: "between", around: "around", evenly: "evenly", stretch: "stretch" };
  var alignValues$2 = Object.keys(alignMap);
  var useAlignProps = { align: { type: String, validator: (e) => alignValues$2.includes(e) } };
  function useAlign(e) {
    return computed2(() => {
      const t = e.align === void 0 ? e.vertical === true ? "stretch" : "left" : e.align;
      return `${e.vertical === true ? "items" : "justify"}-${alignMap[t]}`;
    });
  }
  function getParentVm(e) {
    if (e.$parent !== void 0 && e.$parent !== null)
      return e.$parent;
    e = e.$.parent;
    while (e !== void 0 && e !== null) {
      if (e.proxy !== void 0 && e.proxy !== null)
        return e.proxy;
      e = e.parent;
    }
  }
  function getNormalizedVNodes(e) {
    const t = new Set();
    return e.forEach((e2) => {
      typeof e2.type === "symbol" && Array.isArray(e2.children) === true ? e2.children.forEach((e3) => {
        t.add(e3);
      }) : t.add(e2);
    }), Array.from(t);
  }
  function vmHasRouter(e) {
    return e.appContext.config.globalProperties.$router !== void 0;
  }
  var QBreadcrumbs = defineComponent2({ name: "QBreadcrumbs", props: { ...useAlignProps, separator: { type: String, default: "/" }, separatorColor: String, activeColor: { type: String, default: "primary" }, gutter: { type: String, validator: (e) => ["none", "xs", "sm", "md", "lg", "xl"].includes(e), default: "sm" } }, setup(e, { slots: t }) {
    const o = useAlign(e), n = computed2(() => `flex items-center ${o.value}${e.gutter === "none" ? "" : ` q-gutter-${e.gutter}`}`), a = computed2(() => e.separatorColor ? ` text-${e.separatorColor}` : ""), l = computed2(() => `text-${e.activeColor}`);
    return () => {
      const o2 = getNormalizedVNodes(hSlot(t.default));
      if (o2 === void 0)
        return;
      let i = 1;
      const r = [], s2 = o2.filter((e2) => e2.type !== void 0 && e2.type.name === "QBreadcrumbsEl").length, u = t.separator !== void 0 ? t.separator : () => e.separator;
      return o2.forEach((e2) => {
        if (e2.type !== void 0 && e2.type.name === "QBreadcrumbsEl") {
          const t2 = i < s2;
          i++, r.push(h("div", { class: "flex items-center " + (t2 === true ? l.value : "q-breadcrumbs--last") }, [e2])), t2 === true && r.push(h("div", { class: "q-breadcrumbs__separator" + a.value }, u()));
        } else
          r.push(e2);
      }), h("div", { class: "q-breadcrumbs" }, [h("div", { class: n.value }, r)]);
    };
  } });
  function getOriginalPath(e) {
    return e ? e.aliasOf ? e.aliasOf.path : e.path : "";
  }
  function isSameRouteRecord(e, t) {
    return (e.aliasOf || e) === (t.aliasOf || t);
  }
  function includesParams(e, t) {
    for (const o in t) {
      const n = t[o], a = e[o];
      if (typeof n === "string") {
        if (n !== a)
          return false;
      } else if (Array.isArray(a) === false || a.length !== n.length || n.some((e2, t2) => e2 !== a[t2]))
        return false;
    }
    return true;
  }
  var useRouterLinkProps = { to: [String, Object], replace: Boolean, exact: Boolean, activeClass: { type: String, default: "q-router-link--active" }, exactActiveClass: { type: String, default: "q-router-link--exact-active" }, disable: Boolean };
  function useRouterLink() {
    const e = getCurrentInstance(), { props: t, attrs: o, proxy: n } = e, a = vmHasRouter(e), l = computed2(() => a === true && t.disable !== true && t.to !== void 0 && t.to !== null && t.to !== ""), i = computed2(() => l.value === true ? "a" : t.tag || "div"), r = computed2(() => l.value === true ? n.$router.resolve(t.to) : null), s2 = computed2(() => {
      if (l.value === false)
        return null;
      const { matched: e2 } = r.value, { length: t2 } = e2, o2 = e2[t2 - 1];
      if (o2 === void 0)
        return -1;
      const a2 = n.$route.matched;
      if (a2.length === 0)
        return -1;
      const i2 = a2.findIndex(isSameRouteRecord.bind(null, o2));
      if (i2 > -1)
        return i2;
      const s3 = getOriginalPath(e2[t2 - 2]);
      return t2 > 1 && getOriginalPath(o2) === s3 && a2[a2.length - 1].path !== s3 ? a2.findIndex(isSameRouteRecord.bind(null, e2[t2 - 2])) : i2;
    }), u = computed2(() => l.value === true && s2.value > -1 && includesParams(n.$route.params, r.value.params)), c = computed2(() => u.value === true && s2.value === n.$route.matched.length - 1), d = computed2(() => l.value === true ? c.value === true ? ` ${t.exactActiveClass} ${t.activeClass}` : t.exact === true ? "" : u.value === true ? ` ${t.activeClass}` : "" : ""), p2 = computed2(() => l.value === true ? { href: r.value.href, target: o.target, role: "link" } : {});
    function v(e2) {
      return !(t.disable === true || e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey || e2.__qNavigate !== true && e2.defaultPrevented === true || e2.button !== void 0 && e2.button !== 0 || o.target === "_blank") && (prevent(e2), n.$router[t.replace === true ? "replace" : "push"](t.to).catch(() => {
      }), true);
    }
    return { hasLink: l, linkTag: i, linkRoute: r, linkIsActive: u, linkIsExactActive: c, linkClass: d, linkProps: p2, navigateToLink: v };
  }
  var QBreadcrumbsEl = defineComponent2({ name: "QBreadcrumbsEl", props: { ...useRouterLinkProps, label: String, icon: String, tag: { type: String, default: "span" } }, setup(e, { slots: t }) {
    const { linkTag: o, linkProps: n, hasLink: a, navigateToLink: l } = useRouterLink(), i = computed2(() => {
      const e2 = { ...n.value };
      return a.value === true && (e2.onClick = l), e2;
    }), r = computed2(() => "q-breadcrumbs__el-icon" + (e.label !== void 0 ? " q-breadcrumbs__el-icon--with-label" : ""));
    return () => {
      const n2 = [];
      return e.icon !== void 0 && n2.push(h(QIcon, { class: r.value, name: e.icon })), e.label !== void 0 && n2.push(e.label), h(o.value, { class: "q-breadcrumbs__el q-link flex inline items-center relative-position", ...i.value }, hMergeSlot(t.default, n2));
    };
  } });
  var useSpinnerProps = { size: { type: [Number, String], default: "1em" }, color: String };
  function useSpinner(e) {
    return { cSize: computed2(() => e.size in useSizeDefaults ? `${useSizeDefaults[e.size]}px` : e.size), classes: computed2(() => "q-spinner" + (e.color ? ` text-${e.color}` : "")) };
  }
  var QSpinner = defineComponent2({ name: "QSpinner", props: { ...useSpinnerProps, thickness: { type: Number, default: 5 } }, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value + " q-spinner-mat", width: t.value, height: t.value, viewBox: "25 25 50 50" }, [h("circle", { class: "path", cx: "50", cy: "50", r: "20", fill: "none", stroke: "currentColor", "stroke-width": e.thickness, "stroke-miterlimit": "10" })]);
  } });
  function offset(e) {
    if (e === window)
      return { top: 0, left: 0 };
    const { top: t, left: o } = e.getBoundingClientRect();
    return { top: t, left: o };
  }
  function style(e, t) {
    return window.getComputedStyle(e).getPropertyValue(t);
  }
  function height(e) {
    return e === window ? window.innerHeight : e.getBoundingClientRect().height;
  }
  function width$1(e) {
    return e === window ? window.innerWidth : e.getBoundingClientRect().width;
  }
  function css(e, t) {
    const o = e.style;
    Object.keys(t).forEach((e2) => {
      o[e2] = t[e2];
    });
  }
  function cssBatch(e, t) {
    e.forEach((e2) => css(e2, t));
  }
  function ready(e) {
    if (typeof e === "function")
      return document.readyState !== "loading" ? e() : void document.addEventListener("DOMContentLoaded", e, false);
  }
  function getElement$1(e) {
    if (e === void 0 || e === null)
      return;
    if (typeof e === "string")
      try {
        return document.querySelector(e) || void 0;
      } catch (e2) {
        return;
      }
    const t = isRef(e) === true ? e.value : e;
    return t ? t.$el || t : void 0;
  }
  function childHasFocus(e, t) {
    if (e === void 0 || e.contains(t) === true)
      return true;
    for (let o = e.nextElementSibling; o !== null; o = o.nextElementSibling)
      if (o.contains(t))
        return true;
    return false;
  }
  var dom = { offset, style, height, width: width$1, css, cssBatch, ready };
  function throttle(e, t = 250) {
    let o, n = false;
    return function() {
      return n === false && (n = true, setTimeout(() => {
        n = false;
      }, t), o = e.apply(this, arguments)), o;
    };
  }
  function showRipple(e, t, o, n) {
    o.modifiers.stop === true && stop2(e);
    const a = o.modifiers.color;
    let l = o.modifiers.center;
    l = l === true || n === true;
    const i = document.createElement("span"), r = document.createElement("span"), s2 = position(e), { left: u, top: c, width: d, height: p2 } = t.getBoundingClientRect(), v = Math.sqrt(d * d + p2 * p2), m = v / 2, f = `${(d - v) / 2}px`, h3 = l ? f : `${s2.left - u - m}px`, g = `${(p2 - v) / 2}px`, b = l ? g : `${s2.top - c - m}px`;
    r.className = "q-ripple__inner", css(r, { height: `${v}px`, width: `${v}px`, transform: `translate3d(${h3},${b},0) scale3d(.2,.2,1)`, opacity: 0 }), i.className = `q-ripple${a ? " text-" + a : ""}`, i.setAttribute("dir", "ltr"), i.appendChild(r), t.appendChild(i);
    const y = () => {
      i.remove(), clearTimeout(S);
    };
    o.abort.push(y);
    let S = setTimeout(() => {
      r.classList.add("q-ripple__inner--enter"), r.style.transform = `translate3d(${f},${g},0) scale3d(1,1,1)`, r.style.opacity = 0.2, S = setTimeout(() => {
        r.classList.remove("q-ripple__inner--enter"), r.classList.add("q-ripple__inner--leave"), r.style.opacity = 0, S = setTimeout(() => {
          i.remove(), o.abort.splice(o.abort.indexOf(y), 1);
        }, 275);
      }, 250);
    }, 50);
  }
  function updateModifiers$1(e, { modifiers: t, value: o, arg: n, instance: a }) {
    const l = Object.assign({}, a.$q.config.ripple, t, o);
    e.modifiers = { early: l.early === true, stop: l.stop === true, center: l.center === true, color: l.color || n, keyCodes: [].concat(l.keyCodes || 13) };
  }
  var Ripple = { name: "ripple", beforeMount(e, t) {
    const o = { enabled: t.value !== false, modifiers: {}, abort: [], start(t2) {
      o.enabled === true && t2.qSkipRipple !== true && (o.modifiers.early === true ? ["mousedown", "touchstart"].includes(t2.type) === true : t2.type === "click") && showRipple(t2, e, o, t2.qKeyEvent === true);
    }, keystart: throttle((t2) => {
      o.enabled === true && t2.qSkipRipple !== true && isKeyCode(t2, o.modifiers.keyCodes) === true && t2.type === `key${o.modifiers.early === true ? "down" : "up"}` && showRipple(t2, e, o, true);
    }, 300) };
    updateModifiers$1(o, t), e.__qripple = o, addEvt(o, "main", [[e, "mousedown", "start", "passive"], [e, "touchstart", "start", "passive"], [e, "click", "start", "passive"], [e, "keydown", "keystart", "passive"], [e, "keyup", "keystart", "passive"]]);
  }, updated(e, t) {
    if (t.oldValue !== t.value) {
      const o = e.__qripple;
      o.enabled = t.value !== false, o.enabled === true && Object(t.value) === t.value && updateModifiers$1(o, t);
    }
  }, beforeUnmount(e) {
    const t = e.__qripple;
    t.abort.forEach((e2) => {
      e2();
    }), cleanEvt(t, "main"), delete e._qripple;
  } };
  var padding = { none: 0, xs: 4, sm: 8, md: 16, lg: 24, xl: 32 };
  var defaultSizes$2 = { xs: 8, sm: 10, md: 14, lg: 20, xl: 24 };
  var useBtnProps = { ...useSizeProps, ...useRouterLinkProps, type: { type: String, default: "button" }, label: [Number, String], icon: String, iconRight: String, round: Boolean, outline: Boolean, flat: Boolean, unelevated: Boolean, rounded: Boolean, push: Boolean, glossy: Boolean, size: String, fab: Boolean, fabMini: Boolean, padding: String, color: String, textColor: String, noCaps: Boolean, noWrap: Boolean, dense: Boolean, tabindex: [Number, String], ripple: { type: [Boolean, Object], default: true }, align: { ...useAlignProps.align, default: "center" }, stack: Boolean, stretch: Boolean, loading: { type: Boolean, default: null }, disable: Boolean };
  function useBtn(e) {
    const t = useSize(e, defaultSizes$2), o = useAlign(e), { hasLink: n, linkProps: a, navigateToLink: l } = useRouterLink(), i = computed2(() => {
      const o2 = e.fab === false && e.fabMini === false ? t.value : {};
      return e.padding !== void 0 ? Object.assign({}, o2, { padding: e.padding.split(/\s+/).map((e2) => e2 in padding ? padding[e2] + "px" : e2).join(" "), minWidth: "0", minHeight: "0" }) : o2;
    }), r = computed2(() => e.rounded === true || e.fab === true || e.fabMini === true), s2 = computed2(() => e.disable !== true && e.loading !== true), u = computed2(() => s2.value === true ? e.tabindex || 0 : -1), c = computed2(() => e.type === "a" || n.value === true), d = computed2(() => {
      return e.flat === true ? "flat" : e.outline === true ? "outline" : e.push === true ? "push" : e.unelevated === true ? "unelevated" : "standard";
    }), p2 = computed2(() => {
      const t2 = { tabindex: u.value };
      return e.type !== "a" && (t2.type = e.type), n.value === true ? Object.assign(t2, a.value) : t2.role = e.type === "a" ? "link" : "button", e.loading === true && e.percentage !== void 0 && Object.assign(t2, { role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 100, "aria-valuenow": e.percentage }), e.disable === true && (t2.disabled = "", t2["aria-disabled"] = "true"), t2;
    }), v = computed2(() => {
      let t2;
      return e.color !== void 0 ? t2 = e.flat === true || e.outline === true ? `text-${e.textColor || e.color}` : `bg-${e.color} text-${e.textColor || "white"}` : e.textColor && (t2 = `text-${e.textColor}`), `q-btn--${d.value} q-btn--${e.round === true ? "round" : `rectangle${r.value === true ? " q-btn--rounded" : ""}`}` + (t2 !== void 0 ? " " + t2 : "") + (s2.value === true ? " q-btn--actionable q-focusable q-hoverable" : e.disable === true ? " disabled" : "") + (e.fab === true ? " q-btn--fab" : e.fabMini === true ? " q-btn--fab-mini" : "") + (e.noCaps === true ? " q-btn--no-uppercase" : "") + (e.dense === true ? " q-btn--dense" : "") + (e.stretch === true ? " no-border-radius self-stretch" : "") + (e.glossy === true ? " glossy" : "");
    }), m = computed2(() => o.value + (e.stack === true ? " column" : " row") + (e.noWrap === true ? " no-wrap text-no-wrap" : "") + (e.loading === true ? " q-btn__content--hidden" : ""));
    return { classes: v, style: i, innerClasses: m, attributes: p2, hasLink: n, isLink: c, navigateToLink: l, isActionable: s2 };
  }
  var { passiveCapture } = listenOpts;
  var touchTarget = null;
  var keyboardTarget = null;
  var mouseTarget = null;
  var QBtn = defineComponent2({ name: "QBtn", props: { ...useBtnProps, percentage: Number, darkPercentage: Boolean }, emits: ["click", "keydown", "touchstart", "mousedown", "keyup"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { classes: a, style: l, innerClasses: i, attributes: r, hasLink: s2, isLink: u, navigateToLink: c, isActionable: d } = useBtn(e), p2 = ref(null), v = ref(null);
    let m, f, g = null;
    const b = computed2(() => e.label !== void 0 && e.label !== null && e.label !== ""), y = computed2(() => e.ripple !== false && { keyCodes: u.value === true ? [13, 32] : [13], ...e.ripple === true ? {} : e.ripple }), S = computed2(() => {
      const t2 = Math.max(0, Math.min(100, e.percentage));
      return t2 > 0 ? { transition: "transform 0.6s", transform: `translateX(${t2 - 100}%)` } : {};
    }), w = computed2(() => {
      return e.loading === true ? { onMousedown: M, onTouchstartPassive: M, onClick: M, onKeydown: M, onKeyup: M } : d.value === true ? { onClick: k2, onKeydown: _, onMousedown: T, onTouchstartPassive: q } : { onClick: stopAndPrevent };
    }), x = computed2(() => {
      return [[Ripple, y.value, void 0, { center: e.round }]];
    }), C = computed2(() => ({ ref: p2, class: "q-btn q-btn-item non-selectable no-outline " + a.value, style: l.value, ...r.value, ...w.value }));
    function k2(t2) {
      if (t2 !== void 0) {
        if (t2.defaultPrevented === true)
          return;
        const o2 = document.activeElement;
        if (e.type === "submit" && o2 !== document.body && p2.value.contains(o2) === false && o2.contains(p2.value) === false) {
          p2.value.focus();
          const e2 = () => {
            document.removeEventListener("keydown", stopAndPrevent, true), document.removeEventListener("keyup", e2, passiveCapture), p2.value !== null && p2.value.removeEventListener("blur", e2, passiveCapture);
          };
          document.addEventListener("keydown", stopAndPrevent, true), document.addEventListener("keyup", e2, passiveCapture), p2.value.addEventListener("blur", e2, passiveCapture);
        }
      }
      if (s2.value === true) {
        const e2 = () => {
          t2.__qNavigate = true, c(t2);
        };
        o("click", t2, e2), t2.defaultPrevented !== true && e2();
      } else
        o("click", t2);
    }
    function _(e2) {
      isKeyCode(e2, [13, 32]) === true && (stopAndPrevent(e2), keyboardTarget !== p2.value && (keyboardTarget !== null && $(), p2.value.focus(), keyboardTarget = p2.value, p2.value.classList.add("q-btn--active"), document.addEventListener("keyup", P, true), p2.value.addEventListener("blur", P, passiveCapture))), o("keydown", e2);
    }
    function q(e2) {
      touchTarget !== p2.value && (touchTarget !== null && $(), touchTarget = p2.value, g = e2.target, g.addEventListener("touchcancel", P, passiveCapture), g.addEventListener("touchend", P, passiveCapture)), m = true, clearTimeout(f), f = setTimeout(() => {
        m = false;
      }, 200), o("touchstart", e2);
    }
    function T(e2) {
      mouseTarget !== p2.value && (mouseTarget !== null && $(), mouseTarget = p2.value, p2.value.classList.add("q-btn--active"), document.addEventListener("mouseup", P, passiveCapture)), e2.qSkipRipple = m === true, o("mousedown", e2);
    }
    function P(e2) {
      if (e2 === void 0 || e2.type !== "blur" || document.activeElement !== p2.value) {
        if (e2 !== void 0 && e2.type === "keyup") {
          if (keyboardTarget === p2.value && isKeyCode(e2, [13, 32]) === true) {
            const t2 = new MouseEvent("click", e2);
            t2.qKeyEvent = true, e2.defaultPrevented === true && prevent(t2), e2.cancelBubble === true && stop2(t2), p2.value.dispatchEvent(t2), stopAndPrevent(e2), e2.qKeyEvent = true;
          }
          o("keyup", e2);
        }
        $();
      }
    }
    function $(e2) {
      const t2 = v.value;
      e2 === true || touchTarget !== p2.value && mouseTarget !== p2.value || t2 === null || t2 === document.activeElement || (t2.setAttribute("tabindex", -1), t2.focus()), touchTarget === p2.value && (g !== null && (g.removeEventListener("touchcancel", P, passiveCapture), g.removeEventListener("touchend", P, passiveCapture)), touchTarget = g = null), mouseTarget === p2.value && (document.removeEventListener("mouseup", P, passiveCapture), mouseTarget = null), keyboardTarget === p2.value && (document.removeEventListener("keyup", P, true), p2.value !== null && p2.value.removeEventListener("blur", P, passiveCapture), keyboardTarget = null), p2.value !== null && p2.value.classList.remove("q-btn--active");
    }
    function M(e2) {
      e2.qSkipRipple = true;
    }
    return onBeforeUnmount2(() => {
      $(true);
    }), Object.assign(n, { click: k2 }), () => {
      let o2 = [];
      e.icon !== void 0 && o2.push(h(QIcon, { name: e.icon, left: e.stack === false && b.value === true, role: "img", "aria-hidden": "true" })), b.value === true && o2.push(h("span", { class: "block" }, [e.label])), o2 = hMergeSlot(t.default, o2), e.iconRight !== void 0 && e.round === false && o2.push(h(QIcon, { name: e.iconRight, right: e.stack === false && b.value === true, role: "img", "aria-hidden": "true" }));
      const n2 = [h("span", { class: "q-focus-helper", ref: v })];
      return e.loading === true && e.percentage !== void 0 && n2.push(h("span", { class: "q-btn__progress absolute-full overflow-hidden" }, [h("span", { class: "q-btn__progress-indicator fit block" + (e.darkPercentage === true ? " q-btn__progress--dark" : ""), style: S.value })])), n2.push(h("span", { class: "q-btn__content text-center col items-center q-anchor--skip " + i.value }, o2)), e.loading !== null && n2.push(h(Transition, { name: "q-transition--fade" }, () => e.loading === true ? [h("span", { key: "loading", class: "absolute-full flex flex-center" }, t.loading !== void 0 ? t.loading() : [h(QSpinner)])] : null)), hDir(u.value === true ? "a" : "button", C.value, n2, "ripple", e.disable !== true && e.ripple !== false, () => x.value);
    };
  } });
  var QBtnGroup = defineComponent2({ name: "QBtnGroup", props: { unelevated: Boolean, outline: Boolean, flat: Boolean, rounded: Boolean, push: Boolean, stretch: Boolean, glossy: Boolean, spread: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => {
      const t2 = ["unelevated", "outline", "flat", "rounded", "push", "stretch", "glossy"].filter((t3) => e[t3] === true).map((e2) => `q-btn-group--${e2}`).join(" ");
      return `q-btn-group row no-wrap${t2.length > 0 ? " " + t2 : ""}` + (e.spread === true ? " q-btn-group--spread" : " inline");
    });
    return () => h("div", { class: o.value }, hSlot(t.default));
  } });
  function clearSelection() {
    if (window.getSelection !== void 0) {
      const e = window.getSelection();
      e.empty !== void 0 ? e.empty() : e.removeAllRanges !== void 0 && (e.removeAllRanges(), Platform.is.mobile !== true && e.addRange(document.createRange()));
    } else
      document.selection !== void 0 && document.selection.empty();
  }
  var useAnchorProps = { target: { default: true }, noParentEvent: Boolean, contextMenu: Boolean };
  function useAnchor({ showing: e, avoidEmit: t, configureAnchorEl: o }) {
    const { props: n, proxy: a, emit: l } = getCurrentInstance(), i = ref(null);
    let r;
    function s2(e2) {
      return i.value !== null && (e2 === void 0 || e2.touches === void 0 || e2.touches.length <= 1);
    }
    const u = {};
    function c() {
      cleanEvt(u, "anchor");
    }
    function d(e2) {
      i.value = e2;
      while (i.value.classList.contains("q-anchor--skip"))
        i.value = i.value.parentNode;
      o();
    }
    function p2() {
      if (n.target === false || n.target === "")
        i.value = null;
      else if (n.target === true)
        d(a.$el.parentNode);
      else {
        let e2 = n.target;
        if (typeof n.target === "string")
          try {
            e2 = document.querySelector(n.target);
          } catch (t2) {
            e2 = void 0;
          }
        e2 !== void 0 && e2 !== null ? (i.value = e2.$el || e2, o()) : (i.value = null, console.error(`Anchor: target "${n.target}" not found`));
      }
    }
    return o === void 0 && (Object.assign(u, { hide(e2) {
      a.hide(e2);
    }, toggle(e2) {
      a.toggle(e2);
    }, toggleKey(e2) {
      isKeyCode(e2, 13) === true && a.toggle(e2);
    }, contextClick(e2) {
      a.hide(e2), nextTick2(() => {
        a.show(e2);
      }), prevent(e2);
    }, mobilePrevent: prevent, mobileTouch(e2) {
      if (u.mobileCleanup(e2), s2(e2) !== true)
        return;
      a.hide(e2), i.value.classList.add("non-selectable");
      const t2 = e2.target;
      addEvt(u, "anchor", [[t2, "touchmove", "mobileCleanup", "passive"], [t2, "touchend", "mobileCleanup", "passive"], [t2, "touchcancel", "mobileCleanup", "passive"], [i.value, "contextmenu", "mobilePrevent", "notPassive"]]), r = setTimeout(() => {
        a.show(e2);
      }, 300);
    }, mobileCleanup(t2) {
      i.value.classList.remove("non-selectable"), clearTimeout(r), e.value === true && t2 !== void 0 && clearSelection();
    } }), o = function(e2 = n.contextMenu) {
      if (n.noParentEvent === true || i.value === null)
        return;
      let t2;
      t2 = e2 === true ? a.$q.platform.is.mobile === true ? [[i.value, "touchstart", "mobileTouch", "passive"]] : [[i.value, "click", "hide", "passive"], [i.value, "contextmenu", "contextClick", "notPassive"]] : [[i.value, "click", "toggle", "passive"], [i.value, "keyup", "toggleKey", "passive"]], addEvt(u, "anchor", t2);
    }), watch(() => n.contextMenu, (e2) => {
      i.value !== null && (c(), o(e2));
    }), watch(() => n.target, () => {
      i.value !== null && c(), p2();
    }), watch(() => n.noParentEvent, (e2) => {
      i.value !== null && (e2 === true ? c() : o());
    }), onMounted2(() => {
      p2(), t !== true && n.modelValue === true && i.value === null && l("update:modelValue", false);
    }), onBeforeUnmount2(() => {
      clearTimeout(r), c();
    }), { anchorEl: i, canShow: s2, anchorEvents: u };
  }
  function useScrollTarget(e, t) {
    const o = ref(null);
    let n;
    function a(e2, t2) {
      const o2 = `${t2 !== void 0 ? "add" : "remove"}EventListener`, a2 = t2 !== void 0 ? t2 : n;
      e2 !== window && e2[o2]("scroll", a2, listenOpts.passive), window[o2]("scroll", a2, listenOpts.passive), n = t2;
    }
    function l() {
      o.value !== null && (a(o.value), o.value = null);
    }
    const i = watch(() => e.noParentEvent, () => {
      o.value !== null && (l(), t());
    });
    return onBeforeUnmount2(i), { localScrollTarget: o, unconfigureScrollTarget: l, changeScrollEvent: a };
  }
  var useModelToggleProps = { modelValue: { type: Boolean, default: null }, "onUpdate:modelValue": Function };
  var useModelToggleEmits = ["before-show", "show", "before-hide", "hide"];
  function useModelToggle({ showing: e, canShow: t, hideOnRouteChange: o, handleShow: n, handleHide: a, processOnMount: l }) {
    const i = getCurrentInstance(), { props: r, emit: s2, proxy: u } = i;
    let c;
    function d(t2) {
      e.value === true ? m(t2) : p2(t2);
    }
    function p2(e2) {
      if (r.disable === true || t !== void 0 && t(e2) !== true)
        return;
      const o2 = r["onUpdate:modelValue"] !== void 0;
      o2 === true && (s2("update:modelValue", true), c = e2, nextTick2(() => {
        c === e2 && (c = void 0);
      })), r.modelValue !== null && o2 !== false || v(e2);
    }
    function v(t2) {
      e.value !== true && (e.value = true, s2("before-show", t2), n !== void 0 ? n(t2) : s2("show", t2));
    }
    function m(e2) {
      if (r.disable === true)
        return;
      const t2 = r["onUpdate:modelValue"] !== void 0;
      t2 === true && (s2("update:modelValue", false), c = e2, nextTick2(() => {
        c === e2 && (c = void 0);
      })), r.modelValue !== null && t2 !== false || f(e2);
    }
    function f(t2) {
      e.value !== false && (e.value = false, s2("before-hide", t2), a !== void 0 ? a(t2) : s2("hide", t2));
    }
    function h3(t2) {
      if (r.disable === true && t2 === true)
        r["onUpdate:modelValue"] !== void 0 && s2("update:modelValue", false);
      else if (t2 === true !== e.value) {
        const e2 = t2 === true ? v : f;
        e2(c);
      }
    }
    watch(() => r.modelValue, h3), o !== void 0 && vmHasRouter(i) === true && watch(() => u.$route, () => {
      o.value === true && e.value === true && m();
    }), l === true && onMounted2(() => {
      h3(r.modelValue);
    });
    const g = { show: p2, hide: m, toggle: d };
    return Object.assign(u, g), g;
  }
  var queue2 = [];
  var waitFlags = [];
  function addFocusWaitFlag(e) {
    waitFlags.push(e);
  }
  function removeFocusWaitFlag(e) {
    const t = waitFlags.indexOf(e);
    t !== -1 && waitFlags.splice(t, 1), waitFlags.length === 0 && queue2.length > 0 && (queue2[queue2.length - 1](), queue2 = []);
  }
  function addFocusFn(e) {
    if (waitFlags.length !== 0)
      return queue2.push(e), e;
    e();
  }
  function removeFocusFn(e) {
    const t = queue2.indexOf(e);
    t !== -1 && queue2.splice(t, 1);
  }
  var globalNodes = [];
  var target = document.body;
  function createGlobalNode(e) {
    const t = document.createElement("div");
    if (e !== void 0 && (t.id = e), globalConfig.globalNodes !== void 0) {
      const e2 = globalConfig.globalNodes.class;
      e2 !== void 0 && (t.className = e2);
    }
    return target.appendChild(t), globalNodes.push(t), t;
  }
  function removeGlobalNode(e) {
    globalNodes.splice(globalNodes.indexOf(e), 1), e.remove();
  }
  function changeGlobalNodesTarget(e) {
    e !== target && (target = e, globalNodes.forEach((e2) => {
      e2.contains(target) === false && target.appendChild(e2);
    }));
  }
  var portalList = [];
  function getPortalVm(e) {
    return portalList.find((t) => t.__qPortalInnerRef.value !== null && t.__qPortalInnerRef.value.contains(e));
  }
  function closePortalMenus(e, t) {
    do {
      if (e.$options.name === "QMenu") {
        if (e.hide(t), e.$props.separateClosePopup === true)
          return getParentVm(e);
      } else if (e.__qPortalInnerRef !== void 0) {
        const o = getParentVm(e);
        return o !== void 0 && o.$options.name === "QPopupProxy" ? (e.hide(t), o) : e;
      }
      e = getParentVm(e);
    } while (e !== void 0 && e !== null);
  }
  function closePortals(e, t, o) {
    while (o !== 0 && e !== void 0 && e !== null) {
      if (e.__qPortalInnerRef !== void 0) {
        if (o--, e.$options.name === "QMenu") {
          e = closePortalMenus(e, t);
          continue;
        }
        e.hide(t);
      }
      e = getParentVm(e);
    }
  }
  function isOnGlobalDialog(e) {
    e = e.parent;
    while (e !== void 0 && e !== null) {
      if (e.type.name === "QGlobalDialog")
        return true;
      if (e.type.name === "QDialog" || e.type.name === "QMenu")
        return false;
      e = e.parent;
    }
    return false;
  }
  function usePortal(e, t, o, n) {
    const a = ref(false);
    let l = null;
    const i = {}, r = n === true && isOnGlobalDialog(e);
    function s2(t2) {
      t2 !== true ? (r === false && l === null && (l = createGlobalNode()), a.value = true, portalList.push(e.proxy), addFocusWaitFlag(i)) : removeFocusWaitFlag(i);
    }
    function u() {
      removeFocusWaitFlag(i), a.value = false;
      const t2 = portalList.indexOf(e.proxy);
      t2 > -1 && portalList.splice(t2, 1), l !== null && (removeGlobalNode(l), l = null);
    }
    return onUnmounted(u), Object.assign(e.proxy, { __qPortalInnerRef: t }), { showPortal: s2, hidePortal: u, portalIsActive: a, renderPortal: () => r === true ? o() : a.value === true ? [h(Teleport, { to: l }, o())] : void 0 };
  }
  var useTransitionProps = { transitionShow: { type: String, default: "fade" }, transitionHide: { type: String, default: "fade" }, transitionDuration: { type: [String, Number], default: 300 } };
  function useTransition(e, t) {
    const o = ref(t.value);
    return watch(t, (e2) => {
      nextTick2(() => {
        o.value = e2;
      });
    }), { transition: computed2(() => "q-transition--" + (o.value === true ? e.transitionHide : e.transitionShow)), transitionStyle: computed2(() => `--q-transition-duration: ${e.transitionDuration}ms`) };
  }
  function useTick() {
    let e;
    return onBeforeUnmount2(() => {
      e = void 0;
    }), { registerTick(t) {
      e = t;
    }, removeTick() {
      e = void 0;
    }, prepareTick() {
      if (e !== void 0) {
        const t = e;
        nextTick2(() => {
          e === t && (e(), e = void 0);
        });
      }
    } };
  }
  function useTimeout() {
    let e;
    return onBeforeUnmount2(() => {
      clearTimeout(e);
    }), { registerTimeout(t, o) {
      clearTimeout(e), e = setTimeout(t, o);
    }, removeTimeout() {
      clearTimeout(e);
    } };
  }
  var scrollTargets = [null, document, document.body, document.scrollingElement, document.documentElement];
  function getScrollTarget(e, t) {
    let o = getElement$1(t);
    if (o === void 0) {
      if (e === void 0 || e === null)
        return window;
      o = e.closest(".scroll,.scroll-y,.overflow-auto");
    }
    return scrollTargets.includes(o) ? window : o;
  }
  function getScrollHeight(e) {
    return (e === window ? document.body : e).scrollHeight;
  }
  function getScrollWidth(e) {
    return (e === window ? document.body : e).scrollWidth;
  }
  function getVerticalScrollPosition(e) {
    return e === window ? window.pageYOffset || window.scrollY || document.body.scrollTop || 0 : e.scrollTop;
  }
  function getHorizontalScrollPosition(e) {
    return e === window ? window.pageXOffset || window.scrollX || document.body.scrollLeft || 0 : e.scrollLeft;
  }
  function animVerticalScrollTo(e, t, o = 0) {
    const n = arguments[3] === void 0 ? performance.now() : arguments[3], a = getVerticalScrollPosition(e);
    o <= 0 ? a !== t && setScroll$1(e, t) : requestAnimationFrame((l) => {
      const i = l - n, r = a + (t - a) / Math.max(i, o) * i;
      setScroll$1(e, r), r !== t && animVerticalScrollTo(e, t, o - i, l);
    });
  }
  function animHorizontalScrollTo(e, t, o = 0) {
    const n = arguments[3] === void 0 ? performance.now() : arguments[3], a = getHorizontalScrollPosition(e);
    o <= 0 ? a !== t && setHorizontalScroll(e, t) : requestAnimationFrame((l) => {
      const i = l - n, r = a + (t - a) / Math.max(i, o) * i;
      setHorizontalScroll(e, r), r !== t && animHorizontalScrollTo(e, t, o - i, l);
    });
  }
  function setScroll$1(e, t) {
    e !== window ? e.scrollTop = t : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, t);
  }
  function setHorizontalScroll(e, t) {
    e !== window ? e.scrollLeft = t : window.scrollTo(t, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);
  }
  function setVerticalScrollPosition(e, t, o) {
    o ? animVerticalScrollTo(e, t, o) : setScroll$1(e, t);
  }
  function setHorizontalScrollPosition(e, t, o) {
    o ? animHorizontalScrollTo(e, t, o) : setHorizontalScroll(e, t);
  }
  var size2;
  function getScrollbarWidth() {
    if (size2 !== void 0)
      return size2;
    const e = document.createElement("p"), t = document.createElement("div");
    css(e, { width: "100%", height: "200px" }), css(t, { position: "absolute", top: "0px", left: "0px", visibility: "hidden", width: "200px", height: "150px", overflow: "hidden" }), t.appendChild(e), document.body.appendChild(t);
    const o = e.offsetWidth;
    t.style.overflow = "scroll";
    let n = e.offsetWidth;
    return o === n && (n = t.clientWidth), t.remove(), size2 = o - n, size2;
  }
  function hasScrollbar(e, t = true) {
    return !(!e || e.nodeType !== Node.ELEMENT_NODE) && (t ? e.scrollHeight > e.clientHeight && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-y"])) : e.scrollWidth > e.clientWidth && (e.classList.contains("scroll") || e.classList.contains("overflow-auto") || ["auto", "scroll"].includes(window.getComputedStyle(e)["overflow-x"])));
  }
  var scroll = { getScrollTarget, getScrollHeight, getScrollWidth, getVerticalScrollPosition, getHorizontalScrollPosition, animVerticalScrollTo, animHorizontalScrollTo, setVerticalScrollPosition, setHorizontalScrollPosition, getScrollbarWidth, hasScrollbar };
  var handlers$1 = [];
  var escDown;
  function onKeydown(e) {
    escDown = e.keyCode === 27;
  }
  function onBlur() {
    escDown === true && (escDown = false);
  }
  function onKeyup(e) {
    escDown === true && (escDown = false, isKeyCode(e, 27) === true && handlers$1[handlers$1.length - 1](e));
  }
  function update$4(e) {
    window[e]("keydown", onKeydown), window[e]("blur", onBlur), window[e]("keyup", onKeyup), escDown = false;
  }
  function addEscapeKey(e) {
    client2.is.desktop === true && (handlers$1.push(e), handlers$1.length === 1 && update$4("addEventListener"));
  }
  function removeEscapeKey(e) {
    const t = handlers$1.indexOf(e);
    t > -1 && (handlers$1.splice(t, 1), handlers$1.length === 0 && update$4("removeEventListener"));
  }
  var handlers = [];
  function trigger$1(e) {
    handlers[handlers.length - 1](e);
  }
  function addFocusout(e) {
    client2.is.desktop === true && (handlers.push(e), handlers.length === 1 && document.body.addEventListener("focusin", trigger$1));
  }
  function removeFocusout(e) {
    const t = handlers.indexOf(e);
    t > -1 && (handlers.splice(t, 1), handlers.length === 0 && document.body.removeEventListener("focusin", trigger$1));
  }
  var timer;
  var { notPassiveCapture } = listenOpts;
  var registeredList = [];
  function hasModalsAbove(e) {
    while ((e = e.nextElementSibling) !== null)
      if (e.classList.contains("q-dialog--modal"))
        return true;
    return false;
  }
  function globalHandler(e) {
    clearTimeout(timer);
    const t = e.target;
    if (t !== void 0 && t.nodeType !== 8 && t.classList.contains("no-pointer-events") !== true)
      for (let o = registeredList.length - 1; o >= 0; o--) {
        const n = registeredList[o];
        if (n.anchorEl.value !== null && n.anchorEl.value.contains(t) !== false || t !== document.body && (n.innerRef.value === null || n.innerRef.value.contains(t) !== false) || n.getEl !== void 0 && hasModalsAbove(n.getEl()) === true)
          return;
        e.qClickOutside = true, n.onClickOutside(e);
      }
  }
  function addClickOutside(e) {
    registeredList.push(e), registeredList.length === 1 && (document.addEventListener("mousedown", globalHandler, notPassiveCapture), document.addEventListener("touchstart", globalHandler, notPassiveCapture));
  }
  function removeClickOutside(e) {
    const t = registeredList.findIndex((t2) => t2 === e);
    t > -1 && (registeredList.splice(t, 1), registeredList.length === 0 && (clearTimeout(timer), document.removeEventListener("mousedown", globalHandler, notPassiveCapture), document.removeEventListener("touchstart", globalHandler, notPassiveCapture)));
  }
  var vpLeft;
  var vpTop;
  function validatePosition(e) {
    const t = e.split(" ");
    return t.length === 2 && (["top", "center", "bottom"].includes(t[0]) !== true ? (console.error("Anchor/Self position must start with one of top/center/bottom"), false) : ["left", "middle", "right", "start", "end"].includes(t[1]) === true || (console.error("Anchor/Self position must end with one of left/middle/right/start/end"), false));
  }
  function validateOffset(e) {
    return !e || e.length === 2 && (typeof e[0] === "number" && typeof e[1] === "number");
  }
  var horizontalPos = { "start#ltr": "left", "start#rtl": "right", "end#ltr": "right", "end#rtl": "left" };
  function parsePosition(e, t) {
    const o = e.split(" ");
    return { vertical: o[0], horizontal: horizontalPos[`${o[1]}#${t === true ? "rtl" : "ltr"}`] };
  }
  function getAnchorProps(e, t) {
    let { top: o, left: n, right: a, bottom: l, width: i, height: r } = e.getBoundingClientRect();
    return t !== void 0 && (o -= t[1], n -= t[0], l += t[1], a += t[0], i += t[0], r += t[1]), { top: o, left: n, right: a, bottom: l, width: i, height: r, middle: n + (a - n) / 2, center: o + (l - o) / 2 };
  }
  function getTargetProps(e) {
    return { top: 0, center: e.offsetHeight / 2, bottom: e.offsetHeight, left: 0, middle: e.offsetWidth / 2, right: e.offsetWidth };
  }
  function setPosition(e) {
    if (client2.is.ios === true && window.visualViewport !== void 0) {
      const e2 = document.body.style, { offsetLeft: t2, offsetTop: o2 } = window.visualViewport;
      t2 !== vpLeft && (e2.setProperty("--q-pe-left", t2 + "px"), vpLeft = t2), o2 !== vpTop && (e2.setProperty("--q-pe-top", o2 + "px"), vpTop = o2);
    }
    let t;
    const { scrollLeft: o, scrollTop: n } = e.el;
    if (e.absoluteOffset === void 0)
      t = getAnchorProps(e.anchorEl, e.cover === true ? [0, 0] : e.offset);
    else {
      const { top: o2, left: n2 } = e.anchorEl.getBoundingClientRect(), a2 = o2 + e.absoluteOffset.top, l2 = n2 + e.absoluteOffset.left;
      t = { top: a2, left: l2, width: 1, height: 1, right: l2 + 1, center: a2, middle: l2, bottom: a2 + 1 };
    }
    let a = { maxHeight: e.maxHeight, maxWidth: e.maxWidth, visibility: "visible" };
    e.fit !== true && e.cover !== true || (a.minWidth = t.width + "px", e.cover === true && (a.minHeight = t.height + "px")), Object.assign(e.el.style, a);
    const l = getTargetProps(e.el), i = { top: t[e.anchorOrigin.vertical] - l[e.selfOrigin.vertical], left: t[e.anchorOrigin.horizontal] - l[e.selfOrigin.horizontal] };
    applyBoundaries(i, t, l, e.anchorOrigin, e.selfOrigin), a = { top: i.top + "px", left: i.left + "px" }, i.maxHeight !== void 0 && (a.maxHeight = i.maxHeight + "px", t.height > i.maxHeight && (a.minHeight = a.maxHeight)), i.maxWidth !== void 0 && (a.maxWidth = i.maxWidth + "px", t.width > i.maxWidth && (a.minWidth = a.maxWidth)), Object.assign(e.el.style, a), e.el.scrollTop !== n && (e.el.scrollTop = n), e.el.scrollLeft !== o && (e.el.scrollLeft = o);
  }
  function applyBoundaries(e, t, o, n, a) {
    const l = o.bottom, i = o.right, r = getScrollbarWidth(), s2 = window.innerHeight - r, u = document.body.clientWidth;
    if (e.top < 0 || e.top + l > s2)
      if (a.vertical === "center")
        e.top = t[n.vertical] > s2 / 2 ? Math.max(0, s2 - l) : 0, e.maxHeight = Math.min(l, s2);
      else if (t[n.vertical] > s2 / 2) {
        const o2 = Math.min(s2, n.vertical === "center" ? t.center : n.vertical === a.vertical ? t.bottom : t.top);
        e.maxHeight = Math.min(l, o2), e.top = Math.max(0, o2 - l);
      } else
        e.top = Math.max(0, n.vertical === "center" ? t.center : n.vertical === a.vertical ? t.top : t.bottom), e.maxHeight = Math.min(l, s2 - e.top);
    if (e.left < 0 || e.left + i > u)
      if (e.maxWidth = Math.min(i, u), a.horizontal === "middle")
        e.left = t[n.horizontal] > u / 2 ? Math.max(0, u - i) : 0;
      else if (t[n.horizontal] > u / 2) {
        const o2 = Math.min(u, n.horizontal === "middle" ? t.middle : n.horizontal === a.horizontal ? t.right : t.left);
        e.maxWidth = Math.min(i, o2), e.left = Math.max(0, o2 - e.maxWidth);
      } else
        e.left = Math.max(0, n.horizontal === "middle" ? t.middle : n.horizontal === a.horizontal ? t.left : t.right), e.maxWidth = Math.min(i, u - e.left);
  }
  ["left", "middle", "right"].forEach((e) => {
    horizontalPos[`${e}#ltr`] = e, horizontalPos[`${e}#rtl`] = e;
  });
  var QMenu = defineComponent2({ name: "QMenu", inheritAttrs: false, props: { ...useAnchorProps, ...useModelToggleProps, ...useDarkProps, ...useTransitionProps, persistent: Boolean, autoClose: Boolean, separateClosePopup: Boolean, noRouteDismiss: Boolean, noRefocus: Boolean, noFocus: Boolean, fit: Boolean, cover: Boolean, square: Boolean, anchor: { type: String, validator: validatePosition }, self: { type: String, validator: validatePosition }, offset: { type: Array, validator: validateOffset }, scrollTarget: { default: void 0 }, touchPosition: Boolean, maxHeight: { type: String, default: null }, maxWidth: { type: String, default: null } }, emits: [...useModelToggleEmits, "click", "escape-key"], setup(e, { slots: t, emit: o, attrs: n }) {
    let a, l, i, r = null;
    const s2 = getCurrentInstance(), { proxy: u } = s2, { $q: c } = u, d = ref(null), p2 = ref(false), v = computed2(() => e.persistent !== true && e.noRouteDismiss !== true), m = useDark(e, c), { registerTick: f, removeTick: g, prepareTick: b } = useTick(), { registerTimeout: y, removeTimeout: S } = useTimeout(), { transition: w, transitionStyle: x } = useTransition(e, p2), { localScrollTarget: C, changeScrollEvent: k2, unconfigureScrollTarget: _ } = useScrollTarget(e, D), { anchorEl: q, canShow: T } = useAnchor({ showing: p2 }), { hide: P } = useModelToggle({ showing: p2, canShow: T, handleShow: V, handleHide: I, hideOnRouteChange: v, processOnMount: true }), { showPortal: $, hidePortal: M, renderPortal: B } = usePortal(s2, d, K), Q = { anchorEl: q, innerRef: d, getEl: () => u.$el, onClickOutside(t2) {
      if (e.persistent !== true && p2.value === true)
        return P(t2), (t2.type === "touchstart" || t2.target.classList.contains("q-dialog__backdrop")) && stopAndPrevent(t2), true;
    } }, E = computed2(() => parsePosition(e.anchor || (e.cover === true ? "center middle" : "bottom start"), c.lang.rtl)), O = computed2(() => e.cover === true ? E.value : parsePosition(e.self || "top start", c.lang.rtl)), z = computed2(() => (e.square === true ? " q-menu--square" : "") + (m.value === true ? " q-menu--dark q-dark" : "")), F = computed2(() => e.autoClose === true ? { onClick: N } : {}), L = computed2(() => p2.value === true && e.persistent !== true);
    function R() {
      addFocusFn(() => {
        let e2 = d.value;
        e2 && e2.contains(document.activeElement) !== true && (e2 = e2.querySelector("[autofocus], [data-autofocus]") || e2, e2.focus());
      });
    }
    function V(t2) {
      if (g(), S(), r = e.noRefocus === false ? document.activeElement : null, addFocusout(H), $(), D(), a = void 0, t2 !== void 0 && (e.touchPosition || e.contextMenu)) {
        const e2 = position(t2);
        if (e2.left !== void 0) {
          const { top: t3, left: o2 } = q.value.getBoundingClientRect();
          a = { left: e2.left - o2, top: e2.top - t3 };
        }
      }
      l === void 0 && (l = watch(() => c.screen.width + "|" + c.screen.height + "|" + e.self + "|" + e.anchor + "|" + c.lang.rtl, U)), e.noFocus !== true && document.activeElement.blur(), f(() => {
        U(), e.noFocus !== true && R();
      }), b(), y(() => {
        c.platform.is.ios === true && (i = e.autoClose, d.value.click()), U(), $(true), o("show", t2);
      }, e.transitionDuration);
    }
    function I(t2) {
      g(), S(), A(true), r === null || t2 !== void 0 && t2.qClickOutside === true || r.focus(), y(() => {
        M(), o("hide", t2);
      }, e.transitionDuration);
    }
    function A(e2) {
      a = void 0, l !== void 0 && (l(), l = void 0), e2 !== true && p2.value !== true || (removeFocusout(H), _(), removeClickOutside(Q), removeEscapeKey(j));
    }
    function D() {
      q.value === null && e.scrollTarget === void 0 || (C.value = getScrollTarget(q.value, e.scrollTarget), k2(C.value, U));
    }
    function N(e2) {
      i !== true ? (closePortalMenus(u, e2), o("click", e2)) : i = false;
    }
    function H(e2) {
      L.value === true && childHasFocus(d.value, e2.target) !== true && R();
    }
    function j(e2) {
      o("escape-key"), P(e2);
    }
    function U() {
      const t2 = d.value;
      t2 !== null && q.value !== null && setPosition({ el: t2, offset: e.offset, anchorEl: q.value, anchorOrigin: E.value, selfOrigin: O.value, absoluteOffset: a, fit: e.fit, cover: e.cover, maxHeight: e.maxHeight, maxWidth: e.maxWidth });
    }
    function K() {
      return h(Transition, { name: w.value, appear: true }, () => p2.value === true ? h("div", { ...n, ref: d, tabindex: -1, class: ["q-menu q-position-engine scroll" + z.value, n.class], style: [n.style, x.value], ...F.value }, hSlot(t.default)) : null);
    }
    return watch(L, (e2) => {
      e2 === true ? (addEscapeKey(j), addClickOutside(Q)) : (removeEscapeKey(j), removeClickOutside(Q));
    }), onBeforeUnmount2(A), Object.assign(u, { focus: R, updatePosition: U }), B;
  } });
  var QBtnDropdown = defineComponent2({ name: "QBtnDropdown", props: { ...useBtnProps, modelValue: Boolean, split: Boolean, dropdownIcon: String, contentClass: [Array, String, Object], contentStyle: [Array, String, Object], cover: Boolean, persistent: Boolean, noRouteDismiss: Boolean, autoClose: Boolean, menuAnchor: { type: String, default: "bottom end" }, menuSelf: { type: String, default: "top end" }, menuOffset: Array, disableMainBtn: Boolean, disableDropdown: Boolean, noIconAnimation: Boolean }, emits: ["update:modelValue", "click", "before-show", "show", "before-hide", "hide"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), a = ref(e.modelValue), l = ref(null), i = computed2(() => {
      const t2 = { "aria-expanded": a.value === true ? "true" : "false", "aria-haspopup": "true" };
      return (e.disable === true || e.split === false && e.disableMainBtn === true || e.disableDropdown === true) && (t2["aria-disabled"] = "true"), t2;
    }), r = computed2(() => "q-btn-dropdown__arrow" + (a.value === true && e.noIconAnimation === false ? " rotate-180" : "") + (e.split === false ? " q-btn-dropdown__arrow-container" : ""));
    function s2(e2) {
      a.value = true, o("before-show", e2);
    }
    function u(e2) {
      o("show", e2), o("update:modelValue", true);
    }
    function c(e2) {
      a.value = false, o("before-hide", e2);
    }
    function d(e2) {
      o("hide", e2), o("update:modelValue", false);
    }
    function p2(e2) {
      o("click", e2);
    }
    function v(e2) {
      stop2(e2), g(), o("click", e2);
    }
    function m(e2) {
      l.value !== null && l.value.toggle(e2);
    }
    function f(e2) {
      l.value !== null && l.value.show(e2);
    }
    function g(e2) {
      l.value !== null && l.value.hide(e2);
    }
    return watch(() => e.modelValue, (e2) => {
      l.value !== null && l.value[e2 ? "show" : "hide"]();
    }), watch(() => e.split, g), Object.assign(n, { show: f, hide: g, toggle: m }), onMounted2(() => {
      e.modelValue === true && f();
    }), () => {
      const o2 = [h(QIcon, { class: r.value, name: e.dropdownIcon || n.$q.iconSet.arrow.dropdown })];
      return e.disableDropdown !== true && o2.push(h(QMenu, { ref: l, class: e.contentClass, style: e.contentStyle, cover: e.cover, fit: true, persistent: e.persistent, noRouteDismiss: e.noRouteDismiss, autoClose: e.autoClose, anchor: e.menuAnchor, self: e.menuSelf, offset: e.menuOffset, separateClosePopup: true, onBeforeShow: s2, onShow: u, onBeforeHide: c, onHide: d }, t.default)), e.split === false ? h(QBtn, { class: "q-btn-dropdown q-btn-dropdown--simple", ...e, disable: e.disable === true || e.disableMainBtn === true, noWrap: true, round: false, ...i.value, onClick: p2 }, () => hSlot(t.label, []).concat(o2)) : h(QBtnGroup, { class: "q-btn-dropdown q-btn-dropdown--split no-wrap q-btn-item", outline: e.outline, flat: e.flat, rounded: e.rounded, push: e.push, unelevated: e.glossy, stretch: e.stretch }, () => [h(QBtn, { class: "q-btn-dropdown--current", ...e, disable: e.disable === true || e.disableMainBtn === true, noWrap: true, iconRight: e.iconRight, round: false, onClick: v }, t.label), h(QBtn, { class: "q-btn-dropdown__arrow-container q-anchor--skip", ...i.value, disable: e.disable === true || e.disableDropdown === true, outline: e.outline, flat: e.flat, rounded: e.rounded, push: e.push, size: e.size, color: e.color, textColor: e.textColor, dense: e.dense, ripple: e.ripple }, () => o2)]);
    };
  } });
  var useFormProps = { name: String };
  function useFormAttrs(e) {
    return computed2(() => ({ type: "hidden", name: e.name, value: e.modelValue }));
  }
  function useFormInject(e = {}, t = {}) {
    return (o, n, a) => {
      o[n](h("input", { class: "hidden" + (a || ""), ...e.value, ...t.value }));
    };
  }
  function useFormInputNameAttr(e) {
    return computed2(() => e.name || e.for);
  }
  var QBtnToggle = defineComponent2({ name: "QBtnToggle", props: { ...useFormProps, modelValue: { required: true }, options: { type: Array, required: true, validator: (e) => e.every((e2) => ("label" in e2 || "icon" in e2 || "slot" in e2) && "value" in e2) }, color: String, textColor: String, toggleColor: { type: String, default: "primary" }, toggleTextColor: String, outline: Boolean, flat: Boolean, unelevated: Boolean, rounded: Boolean, push: Boolean, glossy: Boolean, size: String, padding: String, noCaps: Boolean, noWrap: Boolean, dense: Boolean, readonly: Boolean, disable: Boolean, stack: Boolean, stretch: Boolean, spread: Boolean, clearable: Boolean, ripple: { type: [Boolean, Object], default: true } }, emits: ["update:modelValue", "clear", "click"], setup(e, { slots: t, emit: o }) {
    const n = computed2(() => e.options.find((t2) => t2.value === e.modelValue) !== void 0), a = computed2(() => ({ type: "hidden", name: e.name, value: e.modelValue })), l = useFormInject(a), i = computed2(() => e.options.map((t2, o2) => {
      const { attrs: n2, value: a2, slot: l2, ...i2 } = t2;
      return { slot: l2, props: { key: o2, onClick(e2) {
        r(a2, t2, e2);
      }, ...n2, ...i2, outline: e.outline, flat: e.flat, rounded: e.rounded, push: e.push, unelevated: e.unelevated, dense: e.dense, disable: e.disable === true || i2.disable === true, color: a2 === e.modelValue ? s2(i2, "toggleColor") : s2(i2, "color"), textColor: a2 === e.modelValue ? s2(i2, "toggleTextColor") : s2(i2, "textColor"), noCaps: s2(i2, "noCaps") === true, noWrap: s2(i2, "noWrap") === true, size: s2(i2, "size"), padding: s2(i2, "padding"), ripple: s2(i2, "ripple"), stack: s2(i2, "stack") === true, stretch: s2(i2, "stretch") === true } };
    }));
    function r(t2, n2, a2) {
      e.readonly !== true && (e.modelValue === t2 ? e.clearable === true && (o("update:modelValue", null, null), o("clear")) : o("update:modelValue", t2, n2), o("click", a2));
    }
    function s2(t2, o2) {
      return t2[o2] === void 0 ? e[o2] : t2[o2];
    }
    function u() {
      const o2 = i.value.map((e2) => {
        return h(QBtn, e2.props, e2.slot !== void 0 ? t[e2.slot] : void 0);
      });
      return e.name !== void 0 && e.disable !== true && n.value === true && l(o2, "push"), hMergeSlot(t.default, o2);
    }
    return () => h(QBtnGroup, { class: "q-btn-toggle", outline: e.outline, flat: e.flat, rounded: e.rounded, push: e.push, stretch: e.stretch, unelevated: e.unelevated, glossy: e.glossy, spread: e.spread }, u);
  } });
  var QCard = defineComponent2({ name: "QCard", props: { ...useDarkProps, tag: { type: String, default: "div" }, square: Boolean, flat: Boolean, bordered: Boolean }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => "q-card" + (n.value === true ? " q-card--dark q-dark" : "") + (e.bordered === true ? " q-card--bordered" : "") + (e.square === true ? " q-card--square no-border-radius" : "") + (e.flat === true ? " q-card--flat no-shadow" : ""));
    return () => h(e.tag, { class: a.value }, hSlot(t.default));
  } });
  var QCardSection = defineComponent2({ name: "QCardSection", props: { tag: { type: String, default: "div" }, horizontal: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => `q-card__section q-card__section--${e.horizontal === true ? "horiz row no-wrap" : "vert"}`);
    return () => h(e.tag, { class: o.value }, hSlot(t.default));
  } });
  var QCardActions = defineComponent2({ name: "QCardActions", props: { ...useAlignProps, vertical: Boolean }, setup(e, { slots: t }) {
    const o = useAlign(e), n = computed2(() => `q-card__actions ${o.value} q-card__actions--${e.vertical === true ? "vert column" : "horiz row"}`);
    return () => h("div", { class: n.value }, hSlot(t.default));
  } });
  var modifiersAll = { left: true, right: true, up: true, down: true, horizontal: true, vertical: true };
  var directionList = Object.keys(modifiersAll);
  function getModifierDirections(e) {
    const t = {};
    for (const o of directionList)
      e[o] === true && (t[o] = true);
    return Object.keys(t).length === 0 ? modifiersAll : (t.horizontal === true ? t.left = t.right = true : t.left === true && t.right === true && (t.horizontal = true), t.vertical === true ? t.up = t.down = true : t.up === true && t.down === true && (t.vertical = true), t.horizontal === true && t.vertical === true && (t.all = true), t);
  }
  function shouldStart(e, t) {
    return t.event === void 0 && e.target !== void 0 && e.target.draggable !== true && typeof t.handler === "function" && e.target.nodeName.toUpperCase() !== "INPUT" && (e.qClonedBy === void 0 || e.qClonedBy.indexOf(t.uid) === -1);
  }
  function parseArg(e) {
    const t = [0.06, 6, 50];
    return typeof e === "string" && e.length && e.split(":").forEach((e2, o) => {
      const n = parseFloat(e2);
      n && (t[o] = n);
    }), t;
  }
  modifiersAll.all = true;
  var TouchSwipe = { name: "touch-swipe", beforeMount(e, { value: t, arg: o, modifiers: n }) {
    if (n.mouse !== true && client2.has.touch !== true)
      return;
    const a = n.mouseCapture === true ? "Capture" : "", l = { handler: t, sensitivity: parseArg(o), direction: getModifierDirections(n), noop, mouseStart(e2) {
      shouldStart(e2, l) && leftClick(e2) && (addEvt(l, "temp", [[document, "mousemove", "move", `notPassive${a}`], [document, "mouseup", "end", "notPassiveCapture"]]), l.start(e2, true));
    }, touchStart(e2) {
      if (shouldStart(e2, l)) {
        const t2 = e2.target;
        addEvt(l, "temp", [[t2, "touchmove", "move", "notPassiveCapture"], [t2, "touchcancel", "end", "notPassiveCapture"], [t2, "touchend", "end", "notPassiveCapture"]]), l.start(e2);
      }
    }, start(t2, o2) {
      client2.is.firefox === true && preventDraggable(e, true);
      const n2 = position(t2);
      l.event = { x: n2.left, y: n2.top, time: Date.now(), mouse: o2 === true, dir: false };
    }, move(e2) {
      if (l.event === void 0)
        return;
      if (l.event.dir !== false)
        return void stopAndPrevent(e2);
      const t2 = Date.now() - l.event.time;
      if (t2 === 0)
        return;
      const o2 = position(e2), n2 = o2.left - l.event.x, a2 = Math.abs(n2), i = o2.top - l.event.y, r = Math.abs(i);
      if (l.event.mouse !== true) {
        if (a2 < l.sensitivity[1] && r < l.sensitivity[1])
          return void l.end(e2);
      } else if (a2 < l.sensitivity[2] && r < l.sensitivity[2])
        return;
      const s2 = a2 / t2, u = r / t2;
      l.direction.vertical === true && a2 < r && a2 < 100 && u > l.sensitivity[0] && (l.event.dir = i < 0 ? "up" : "down"), l.direction.horizontal === true && a2 > r && r < 100 && s2 > l.sensitivity[0] && (l.event.dir = n2 < 0 ? "left" : "right"), l.direction.up === true && a2 < r && i < 0 && a2 < 100 && u > l.sensitivity[0] && (l.event.dir = "up"), l.direction.down === true && a2 < r && i > 0 && a2 < 100 && u > l.sensitivity[0] && (l.event.dir = "down"), l.direction.left === true && a2 > r && n2 < 0 && r < 100 && s2 > l.sensitivity[0] && (l.event.dir = "left"), l.direction.right === true && a2 > r && n2 > 0 && r < 100 && s2 > l.sensitivity[0] && (l.event.dir = "right"), l.event.dir !== false ? (stopAndPrevent(e2), l.event.mouse === true && (document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), clearSelection(), l.styleCleanup = (e3) => {
        l.styleCleanup = void 0, document.body.classList.remove("non-selectable");
        const t3 = () => {
          document.body.classList.remove("no-pointer-events--children");
        };
        e3 === true ? setTimeout(t3, 50) : t3();
      }), l.handler({ evt: e2, touch: l.event.mouse !== true, mouse: l.event.mouse, direction: l.event.dir, duration: t2, distance: { x: a2, y: r } })) : l.end(e2);
    }, end(t2) {
      l.event !== void 0 && (cleanEvt(l, "temp"), client2.is.firefox === true && preventDraggable(e, false), l.styleCleanup !== void 0 && l.styleCleanup(true), t2 !== void 0 && l.event.dir !== false && stopAndPrevent(t2), l.event = void 0);
    } };
    e.__qtouchswipe = l, n.mouse === true && addEvt(l, "main", [[e, "mousedown", "mouseStart", `passive${a}`]]), client2.has.touch === true && addEvt(l, "main", [[e, "touchstart", "touchStart", `passive${n.capture === true ? "Capture" : ""}`], [e, "touchmove", "noop", "notPassiveCapture"]]);
  }, updated(e, t) {
    const o = e.__qtouchswipe;
    o !== void 0 && (t.oldValue !== t.value && (typeof t.value !== "function" && o.end(), o.handler = t.value), o.direction = getModifierDirections(t.modifiers));
  }, beforeUnmount(e) {
    const t = e.__qtouchswipe;
    t !== void 0 && (cleanEvt(t, "main"), cleanEvt(t, "temp"), client2.is.firefox === true && preventDraggable(e, false), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchswipe);
  } };
  function useCache() {
    const e = new Map();
    return { getCache: function(t, o) {
      return e[t] === void 0 ? e[t] = o : e[t];
    }, getCacheWithFn: function(t, o) {
      return e[t] === void 0 ? e[t] = o() : e[t];
    } };
  }
  var usePanelChildProps = { name: { required: true }, disable: Boolean };
  var PanelWrapper$1 = { setup(e, { slots: t }) {
    return () => h("div", { class: "q-panel scroll", role: "tabpanel" }, hSlot(t.default));
  } };
  var usePanelProps = { modelValue: { required: true }, animated: Boolean, infinite: Boolean, swipeable: Boolean, vertical: Boolean, transitionPrev: String, transitionNext: String, keepAlive: Boolean, keepAliveInclude: [String, Array, RegExp], keepAliveExclude: [String, Array, RegExp], keepAliveMax: Number };
  var usePanelEmits = ["update:modelValue", "before-transition", "transition"];
  function usePanel() {
    const { props: e, emit: t, proxy: o } = getCurrentInstance(), { getCacheWithFn: n } = useCache();
    let a, l;
    const i = ref(null), r = ref(null);
    function s2(t2) {
      const n2 = e.vertical === true ? "up" : "left";
      C((o.$q.lang.rtl === true ? -1 : 1) * (t2.direction === n2 ? 1 : -1));
    }
    const u = computed2(() => {
      return [[TouchSwipe, s2, void 0, { horizontal: e.vertical !== true, vertical: e.vertical, mouse: true }]];
    }), c = computed2(() => e.transitionPrev || `slide-${e.vertical === true ? "down" : "right"}`), d = computed2(() => e.transitionNext || `slide-${e.vertical === true ? "up" : "left"}`), p2 = computed2(() => typeof e.modelValue === "string" || typeof e.modelValue === "number" ? e.modelValue : String(e.modelValue)), v = computed2(() => ({ include: e.keepAliveInclude, exclude: e.keepAliveExclude, max: e.keepAliveMax })), m = computed2(() => e.keepAliveInclude !== void 0 || e.keepAliveExclude !== void 0);
    function f() {
      C(1);
    }
    function g() {
      C(-1);
    }
    function b(e2) {
      t("update:modelValue", e2);
    }
    function y(e2) {
      return e2 !== void 0 && e2 !== null && e2 !== "";
    }
    function S(e2) {
      return a.findIndex((t2) => {
        return t2.props.name === e2 && t2.props.disable !== "" && t2.props.disable !== true;
      });
    }
    function w() {
      return a.filter((e2) => {
        return e2.props.disable !== "" && e2.props.disable !== true;
      });
    }
    function x(t2) {
      const o2 = t2 !== 0 && e.animated === true && i.value !== -1 ? "q-transition--" + (t2 === -1 ? c.value : d.value) : null;
      r.value !== o2 && (r.value = o2);
    }
    function C(o2, n2 = i.value) {
      let r2 = n2 + o2;
      while (r2 > -1 && r2 < a.length) {
        const e2 = a[r2];
        if (e2 !== void 0 && e2.props.disable !== "" && e2.props.disable !== true)
          return x(o2), l = true, t("update:modelValue", e2.props.name), void setTimeout(() => {
            l = false;
          });
        r2 += o2;
      }
      e.infinite === true && a.length > 0 && n2 !== -1 && n2 !== a.length && C(o2, o2 === -1 ? a.length : -1);
    }
    function k2() {
      const t2 = S(e.modelValue);
      return i.value !== t2 && (i.value = t2), true;
    }
    function _() {
      const t2 = y(e.modelValue) && k2() && a[i.value];
      return e.keepAlive === true ? [h(KeepAlive, v.value, [h(m.value === true ? n(p2.value, () => ({ ...PanelWrapper$1, name: p2.value })) : PanelWrapper$1, { key: p2.value }, () => t2)])] : [h("div", { class: "q-panel scroll", key: p2.value, role: "tabpanel" }, [t2])];
    }
    function q() {
      if (a.length !== 0)
        return e.animated === true ? [h(Transition, { name: r.value }, _)] : _();
    }
    function T(e2) {
      return a = getNormalizedVNodes(hSlot(e2.default, [])).filter((e3) => e3.props !== null && e3.props.slot === void 0 && y(e3.props.name)), a.length;
    }
    function P() {
      return a;
    }
    return watch(() => e.modelValue, (e2, o2) => {
      const n2 = y(e2) === true ? S(e2) : -1;
      l !== true && x(n2 === -1 ? 0 : n2 < S(o2) ? -1 : 1), i.value !== n2 && (i.value = n2, t("before-transition", e2, o2), nextTick2(() => {
        t("transition", e2, o2);
      }));
    }), Object.assign(o, { next: f, previous: g, goTo: b }), { panelIndex: i, panelDirectives: u, updatePanelsList: T, updatePanelIndex: k2, getPanelContent: q, getEnabledPanels: w, getPanels: P, isValidPanelName: y, keepAliveProps: v, needsUniqueKeepAliveWrapper: m, goToPanelByOffset: C, goToPanel: b, nextPanel: f, previousPanel: g };
  }
  var useFullscreenProps = { fullscreen: Boolean, noRouteFullscreenExit: Boolean };
  var useFullscreenEmits = ["update:fullscreen", "fullscreen"];
  function useFullscreen() {
    const e = getCurrentInstance(), { props: t, emit: o, proxy: n } = e;
    let a, l, i;
    const r = ref(false);
    function s2() {
      r.value === true ? c() : u();
    }
    function u() {
      r.value !== true && (r.value = true, i = n.$el.parentNode, i.replaceChild(l, n.$el), document.body.appendChild(n.$el), document.body.classList.add("q-body--fullscreen-mixin"), a = { handler: c }, History.add(a));
    }
    function c() {
      r.value === true && (a !== void 0 && (History.remove(a), a = void 0), i.replaceChild(n.$el, l), document.body.classList.remove("q-body--fullscreen-mixin"), r.value = false, n.$el.scrollIntoView !== void 0 && setTimeout(() => {
        n.$el.scrollIntoView();
      }));
    }
    return vmHasRouter(e) === true && watch(() => n.$route, () => {
      t.noRouteFullscreenExit !== true && c();
    }), watch(() => t.fullscreen, (e2) => {
      r.value !== e2 && s2();
    }), watch(r, (e2) => {
      o("update:fullscreen", e2), o("fullscreen", e2);
    }), onBeforeMount(() => {
      l = document.createElement("span");
    }), onMounted2(() => {
      t.fullscreen === true && u();
    }), onBeforeUnmount2(c), Object.assign(n, { toggleFullscreen: s2, setFullscreen: u, exitFullscreen: c }), { inFullscreen: r, toggleFullscreen: s2 };
  }
  var hasMap = typeof Map === "function";
  var hasSet = typeof Set === "function";
  var hasArrayBuffer = typeof ArrayBuffer === "function";
  function isDeepEqual(e, t) {
    if (e === t)
      return true;
    if (e !== null && t !== null && typeof e === "object" && typeof t === "object") {
      if (e.constructor !== t.constructor)
        return false;
      let o, n;
      if (e.constructor === Array) {
        if (o = e.length, o !== t.length)
          return false;
        for (n = o; n-- !== 0; )
          if (isDeepEqual(e[n], t[n]) !== true)
            return false;
        return true;
      }
      if (hasMap === true && e.constructor === Map) {
        if (e.size !== t.size)
          return false;
        n = e.entries().next();
        while (n.done !== true) {
          if (t.has(n.value[0]) !== true)
            return false;
          n = n.next();
        }
        n = e.entries().next();
        while (n.done !== true) {
          if (isDeepEqual(n.value[1], t.get(n.value[0])) !== true)
            return false;
          n = n.next();
        }
        return true;
      }
      if (hasSet === true && e.constructor === Set) {
        if (e.size !== t.size)
          return false;
        n = e.entries().next();
        while (n.done !== true) {
          if (t.has(n.value[0]) !== true)
            return false;
          n = n.next();
        }
        return true;
      }
      if (hasArrayBuffer === true && e.buffer != null && e.buffer.constructor === ArrayBuffer) {
        if (o = e.length, o !== t.length)
          return false;
        for (n = o; n-- !== 0; )
          if (e[n] !== t[n])
            return false;
        return true;
      }
      if (e.constructor === RegExp)
        return e.source === t.source && e.flags === t.flags;
      if (e.valueOf !== Object.prototype.valueOf)
        return e.valueOf() === t.valueOf();
      if (e.toString !== Object.prototype.toString)
        return e.toString() === t.toString();
      const a = Object.keys(e);
      if (o = a.length, o !== Object.keys(t).length)
        return false;
      for (n = o; n-- !== 0; ) {
        const o2 = a[n];
        if (isDeepEqual(e[o2], t[o2]) !== true)
          return false;
      }
      return true;
    }
    return e !== e && t !== t;
  }
  function isDate2(e) {
    return Object.prototype.toString.call(e) === "[object Date]";
  }
  function isNumber(e) {
    return typeof e === "number" && isFinite(e);
  }
  var navigationPositionOptions = ["top", "right", "bottom", "left"];
  var controlTypeOptions = ["regular", "flat", "outline", "push", "unelevated"];
  var QCarousel = defineComponent2({ name: "QCarousel", props: { ...useDarkProps, ...usePanelProps, ...useFullscreenProps, transitionPrev: { type: String, default: "fade" }, transitionNext: { type: String, default: "fade" }, height: String, padding: Boolean, controlColor: String, controlTextColor: String, controlType: { type: String, validator: (e) => controlTypeOptions.includes(e), default: "flat" }, autoplay: [Number, Boolean], arrows: Boolean, prevIcon: String, nextIcon: String, navigation: Boolean, navigationPosition: { type: String, validator: (e) => navigationPositionOptions.includes(e) }, navigationIcon: String, navigationActiveIcon: String, thumbnails: Boolean }, emits: [...useFullscreenEmits, ...usePanelEmits], setup(e, { slots: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = useDark(e, o);
    let a, l;
    const { updatePanelsList: i, getPanelContent: r, panelDirectives: s2, goToPanel: u, previousPanel: c, nextPanel: d, getEnabledPanels: p2, panelIndex: v } = usePanel(), { inFullscreen: m } = useFullscreen(), f = computed2(() => m.value !== true && e.height !== void 0 ? { height: e.height } : {}), g = computed2(() => e.vertical === true ? "vertical" : "horizontal"), b = computed2(() => `q-carousel q-panel-parent q-carousel--with${e.padding === true ? "" : "out"}-padding` + (m.value === true ? " fullscreen" : "") + (n.value === true ? " q-carousel--dark q-dark" : "") + (e.arrows === true ? ` q-carousel--arrows-${g.value}` : "") + (e.navigation === true ? ` q-carousel--navigation-${x.value}` : "")), y = computed2(() => {
      const t2 = [e.prevIcon || o.iconSet.carousel[e.vertical === true ? "up" : "left"], e.nextIcon || o.iconSet.carousel[e.vertical === true ? "down" : "right"]];
      return e.vertical === false && o.lang.rtl === true ? t2.reverse() : t2;
    }), S = computed2(() => e.navigationIcon || o.iconSet.carousel.navigationIcon), w = computed2(() => e.navigationActiveIcon || S.value), x = computed2(() => e.navigationPosition || (e.vertical === true ? "right" : "bottom")), C = computed2(() => ({ color: e.controlColor, textColor: e.controlTextColor, round: true, [e.controlType]: true, dense: true }));
    function k2() {
      a = setTimeout(d, isNumber(e.autoplay) ? e.autoplay : 5e3);
    }
    function _(t2, o2) {
      return h("div", { class: `q-carousel__control q-carousel__navigation no-wrap absolute flex q-carousel__navigation--${t2} q-carousel__navigation--${x.value}` + (e.controlColor !== void 0 ? ` text-${e.controlColor}` : "") }, [h("div", { class: "q-carousel__navigation-inner flex flex-center no-wrap" }, p2().map(o2))]);
    }
    function q() {
      const o2 = [];
      if (e.navigation === true) {
        const e2 = t["navigation-icon"] !== void 0 ? t["navigation-icon"] : (e3) => h(QBtn, { key: "nav" + e3.name, class: `q-carousel__navigation-icon q-carousel__navigation-icon--${e3.active === true ? "" : "in"}active`, ...e3.btnProps, onClick: e3.onClick }), n2 = l - 1;
        o2.push(_("buttons", (t2, o3) => {
          const a2 = t2.props.name, l2 = v.value === o3;
          return e2({ index: o3, maxIndex: n2, name: a2, active: l2, btnProps: { icon: l2 === true ? w.value : S.value, size: "sm", ...C.value }, onClick: () => {
            u(a2);
          } });
        }));
      } else if (e.thumbnails === true) {
        const t2 = e.controlColor !== void 0 ? ` text-${e.controlColor}` : "";
        o2.push(_("thumbnails", (o3) => {
          const n2 = o3.props;
          return h("img", { key: "tmb#" + n2.name, class: `q-carousel__thumbnail q-carousel__thumbnail--${n2.name === e.modelValue ? "" : "in"}active` + t2, src: n2.imgSrc || n2["img-src"], onClick: () => {
            u(n2.name);
          } });
        }));
      }
      return e.arrows === true && v.value >= 0 && ((e.infinite === true || v.value > 0) && o2.push(h("div", { key: "prev", class: `q-carousel__control q-carousel__arrow q-carousel__prev-arrow q-carousel__prev-arrow--${g.value} absolute flex flex-center` }, [h(QBtn, { icon: y.value[0], ...C.value, onClick: c })])), (e.infinite === true || v.value < l - 1) && o2.push(h("div", { key: "next", class: `q-carousel__control q-carousel__arrow q-carousel__next-arrow q-carousel__next-arrow--${g.value} absolute flex flex-center` }, [h(QBtn, { icon: y.value[1], ...C.value, onClick: d })]))), hMergeSlot(t.control, o2);
    }
    return watch(() => e.modelValue, () => {
      e.autoplay && (clearInterval(a), k2());
    }), watch(() => e.autoplay, (e2) => {
      e2 ? k2() : clearInterval(a);
    }), onMounted2(() => {
      e.autoplay && k2();
    }), onBeforeUnmount2(() => {
      clearInterval(a);
    }), () => {
      return l = i(t), h("div", { class: b.value, style: f.value }, [hDir("div", { class: "q-carousel__slides-container" }, r(), "sl-cont", e.swipeable, () => s2.value)].concat(q()));
    };
  } });
  var QCarouselSlide = defineComponent2({ name: "QCarouselSlide", props: { ...usePanelChildProps, imgSrc: String }, setup(e, { slots: t }) {
    const o = computed2(() => e.imgSrc ? { backgroundImage: `url("${e.imgSrc}")` } : {});
    return () => h("div", { class: "q-carousel__slide", style: o.value }, hSlot(t.default));
  } });
  var QCarouselControl = defineComponent2({ name: "QCarouselControl", props: { position: { type: String, default: "bottom-right", validator: (e) => ["top-right", "top-left", "bottom-right", "bottom-left", "top", "right", "bottom", "left"].includes(e) }, offset: { type: Array, default: () => [18, 18], validator: (e) => e.length === 2 } }, setup(e, { slots: t }) {
    const o = computed2(() => `q-carousel__control absolute absolute-${e.position}`), n = computed2(() => ({ margin: `${e.offset[1]}px ${e.offset[0]}px` }));
    return () => h("div", { class: o.value, style: n.value }, hSlot(t.default));
  } });
  var QChatMessage = defineComponent2({ name: "QChatMessage", props: { sent: Boolean, label: String, bgColor: String, textColor: String, name: String, avatar: String, text: Array, stamp: String, size: String, labelHtml: Boolean, nameHtml: Boolean, textHtml: Boolean, stampHtml: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => e.sent === true ? "sent" : "received"), n = computed2(() => `q-message-text-content q-message-text-content--${o.value}` + (e.textColor !== void 0 ? ` text-${e.textColor}` : "")), a = computed2(() => `q-message-text q-message-text--${o.value}` + (e.bgColor !== void 0 ? ` text-${e.bgColor}` : "")), l = computed2(() => "q-message-container row items-end no-wrap" + (e.sent === true ? " reverse" : "")), i = computed2(() => e.size !== void 0 ? `col-${e.size}` : ""), r = computed2(() => ({ msg: e.textHtml === true ? "innerHTML" : "textContent", stamp: e.stampHtml === true ? "innerHTML" : "textContent", name: e.nameHtml === true ? "innerHTML" : "textContent", label: e.labelHtml === true ? "innerHTML" : "textContent" }));
    function s2(o2) {
      return t.stamp !== void 0 ? [o2, h("div", { class: "q-message-stamp" }, t.stamp())] : e.stamp ? [o2, h("div", { class: "q-message-stamp", [r.value.stamp]: e.stamp })] : [o2];
    }
    function u(e2, t2) {
      const o2 = t2 === true ? e2.length > 1 ? (e3) => e3 : (e3) => h("div", [e3]) : (e3) => h("div", { [r.value.msg]: e3 });
      return e2.map((e3, t3) => h("div", { key: t3, class: a.value }, [h("div", { class: n.value }, s2(o2(e3)))]));
    }
    return () => {
      const n2 = [];
      t.avatar !== void 0 ? n2.push(t.avatar()) : e.avatar !== void 0 && n2.push(h("img", { class: `q-message-avatar q-message-avatar--${o.value}`, src: e.avatar, "aria-hidden": "true" }));
      const a2 = [];
      t.name !== void 0 ? a2.push(h("div", { class: `q-message-name q-message-name--${o.value}` }, t.name())) : e.name !== void 0 && a2.push(h("div", { class: `q-message-name q-message-name--${o.value}`, [r.value.name]: e.name })), t.default !== void 0 ? a2.push(u(getNormalizedVNodes(t.default()), true)) : e.text !== void 0 && a2.push(u(e.text)), n2.push(h("div", { class: i.value }, a2));
      const s3 = [];
      return t.label !== void 0 ? s3.push(h("div", { class: "q-message-label" }, t.label())) : e.label !== void 0 && s3.push(h("div", { class: "q-message-label", [r.value.label]: e.label })), s3.push(h("div", { class: l.value }, n2)), h("div", { class: `q-message q-message-${o.value}` }, s3);
    };
  } });
  function useRefocusTarget(e, t) {
    const o = ref(null), n = computed2(() => {
      return e.disable !== true ? null : h("span", { ref: o, class: "no-outline", tabindex: -1 });
    });
    function a(e2) {
      e2 !== void 0 && e2.type.indexOf("key") === 0 ? document.activeElement !== t.value && t.value.contains(document.activeElement) === true && t.value.focus() : e2 !== void 0 && t.value.contains(e2.target) !== true || o.value === null || o.value.focus();
    }
    return { refocusTargetEl: n, refocusTarget: a };
  }
  var optionSizes = { xs: 30, sm: 35, md: 40, lg: 50, xl: 60 };
  var useCheckboxProps = { ...useDarkProps, ...useSizeProps, ...useFormProps, modelValue: { required: true, default: null }, val: {}, trueValue: { default: true }, falseValue: { default: false }, indeterminateValue: { default: null }, toggleOrder: { type: String, validator: (e) => e === "tf" || e === "ft" }, toggleIndeterminate: Boolean, label: String, leftLabel: Boolean, color: String, keepColor: Boolean, dense: Boolean, disable: Boolean, tabindex: [String, Number] };
  var useCheckboxEmits = ["update:modelValue"];
  function useCheckbox(e, t) {
    const { props: o, slots: n, emit: a, proxy: l } = getCurrentInstance(), { $q: i } = l, r = useDark(o, i), s2 = ref(null), { refocusTargetEl: u, refocusTarget: c } = useRefocusTarget(o, s2), d = useSize(o, optionSizes), p2 = computed2(() => o.val !== void 0 && Array.isArray(o.modelValue)), v = computed2(() => p2.value === true ? o.modelValue.indexOf(o.val) : -1), m = computed2(() => p2.value === true ? v.value > -1 : o.modelValue === o.trueValue), f = computed2(() => p2.value === true ? v.value === -1 : o.modelValue === o.falseValue), g = computed2(() => m.value === false && f.value === false), b = computed2(() => o.disable === true ? -1 : o.tabindex || 0), y = computed2(() => `q-${e} cursor-pointer no-outline row inline no-wrap items-center` + (o.disable === true ? " disabled" : "") + (r.value === true ? ` q-${e}--dark` : "") + (o.dense === true ? ` q-${e}--dense` : "") + (o.leftLabel === true ? " reverse" : "")), S = computed2(() => {
      const t2 = m.value === true ? "truthy" : f.value === true ? "falsy" : "indet", n2 = o.color === void 0 || o.keepColor !== true && (e === "toggle" ? m.value !== true : f.value === true) ? "" : ` text-${o.color}`;
      return `q-${e}__inner relative-position non-selectable q-${e}__inner--${t2}${n2}`;
    }), w = computed2(() => {
      const e2 = { type: "checkbox" };
      return o.name !== void 0 && Object.assign(e2, { checked: m.value, name: o.name, value: p2.value === true ? o.val : o.trueValue }), e2;
    }), x = useFormInject(w), C = computed2(() => {
      const e2 = { tabindex: b.value, role: "checkbox", "aria-label": o.label, "aria-checked": g.value === true ? "mixed" : m.value === true ? "true" : "false" };
      return o.disable === true && (e2["aria-disabled"] = "true"), e2;
    });
    function k2(e2) {
      e2 !== void 0 && (stopAndPrevent(e2), c(e2)), o.disable !== true && a("update:modelValue", _(), e2);
    }
    function _() {
      if (p2.value === true) {
        if (m.value === true) {
          const e2 = o.modelValue.slice();
          return e2.splice(v.value, 1), e2;
        }
        return o.modelValue.concat([o.val]);
      }
      if (m.value === true) {
        if (o.toggleOrder !== "ft" || o.toggleIndeterminate === false)
          return o.falseValue;
      } else {
        if (f.value !== true)
          return o.toggleOrder !== "ft" ? o.trueValue : o.falseValue;
        if (o.toggleOrder === "ft" || o.toggleIndeterminate === false)
          return o.trueValue;
      }
      return o.indeterminateValue;
    }
    function q(e2) {
      e2.keyCode !== 13 && e2.keyCode !== 32 || stopAndPrevent(e2);
    }
    function T(e2) {
      e2.keyCode !== 13 && e2.keyCode !== 32 || k2(e2);
    }
    const P = t(m, g);
    return Object.assign(l, { toggle: k2 }), () => {
      const t2 = P();
      o.disable !== true && x(t2, "unshift", ` q-${e}__native absolute q-ma-none q-pa-none`);
      const a2 = [h("div", { class: S.value, style: d.value }, t2)];
      u.value !== null && a2.push(u.value);
      const l2 = o.label !== void 0 ? hMergeSlot(n.default, [o.label]) : hSlot(n.default);
      return l2 !== void 0 && a2.push(h("div", { class: `q-${e}__label q-anchor--skip` }, l2)), h("div", { ref: s2, class: y.value, ...C.value, onClick: k2, onKeydown: q, onKeyup: T }, a2);
    };
  }
  var bgNode = h("div", { class: "q-checkbox__bg absolute" }, [h("svg", { class: "q-checkbox__svg fit absolute-full", viewBox: "0 0 24 24", "aria-hidden": "true" }, [h("path", { class: "q-checkbox__truthy", fill: "none", d: "M1.73,12.91 8.1,19.28 22.79,4.59" }), h("path", { class: "q-checkbox__indet", d: "M4,14H20V10H4" })])]);
  var QCheckbox = defineComponent2({ name: "QCheckbox", props: useCheckboxProps, emits: useCheckboxEmits, setup() {
    return useCheckbox("checkbox", () => () => [bgNode]);
  } });
  var defaultSizes$1 = { xs: 8, sm: 10, md: 14, lg: 20, xl: 24 };
  var QChip = defineComponent2({ name: "QChip", props: { ...useDarkProps, ...useSizeProps, dense: Boolean, icon: String, iconRight: String, iconRemove: String, iconSelected: String, label: [String, Number], color: String, textColor: String, modelValue: { type: Boolean, default: true }, selected: { type: Boolean, default: null }, square: Boolean, outline: Boolean, clickable: Boolean, removable: Boolean, tabindex: [String, Number], disable: Boolean, ripple: { type: [Boolean, Object], default: true } }, emits: ["update:modelValue", "update:selected", "remove", "click"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useDark(e, n), l = useSize(e, defaultSizes$1), i = computed2(() => e.selected === true || e.icon !== void 0), r = computed2(() => e.selected === true ? e.iconSelected || n.iconSet.chip.selected : e.icon), s2 = computed2(() => e.iconRemove || n.iconSet.chip.remove), u = computed2(() => e.disable === false && (e.clickable === true || e.selected !== null)), c = computed2(() => {
      const t2 = e.outline === true && e.color || e.textColor;
      return "q-chip row inline no-wrap items-center" + (e.outline === false && e.color !== void 0 ? ` bg-${e.color}` : "") + (t2 ? ` text-${t2} q-chip--colored` : "") + (e.disable === true ? " disabled" : "") + (e.dense === true ? " q-chip--dense" : "") + (e.outline === true ? " q-chip--outline" : "") + (e.selected === true ? " q-chip--selected" : "") + (u.value === true ? " q-chip--clickable cursor-pointer non-selectable q-hoverable" : "") + (e.square === true ? " q-chip--square" : "") + (a.value === true ? " q-chip--dark q-dark" : "");
    }), d = computed2(() => e.disable === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: e.tabindex || 0 });
    function p2(e2) {
      e2.keyCode === 13 && v(e2);
    }
    function v(t2) {
      e.disable || (o("update:selected", !e.selected), o("click", t2));
    }
    function m(t2) {
      t2.keyCode !== void 0 && t2.keyCode !== 13 || (stopAndPrevent(t2), e.disable === false && (o("update:modelValue", false), o("remove")));
    }
    function f() {
      const o2 = [];
      u.value === true && o2.push(h("div", { class: "q-focus-helper" })), i.value === true && o2.push(h(QIcon, { class: "q-chip__icon q-chip__icon--left", name: r.value }));
      const n2 = e.label !== void 0 ? [h("div", { class: "ellipsis" }, [e.label])] : void 0;
      return o2.push(h("div", { class: "q-chip__content col row no-wrap items-center q-anchor--skip" }, hMergeSlotSafely(t.default, n2))), e.iconRight && o2.push(h(QIcon, { class: "q-chip__icon q-chip__icon--right", name: e.iconRight })), e.removable === true && o2.push(h(QIcon, { class: "q-chip__icon q-chip__icon--remove cursor-pointer", name: s2.value, ...d.value, onClick: m, onKeyup: m })), o2;
    }
    return () => {
      if (e.modelValue === false)
        return;
      const t2 = { class: c.value, style: l.value };
      return u.value === true && Object.assign(t2, d.value, { onClick: v, onKeyup: p2 }), hDir("div", t2, f(), "ripple", e.ripple !== false && e.disable !== true, () => [[Ripple, e.ripple]]);
    };
  } });
  var useCircularCommonProps = { ...useSizeProps, min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, color: String, centerColor: String, trackColor: String, fontSize: String, thickness: { type: Number, default: 0.2, validator: (e) => e >= 0 && e <= 1 }, angle: { type: Number, default: 0 }, showValue: Boolean, reverse: Boolean, instantFeedback: Boolean };
  var radius = 50;
  var diameter = 2 * radius;
  var circumference = diameter * Math.PI;
  var strokeDashArray = Math.round(1e3 * circumference) / 1e3;
  var QCircularProgress = defineComponent2({ name: "QCircularProgress", props: { ...useCircularCommonProps, value: { type: Number, default: 0 }, indeterminate: Boolean }, setup(e, { slots: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = useSize(e), a = computed2(() => {
      const t2 = (o.lang.rtl === true ? -1 : 1) * e.angle;
      return { transform: e.reverse !== (o.lang.rtl === true) ? `scale3d(-1, 1, 1) rotate3d(0, 0, 1, ${-90 - t2}deg)` : `rotate3d(0, 0, 1, ${t2 - 90}deg)` };
    }), l = computed2(() => e.instantFeedback !== true && e.indeterminate !== true ? { transition: "stroke-dashoffset 0.6s ease 0s, stroke 0.6s ease" } : ""), i = computed2(() => diameter / (1 - e.thickness / 2)), r = computed2(() => `${i.value / 2} ${i.value / 2} ${i.value} ${i.value}`), s2 = computed2(() => between(e.value, e.min, e.max)), u = computed2(() => circumference * (1 - (s2.value - e.min) / (e.max - e.min))), c = computed2(() => e.thickness / 2 * i.value);
    function d({ thickness: e2, offset: t2, color: o2, cls: n2 }) {
      return h("circle", { class: "q-circular-progress__" + n2 + (o2 !== void 0 ? ` text-${o2}` : ""), style: l.value, fill: "transparent", stroke: "currentColor", "stroke-width": e2, "stroke-dasharray": strokeDashArray, "stroke-dashoffset": t2, cx: i.value, cy: i.value, r: radius });
    }
    return () => {
      const o2 = [];
      e.centerColor !== void 0 && e.centerColor !== "transparent" && o2.push(h("circle", { class: `q-circular-progress__center text-${e.centerColor}`, fill: "currentColor", r: radius - c.value / 2, cx: i.value, cy: i.value })), e.trackColor !== void 0 && e.trackColor !== "transparent" && o2.push(d({ cls: "track", thickness: c.value, offset: 0, color: e.trackColor })), o2.push(d({ cls: "circle", thickness: c.value, offset: u.value, color: e.color }));
      const l2 = [h("svg", { class: "q-circular-progress__svg", style: a.value, viewBox: r.value, "aria-hidden": "true" }, o2)];
      return e.showValue === true && l2.push(h("div", { class: "q-circular-progress__text absolute-full row flex-center content-center", style: { fontSize: e.fontSize } }, t.default !== void 0 ? t.default() : [h("div", s2.value)])), h("div", { class: `q-circular-progress q-circular-progress--${e.indeterminate === true ? "in" : ""}determinate`, style: n.value, role: "progressbar", "aria-valuemin": e.min, "aria-valuemax": e.max, "aria-valuenow": e.indeterminate === true ? void 0 : s2.value }, hMergeSlotSafely(t.internal, l2));
    };
  } });
  function getChanges(e, t, o) {
    const n = position(e);
    let a, l = n.left - t.event.x, i = n.top - t.event.y, r = Math.abs(l), s2 = Math.abs(i);
    const u = t.direction;
    u.horizontal === true && u.vertical !== true ? a = l < 0 ? "left" : "right" : u.horizontal !== true && u.vertical === true ? a = i < 0 ? "up" : "down" : u.up === true && i < 0 ? (a = "up", r > s2 && (u.left === true && l < 0 ? a = "left" : u.right === true && l > 0 && (a = "right"))) : u.down === true && i > 0 ? (a = "down", r > s2 && (u.left === true && l < 0 ? a = "left" : u.right === true && l > 0 && (a = "right"))) : u.left === true && l < 0 ? (a = "left", r < s2 && (u.up === true && i < 0 ? a = "up" : u.down === true && i > 0 && (a = "down"))) : u.right === true && l > 0 && (a = "right", r < s2 && (u.up === true && i < 0 ? a = "up" : u.down === true && i > 0 && (a = "down")));
    let c = false;
    if (a === void 0 && o === false) {
      if (t.event.isFirst === true || t.event.lastDir === void 0)
        return {};
      a = t.event.lastDir, c = true, a === "left" || a === "right" ? (n.left -= l, r = 0, l = 0) : (n.top -= i, s2 = 0, i = 0);
    }
    return { synthetic: c, payload: { evt: e, touch: t.event.mouse !== true, mouse: t.event.mouse === true, position: n, direction: a, isFirst: t.event.isFirst, isFinal: o === true, duration: Date.now() - t.event.time, distance: { x: r, y: s2 }, offset: { x: l, y: i }, delta: { x: n.left - t.event.lastX, y: n.top - t.event.lastY } } };
  }
  var uid$4 = 0;
  var TouchPan = { name: "touch-pan", beforeMount(e, { value: t, modifiers: o }) {
    if (o.mouse !== true && client2.has.touch !== true)
      return;
    function n(e2, t2) {
      o.mouse === true && t2 === true ? stopAndPrevent(e2) : (o.stop === true && stop2(e2), o.prevent === true && prevent(e2));
    }
    const a = { uid: "qvtp_" + uid$4++, handler: t, modifiers: o, direction: getModifierDirections(o), noop, mouseStart(e2) {
      shouldStart(e2, a) && leftClick(e2) && (addEvt(a, "temp", [[document, "mousemove", "move", "notPassiveCapture"], [document, "mouseup", "end", "passiveCapture"]]), a.start(e2, true));
    }, touchStart(e2) {
      if (console.log("touchStart"), shouldStart(e2, a)) {
        const t2 = e2.target;
        addEvt(a, "temp", [[t2, "touchmove", "move", "notPassiveCapture"], [t2, "touchcancel", "end", "passiveCapture"], [t2, "touchend", "end", "passiveCapture"]]), a.start(e2);
      }
    }, start(t2, n2) {
      client2.is.firefox === true && preventDraggable(e, true), a.lastEvt = t2;
      const l = position(t2);
      if (n2 === true || o.stop === true) {
        if (a.direction.all !== true && (n2 !== true || a.direction.mouseAllDir !== true)) {
          const e2 = t2.type.indexOf("mouse") > -1 ? new MouseEvent(t2.type, t2) : new TouchEvent(t2.type, t2);
          t2.defaultPrevented === true && prevent(e2), t2.cancelBubble === true && stop2(e2), e2.qClonedBy = t2.qClonedBy === void 0 ? [a.uid] : t2.qClonedBy.concat(a.uid), e2.qKeyEvent = t2.qKeyEvent, e2.qClickOutside = t2.qClickOutside, a.initialEvent = { target: t2.target, event: e2 };
        }
        stop2(t2);
      }
      a.event = { x: l.left, y: l.top, time: Date.now(), mouse: n2 === true, detected: false, isFirst: true, isFinal: false, lastX: l.left, lastY: l.top };
    }, move(e2) {
      if (a.event === void 0)
        return;
      a.lastEvt = e2;
      const t2 = a.event.mouse === true, l = () => {
        n(e2, t2), o.preserveCursor !== true && (document.documentElement.style.cursor = "grabbing"), t2 === true && document.body.classList.add("no-pointer-events--children"), document.body.classList.add("non-selectable"), clearSelection(), a.styleCleanup = (e3) => {
          if (a.styleCleanup = void 0, o.preserveCursor !== true && (document.documentElement.style.cursor = ""), document.body.classList.remove("non-selectable"), t2 === true) {
            const t3 = () => {
              document.body.classList.remove("no-pointer-events--children");
            };
            e3 !== void 0 ? setTimeout(() => {
              t3(), e3();
            }, 50) : t3();
          } else
            e3 !== void 0 && e3();
        };
      };
      if (a.event.detected === true) {
        a.event.isFirst !== true && n(e2, a.event.mouse);
        const { payload: t3, synthetic: o2 } = getChanges(e2, a, false);
        return void (t3 !== void 0 && (a.handler(t3) === false ? a.end(e2) : (a.styleCleanup === void 0 && a.event.isFirst === true && l(), a.event.lastX = t3.position.left, a.event.lastY = t3.position.top, a.event.lastDir = o2 === true ? void 0 : t3.direction, a.event.isFirst = false)));
      }
      if (a.direction.all === true || t2 === true && a.modifiers.mouseAllDir === true)
        return l(), a.event.detected = true, void a.move(e2);
      const i = position(e2), r = i.left - a.event.x, s2 = i.top - a.event.y, u = Math.abs(r), c = Math.abs(s2);
      u !== c && (a.direction.horizontal === true && u > c || a.direction.vertical === true && u < c || a.direction.up === true && u < c && s2 < 0 || a.direction.down === true && u < c && s2 > 0 || a.direction.left === true && u > c && r < 0 || a.direction.right === true && u > c && r > 0 ? (a.event.detected = true, a.move(e2)) : a.end(e2, true));
    }, end(t2, o2) {
      if (a.event !== void 0) {
        if (cleanEvt(a, "temp"), client2.is.firefox === true && preventDraggable(e, false), o2 === true)
          a.styleCleanup !== void 0 && a.styleCleanup(), a.event.detected !== true && a.initialEvent !== void 0 && a.initialEvent.target.dispatchEvent(a.initialEvent.event);
        else if (a.event.detected === true) {
          a.event.isFirst === true && a.handler(getChanges(t2 === void 0 ? a.lastEvt : t2, a).payload);
          const { payload: e2 } = getChanges(t2 === void 0 ? a.lastEvt : t2, a, true), o3 = () => {
            a.handler(e2);
          };
          a.styleCleanup !== void 0 ? a.styleCleanup(o3) : o3();
        }
        a.event = void 0, a.initialEvent = void 0, a.lastEvt = void 0;
      }
    } };
    e.__qtouchpan = a, o.mouse === true && addEvt(a, "main", [[e, "mousedown", "mouseStart", `passive${o.mouseCapture === true ? "Capture" : ""}`]]), client2.has.touch === true && addEvt(a, "main", [[e, "touchstart", "touchStart", `passive${o.capture === true ? "Capture" : ""}`], [e, "touchmove", "noop", "notPassiveCapture"]]);
  }, updated(e, t) {
    const o = e.__qtouchpan;
    o !== void 0 && (t.oldValue !== t.value && (typeof value !== "function" && o.end(), o.handler = t.value), o.direction = getModifierDirections(t.modifiers));
  }, beforeUnmount(e) {
    const t = e.__qtouchpan;
    t !== void 0 && (t.event !== void 0 && t.end(), cleanEvt(t, "main"), cleanEvt(t, "temp"), client2.is.firefox === true && preventDraggable(e, false), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchpan);
  } };
  var keyCodes$2 = [34, 37, 40, 33, 39, 38];
  function getRatio(e, t, o, n) {
    const a = position(e), l = between(n === true ? (a.top - t.top) / t.height : (a.left - t.left) / t.width, 0, 1);
    return o === true ? 1 - l : l;
  }
  function getModel(e, t, o, n, a) {
    let l = t + e * (o - t);
    if (n > 0) {
      const e2 = (l - t) % n;
      l += (Math.abs(e2) >= n / 2 ? (e2 < 0 ? -1 : 1) * n : 0) - e2;
    }
    return a > 0 && (l = parseFloat(l.toFixed(a))), between(l, t, o);
  }
  var useSliderProps = { ...useDarkProps, min: { type: Number, default: 0 }, max: { type: Number, default: 100 }, step: { type: Number, default: 1, validator: (e) => e >= 0 }, color: String, labelColor: String, labelTextColor: String, dense: Boolean, label: Boolean, labelAlways: Boolean, markers: Boolean, snap: Boolean, vertical: Boolean, reverse: Boolean, disable: Boolean, readonly: Boolean, tabindex: [String, Number], thumbPath: { type: String, default: "M 4, 10 a 6,6 0 1,0 12,0 a 6,6 0 1,0 -12,0" } };
  var useSliderEmits = ["pan", "update:modelValue", "change"];
  function useSlider({ updateValue: e, updatePosition: t, getDragging: o }) {
    const { props: n, emit: a, proxy: { $q: l } } = getCurrentInstance(), i = useDark(n, l), r = ref(false), s2 = ref(false), u = ref(false), c = ref(false), d = computed2(() => n.vertical === true ? "--v" : "--h"), p2 = computed2(() => n.vertical === true ? n.reverse === true : n.reverse !== (l.lang.rtl === true)), v = computed2(() => n.disable !== true && n.readonly !== true && n.min < n.max), m = computed2(() => `q-slider q-slider${d.value} q-slider--${r.value === true ? "" : "in"}active` + (p2.value === true ? " q-slider--reversed" : "") + (n.color !== void 0 ? ` text-${n.color}` : "") + (n.disable === true ? " disabled" : " q-slider--enabled" + (v.value === true ? " q-slider--editable" : "")) + (u.value === "both" ? " q-slider--focus" : "") + (n.label || n.labelAlways === true ? " q-slider--label" : "") + (n.labelAlways === true ? " q-slider--label-always" : "") + (i.value === true ? " q-slider--dark" : "") + (n.dense === true ? " q-slider--dense q-slider--dense" + d.value : "")), f = computed2(() => (String(n.step).trim("0").split(".")[1] || "").length), g = computed2(() => n.step === 0 ? 1 : n.step), b = computed2(() => n.max - n.min), y = computed2(() => {
      if (b.value !== 0) {
        const e2 = 100 * g.value / b.value;
        return { backgroundSize: n.vertical === true ? `2px ${e2}%` : `${e2}% 2px` };
      }
      return null;
    }), S = computed2(() => v.value === true ? n.tabindex || 0 : -1), w = computed2(() => n.vertical === true ? p2.value === true ? "bottom" : "top" : p2.value === true ? "right" : "left"), x = computed2(() => n.vertical === true ? "height" : "width"), C = computed2(() => n.vertical === true ? "vertical" : "horizontal"), k2 = computed2(() => {
      const e2 = { role: "slider", "aria-valuemin": n.min, "aria-valuemax": n.max, "aria-orientation": C.value, "data-step": n.step };
      return n.disable === true ? e2["aria-disabled"] = "true" : n.readonly === true && (e2["aria-readonly"] = "true"), e2;
    }), _ = computed2(() => {
      return [[TouchPan, P, void 0, { [C.value]: true, prevent: true, stop: true, mouse: true, mouseAllDir: true }]];
    });
    function q() {
      return h("svg", { class: "q-slider__thumb absolute", viewBox: "0 0 20 20", width: "20", height: "20", "aria-hidden": "true" }, [h("path", { d: n.thumbPath })]);
    }
    function T(e2, t2) {
      if (n.vertical === true)
        return {};
      const o2 = `${Math.ceil(20 * Math.abs(0.5 - t2))}px`;
      return { pin: { transformOrigin: `${l.lang.rtl === true ? o2 : `calc(100% - ${o2})`} 50%` }, pinTextContainer: { [l.lang.rtl === true ? "left" : "right"]: `${100 * e2}%`, transform: `translateX(${Math.ceil(20 * (l.lang.rtl === true ? -1 : 1) * e2)}px)` } };
    }
    function P(n2) {
      n2.isFinal ? (c.value !== void 0 && (t(n2.evt), n2.touch === true && e(true), c.value = void 0, a("pan", "end")), r.value = false) : n2.isFirst ? (c.value = o(n2.evt), t(n2.evt), e(), r.value = true, a("pan", "start")) : (t(n2.evt), e());
    }
    function $() {
      u.value = false;
    }
    function M(n2) {
      t(n2, o(n2)), e(), s2.value = true, r.value = true, document.addEventListener("mouseup", B, true);
    }
    function B() {
      s2.value = false, c.value === void 0 && (r.value = false), e(true), $(), document.removeEventListener("mouseup", B, true);
    }
    function Q(n2) {
      t(n2, o(n2)), e(true);
    }
    function E(t2) {
      keyCodes$2.includes(t2.keyCode) && e(true);
    }
    return onBeforeUnmount2(() => {
      document.removeEventListener("mouseup", B, true);
    }), { state: { active: r, focus: u, preventFocus: s2, dragging: c, axis: d, isReversed: p2, editable: v, classes: m, decimals: f, step: g, minMaxDiff: b, markerStyle: y, tabindex: S, positionProp: w, sizeProp: x, attributes: k2, panDirective: _ }, methods: { onActivate: M, onMobileClick: Q, onBlur: $, onKeyup: E, getThumbSvg: q, getPinStyle: T } };
  }
  var QSlider = defineComponent2({ name: "QSlider", props: { ...useSliderProps, ...useFormProps, modelValue: { required: true, default: null, validator: (e) => typeof e === "number" || e === null }, labelValue: [String, Number] }, emits: useSliderEmits, setup(e, { emit: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = useFormAttrs(e), a = useFormInject(n), l = ref(null), i = ref(e.modelValue === null ? e.min : e.modelValue), r = ref(0), { state: s2, methods: u } = useSlider({ updateValue: w, updatePosition: C, getDragging: x }), c = computed2(() => s2.minMaxDiff.value === 0 ? 0 : (i.value - e.min) / s2.minMaxDiff.value), d = computed2(() => s2.active.value === true ? r.value : c.value), p2 = computed2(() => ({ [s2.positionProp.value]: 0, [s2.sizeProp.value]: `${100 * d.value}%` })), v = computed2(() => ({ [s2.positionProp.value]: `${100 * d.value}%` })), m = computed2(() => s2.preventFocus.value === false && s2.focus.value === true ? " q-slider--focus" : ""), f = computed2(() => e.labelColor !== void 0 ? `text-${e.labelColor}` : ""), g = computed2(() => "q-slider__pin-value-marker-text" + (e.labelTextColor !== void 0 ? ` text-${e.labelTextColor}` : "")), b = computed2(() => {
      return s2.editable.value !== true ? {} : o.platform.is.mobile === true ? { onClick: u.onMobileClick } : { onMousedown: u.onActivate, onFocus: k2, onBlur: u.onBlur, onKeydown: _, onKeyup: u.onKeyup };
    }), y = computed2(() => e.labelValue !== void 0 ? e.labelValue : i.value), S = computed2(() => {
      const t2 = e.reverse === true ? -d.value : d.value - 1;
      return u.getPinStyle(t2, d.value);
    });
    function w(o2) {
      i.value !== e.modelValue && t("update:modelValue", i.value), o2 === true && t("change", i.value);
    }
    function x() {
      return l.value.getBoundingClientRect();
    }
    function C(t2, o2 = s2.dragging.value) {
      const n2 = getRatio(t2, o2, s2.isReversed.value, e.vertical);
      i.value = getModel(n2, e.min, e.max, e.step, s2.decimals.value), r.value = e.snap !== true || e.step === 0 ? n2 : s2.minMaxDiff.value === 0 ? 0 : (i.value - e.min) / s2.minMaxDiff.value;
    }
    function k2() {
      s2.focus.value = true;
    }
    function _(t2) {
      if (!keyCodes$2.includes(t2.keyCode))
        return;
      stopAndPrevent(t2);
      const o2 = ([34, 33].includes(t2.keyCode) ? 10 : 1) * s2.step.value, n2 = [34, 37, 40].includes(t2.keyCode) ? -o2 : o2;
      i.value = between(parseFloat((i.value + n2).toFixed(s2.decimals.value)), e.min, e.max), w();
    }
    return watch(() => e.modelValue, (t2) => {
      i.value = t2 === null ? 0 : between(t2, e.min, e.max);
    }), watch(() => e.min + e.max, () => {
      i.value = between(i.value, e.min, e.max);
    }), () => {
      const t2 = [u.getThumbSvg(), h("div", { class: "q-slider__focus-ring" })];
      e.label !== true && e.labelAlways !== true || t2.push(h("div", { class: `q-slider__pin q-slider__pin${s2.axis.value} absolute ` + f.value, style: S.value.pin }, [h("div", { class: `q-slider__pin-text-container q-slider__pin-text-container${s2.axis.value}`, style: S.value.pinTextContainer }, [h("span", { class: "q-slider__pin-text " + g.value }, [y.value])])]), h("div", { class: `q-slider__arrow q-slider__arrow${s2.axis.value} ${f.value}` })), e.name !== void 0 && e.disable !== true && a(t2, "push");
      const o2 = [h("div", { class: `q-slider__track q-slider__track${s2.axis.value} absolute`, style: p2.value })];
      e.markers === true && o2.push(h("div", { class: `q-slider__track-markers q-slider__track-markers${s2.axis.value} absolute-full fit`, style: s2.markerStyle.value }));
      const n2 = [h("div", { class: `q-slider__track-container q-slider__track-container${s2.axis.value} absolute` }, o2), h("div", { class: `q-slider__thumb-container q-slider__thumb-container${s2.axis.value} absolute non-selectable` + m.value, style: v.value }, t2)], i2 = { ref: l, class: s2.classes.value + (e.modelValue === null ? " q-slider--no-value" : ""), ...s2.attributes.value, "aria-valuenow": e.modelValue, tabindex: s2.tabindex.value, ...b.value };
      return hDir("div", i2, n2, "slide", s2.editable.value, () => s2.panDirective.value);
    };
  } });
  function useCanRender() {
    const e = ref(!isRuntimeSsrPreHydration.value);
    return e.value === false && onMounted2(() => {
      e.value = true;
    }), e;
  }
  var hasObserver = typeof ResizeObserver !== "undefined";
  var resizeProps = hasObserver === true ? {} : { style: "display:block;position:absolute;top:0;left:0;right:0;bottom:0;height:100%;width:100%;overflow:hidden;pointer-events:none;z-index:-1;", url: "about:blank" };
  var QResizeObserver = defineComponent2({ name: "QResizeObserver", props: { debounce: { type: [String, Number], default: 100 } }, emits: ["resize"], setup(e, { emit: t }) {
    let o, n, a = { width: -1, height: -1 };
    function l(t2) {
      t2 === true || e.debounce === 0 || e.debounce === "0" ? i() : o || (o = setTimeout(i, e.debounce));
    }
    function i() {
      if (o = void 0, n) {
        const { offsetWidth: e2, offsetHeight: o2 } = n;
        e2 === a.width && o2 === a.height || (a = { width: e2, height: o2 }, t("resize", a));
      }
    }
    const r = getCurrentInstance();
    if (Object.assign(r.proxy, { trigger: l }), hasObserver === true) {
      let e2;
      return onMounted2(() => {
        nextTick2(() => {
          n = r.proxy.$el.parentNode, n && (e2 = new ResizeObserver(l), e2.observe(n), i());
        });
      }), onBeforeUnmount2(() => {
        clearTimeout(o), e2 !== void 0 && (e2.disconnect !== void 0 ? e2.disconnect() : n && e2.unobserve(n));
      }), noop;
    }
    {
      let s2 = function() {
        clearTimeout(o), t2 !== void 0 && (t2.removeEventListener !== void 0 && t2.removeEventListener("resize", l, listenOpts.passive), t2 = void 0);
      }, u = function() {
        s2(), n && n.contentDocument && (t2 = n.contentDocument.defaultView, t2.addEventListener("resize", l, listenOpts.passive), i());
      };
      const e2 = useCanRender();
      let t2;
      return onMounted2(() => {
        nextTick2(() => {
          n = r.proxy.$el, n && u();
        });
      }), onBeforeUnmount2(s2), () => {
        if (e2.value === true)
          return h("object", { style: resizeProps.style, tabindex: -1, type: "text/html", data: resizeProps.url, "aria-hidden": "true", onLoad: u });
      };
    }
  } });
  function getIndicatorClass(e, t, o) {
    const n = o === true ? ["left", "right"] : ["top", "bottom"];
    return `absolute-${t === true ? n[0] : n[1]}${e ? ` text-${e}` : ""}`;
  }
  var alignValues$1 = ["left", "center", "right", "justify"];
  var QTabs = defineComponent2({ name: "QTabs", props: { modelValue: [Number, String], align: { type: String, default: "center", validator: (e) => alignValues$1.includes(e) }, breakpoint: { type: [String, Number], default: 600 }, vertical: Boolean, shrink: Boolean, stretch: Boolean, activeColor: String, activeBgColor: String, indicatorColor: String, leftIcon: String, rightIcon: String, outsideArrows: Boolean, mobileArrows: Boolean, switchIndicator: Boolean, narrowIndicator: Boolean, inlineLabel: Boolean, noCaps: Boolean, dense: Boolean, contentClass: String, "onUpdate:modelValue": Function }, setup(e, { slots: t, emit: o }) {
    const n = getCurrentInstance(), { proxy: { $q: a } } = n, { registerTick: l, prepareTick: i } = useTick(), { registerTimeout: r } = useTimeout(), s2 = ref(null), u = ref(null), c = ref(e.modelValue), d = ref(false), p2 = ref(true), v = ref(false), m = ref(false), f = computed2(() => a.platform.is.desktop === true || e.mobileArrows === true), g = [];
    let b, y, S, w = false, x = f.value === true ? Q : noop;
    const C = computed2(() => ({ activeColor: e.activeColor, activeBgColor: e.activeBgColor, indicatorClass: getIndicatorClass(e.indicatorColor, e.switchIndicator, e.vertical), narrowIndicator: e.narrowIndicator, inlineLabel: e.inlineLabel, noCaps: e.noCaps })), k2 = computed2(() => {
      const t2 = d.value === true ? "left" : m.value === true ? "justify" : e.align;
      return `q-tabs__content--align-${t2}`;
    }), _ = computed2(() => `q-tabs row no-wrap items-center q-tabs--${d.value === true ? "" : "not-"}scrollable q-tabs--${e.vertical === true ? "vertical" : "horizontal"} q-tabs__arrows--${f.value === true && e.outsideArrows === true ? "outside" : "inside"}` + (e.dense === true ? " q-tabs--dense" : "") + (e.shrink === true ? " col-shrink" : "") + (e.stretch === true ? " self-stretch" : "")), q = computed2(() => "q-tabs__content row no-wrap items-center self-stretch hide-scrollbar " + k2.value + (e.contentClass !== void 0 ? ` ${e.contentClass}` : "") + (a.platform.is.mobile === true ? " scroll" : "")), T = computed2(() => e.vertical === true ? { container: "height", content: "offsetHeight", scroll: "scrollHeight" } : { container: "width", content: "offsetWidth", scroll: "scrollWidth" });
    function P({ name: t2, setCurrent: n2, skipEmit: a2, fromRoute: l2 }) {
      c.value !== t2 && (a2 !== true && o("update:modelValue", t2), n2 !== true && e["onUpdate:modelValue"] !== void 0 || (B(c.value, t2), c.value = t2)), l2 !== void 0 && (w = l2);
    }
    function $() {
      l(() => {
        n.isDeactivated !== true && n.isUnmounted !== true && M({ width: s2.value.offsetWidth, height: s2.value.offsetHeight });
      }), i();
    }
    function M(t2) {
      if (T.value === void 0 || u.value === null)
        return;
      const o2 = t2[T.value.container], n2 = Math.min(u.value[T.value.scroll], Array.prototype.reduce.call(u.value.children, (e2, t3) => e2 + t3[T.value.content], 0)), a2 = o2 > 0 && n2 > o2;
      d.value !== a2 && (d.value = a2), a2 === true && nextTick2(x);
      const l2 = o2 < parseInt(e.breakpoint, 10);
      m.value !== l2 && (m.value = l2);
    }
    function B(t2, o2) {
      const n2 = t2 !== void 0 && t2 !== null && t2 !== "" ? g.find((e2) => e2.name.value === t2) : null, a2 = o2 !== void 0 && o2 !== null && o2 !== "" ? g.find((e2) => e2.name.value === o2) : null;
      if (n2 && a2) {
        const t3 = n2.tabIndicatorRef.value, o3 = a2.tabIndicatorRef.value;
        clearTimeout(b), t3.style.transition = "none", t3.style.transform = "none", o3.style.transition = "none", o3.style.transform = "none";
        const l2 = t3.getBoundingClientRect(), i2 = o3.getBoundingClientRect();
        o3.style.transform = e.vertical === true ? `translate3d(0,${l2.top - i2.top}px,0) scale3d(1,${i2.height ? l2.height / i2.height : 1},1)` : `translate3d(${l2.left - i2.left}px,0,0) scale3d(${i2.width ? l2.width / i2.width : 1},1,1)`, nextTick2(() => {
          b = setTimeout(() => {
            o3.style.transition = "transform .25s cubic-bezier(.4, 0, .2, 1)", o3.style.transform = "none";
          }, 70);
        });
      }
      if (a2 && d.value === true) {
        const { left: t3, width: o3, top: n3, height: l2 } = u.value.getBoundingClientRect(), i2 = a2.rootRef.value.getBoundingClientRect();
        let r2 = e.vertical === true ? i2.top - n3 : i2.left - t3;
        if (r2 < 0)
          return u.value[e.vertical === true ? "scrollTop" : "scrollLeft"] += Math.floor(r2), void x();
        r2 += e.vertical === true ? i2.height - l2 : i2.width - o3, r2 > 0 && (u.value[e.vertical === true ? "scrollTop" : "scrollLeft"] += Math.ceil(r2), x());
      }
    }
    function Q() {
      const t2 = u.value;
      if (t2 !== null) {
        const o2 = t2.getBoundingClientRect(), n2 = e.vertical === true ? t2.scrollTop : t2.scrollLeft;
        p2.value = n2 > 0, v.value = e.vertical === true ? Math.ceil(n2 + o2.height) < t2.scrollHeight : Math.ceil(n2 + o2.width) < t2.scrollWidth;
      }
    }
    function E(e2) {
      F(), L(e2), y = setInterval(() => {
        L(e2) && F();
      }, 5);
    }
    function O() {
      E(0);
    }
    function z() {
      E(9999);
    }
    function F() {
      clearInterval(y);
    }
    function L(t2) {
      const o2 = u.value;
      let n2 = e.vertical === true ? o2.scrollTop : o2.scrollLeft, a2 = false;
      const l2 = t2 < n2 ? -1 : 1;
      return n2 += 5 * l2, n2 < 0 ? (a2 = true, n2 = 0) : (l2 === -1 && n2 <= t2 || l2 === 1 && n2 >= t2) && (a2 = true, n2 = t2), o2[e.vertical === true ? "scrollTop" : "scrollLeft"] = n2, x(), a2;
    }
    function R() {
      return g.filter((e2) => e2.routerProps !== void 0 && e2.routerProps.hasLink.value === true);
    }
    function V() {
      let e2 = "", t2 = null, o2 = w;
      R().forEach((n2) => {
        n2.routerProps !== void 0 && n2.routerProps[n2.routerProps.exact.value === true ? "linkIsExactActive" : "linkIsActive"].value === true && n2.routerProps.linkRoute.value.href.length > e2.length ? (e2 = n2.routerProps.linkRoute.value.href, t2 = n2.name.value) : c.value === n2.name.value && (o2 = true);
      }), o2 !== true && t2 === null || P({ name: t2, setCurrent: true, fromRoute: true });
    }
    function I() {
      r(V);
    }
    function A(e2) {
      g.push(e2);
      const t2 = R();
      t2.length > 0 && (S === void 0 && (S = watch(() => n.proxy.$route, I)), I());
    }
    function D(e2) {
      if (g.splice(g.indexOf(e2), 1), S !== void 0) {
        const e3 = R();
        e3.length === 0 && (S(), S = void 0), I();
      }
    }
    return watch(() => e.modelValue, (e2) => {
      P({ name: e2, setCurrent: true, skipEmit: true });
    }), watch(() => e.outsideArrows, () => {
      nextTick2($());
    }), watch(f, (e2) => {
      x = e2 === true ? Q : noop, nextTick2($());
    }), provide2(tabsKey, { currentModel: c, tabProps: C, registerTab: A, unregisterTab: D, verifyRouteModel: I, updateModel: P, recalculateScroll: $ }), onBeforeUnmount2(() => {
      clearTimeout(b), S !== void 0 && S();
    }), onActivated($), () => {
      const o2 = [h(QResizeObserver, { onResize: M }), h("div", { ref: u, class: q.value, onScroll: x }, hSlot(t.default))];
      return f.value === true && o2.push(h(QIcon, { class: "q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon" + (p2.value === true ? "" : " q-tabs__arrow--faded"), name: e.leftIcon || a.iconSet.tabs[e.vertical === true ? "up" : "left"], onMousedown: O, onTouchstartPassive: O, onMouseup: F, onMouseleave: F, onTouchend: F }), h(QIcon, { class: "q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon" + (v.value === true ? "" : " q-tabs__arrow--faded"), name: e.rightIcon || a.iconSet.tabs[e.vertical === true ? "down" : "right"], onMousedown: z, onTouchstartPassive: z, onMouseup: F, onMouseleave: F, onTouchend: F })), h("div", { ref: s2, class: _.value, role: "tablist" }, o2);
    };
  } });
  var uid$3 = 0;
  var useTabEmits = ["click", "keyup"];
  var useTabProps = { icon: String, label: [Number, String], alert: [Boolean, String], alertIcon: String, name: { type: [Number, String], default: () => `t_${uid$3++}` }, noCaps: Boolean, tabindex: [String, Number], disable: Boolean, contentClass: String, ripple: { type: [Boolean, Object], default: true } };
  function useTab(e, t, o, n) {
    const a = inject2(tabsKey, () => {
      console.error("QTab/QRouteTab component needs to be child of QTabs");
    }), l = ref(null), i = ref(null), r = ref(null), s2 = computed2(() => a.currentModel.value === e.name), u = computed2(() => `q-tab relative-position self-stretch flex flex-center text-center q-tab--${s2.value === true ? "" : "in"}active` + (s2.value === true ? (a.tabProps.value.activeColor ? ` text-${a.tabProps.value.activeColor}` : "") + (a.tabProps.value.activeBgColor ? ` bg-${a.tabProps.value.activeBgColor}` : "") : "") + (e.icon && e.label && a.tabProps.value.inlineLabel === false ? " q-tab--full" : "") + (e.noCaps === true || a.tabProps.value.noCaps === true ? " q-tab--no-caps" : "") + (e.disable === true ? " disabled" : " q-focusable q-hoverable cursor-pointer") + (n !== void 0 && n.linkClass.value !== "" ? ` ${n.linkClass.value}` : "")), c = computed2(() => "q-tab__content self-stretch flex-center relative-position q-anchor--skip non-selectable " + (a.tabProps.value.inlineLabel === true ? "row no-wrap q-tab__content--inline" : "column") + (e.contentClass !== void 0 ? ` ${e.contentClass}` : "")), d = computed2(() => e.disable === true || s2.value === true ? -1 : e.tabindex || 0);
    function p2(t2, i2) {
      if (i2 !== true && l.value !== null && l.value.focus(), e.disable !== true)
        if (n !== void 0)
          if (n.hasLink.value === true) {
            const e2 = () => {
              t2.__qNavigate = true, n.navigateToLink(t2);
            };
            o("click", t2, e2), t2.defaultPrevented !== true && e2();
          } else
            o("click", t2);
        else
          o("click", t2), a.updateModel({ name: e.name, fromRoute: false });
    }
    function v(e2) {
      isKeyCode(e2, 13) === true && p2(e2, true), o("keyup", e2);
    }
    function m() {
      const o2 = a.tabProps.value.narrowIndicator, n2 = [], i2 = h("div", { ref: r, class: ["q-tab__indicator", a.tabProps.value.indicatorClass] });
      e.icon !== void 0 && n2.push(h(QIcon, { class: "q-tab__icon", name: e.icon })), e.label !== void 0 && n2.push(h("div", { class: "q-tab__label" }, e.label)), e.alert !== false && n2.push(e.alertIcon !== void 0 ? h(QIcon, { class: "q-tab__alert-icon", color: e.alert !== true ? e.alert : void 0, name: e.alertIcon }) : h("div", { class: "q-tab__alert" + (e.alert !== true ? ` text-${e.alert}` : "") })), o2 === true && n2.push(i2);
      const s3 = [h("div", { class: "q-focus-helper", tabindex: -1, ref: l }), h("div", { class: c.value }, hMergeSlot(t.default, n2))];
      return o2 === false && s3.push(i2), s3;
    }
    const f = { name: computed2(() => e.name), rootRef: i, tabIndicatorRef: r, routerProps: n };
    function g(t2, o2) {
      const n2 = { ref: i, class: u.value, tabindex: d.value, role: "tab", "aria-selected": s2.value, "aria-disabled": e.disable === true ? "true" : void 0, onClick: p2, onKeyup: v, ...o2 };
      return hDir(t2, n2, m(), "main", e.ripple !== false && e.disable === false, () => [[Ripple, e.ripple]]);
    }
    return onBeforeUnmount2(() => {
      a.unregisterTab(f), a.recalculateScroll();
    }), onMounted2(() => {
      a.registerTab(f), a.recalculateScroll();
    }), { renderTab: g, $tabs: a };
  }
  var QTab = defineComponent2({ name: "QTab", props: useTabProps, emits: useTabEmits, setup(e, { slots: t, emit: o }) {
    const { renderTab: n } = useTab(e, t, o);
    return () => n("div");
  } });
  var QTabPanels = defineComponent2({ name: "QTabPanels", props: { ...usePanelProps, ...useDarkProps }, emits: usePanelEmits, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), { updatePanelsList: a, getPanelContent: l, panelDirectives: i } = usePanel(), r = computed2(() => "q-tab-panels q-panel-parent" + (n.value === true ? " q-tab-panels--dark q-dark" : ""));
    return () => {
      return a(t), hDir("div", { class: r.value }, l(), "pan", e.swipeable, () => i.value);
    };
  } });
  var QTabPanel = defineComponent2({ name: "QTabPanel", props: usePanelChildProps, setup(e, { slots: t }) {
    return () => h("div", { class: "q-tab-panel" }, hSlot(t.default));
  } });
  var hex = /^#[0-9a-fA-F]{3}([0-9a-fA-F]{3})?$/;
  var hexa = /^#[0-9a-fA-F]{4}([0-9a-fA-F]{4})?$/;
  var hexOrHexa = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/;
  var rgb = /^rgb\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5])\)$/;
  var rgba = /^rgba\(((0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),){2}(0|[1-9][\d]?|1[\d]{0,2}|2[\d]?|2[0-4][\d]|25[0-5]),(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/;
  var testPattern = { date: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e), time: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d$/.test(e), fulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d:[0-5]\d$/.test(e), timeOrFulltime: (e) => /^([0-1]?\d|2[0-3]):[0-5]\d(:[0-5]\d)?$/.test(e), hexColor: (e) => hex.test(e), hexaColor: (e) => hexa.test(e), hexOrHexaColor: (e) => hexOrHexa.test(e), rgbColor: (e) => rgb.test(e), rgbaColor: (e) => rgba.test(e), rgbOrRgbaColor: (e) => rgb.test(e) || rgba.test(e), hexOrRgbColor: (e) => hex.test(e) || rgb.test(e), hexaOrRgbaColor: (e) => hexa.test(e) || rgba.test(e), anyColor: (e) => hexOrHexa.test(e) || rgb.test(e) || rgba.test(e) };
  var patterns = { testPattern };
  var reRGBA = /^rgb(a)?\((\d{1,3}),(\d{1,3}),(\d{1,3}),?([01]?\.?\d*?)?\)$/;
  function rgbToHex({ r: e, g: t, b: o, a: n }) {
    const a = n !== void 0;
    if (e = Math.round(e), t = Math.round(t), o = Math.round(o), e > 255 || t > 255 || o > 255 || a && n > 100)
      throw new TypeError("Expected 3 numbers below 256 (and optionally one below 100)");
    return n = a ? (256 | Math.round(255 * n / 100)).toString(16).slice(1) : "", "#" + (o | t << 8 | e << 16 | 1 << 24).toString(16).slice(1) + n;
  }
  function rgbToString({ r: e, g: t, b: o, a: n }) {
    return `rgb${n !== void 0 ? "a" : ""}(${e},${t},${o}${n !== void 0 ? "," + n / 100 : ""})`;
  }
  function hexToRgb(e) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string");
    e = e.replace(/^#/, ""), e.length === 3 ? e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] : e.length === 4 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2] + e[3] + e[3]);
    const t = parseInt(e, 16);
    return e.length > 6 ? { r: t >> 24 & 255, g: t >> 16 & 255, b: t >> 8 & 255, a: Math.round((255 & t) / 2.55) } : { r: t >> 16, g: t >> 8 & 255, b: 255 & t };
  }
  function hsvToRgb({ h: e, s: t, v: o, a: n }) {
    let a, l, i;
    t /= 100, o /= 100, e /= 360;
    const r = Math.floor(6 * e), s2 = 6 * e - r, u = o * (1 - t), c = o * (1 - s2 * t), d = o * (1 - (1 - s2) * t);
    switch (r % 6) {
      case 0:
        a = o, l = d, i = u;
        break;
      case 1:
        a = c, l = o, i = u;
        break;
      case 2:
        a = u, l = o, i = d;
        break;
      case 3:
        a = u, l = c, i = o;
        break;
      case 4:
        a = d, l = u, i = o;
        break;
      case 5:
        a = o, l = u, i = c;
        break;
    }
    return { r: Math.round(255 * a), g: Math.round(255 * l), b: Math.round(255 * i), a: n };
  }
  function rgbToHsv({ r: e, g: t, b: o, a: n }) {
    const a = Math.max(e, t, o), l = Math.min(e, t, o), i = a - l, r = a === 0 ? 0 : i / a, s2 = a / 255;
    let u;
    switch (a) {
      case l:
        u = 0;
        break;
      case e:
        u = t - o + i * (t < o ? 6 : 0), u /= 6 * i;
        break;
      case t:
        u = o - e + 2 * i, u /= 6 * i;
        break;
      case o:
        u = e - t + 4 * i, u /= 6 * i;
        break;
    }
    return { h: Math.round(360 * u), s: Math.round(100 * r), v: Math.round(100 * s2), a: n };
  }
  function textToRgb(e) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string");
    const t = e.replace(/ /g, ""), o = reRGBA.exec(t);
    if (o === null)
      return hexToRgb(t);
    const n = { r: Math.min(255, parseInt(o[2], 10)), g: Math.min(255, parseInt(o[3], 10)), b: Math.min(255, parseInt(o[4], 10)) };
    if (o[1]) {
      const e2 = parseFloat(o[5]);
      n.a = 100 * Math.min(1, isNaN(e2) === true ? 1 : e2);
    }
    return n;
  }
  function lighten(e, t) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string as color");
    if (typeof t !== "number")
      throw new TypeError("Expected a numeric percent");
    const o = textToRgb(e), n = t < 0 ? 0 : 255, a = Math.abs(t) / 100, l = o.r, i = o.g, r = o.b;
    return "#" + (16777216 + 65536 * (Math.round((n - l) * a) + l) + 256 * (Math.round((n - i) * a) + i) + (Math.round((n - r) * a) + r)).toString(16).slice(1);
  }
  function luminosity(e) {
    if (typeof e !== "string" && (!e || e.r === void 0))
      throw new TypeError("Expected a string or a {r, g, b} object as color");
    const t = typeof e === "string" ? textToRgb(e) : e, o = t.r / 255, n = t.g / 255, a = t.b / 255, l = o <= 0.03928 ? o / 12.92 : Math.pow((o + 0.055) / 1.055, 2.4), i = n <= 0.03928 ? n / 12.92 : Math.pow((n + 0.055) / 1.055, 2.4), r = a <= 0.03928 ? a / 12.92 : Math.pow((a + 0.055) / 1.055, 2.4);
    return 0.2126 * l + 0.7152 * i + 0.0722 * r;
  }
  function brightness(e) {
    if (typeof e !== "string" && (!e || e.r === void 0))
      throw new TypeError("Expected a string or a {r, g, b} object as color");
    const t = typeof e === "string" ? textToRgb(e) : e;
    return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3;
  }
  function blend(e, t) {
    if (typeof e !== "string" && (!e || e.r === void 0))
      throw new TypeError("Expected a string or a {r, g, b[, a]} object as fgColor");
    if (typeof t !== "string" && (!t || t.r === void 0))
      throw new TypeError("Expected a string or a {r, g, b[, a]} object as bgColor");
    const o = typeof e === "string" ? textToRgb(e) : e, n = o.r / 255, a = o.g / 255, l = o.b / 255, i = o.a !== void 0 ? o.a / 100 : 1, r = typeof t === "string" ? textToRgb(t) : t, s2 = r.r / 255, u = r.g / 255, c = r.b / 255, d = r.a !== void 0 ? r.a / 100 : 1, p2 = i + d * (1 - i), v = Math.round((n * i + s2 * d * (1 - i)) / p2 * 255), m = Math.round((a * i + u * d * (1 - i)) / p2 * 255), f = Math.round((l * i + c * d * (1 - i)) / p2 * 255), h3 = { r: v, g: m, b: f, a: Math.round(100 * p2) };
    return typeof e === "string" ? rgbToHex(h3) : h3;
  }
  function changeAlpha(e, t) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string as color");
    if (t === void 0 || t < -1 || t > 1)
      throw new TypeError("Expected offset to be between -1 and 1");
    const { r: o, g: n, b: a, a: l } = textToRgb(e), i = l !== void 0 ? l / 100 : 0;
    return rgbToHex({ r: o, g: n, b: a, a: Math.round(100 * Math.min(1, Math.max(0, i + t))) });
  }
  function getPaletteColor(e) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string as color");
    const t = document.createElement("div");
    t.className = `text-${e} invisible fixed no-pointer-events`, document.body.appendChild(t);
    const o = getComputedStyle(t).getPropertyValue("color");
    return t.remove(), rgbToHex(textToRgb(o));
  }
  var colors = { rgbToHex, hexToRgb, hsvToRgb, rgbToHsv, textToRgb, lighten, luminosity, brightness, blend, changeAlpha, getPaletteColor };
  var palette = ["rgb(255,204,204)", "rgb(255,230,204)", "rgb(255,255,204)", "rgb(204,255,204)", "rgb(204,255,230)", "rgb(204,255,255)", "rgb(204,230,255)", "rgb(204,204,255)", "rgb(230,204,255)", "rgb(255,204,255)", "rgb(255,153,153)", "rgb(255,204,153)", "rgb(255,255,153)", "rgb(153,255,153)", "rgb(153,255,204)", "rgb(153,255,255)", "rgb(153,204,255)", "rgb(153,153,255)", "rgb(204,153,255)", "rgb(255,153,255)", "rgb(255,102,102)", "rgb(255,179,102)", "rgb(255,255,102)", "rgb(102,255,102)", "rgb(102,255,179)", "rgb(102,255,255)", "rgb(102,179,255)", "rgb(102,102,255)", "rgb(179,102,255)", "rgb(255,102,255)", "rgb(255,51,51)", "rgb(255,153,51)", "rgb(255,255,51)", "rgb(51,255,51)", "rgb(51,255,153)", "rgb(51,255,255)", "rgb(51,153,255)", "rgb(51,51,255)", "rgb(153,51,255)", "rgb(255,51,255)", "rgb(255,0,0)", "rgb(255,128,0)", "rgb(255,255,0)", "rgb(0,255,0)", "rgb(0,255,128)", "rgb(0,255,255)", "rgb(0,128,255)", "rgb(0,0,255)", "rgb(128,0,255)", "rgb(255,0,255)", "rgb(245,0,0)", "rgb(245,123,0)", "rgb(245,245,0)", "rgb(0,245,0)", "rgb(0,245,123)", "rgb(0,245,245)", "rgb(0,123,245)", "rgb(0,0,245)", "rgb(123,0,245)", "rgb(245,0,245)", "rgb(214,0,0)", "rgb(214,108,0)", "rgb(214,214,0)", "rgb(0,214,0)", "rgb(0,214,108)", "rgb(0,214,214)", "rgb(0,108,214)", "rgb(0,0,214)", "rgb(108,0,214)", "rgb(214,0,214)", "rgb(163,0,0)", "rgb(163,82,0)", "rgb(163,163,0)", "rgb(0,163,0)", "rgb(0,163,82)", "rgb(0,163,163)", "rgb(0,82,163)", "rgb(0,0,163)", "rgb(82,0,163)", "rgb(163,0,163)", "rgb(92,0,0)", "rgb(92,46,0)", "rgb(92,92,0)", "rgb(0,92,0)", "rgb(0,92,46)", "rgb(0,92,92)", "rgb(0,46,92)", "rgb(0,0,92)", "rgb(46,0,92)", "rgb(92,0,92)", "rgb(255,255,255)", "rgb(205,205,205)", "rgb(178,178,178)", "rgb(153,153,153)", "rgb(127,127,127)", "rgb(102,102,102)", "rgb(76,76,76)", "rgb(51,51,51)", "rgb(25,25,25)", "rgb(0,0,0)"];
  var thumbPath = "M5 5 h10 v10 h-10 v-10 z";
  var QColor = defineComponent2({ name: "QColor", props: { ...useDarkProps, ...useFormProps, modelValue: String, defaultValue: String, defaultView: { type: String, default: "spectrum", validator: (e) => ["spectrum", "tune", "palette"].includes(e) }, formatModel: { type: String, default: "auto", validator: (e) => ["auto", "hex", "rgb", "hexa", "rgba"].includes(e) }, palette: Array, noHeader: Boolean, noFooter: Boolean, square: Boolean, flat: Boolean, bordered: Boolean, disable: Boolean, readonly: Boolean }, emits: ["update:modelValue", "change"], setup(e, { emit: t }) {
    const { proxy: o } = getCurrentInstance(), { $q: n } = o, a = useDark(e, n), { getCache: l } = useCache(), i = ref(null), r = ref(null), s2 = computed2(() => e.formatModel === "auto" ? null : e.formatModel.indexOf("hex") > -1), u = computed2(() => e.formatModel === "auto" ? null : e.formatModel.indexOf("a") > -1), c = ref(e.formatModel === "auto" ? e.modelValue === void 0 || e.modelValue === null || e.modelValue === "" || e.modelValue.startsWith("#") ? "hex" : "rgb" : e.formatModel.startsWith("hex") ? "hex" : "rgb"), d = ref(e.defaultView), p2 = ref($(e.modelValue || e.defaultValue)), v = computed2(() => e.disable !== true && e.readonly !== true), m = computed2(() => e.modelValue === void 0 || e.modelValue === null || e.modelValue === "" || e.modelValue.startsWith("#")), f = computed2(() => s2.value !== null ? s2.value : m.value), g = computed2(() => ({ type: "hidden", name: e.name, value: p2.value[f.value === true ? "hex" : "rgb"] })), b = useFormInject(g), y = computed2(() => u.value !== null ? u.value : p2.value.a !== void 0), S = computed2(() => ({ backgroundColor: p2.value.rgb || "#000" })), w = computed2(() => {
      const e2 = p2.value.a !== void 0 && p2.value.a < 65 || luminosity(p2.value) > 0.4;
      return `q-color-picker__header-content absolute-full q-color-picker__header-content--${e2 ? "light" : "dark"}`;
    }), x = computed2(() => ({ background: `hsl(${p2.value.h},100%,50%)` })), C = computed2(() => ({ top: `${100 - p2.value.v}%`, [n.lang.rtl === true ? "right" : "left"]: `${p2.value.s}%` })), k2 = computed2(() => e.palette !== void 0 && e.palette.length > 0 ? e.palette : palette), _ = computed2(() => "q-color-picker" + (e.bordered === true ? " q-color-picker--bordered" : "") + (e.square === true ? " q-color-picker--square no-border-radius" : "") + (e.flat === true ? " q-color-picker--flat no-shadow" : "") + (e.disable === true ? " disabled" : "") + (a.value === true ? " q-color-picker--dark q-dark" : "")), q = computed2(() => {
      return e.disable === true ? { "aria-disabled": "true" } : e.readonly === true ? { "aria-readonly": "true" } : {};
    }), T = computed2(() => {
      return [[TouchPan, z, void 0, { prevent: true, stop: true, mouse: true }]];
    });
    function P(e2, o2) {
      p2.value.hex = rgbToHex(e2), p2.value.rgb = rgbToString(e2), p2.value.r = e2.r, p2.value.g = e2.g, p2.value.b = e2.b, p2.value.a = e2.a;
      const n2 = p2.value[f.value === true ? "hex" : "rgb"];
      t("update:modelValue", n2), o2 === true && t("change", n2);
    }
    function $(t2) {
      const o2 = u.value !== void 0 ? u.value : e.formatModel === "auto" ? null : e.formatModel.indexOf("a") > -1;
      if (typeof t2 !== "string" || t2.length === 0 || testPattern.anyColor(t2.replace(/ /g, "")) !== true)
        return { h: 0, s: 0, v: 0, r: 0, g: 0, b: 0, a: o2 === true ? 100 : void 0, hex: void 0, rgb: void 0 };
      const n2 = textToRgb(t2);
      return o2 === true && n2.a === void 0 && (n2.a = 100), n2.hex = rgbToHex(n2), n2.rgb = rgbToString(n2), Object.assign(n2, rgbToHsv(n2));
    }
    function M(e2, t2, o2) {
      const a2 = i.value;
      if (a2 === void 0)
        return;
      const l2 = a2.clientWidth, r2 = a2.clientHeight, s3 = a2.getBoundingClientRect();
      let u2 = Math.min(l2, Math.max(0, e2 - s3.left));
      n.lang.rtl === true && (u2 = l2 - u2);
      const c4 = Math.min(r2, Math.max(0, t2 - s3.top)), d2 = Math.round(100 * u2 / l2), v2 = Math.round(100 * Math.max(0, Math.min(1, -c4 / r2 + 1))), m2 = hsvToRgb({ h: p2.value.h, s: d2, v: v2, a: y.value === true ? p2.value.a : void 0 });
      p2.value.s = d2, p2.value.v = v2, P(m2, o2);
    }
    function B(e2, t2) {
      const o2 = Math.round(e2), n2 = hsvToRgb({ h: o2, s: p2.value.s, v: p2.value.v, a: y.value === true ? p2.value.a : void 0 });
      p2.value.h = o2, P(n2, t2);
    }
    function Q(e2, t2, n2, a2, l2) {
      if (a2 !== void 0 && stop2(a2), !/^[0-9]+$/.test(e2))
        return void (l2 === true && o.$forceUpdate());
      const i2 = Math.floor(Number(e2));
      if (i2 < 0 || i2 > n2)
        return void (l2 === true && o.$forceUpdate());
      const r2 = { r: t2 === "r" ? i2 : p2.value.r, g: t2 === "g" ? i2 : p2.value.g, b: t2 === "b" ? i2 : p2.value.b, a: y.value === true ? t2 === "a" ? i2 : p2.value.a : void 0 };
      if (t2 !== "a") {
        const e3 = rgbToHsv(r2);
        p2.value.h = e3.h, p2.value.s = e3.s, p2.value.v = e3.v;
      }
      if (P(r2, l2), a2 !== void 0 && l2 !== true && a2.target.selectionEnd !== void 0) {
        const e3 = a2.target.selectionEnd;
        nextTick2(() => {
          a2.target.setSelectionRange(e3, e3);
        });
      }
    }
    function E(e2, t2) {
      let o2;
      const n2 = e2.target.value;
      if (stop2(e2), c.value === "hex") {
        if (n2.length !== (y.value === true ? 9 : 7) || !/^#[0-9A-Fa-f]+$/.test(n2))
          return true;
        o2 = hexToRgb(n2);
      } else {
        let e3;
        if (!n2.endsWith(")"))
          return true;
        if (y.value !== true && n2.startsWith("rgb(")) {
          if (e3 = n2.substring(4, n2.length - 1).split(",").map((e4) => parseInt(e4, 10)), e3.length !== 3 || !/^rgb\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3}\)$/.test(n2))
            return true;
        } else {
          if (y.value !== true || !n2.startsWith("rgba("))
            return true;
          {
            if (e3 = n2.substring(5, n2.length - 1).split(","), e3.length !== 4 || !/^rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(0|0\.[0-9]+[1-9]|0\.[1-9]+|1)\)$/.test(n2))
              return true;
            for (let o3 = 0; o3 < 3; o3++) {
              const t4 = parseInt(e3[o3], 10);
              if (t4 < 0 || t4 > 255)
                return true;
              e3[o3] = t4;
            }
            const t3 = parseFloat(e3[3]);
            if (t3 < 0 || t3 > 1)
              return true;
            e3[3] = t3;
          }
        }
        if (e3[0] < 0 || e3[0] > 255 || e3[1] < 0 || e3[1] > 255 || e3[2] < 0 || e3[2] > 255 || y.value === true && (e3[3] < 0 || e3[3] > 1))
          return true;
        o2 = { r: e3[0], g: e3[1], b: e3[2], a: y.value === true ? 100 * e3[3] : void 0 };
      }
      const a2 = rgbToHsv(o2);
      if (p2.value.h = a2.h, p2.value.s = a2.s, p2.value.v = a2.v, P(o2, t2), t2 !== true) {
        const t3 = e2.target.selectionEnd;
        nextTick2(() => {
          e2.target.setSelectionRange(t3, t3);
        });
      }
    }
    function O(e2) {
      const t2 = $(e2), o2 = { r: t2.r, g: t2.g, b: t2.b, a: t2.a };
      o2.a === void 0 && (o2.a = p2.value.a), p2.value.h = t2.h, p2.value.s = t2.s, p2.value.v = t2.v, P(o2, true);
    }
    function z(e2) {
      e2.isFinal ? M(e2.position.left, e2.position.top, true) : F(e2);
    }
    watch(() => e.modelValue, (t2) => {
      const o2 = $(t2 || e.defaultValue);
      o2.hex !== p2.value.hex && (p2.value = o2);
    }), watch(() => e.defaultValue, (t2) => {
      if (!e.modelValue && t2) {
        const e2 = $(t2);
        e2.hex !== p2.value.hex && (p2.value = e2);
      }
    });
    const F = throttle((e2) => {
      M(e2.position.left, e2.position.top);
    }, 20);
    function L(e2) {
      M(e2.pageX - window.pageXOffset, e2.pageY - window.pageYOffset, true);
    }
    function R(e2) {
      M(e2.pageX - window.pageXOffset, e2.pageY - window.pageYOffset);
    }
    function V(e2) {
      r.value !== null && (r.value.$el.style.opacity = e2 ? 1 : 0);
    }
    function I() {
      return h("div", { class: "q-color-picker__header relative-position overflow-hidden" }, [h("div", { class: "q-color-picker__header-bg absolute-full" }), h("div", { class: w.value, style: S.value }, [h(QTabs, { modelValue: c.value, dense: true, align: "justify", ...l("topVTab", { "onUpdate:modelValue": (e2) => {
        c.value = e2;
      } }) }, () => [h(QTab, { label: "HEX" + (y.value === true ? "A" : ""), name: "hex", ripple: false }), h(QTab, { label: "RGB" + (y.value === true ? "A" : ""), name: "rgb", ripple: false })]), h("div", { class: "q-color-picker__header-banner row flex-center no-wrap" }, [h("input", { class: "fit", value: p2.value[c.value], ...v.value !== true ? { readonly: true } : {}, ...l("topIn", { onInput: (e2) => {
        V(E(e2) === true);
      }, onChange: stop2, onBlur: (e2) => {
        E(e2, true) === true && o.$forceUpdate(), V(false);
      } }) }), h(QIcon, { ref: r, class: "q-color-picker__error-icon absolute no-pointer-events", name: n.iconSet.type.negative })])])]);
    }
    function A() {
      return h(QTabPanels, { modelValue: d.value, animated: true }, () => [h(QTabPanel, { class: "q-color-picker__spectrum-tab overflow-hidden", name: "spectrum" }, N), h(QTabPanel, { class: "q-pa-md q-color-picker__tune-tab", name: "tune" }, H), h(QTabPanel, { class: "q-color-picker__palette-tab", name: "palette" }, j)]);
    }
    function D() {
      return h("div", { class: "q-color-picker__footer relative-position overflow-hidden" }, [h(QTabs, { class: "absolute-full", modelValue: d.value, dense: true, align: "justify", ...l("ftIn", { "onUpdate:modelValue": (e2) => {
        d.value = e2;
      } }) }, () => [h(QTab, { icon: n.iconSet.colorPicker.spectrum, name: "spectrum", ripple: false }), h(QTab, { icon: n.iconSet.colorPicker.tune, name: "tune", ripple: false }), h(QTab, { icon: n.iconSet.colorPicker.palette, name: "palette", ripple: false })])]);
    }
    function N() {
      const e2 = { ref: i, class: "q-color-picker__spectrum non-selectable relative-position cursor-pointer" + (v.value !== true ? " readonly" : ""), style: x.value, ...v.value === true ? { onClick: L, onMousedown: R } : {} }, t2 = [h("div", { style: { paddingBottom: "100%" } }), h("div", { class: "q-color-picker__spectrum-white absolute-full" }), h("div", { class: "q-color-picker__spectrum-black absolute-full" }), h("div", { class: "absolute", style: C.value }, [p2.value.hex !== void 0 ? h("div", { class: "q-color-picker__spectrum-circle" }) : null])], o2 = [h("div", { class: "q-color-picker__hue non-selectable" }, [h(QSlider, { modelValue: p2.value.h, min: 0, max: 360, fillHandleAlways: true, readonly: v.value !== true, thumbPath, "onUpdate:modelValue": B, ...l("lazyhue", { onChange: (e3) => B(e3, true) }) })])];
      return y.value === true && o2.push(h("div", { class: "q-color-picker__alpha non-selectable" }, [h(QSlider, { modelValue: p2.value.a, min: 0, max: 100, fillHandleAlways: true, readonly: v.value !== true, thumbPath, ...l("alphaSlide", { "onUpdate:modelValue": (e3) => Q(e3, "a", 100), onChange: (e3) => Q(e3, "a", 100, void 0, true) }) })])), [hDir("div", e2, t2, "spec", v.value, () => T.value), h("div", { class: "q-color-picker__sliders" }, o2)];
    }
    function H() {
      return [h("div", { class: "row items-center no-wrap" }, [h("div", "R"), h(QSlider, { modelValue: p2.value.r, min: 0, max: 255, color: "red", dark: a.value, readonly: v.value !== true, ...l("rSlide", { "onUpdate:modelValue": (e2) => Q(e2, "r", 255), onChange: (e2) => Q(e2, "r", 255, void 0, true) }) }), h("input", { value: p2.value.r, maxlength: 3, readonly: v.value !== true, onChange: stop2, ...l("rIn", { onInput: (e2) => Q(e2.target.value, "r", 255, e2), onBlur: (e2) => Q(e2.target.value, "r", 255, e2, true) }) })]), h("div", { class: "row items-center no-wrap" }, [h("div", "G"), h(QSlider, { modelValue: p2.value.g, min: 0, max: 255, color: "green", dark: a.value, readonly: v.value !== true, ...l("gSlide", { "onUpdate:modelValue": (e2) => Q(e2, "g", 255), onChange: (e2) => Q(e2, "g", 255, void 0, true) }) }), h("input", { value: p2.value.g, maxlength: 3, readonly: v.value !== true, onChange: stop2, ...l("gIn", { onInput: (e2) => Q(e2.target.value, "g", 255, e2), onBlur: (e2) => Q(e2.target.value, "g", 255, e2, true) }) })]), h("div", { class: "row items-center no-wrap" }, [h("div", "B"), h(QSlider, { modelValue: p2.value.b, min: 0, max: 255, color: "blue", readonly: v.value !== true, dark: a.value, ...l("bSlide", { "onUpdate:modelValue": (e2) => Q(e2, "b", 255), onChange: (e2) => Q(e2, "b", 255, void 0, true) }) }), h("input", { value: p2.value.b, maxlength: 3, readonly: v.value !== true, onChange: stop2, ...l("bIn", { onInput: (e2) => Q(e2.target.value, "b", 255, e2), onBlur: (e2) => Q(e2.target.value, "b", 255, e2, true) }) })]), y.value === true ? h("div", { class: "row items-center no-wrap" }, [h("div", "A"), h(QSlider, { modelValue: p2.value.a, color: "grey", readonly: v.value !== true, dark: a.value, ...l("aSlide", { "onUpdate:modelValue": (e2) => Q(e2, "a", 100), onChange: (e2) => Q(e2, "a", 100, void 0, true) }) }), h("input", { value: p2.value.a, maxlength: 3, readonly: v.value !== true, onChange: stop2, ...l("aIn", { onInput: (e2) => Q(e2.target.value, "a", 100, e2), onBlur: (e2) => Q(e2.target.value, "a", 100, e2, true) }) })]) : null];
    }
    function j() {
      return [h("div", { class: "row items-center q-color-picker__palette-rows" + (v.value === true ? " q-color-picker__palette-rows--editable" : "") }, k2.value.map((e2) => h("div", { class: "q-color-picker__cube col-auto", style: { backgroundColor: e2 }, ...v.value === true ? l("palette#" + e2, { onClick: () => {
        O(e2);
      } }) : {} })))];
    }
    return () => {
      const t2 = [A()];
      return e.name !== void 0 && e.disable !== true && b(t2, "push"), e.noHeader !== true && t2.unshift(I()), e.noFooter !== true && t2.push(D()), h("div", { class: _.value, ...q.value }, t2);
    };
  } });
  var breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];
  function toJalaali(e, t, o) {
    return Object.prototype.toString.call(e) === "[object Date]" && (o = e.getDate(), t = e.getMonth() + 1, e = e.getFullYear()), d2j(g2d(e, t, o));
  }
  function toGregorian(e, t, o) {
    return d2g(j2d(e, t, o));
  }
  function isLeapJalaaliYear(e) {
    return jalCalLeap(e) === 0;
  }
  function jalaaliMonthLength(e, t) {
    return t <= 6 ? 31 : t <= 11 ? 30 : isLeapJalaaliYear(e) ? 30 : 29;
  }
  function jalCalLeap(e) {
    const t = breaks.length;
    let o, n, a, l, i, r = breaks[0];
    if (e < r || e >= breaks[t - 1])
      throw new Error("Invalid Jalaali year " + e);
    for (i = 1; i < t; i += 1) {
      if (o = breaks[i], n = o - r, e < o)
        break;
      r = o;
    }
    return l = e - r, n - l < 6 && (l = l - n + 33 * div(n + 4, 33)), a = mod(mod(l + 1, 33) - 1, 4), a === -1 && (a = 4), a;
  }
  function jalCal(e, t) {
    const o = breaks.length, n = e + 621;
    let a, l, i, r, s2, u = -14, c = breaks[0];
    if (e < c || e >= breaks[o - 1])
      throw new Error("Invalid Jalaali year " + e);
    for (s2 = 1; s2 < o; s2 += 1) {
      if (a = breaks[s2], l = a - c, e < a)
        break;
      u = u + 8 * div(l, 33) + div(mod(l, 33), 4), c = a;
    }
    r = e - c, u = u + 8 * div(r, 33) + div(mod(r, 33) + 3, 4), mod(l, 33) === 4 && l - r === 4 && (u += 1);
    const d = div(n, 4) - div(3 * (div(n, 100) + 1), 4) - 150, p2 = 20 + u - d;
    return t || (l - r < 6 && (r = r - l + 33 * div(l + 4, 33)), i = mod(mod(r + 1, 33) - 1, 4), i === -1 && (i = 4)), { leap: i, gy: n, march: p2 };
  }
  function j2d(e, t, o) {
    const n = jalCal(e, true);
    return g2d(n.gy, 3, n.march) + 31 * (t - 1) - div(t, 7) * (t - 7) + o - 1;
  }
  function d2j(e) {
    const t = d2g(e).gy;
    let o, n, a, l = t - 621;
    const i = jalCal(l, false), r = g2d(t, 3, i.march);
    if (a = e - r, a >= 0) {
      if (a <= 185)
        return n = 1 + div(a, 31), o = mod(a, 31) + 1, { jy: l, jm: n, jd: o };
      a -= 186;
    } else
      l -= 1, a += 179, i.leap === 1 && (a += 1);
    return n = 7 + div(a, 30), o = mod(a, 30) + 1, { jy: l, jm: n, jd: o };
  }
  function g2d(e, t, o) {
    let n = div(1461 * (e + div(t - 8, 6) + 100100), 4) + div(153 * mod(t + 9, 12) + 2, 5) + o - 34840408;
    return n = n - div(3 * div(e + 100100 + div(t - 8, 6), 100), 4) + 752, n;
  }
  function d2g(e) {
    let t = 4 * e + 139361631;
    t = t + 4 * div(3 * div(4 * e + 183187720, 146097), 4) - 3908;
    const o = 5 * div(mod(t, 1461), 4) + 308, n = div(mod(o, 153), 5) + 1, a = mod(div(o, 153), 12) + 1, l = div(t, 1461) - 100100 + div(8 - a, 6);
    return { gy: l, gm: a, gd: n };
  }
  function div(e, t) {
    return ~~(e / t);
  }
  function mod(e, t) {
    return e - ~~(e / t) * t;
  }
  var calendars = ["gregorian", "persian"];
  var useDatetimeProps = { modelValue: { required: true }, mask: { type: String }, locale: Object, calendar: { type: String, validator: (e) => calendars.includes(e), default: "gregorian" }, landscape: Boolean, color: String, textColor: String, square: Boolean, flat: Boolean, bordered: Boolean, readonly: Boolean, disable: Boolean };
  var useDatetimeEmits = ["update:modelValue"];
  function getDayHash(e) {
    return e.year + "/" + pad(e.month) + "/" + pad(e.day);
  }
  function useDatetime(e, t) {
    const o = computed2(() => {
      return e.disable !== true && e.readonly !== true;
    }), n = computed2(() => {
      return e.editable === true ? 0 : -1;
    }), a = computed2(() => {
      const t2 = [];
      return e.color !== void 0 && t2.push(`bg-${e.color}`), e.textColor !== void 0 && t2.push(`text-${e.textColor}`), t2.join(" ");
    });
    function l() {
      return e.locale || t.lang.date;
    }
    function i(t2) {
      const o2 = new Date(), n2 = t2 === true ? null : 0;
      if (e.calendar === "persian") {
        const e2 = toJalaali(o2);
        return { year: e2.jy, month: e2.jm, day: e2.jd };
      }
      return { year: o2.getFullYear(), month: o2.getMonth() + 1, day: o2.getDate(), hour: n2, minute: n2, second: n2, millisecond: n2 };
    }
    return { editable: o, tabindex: n, headerClass: a, getLocale: l, getCurrentDate: i };
  }
  var MILLISECONDS_IN_DAY = 864e5;
  var MILLISECONDS_IN_HOUR = 36e5;
  var MILLISECONDS_IN_MINUTE = 6e4;
  var defaultMask = "YYYY-MM-DDTHH:mm:ss.SSSZ";
  var token = /\[((?:[^\]\\]|\\]|\\)*)\]|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]/g;
  var reverseToken = /(\[[^\]]*\])|d{1,4}|M{1,4}|m{1,2}|w{1,2}|Qo|Do|D{1,4}|YY(?:YY)?|H{1,2}|h{1,2}|s{1,2}|S{1,3}|Z{1,2}|a{1,2}|[AQExX]|([.*+:?^,\s${}()|\\]+)/g;
  var regexStore = {};
  function getRegexData(e, t) {
    const o = "(" + t.days.join("|") + ")", n = e + o;
    if (regexStore[n] !== void 0)
      return regexStore[n];
    const a = "(" + t.daysShort.join("|") + ")", l = "(" + t.months.join("|") + ")", i = "(" + t.monthsShort.join("|") + ")", r = {};
    let s2 = 0;
    const u = e.replace(reverseToken, (e2) => {
      switch (s2++, e2) {
        case "YY":
          return r.YY = s2, "(-?\\d{1,2})";
        case "YYYY":
          return r.YYYY = s2, "(-?\\d{1,4})";
        case "M":
          return r.M = s2, "(\\d{1,2})";
        case "MM":
          return r.M = s2, "(\\d{2})";
        case "MMM":
          return r.MMM = s2, i;
        case "MMMM":
          return r.MMMM = s2, l;
        case "D":
          return r.D = s2, "(\\d{1,2})";
        case "Do":
          return r.D = s2++, "(\\d{1,2}(st|nd|rd|th))";
        case "DD":
          return r.D = s2, "(\\d{2})";
        case "H":
          return r.H = s2, "(\\d{1,2})";
        case "HH":
          return r.H = s2, "(\\d{2})";
        case "h":
          return r.h = s2, "(\\d{1,2})";
        case "hh":
          return r.h = s2, "(\\d{2})";
        case "m":
          return r.m = s2, "(\\d{1,2})";
        case "mm":
          return r.m = s2, "(\\d{2})";
        case "s":
          return r.s = s2, "(\\d{1,2})";
        case "ss":
          return r.s = s2, "(\\d{2})";
        case "S":
          return r.S = s2, "(\\d{1})";
        case "SS":
          return r.S = s2, "(\\d{2})";
        case "SSS":
          return r.S = s2, "(\\d{3})";
        case "A":
          return r.A = s2, "(AM|PM)";
        case "a":
          return r.a = s2, "(am|pm)";
        case "aa":
          return r.aa = s2, "(a\\.m\\.|p\\.m\\.)";
        case "ddd":
          return a;
        case "dddd":
          return o;
        case "Q":
        case "d":
        case "E":
          return "(\\d{1})";
        case "Qo":
          return "(1st|2nd|3rd|4th)";
        case "DDD":
        case "DDDD":
          return "(\\d{1,3})";
        case "w":
          return "(\\d{1,2})";
        case "ww":
          return "(\\d{2})";
        case "Z":
          return r.Z = s2, "(Z|[+-]\\d{2}:\\d{2})";
        case "ZZ":
          return r.ZZ = s2, "(Z|[+-]\\d{2}\\d{2})";
        case "X":
          return r.X = s2, "(-?\\d+)";
        case "x":
          return r.x = s2, "(-?\\d{4,})";
        default:
          return s2--, e2[0] === "[" && (e2 = e2.substring(1, e2.length - 1)), e2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    }), c = { map: r, regex: new RegExp("^" + u) };
    return regexStore[n] = c, c;
  }
  function extractDate(e, t, o) {
    const n = __splitDate(e, t, o), a = new Date(n.year, n.month === null ? null : n.month - 1, n.day, n.hour, n.minute, n.second, n.millisecond), l = a.getTimezoneOffset();
    return n.timezoneOffset === null || n.timezoneOffset === l ? a : getChange(a, { minutes: n.timezoneOffset - l }, true);
  }
  function __splitDate(e, t, o, n, a) {
    const l = { year: null, month: null, day: null, hour: null, minute: null, second: null, millisecond: null, timezoneOffset: null, dateHash: null, timeHash: null };
    if (a !== void 0 && Object.assign(l, a), e === void 0 || e === null || e === "" || typeof e !== "string")
      return l;
    t === void 0 && (t = defaultMask);
    const i = o !== void 0 ? o : Plugin$7.props.date, r = i.months, s2 = i.monthsShort, { regex: u, map: c } = getRegexData(t, i), d = e.match(u);
    if (d === null)
      return l;
    let p2 = "";
    if (c.X !== void 0 || c.x !== void 0) {
      const e2 = parseInt(d[c.X !== void 0 ? c.X : c.x], 10);
      if (isNaN(e2) === true || e2 < 0)
        return l;
      const t2 = new Date(e2 * (c.X !== void 0 ? 1e3 : 1));
      l.year = t2.getFullYear(), l.month = t2.getMonth() + 1, l.day = t2.getDate(), l.hour = t2.getHours(), l.minute = t2.getMinutes(), l.second = t2.getSeconds(), l.millisecond = t2.getMilliseconds();
    } else {
      if (c.YYYY !== void 0)
        l.year = parseInt(d[c.YYYY], 10);
      else if (c.YY !== void 0) {
        const e2 = parseInt(d[c.YY], 10);
        l.year = e2 < 0 ? e2 : 2e3 + e2;
      }
      if (c.M !== void 0) {
        if (l.month = parseInt(d[c.M], 10), l.month < 1 || l.month > 12)
          return l;
      } else
        c.MMM !== void 0 ? l.month = s2.indexOf(d[c.MMM]) + 1 : c.MMMM !== void 0 && (l.month = r.indexOf(d[c.MMMM]) + 1);
      if (c.D !== void 0) {
        if (l.day = parseInt(d[c.D], 10), l.year === null || l.month === null || l.day < 1)
          return l;
        const e2 = n !== "persian" ? new Date(l.year, l.month, 0).getDate() : jalaaliMonthLength(l.year, l.month);
        if (l.day > e2)
          return l;
      }
      c.H !== void 0 ? l.hour = parseInt(d[c.H], 10) % 24 : c.h !== void 0 && (l.hour = parseInt(d[c.h], 10) % 12, (c.A && d[c.A] === "PM" || c.a && d[c.a] === "pm" || c.aa && d[c.aa] === "p.m.") && (l.hour += 12), l.hour = l.hour % 24), c.m !== void 0 && (l.minute = parseInt(d[c.m], 10) % 60), c.s !== void 0 && (l.second = parseInt(d[c.s], 10) % 60), c.S !== void 0 && (l.millisecond = parseInt(d[c.S], 10) * 10 ** (3 - d[c.S].length)), c.Z === void 0 && c.ZZ === void 0 || (p2 = c.Z !== void 0 ? d[c.Z].replace(":", "") : d[c.ZZ], l.timezoneOffset = (p2[0] === "+" ? -1 : 1) * (60 * p2.slice(1, 3) + 1 * p2.slice(3, 5)));
    }
    return l.dateHash = l.year + "/" + pad(l.month) + "/" + pad(l.day), l.timeHash = pad(l.hour) + ":" + pad(l.minute) + ":" + pad(l.second) + p2, l;
  }
  function formatTimezone(e, t = "") {
    const o = e > 0 ? "-" : "+", n = Math.abs(e), a = Math.floor(n / 60), l = n % 60;
    return o + pad(a) + t + pad(l);
  }
  function setMonth(e, t) {
    const o = new Date(e.getFullYear(), t, 0, 0, 0, 0, 0), n = o.getDate();
    e.setMonth(t - 1, Math.min(n, e.getDate()));
  }
  function getChange(e, t, o) {
    const n = new Date(e), a = o ? 1 : -1;
    return Object.keys(t).forEach((e2) => {
      if (e2 === "months")
        return void setMonth(n, n.getMonth() + 1 + a * t.months);
      const o2 = e2 === "years" ? "FullYear" : capitalize2(e2 === "days" ? "date" : e2);
      n[`set${o2}`](n[`get${o2}`]() + a * t[e2]);
    }), n;
  }
  function isValid(e) {
    return typeof e === "number" || isNaN(Date.parse(e)) === false;
  }
  function buildDate(e, t) {
    return adjustDate(new Date(), e, t);
  }
  function getDayOfWeek(e) {
    const t = new Date(e).getDay();
    return t === 0 ? 7 : t;
  }
  function getWeekOfYear(e) {
    const t = new Date(e.getFullYear(), e.getMonth(), e.getDate());
    t.setDate(t.getDate() - (t.getDay() + 6) % 7 + 3);
    const o = new Date(t.getFullYear(), 0, 4);
    o.setDate(o.getDate() - (o.getDay() + 6) % 7 + 3);
    const n = t.getTimezoneOffset() - o.getTimezoneOffset();
    t.setHours(t.getHours() - n);
    const a = (t - o) / (7 * MILLISECONDS_IN_DAY);
    return 1 + Math.floor(a);
  }
  function getDayIdentifier(e) {
    return 1e4 * e.getFullYear() + 100 * e.getMonth() + e.getDate();
  }
  function getDateIdentifier(e, t) {
    const o = new Date(e);
    return t === true ? getDayIdentifier(o) : o.getTime();
  }
  function isBetweenDates(e, t, o, n = {}) {
    const a = getDateIdentifier(t, n.onlyDate), l = getDateIdentifier(o, n.onlyDate), i = getDateIdentifier(e, n.onlyDate);
    return (i > a || n.inclusiveFrom === true && i === a) && (i < l || n.inclusiveTo === true && i === l);
  }
  function addToDate(e, t) {
    return getChange(e, t, true);
  }
  function subtractFromDate(e, t) {
    return getChange(e, t, false);
  }
  function adjustDate(e, t, o) {
    const n = new Date(e), a = `set${o === true ? "UTC" : ""}`;
    return Object.keys(t).forEach((e2) => {
      if (e2 === "month")
        return void setMonth(n, t.month);
      const o2 = e2 === "year" ? "FullYear" : e2.charAt(0).toUpperCase() + e2.slice(1);
      n[`${a}${o2}`](t[e2]);
    }), n;
  }
  function startOfDate(e, t, o) {
    const n = new Date(e), a = `set${o === true ? "UTC" : ""}`;
    switch (t) {
      case "year":
        n[`${a}Month`](0);
      case "month":
        n[`${a}Date`](1);
      case "day":
        n[`${a}Hours`](0);
      case "hour":
        n[`${a}Minutes`](0);
      case "minute":
        n[`${a}Seconds`](0);
      case "second":
        n[`${a}Milliseconds`](0);
    }
    return n;
  }
  function endOfDate(e, t, o) {
    const n = new Date(e), a = `set${o === true ? "UTC" : ""}`;
    switch (t) {
      case "year":
        n[`${a}Month`](11);
      case "month":
        n[`${a}Date`](daysInMonth(n));
      case "day":
        n[`${a}Hours`](23);
      case "hour":
        n[`${a}Minutes`](59);
      case "minute":
        n[`${a}Seconds`](59);
      case "second":
        n[`${a}Milliseconds`](999);
    }
    return n;
  }
  function getMaxDate(e) {
    let t = new Date(e);
    return Array.prototype.slice.call(arguments, 1).forEach((e2) => {
      t = Math.max(t, new Date(e2));
    }), t;
  }
  function getMinDate(e) {
    let t = new Date(e);
    return Array.prototype.slice.call(arguments, 1).forEach((e2) => {
      t = Math.min(t, new Date(e2));
    }), t;
  }
  function getDiff(e, t, o) {
    return (e.getTime() - e.getTimezoneOffset() * MILLISECONDS_IN_MINUTE - (t.getTime() - t.getTimezoneOffset() * MILLISECONDS_IN_MINUTE)) / o;
  }
  function getDateDiff(e, t, o = "days") {
    const n = new Date(e), a = new Date(t);
    switch (o) {
      case "years":
        return n.getFullYear() - a.getFullYear();
      case "months":
        return 12 * (n.getFullYear() - a.getFullYear()) + n.getMonth() - a.getMonth();
      case "days":
        return getDiff(startOfDate(n, "day"), startOfDate(a, "day"), MILLISECONDS_IN_DAY);
      case "hours":
        return getDiff(startOfDate(n, "hour"), startOfDate(a, "hour"), MILLISECONDS_IN_HOUR);
      case "minutes":
        return getDiff(startOfDate(n, "minute"), startOfDate(a, "minute"), MILLISECONDS_IN_MINUTE);
      case "seconds":
        return getDiff(startOfDate(n, "second"), startOfDate(a, "second"), 1e3);
    }
  }
  function getDayOfYear(e) {
    return getDateDiff(e, startOfDate(e, "year"), "days") + 1;
  }
  function inferDateFormat(e) {
    return isDate2(e) === true ? "date" : typeof e === "number" ? "number" : "string";
  }
  function getDateBetween(e, t, o) {
    const n = new Date(e);
    if (t) {
      const e2 = new Date(t);
      if (n < e2)
        return e2;
    }
    if (o) {
      const e2 = new Date(o);
      if (n > e2)
        return e2;
    }
    return n;
  }
  function isSameDate(e, t, o) {
    const n = new Date(e), a = new Date(t);
    if (o === void 0)
      return n.getTime() === a.getTime();
    switch (o) {
      case "second":
        if (n.getSeconds() !== a.getSeconds())
          return false;
      case "minute":
        if (n.getMinutes() !== a.getMinutes())
          return false;
      case "hour":
        if (n.getHours() !== a.getHours())
          return false;
      case "day":
        if (n.getDate() !== a.getDate())
          return false;
      case "month":
        if (n.getMonth() !== a.getMonth())
          return false;
      case "year":
        if (n.getFullYear() !== a.getFullYear())
          return false;
        break;
      default:
        throw new Error(`date isSameDate unknown unit ${o}`);
    }
    return true;
  }
  function daysInMonth(e) {
    return new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate();
  }
  function getOrdinal(e) {
    if (e >= 11 && e <= 13)
      return `${e}th`;
    switch (e % 10) {
      case 1:
        return `${e}st`;
      case 2:
        return `${e}nd`;
      case 3:
        return `${e}rd`;
    }
    return `${e}th`;
  }
  var formatter = { YY(e, t, o) {
    const n = this.YYYY(e, t, o) % 100;
    return n > 0 ? pad(n) : "-" + pad(Math.abs(n));
  }, YYYY(e, t, o) {
    return o !== void 0 && o !== null ? o : e.getFullYear();
  }, M(e) {
    return e.getMonth() + 1;
  }, MM(e) {
    return pad(e.getMonth() + 1);
  }, MMM(e, t) {
    return t.monthsShort[e.getMonth()];
  }, MMMM(e, t) {
    return t.months[e.getMonth()];
  }, Q(e) {
    return Math.ceil((e.getMonth() + 1) / 3);
  }, Qo(e) {
    return getOrdinal(this.Q(e));
  }, D(e) {
    return e.getDate();
  }, Do(e) {
    return getOrdinal(e.getDate());
  }, DD(e) {
    return pad(e.getDate());
  }, DDD(e) {
    return getDayOfYear(e);
  }, DDDD(e) {
    return pad(getDayOfYear(e), 3);
  }, d(e) {
    return e.getDay();
  }, dd(e, t) {
    return this.dddd(e, t).slice(0, 2);
  }, ddd(e, t) {
    return t.daysShort[e.getDay()];
  }, dddd(e, t) {
    return t.days[e.getDay()];
  }, E(e) {
    return e.getDay() || 7;
  }, w(e) {
    return getWeekOfYear(e);
  }, ww(e) {
    return pad(getWeekOfYear(e));
  }, H(e) {
    return e.getHours();
  }, HH(e) {
    return pad(e.getHours());
  }, h(e) {
    const t = e.getHours();
    return t === 0 ? 12 : t > 12 ? t % 12 : t;
  }, hh(e) {
    return pad(this.h(e));
  }, m(e) {
    return e.getMinutes();
  }, mm(e) {
    return pad(e.getMinutes());
  }, s(e) {
    return e.getSeconds();
  }, ss(e) {
    return pad(e.getSeconds());
  }, S(e) {
    return Math.floor(e.getMilliseconds() / 100);
  }, SS(e) {
    return pad(Math.floor(e.getMilliseconds() / 10));
  }, SSS(e) {
    return pad(e.getMilliseconds(), 3);
  }, A(e) {
    return this.H(e) < 12 ? "AM" : "PM";
  }, a(e) {
    return this.H(e) < 12 ? "am" : "pm";
  }, aa(e) {
    return this.H(e) < 12 ? "a.m." : "p.m.";
  }, Z(e, t, o, n) {
    const a = n === void 0 || n === null ? e.getTimezoneOffset() : n;
    return formatTimezone(a, ":");
  }, ZZ(e, t, o, n) {
    const a = n === void 0 || n === null ? e.getTimezoneOffset() : n;
    return formatTimezone(a);
  }, X(e) {
    return Math.floor(e.getTime() / 1e3);
  }, x(e) {
    return e.getTime();
  } };
  function formatDate(e, t, o, n, a) {
    if (e !== 0 && !e || e === 1 / 0 || e === -1 / 0)
      return;
    const l = new Date(e);
    if (isNaN(l))
      return;
    t === void 0 && (t = defaultMask);
    const i = o !== void 0 ? o : Plugin$7.props.date;
    return t.replace(token, (e2, t2) => e2 in formatter ? formatter[e2](l, i, n, a) : t2 === void 0 ? e2 : t2.split("\\]").join("]"));
  }
  function clone$1(e) {
    return isDate2(e) === true ? new Date(e.getTime()) : e;
  }
  var date = { isValid, extractDate, buildDate, getDayOfWeek, getWeekOfYear, isBetweenDates, addToDate, subtractFromDate, adjustDate, startOfDate, endOfDate, getMaxDate, getMinDate, getDateDiff, getDayOfYear, inferDateFormat, getDateBetween, isSameDate, daysInMonth, formatDate, clone: clone$1 };
  var yearsInterval = 20;
  var views = ["Calendar", "Years", "Months"];
  var viewIsValid = (e) => views.includes(e);
  var yearMonthValidator = (e) => /^-?[\d]+\/[0-1]\d$/.test(e);
  var lineStr = " \u2014 ";
  function getMonthHash(e) {
    return e.year + "/" + pad(e.month);
  }
  var QDate = defineComponent2({ name: "QDate", props: { ...useDatetimeProps, ...useFormProps, ...useDarkProps, multiple: Boolean, range: Boolean, title: String, subtitle: String, mask: { default: "YYYY/MM/DD" }, defaultYearMonth: { type: String, validator: yearMonthValidator }, yearsInMonthView: Boolean, events: [Array, Function], eventColor: [String, Function], emitImmediately: Boolean, options: [Array, Function], navigationMinYearMonth: { type: String, validator: yearMonthValidator }, navigationMaxYearMonth: { type: String, validator: yearMonthValidator }, noUnset: Boolean, firstDayOfWeek: [String, Number], todayBtn: Boolean, minimal: Boolean, defaultView: { type: String, default: "Calendar", validator: viewIsValid } }, emits: [...useDatetimeEmits, "range-start", "range-end", "navigation"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = useDark(e, a), { getCache: i } = useCache(), { tabindex: r, headerClass: s2, getLocale: u, getCurrentDate: c } = useDatetime(e, a);
    let d;
    const p2 = useFormAttrs(e), v = useFormInject(p2), m = ref(null), f = ref(de()), g = ref(u()), b = computed2(() => de()), y = computed2(() => u()), S = computed2(() => c()), w = ref(ve(f.value, g.value)), x = ref(e.defaultView), C = a.lang.rtl === true ? "right" : "left", k2 = ref(C.value), _ = ref(C.value), q = w.value.year, T = ref(q - q % yearsInterval - (q < 0 ? yearsInterval : 0)), P = ref(null), $ = computed2(() => {
      const t2 = e.landscape === true ? "landscape" : "portrait";
      return `q-date q-date--${t2} q-date--${t2}-${e.minimal === true ? "minimal" : "standard"}` + (l.value === true ? " q-date--dark q-dark" : "") + (e.bordered === true ? " q-date--bordered" : "") + (e.square === true ? " q-date--square no-border-radius" : "") + (e.flat === true ? " q-date--flat no-shadow" : "") + (e.disable === true ? " disabled" : e.readonly === true ? " q-date--readonly" : "");
    }), M = computed2(() => {
      return e.color || "primary";
    }), B = computed2(() => {
      return e.textColor || "white";
    }), Q = computed2(() => e.emitImmediately === true && e.multiple !== true && e.range !== true), E = computed2(() => Array.isArray(e.modelValue) === true ? e.modelValue : e.modelValue !== null && e.modelValue !== void 0 ? [e.modelValue] : []), O = computed2(() => E.value.filter((e2) => typeof e2 === "string").map((e2) => pe(e2, f.value, g.value)).filter((e2) => e2.dateHash !== null)), z = computed2(() => {
      const e2 = (e3) => pe(e3, f.value, g.value);
      return E.value.filter((e3) => Object(e3) === e3 && e3.from !== void 0 && e3.to !== void 0).map((t2) => ({ from: e2(t2.from), to: e2(t2.to) })).filter((e3) => e3.from.dateHash !== null && e3.to.dateHash !== null && e3.from.dateHash < e3.to.dateHash);
    }), F = computed2(() => e.calendar !== "persian" ? (e2) => new Date(e2.year, e2.month - 1, e2.day) : (e2) => {
      const t2 = toGregorian(e2.year, e2.month, e2.day);
      return new Date(t2.gy, t2.gm - 1, t2.gd);
    }), L = computed2(() => e.calendar === "persian" ? getDayHash : (e2, t2, o2) => formatDate(new Date(e2.year, e2.month - 1, e2.day, e2.hour, e2.minute, e2.second, e2.millisecond), t2 === void 0 ? f.value : t2, o2 === void 0 ? g.value : o2, e2.year, e2.timezoneOffset)), R = computed2(() => O.value.length + z.value.reduce((e2, t2) => e2 + 1 + getDateDiff(F.value(t2.to), F.value(t2.from)), 0)), V = computed2(() => {
      if (e.title !== void 0 && e.title !== null && e.title.length > 0)
        return e.title;
      if (P.value !== null) {
        const e2 = P.value.init, t3 = F.value(e2);
        return g.value.daysShort[t3.getDay()] + ", " + g.value.monthsShort[e2.month - 1] + " " + e2.day + lineStr + "?";
      }
      if (R.value === 0)
        return lineStr;
      if (R.value > 1)
        return `${R.value} ${g.value.pluralDay}`;
      const t2 = O.value[0], o2 = F.value(t2);
      return isNaN(o2.valueOf()) === true ? lineStr : g.value.headerTitle !== void 0 ? g.value.headerTitle(o2, t2) : g.value.daysShort[o2.getDay()] + ", " + g.value.monthsShort[t2.month - 1] + " " + t2.day;
    }), I = computed2(() => {
      const e2 = O.value.concat(z.value.map((e3) => e3.from)).sort((e3, t2) => e3.year - t2.year || e3.month - t2.month);
      return e2[0];
    }), A = computed2(() => {
      const e2 = O.value.concat(z.value.map((e3) => e3.to)).sort((e3, t2) => t2.year - e3.year || t2.month - e3.month);
      return e2[0];
    }), D = computed2(() => {
      if (e.subtitle !== void 0 && e.subtitle !== null && e.subtitle.length > 0)
        return e.subtitle;
      if (R.value === 0)
        return lineStr;
      if (R.value > 1) {
        const e2 = I.value, t2 = A.value, o2 = g.value.monthsShort;
        return o2[e2.month - 1] + (e2.year !== t2.year ? " " + e2.year + lineStr + o2[t2.month - 1] + " " : e2.month !== t2.month ? lineStr + o2[t2.month - 1] : "") + " " + t2.year;
      }
      return O.value[0].year;
    }), N = computed2(() => {
      const e2 = [a.iconSet.datetime.arrowLeft, a.iconSet.datetime.arrowRight];
      return a.lang.rtl === true ? e2.reverse() : e2;
    }), H = computed2(() => e.firstDayOfWeek !== void 0 ? Number(e.firstDayOfWeek) : g.value.firstDayOfWeek), j = computed2(() => {
      const e2 = g.value.daysShort, t2 = H.value;
      return t2 > 0 ? e2.slice(t2, 7).concat(e2.slice(0, t2)) : e2;
    }), U = computed2(() => {
      const t2 = w.value;
      return e.calendar !== "persian" ? new Date(t2.year, t2.month, 0).getDate() : jalaaliMonthLength(t2.year, t2.month);
    }), K = computed2(() => typeof e.eventColor === "function" ? e.eventColor : () => e.eventColor), W = computed2(() => {
      if (e.navigationMinYearMonth === void 0)
        return null;
      const t2 = e.navigationMinYearMonth.split("/");
      return { year: parseInt(t2[0], 10), month: parseInt(t2[1], 10) };
    }), Y = computed2(() => {
      if (e.navigationMaxYearMonth === void 0)
        return null;
      const t2 = e.navigationMaxYearMonth.split("/");
      return { year: parseInt(t2[0], 10), month: parseInt(t2[1], 10) };
    }), G = computed2(() => {
      const e2 = { month: { prev: true, next: true }, year: { prev: true, next: true } };
      return W.value !== null && W.value.year >= w.value.year && (e2.year.prev = false, W.value.year === w.value.year && W.value.month >= w.value.month && (e2.month.prev = false)), Y.value !== null && Y.value.year <= w.value.year && (e2.year.next = false, Y.value.year === w.value.year && Y.value.month <= w.value.month && (e2.month.next = false)), e2;
    }), X = computed2(() => {
      const e2 = {};
      return O.value.forEach((t2) => {
        const o2 = getMonthHash(t2);
        e2[o2] === void 0 && (e2[o2] = []), e2[o2].push(t2.day);
      }), e2;
    }), Z = computed2(() => {
      const e2 = {};
      return z.value.forEach((t2) => {
        const o2 = getMonthHash(t2.from), n2 = getMonthHash(t2.to);
        if (e2[o2] === void 0 && (e2[o2] = []), e2[o2].push({ from: t2.from.day, to: o2 === n2 ? t2.to.day : void 0, range: t2 }), o2 < n2) {
          let o3;
          const { year: a2, month: l2 } = t2.from, i2 = l2 < 12 ? { year: a2, month: l2 + 1 } : { year: a2 + 1, month: 1 };
          while ((o3 = getMonthHash(i2)) <= n2)
            e2[o3] === void 0 && (e2[o3] = []), e2[o3].push({ from: void 0, to: o3 === n2 ? t2.to.day : void 0, range: t2 }), i2.month++, i2.month > 12 && (i2.year++, i2.month = 1);
        }
      }), e2;
    }), J = computed2(() => {
      if (P.value === null)
        return;
      const { init: e2, initHash: t2, final: o2, finalHash: n2 } = P.value, [a2, l2] = t2 <= n2 ? [e2, o2] : [o2, e2], i2 = getMonthHash(a2), r2 = getMonthHash(l2);
      if (i2 !== ee.value && r2 !== ee.value)
        return;
      const s3 = {};
      return i2 === ee.value ? (s3.from = a2.day, s3.includeFrom = true) : s3.from = 1, r2 === ee.value ? (s3.to = l2.day, s3.includeTo = true) : s3.to = U.value, s3;
    }), ee = computed2(() => getMonthHash(w.value)), te = computed2(() => {
      const t2 = {};
      if (e.options === void 0) {
        for (let e2 = 1; e2 <= U.value; e2++)
          t2[e2] = true;
        return t2;
      }
      const o2 = typeof e.options === "function" ? e.options : (t3) => e.options.includes(t3);
      for (let e2 = 1; e2 <= U.value; e2++) {
        const n2 = ee.value + "/" + pad(e2);
        t2[e2] = o2(n2);
      }
      return t2;
    }), oe = computed2(() => {
      const t2 = {};
      if (e.events === void 0)
        for (let e2 = 1; e2 <= U.value; e2++)
          t2[e2] = false;
      else {
        const o2 = typeof e.events === "function" ? e.events : (t3) => e.events.includes(t3);
        for (let e2 = 1; e2 <= U.value; e2++) {
          const n2 = ee.value + "/" + pad(e2);
          t2[e2] = o2(n2) === true && K.value(n2);
        }
      }
      return t2;
    }), ne = computed2(() => {
      let t2, o2;
      const { year: n2, month: a2 } = w.value;
      if (e.calendar !== "persian")
        t2 = new Date(n2, a2 - 1, 1), o2 = new Date(n2, a2 - 1, 0).getDate();
      else {
        const e2 = toGregorian(n2, a2, 1);
        t2 = new Date(e2.gy, e2.gm - 1, e2.gd);
        let l2 = a2 - 1, i2 = n2;
        l2 === 0 && (l2 = 12, i2--), o2 = jalaaliMonthLength(i2, l2);
      }
      return { days: t2.getDay() - H.value - 1, endDay: o2 };
    }), ae = computed2(() => {
      const e2 = [], { days: t2, endDay: o2 } = ne.value, n2 = t2 < 0 ? t2 + 7 : t2;
      if (n2 < 6)
        for (let i2 = o2 - n2; i2 <= o2; i2++)
          e2.push({ i: i2, fill: true });
      const a2 = e2.length;
      for (let i2 = 1; i2 <= U.value; i2++) {
        const t3 = { i: i2, event: oe.value[i2], classes: [] };
        te.value[i2] === true && (t3.in = true, t3.flat = true), e2.push(t3);
      }
      if (X.value[ee.value] !== void 0 && X.value[ee.value].forEach((t3) => {
        const o3 = a2 + t3 - 1;
        Object.assign(e2[o3], { selected: true, unelevated: true, flat: false, color: M.value, textColor: B.value });
      }), Z.value[ee.value] !== void 0 && Z.value[ee.value].forEach((t3) => {
        if (t3.from !== void 0) {
          const o3 = a2 + t3.from - 1, n3 = a2 + (t3.to || U.value) - 1;
          for (let a3 = o3; a3 <= n3; a3++)
            Object.assign(e2[a3], { range: t3.range, unelevated: true, color: M.value, textColor: B.value });
          Object.assign(e2[o3], { rangeFrom: true, flat: false }), t3.to !== void 0 && Object.assign(e2[n3], { rangeTo: true, flat: false });
        } else if (t3.to !== void 0) {
          const o3 = a2 + t3.to - 1;
          for (let n3 = a2; n3 <= o3; n3++)
            Object.assign(e2[n3], { range: t3.range, unelevated: true, color: M.value, textColor: B.value });
          Object.assign(e2[o3], { flat: false, rangeTo: true });
        } else {
          const o3 = a2 + U.value - 1;
          for (let n3 = a2; n3 <= o3; n3++)
            Object.assign(e2[n3], { range: t3.range, unelevated: true, color: M.value, textColor: B.value });
        }
      }), J.value !== void 0) {
        const t3 = a2 + J.value.from - 1, o3 = a2 + J.value.to - 1;
        for (let n3 = t3; n3 <= o3; n3++)
          e2[n3].color = M.value, e2[n3].editRange = true;
        J.value.includeFrom === true && (e2[t3].editRangeFrom = true), J.value.includeTo === true && (e2[o3].editRangeTo = true);
      }
      w.value.year === S.value.year && w.value.month === S.value.month && (e2[a2 + S.value.day - 1].today = true);
      const l2 = e2.length % 7;
      if (l2 > 0) {
        const t3 = 7 - l2;
        for (let o3 = 1; o3 <= t3; o3++)
          e2.push({ i: o3, fill: true });
      }
      return e2.forEach((e3) => {
        let t3 = "q-date__calendar-item ";
        e3.fill === true ? t3 += "q-date__calendar-item--fill" : (t3 += `q-date__calendar-item--${e3.in === true ? "in" : "out"}`, e3.range !== void 0 && (t3 += ` q-date__range${e3.rangeTo === true ? "-to" : e3.rangeFrom === true ? "-from" : ""}`), e3.editRange === true && (t3 += ` q-date__edit-range${e3.editRangeFrom === true ? "-from" : ""}${e3.editRangeTo === true ? "-to" : ""}`), e3.range === void 0 && e3.editRange !== true || (t3 += ` text-${e3.color}`)), e3.classes = t3;
      }), e2;
    }), le = computed2(() => e.disable === true ? { "aria-disabled": "true" } : e.readonly === true ? { "aria-readonly": "true" } : {});
    function ie() {
      ye(S.value, getMonthHash(S.value)), ue(S.value.year, S.value.month);
    }
    function re(e2) {
      viewIsValid(e2) === true && (x.value = e2);
    }
    function se(e2, t2) {
      if (["month", "year"].includes(e2)) {
        const o2 = e2 === "month" ? fe : he;
        o2(t2 === true ? -1 : 1);
      }
    }
    function ue(e2, t2) {
      x.value = "Calendar", we(e2, t2);
    }
    function ce(t2, o2) {
      if (e.range === false || !t2)
        return void (P.value = null);
      const n2 = Object.assign({ ...w.value }, t2), a2 = o2 !== void 0 ? Object.assign({ ...w.value }, o2) : n2;
      P.value = { init: n2, initHash: getDayHash(n2), final: a2, finalHash: getDayHash(a2) }, ue(n2.year, n2.month);
    }
    function de() {
      return e.calendar === "persian" ? "YYYY/MM/DD" : e.mask;
    }
    function pe(t2, o2, n2) {
      return __splitDate(t2, o2, n2, e.calendar, { hour: 0, minute: 0, second: 0, millisecond: 0 });
    }
    function ve(t2, o2) {
      const n2 = Array.isArray(e.modelValue) === true ? e.modelValue : e.modelValue ? [e.modelValue] : [];
      if (n2.length === 0)
        return me();
      const a2 = pe(n2[0].from !== void 0 ? n2[0].from : n2[0], t2, o2);
      return a2.dateHash === null ? me() : a2;
    }
    function me() {
      let t2, o2;
      if (e.defaultYearMonth !== void 0) {
        const n2 = e.defaultYearMonth.split("/");
        t2 = parseInt(n2[0], 10), o2 = parseInt(n2[1], 10);
      } else {
        const e2 = S.value !== void 0 ? S.value : c();
        t2 = e2.year, o2 = e2.month;
      }
      return { year: t2, month: o2, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0, dateHash: t2 + "/" + pad(o2) + "/01" };
    }
    function fe(e2) {
      let t2 = w.value.year, o2 = Number(w.value.month) + e2;
      o2 === 13 ? (o2 = 1, t2++) : o2 === 0 && (o2 = 12, t2--), we(t2, o2), Q.value === true && Ce("month");
    }
    function he(e2) {
      const t2 = Number(w.value.year) + e2;
      we(t2, w.value.month), Q.value === true && Ce("year");
    }
    function ge(t2) {
      we(t2, w.value.month), x.value = e.defaultView === "Years" ? "Months" : "Calendar", Q.value === true && Ce("year");
    }
    function be(e2) {
      we(w.value.year, e2), x.value = "Calendar", Q.value === true && Ce("month");
    }
    function ye(e2, t2) {
      const o2 = X.value[t2], n2 = o2 !== void 0 && o2.includes(e2.day) === true ? Te : qe;
      n2(e2);
    }
    function Se(e2) {
      return { year: e2.year, month: e2.month, day: e2.day };
    }
    function we(e2, t2) {
      W.value !== null && e2 <= W.value.year && (e2 = W.value.year, t2 < W.value.month && (t2 = W.value.month)), Y.value !== null && e2 >= Y.value.year && (e2 = Y.value.year, t2 > Y.value.month && (t2 = Y.value.month));
      const o2 = e2 + "/" + pad(t2) + "/01";
      o2 !== w.value.dateHash && (k2.value = w.value.dateHash < o2 === (a.lang.rtl !== true) ? "left" : "right", e2 !== w.value.year && (_.value = k2.value), nextTick2(() => {
        T.value = e2 - e2 % yearsInterval - (e2 < 0 ? yearsInterval : 0), Object.assign(w.value, { year: e2, month: t2, day: 1, dateHash: o2 });
      }));
    }
    function xe(t2, n2, a2) {
      const l2 = t2 !== null && t2.length === 1 && e.multiple === false ? t2[0] : t2;
      d = l2;
      const { reason: i2, details: r2 } = ke(n2, a2);
      o("update:modelValue", l2, i2, r2);
    }
    function Ce(t2) {
      const n2 = O.value[0] !== void 0 && O.value[0].dateHash !== null ? { ...O.value[0] } : { ...w.value };
      nextTick2(() => {
        n2.year = w.value.year, n2.month = w.value.month;
        const a2 = e.calendar !== "persian" ? new Date(n2.year, n2.month, 0).getDate() : jalaaliMonthLength(n2.year, n2.month);
        n2.day = Math.min(Math.max(1, n2.day), a2);
        const l2 = _e(n2);
        d = l2;
        const { details: i2 } = ke("", n2);
        o("update:modelValue", l2, t2, i2);
      });
    }
    function ke(e2, t2) {
      return t2.from !== void 0 ? { reason: `${e2}-range`, details: { ...Se(t2.target), from: Se(t2.from), to: Se(t2.to) } } : { reason: `${e2}-day`, details: Se(t2) };
    }
    function _e(e2, t2, o2) {
      return e2.from !== void 0 ? { from: L.value(e2.from, t2, o2), to: L.value(e2.to, t2, o2) } : L.value(e2, t2, o2);
    }
    function qe(t2) {
      let o2;
      if (e.multiple === true)
        if (t2.from !== void 0) {
          const e2 = getDayHash(t2.from), n2 = getDayHash(t2.to), a2 = O.value.filter((t3) => t3.dateHash < e2 || t3.dateHash > n2), l2 = z.value.filter(({ from: t3, to: o3 }) => o3.dateHash < e2 || t3.dateHash > n2);
          o2 = a2.concat(l2).concat(t2).map((e3) => _e(e3));
        } else {
          const e2 = E.value.slice();
          e2.push(_e(t2)), o2 = e2;
        }
      else
        o2 = _e(t2);
      xe(o2, "add", t2);
    }
    function Te(t2) {
      if (e.noUnset === true)
        return;
      let o2 = null;
      if (e.multiple === true && Array.isArray(e.modelValue) === true) {
        const n2 = _e(t2);
        o2 = t2.from !== void 0 ? e.modelValue.filter((e2) => e2.from === void 0 || e2.from !== n2.from && e2.to !== n2.to) : e.modelValue.filter((e2) => e2 !== n2), o2.length === 0 && (o2 = null);
      }
      xe(o2, "remove", t2);
    }
    function Pe(t2, n2, a2) {
      const l2 = O.value.concat(z.value).map((e2) => _e(e2, t2, n2)).filter((e2) => {
        return e2.from !== void 0 ? e2.from.dateHash !== null && e2.to.dateHash !== null : e2.dateHash !== null;
      });
      o("update:modelValue", (e.multiple === true ? l2 : l2[0]) || null, a2);
    }
    function $e() {
      if (e.minimal !== true)
        return h("div", { class: "q-date__header " + s2.value }, [h("div", { class: "relative-position" }, [h(Transition, { name: "q-transition--fade" }, () => h("div", { key: "h-yr-" + D.value, class: "q-date__header-subtitle q-date__header-link " + (x.value === "Years" ? "q-date__header-link--active" : "cursor-pointer"), tabindex: r.value, ...i("vY", { onClick() {
          x.value = "Years";
        }, onKeyup(e2) {
          e2.keyCode === 13 && (x.value = "Years");
        } }) }, [D.value]))]), h("div", { class: "q-date__header-title relative-position flex no-wrap" }, [h("div", { class: "relative-position col" }, [h(Transition, { name: "q-transition--fade" }, () => h("div", { key: "h-sub" + V.value, class: "q-date__header-title-label q-date__header-link " + (x.value === "Calendar" ? "q-date__header-link--active" : "cursor-pointer"), tabindex: r.value, ...i("vC", { onClick() {
          x.value = "Calendar";
        }, onKeyup(e2) {
          e2.keyCode === 13 && (x.value = "Calendar");
        } }) }, [V.value]))]), e.todayBtn === true ? h(QBtn, { class: "q-date__header-today self-start", icon: a.iconSet.datetime.today, flat: true, size: "sm", round: true, tabindex: r.value, onClick: ie }) : null])]);
    }
    function Me({ label: e2, type: t2, key: o2, dir: n2, goTo: a2, boundaries: l2, cls: s3 }) {
      return [h("div", { class: "row items-center q-date__arrow" }, [h(QBtn, { round: true, dense: true, size: "sm", flat: true, icon: N.value[0], tabindex: r.value, disable: l2.prev === false, ...i("go-#" + t2, { onClick() {
        a2(-1);
      } }) })]), h("div", { class: "relative-position overflow-hidden flex flex-center" + s3 }, [h(Transition, { name: "q-transition--jump-" + n2 }, () => h("div", { key: o2 }, [h(QBtn, { flat: true, dense: true, noCaps: true, label: e2, tabindex: r.value, ...i("view#" + t2, { onClick: () => {
        x.value = t2;
      } }) })]))]), h("div", { class: "row items-center q-date__arrow" }, [h(QBtn, { round: true, dense: true, size: "sm", flat: true, icon: N.value[1], tabindex: r.value, disable: l2.next === false, ...i("go+#" + t2, { onClick() {
        a2(1);
      } }) })])];
    }
    watch(() => e.modelValue, (e2) => {
      if (d === e2)
        d = 0;
      else {
        const { year: e3, month: t2 } = ve(f.value, g.value);
        we(e3, t2);
      }
    }), watch(x, () => {
      m.value !== null && m.value.focus();
    }), watch(() => w.value.year, (e2) => {
      o("navigation", { year: e2, month: w.value.month });
    }), watch(() => w.value.month, (e2) => {
      o("navigation", { year: w.value.year, month: e2 });
    }), watch(b, (e2) => {
      Pe(e2, g.value, "mask"), f.value = e2;
    }), watch(y, (e2) => {
      Pe(f.value, e2, "locale"), g.value = e2;
    }), Object.assign(n, { setToday: ie, setView: re, offsetCalendar: se, setCalendarTo: ue, setEditingRange: ce });
    const Be = { Calendar: () => [h("div", { key: "calendar-view", class: "q-date__view q-date__calendar" }, [h("div", { class: "q-date__navigation row items-center no-wrap" }, Me({ label: g.value.months[w.value.month - 1], type: "Months", key: w.value.month, dir: k2.value, goTo: fe, boundaries: G.value.month, cls: " col" }).concat(Me({ label: w.value.year, type: "Years", key: w.value.year, dir: _.value, goTo: he, boundaries: G.value.year, cls: "" }))), h("div", { class: "q-date__calendar-weekdays row items-center no-wrap" }, j.value.map((e2) => h("div", { class: "q-date__calendar-item" }, [h("div", e2)]))), h("div", { class: "q-date__calendar-days-container relative-position overflow-hidden" }, [h(Transition, { name: "q-transition--slide-" + k2.value }, () => h("div", { key: ee.value, class: "q-date__calendar-days fit" }, ae.value.map((e2) => h("div", { class: e2.classes }, [e2.in === true ? h(QBtn, { class: e2.today === true ? "q-date__today" : "", dense: true, flat: e2.flat, unelevated: e2.unelevated, color: e2.color, textColor: e2.textColor, label: e2.i, tabindex: r.value, ...i("day#" + e2.i, { onClick: () => {
      Qe(e2.i);
    }, onMouseover: () => {
      Ee(e2.i);
    } }) }, e2.event !== false ? () => h("div", { class: "q-date__event bg-" + e2.event }) : null) : h("div", "" + e2.i)]))))])])], Months() {
      const t2 = w.value.year === S.value.year, o2 = (e2) => {
        return W.value !== null && w.value.year === W.value.year && W.value.month > e2 || Y.value !== null && w.value.year === Y.value.year && Y.value.month < e2;
      }, n2 = g.value.monthsShort.map((e2, n3) => {
        const a2 = w.value.month === n3 + 1;
        return h("div", { class: "q-date__months-item flex flex-center" }, [h(QBtn, { class: t2 === true && S.value.month === n3 + 1 ? "q-date__today" : null, flat: a2 !== true, label: e2, unelevated: a2, color: a2 === true ? M.value : null, textColor: a2 === true ? B.value : null, tabindex: r.value, disable: o2(n3 + 1), ...i("month#" + n3, { onClick: () => {
          be(n3 + 1);
        } }) })]);
      });
      return e.yearsInMonthView === true && n2.unshift(h("div", { class: "row no-wrap full-width" }, [Me({ label: w.value.year, type: "Years", key: w.value.year, dir: _.value, goTo: he, boundaries: G.value.year, cls: " col" })])), h("div", { key: "months-view", class: "q-date__view q-date__months flex flex-center" }, n2);
    }, Years() {
      const e2 = T.value, t2 = e2 + yearsInterval, o2 = [], n2 = (e3) => {
        return W.value !== null && W.value.year > e3 || Y.value !== null && Y.value.year < e3;
      };
      for (let a2 = e2; a2 <= t2; a2++) {
        const e3 = w.value.year === a2;
        o2.push(h("div", { class: "q-date__years-item flex flex-center" }, [h(QBtn, { key: "yr" + a2, class: S.value.year === a2 ? "q-date__today" : null, flat: !e3, label: a2, dense: true, unelevated: e3, color: e3 === true ? M.value : null, textColor: e3 === true ? B.value : null, tabindex: r.value, disable: n2(a2), ...i("yr#" + a2, { onClick: () => {
          ge(a2);
        } }) })]));
      }
      return h("div", { class: "q-date__view q-date__years flex flex-center" }, [h("div", { class: "col-auto" }, [h(QBtn, { round: true, dense: true, flat: true, icon: N.value[0], tabindex: r.value, disable: n2(e2), ...i("y-", { onClick: () => {
        T.value -= yearsInterval;
      } }) })]), h("div", { class: "q-date__years-content col self-stretch row items-center" }, o2), h("div", { class: "col-auto" }, [h(QBtn, { round: true, dense: true, flat: true, icon: N.value[1], tabindex: r.value, disable: n2(t2), ...i("y+", { onClick: () => {
        T.value += yearsInterval;
      } }) })])]);
    } };
    function Qe(t2) {
      const n2 = { ...w.value, day: t2 };
      if (e.range !== false)
        if (P.value === null) {
          const e2 = ae.value.find((e3) => e3.fill !== true && e3.i === t2);
          if (e2.range !== void 0)
            return void Te({ target: n2, from: e2.range.from, to: e2.range.to });
          if (e2.selected === true)
            return void Te(n2);
          const a2 = getDayHash(n2);
          P.value = { init: n2, initHash: a2, final: n2, finalHash: a2 }, o("range-start", Se(n2));
        } else {
          const e2 = P.value.initHash, t3 = getDayHash(n2), a2 = e2 <= t3 ? { from: P.value.init, to: n2 } : { from: n2, to: P.value.init };
          P.value = null, qe(e2 === t3 ? n2 : { target: n2, ...a2 }), o("range-end", { from: Se(a2.from), to: Se(a2.to) });
        }
      else
        ye(n2, ee.value);
    }
    function Ee(e2) {
      if (P.value !== null) {
        const t2 = { ...w.value, day: e2 };
        Object.assign(P.value, { final: t2, finalHash: getDayHash(t2) });
      }
    }
    return () => {
      const o2 = [h("div", { class: "q-date__content col relative-position" }, [h(Transition, { name: "q-transition--fade" }, Be[x.value])])], n2 = hSlot(t.default);
      return n2 !== void 0 && o2.push(h("div", { class: "q-date__actions" }, n2)), e.name !== void 0 && e.disable !== true && v(o2, "push"), h("div", { class: $.value, ...le.value }, [$e(), h("div", { ref: m, class: "q-date__main col column", tabindex: -1 }, o2)]);
    };
  } });
  function useHistory(e, t, o) {
    let n;
    function a() {
      n !== void 0 && (History.remove(n), n = void 0);
    }
    return onBeforeUnmount2(() => {
      e.value === true && a();
    }), { removeFromHistory: a, addToHistory() {
      n = { condition: () => o.value === true, handler: t }, History.add(n);
    } };
  }
  var scrollPositionX;
  var scrollPositionY;
  var maxScrollTop;
  var bodyLeft;
  var bodyTop;
  var closeTimer;
  var registered = 0;
  var vpPendingUpdate = false;
  function onWheel(e) {
    shouldPreventScroll(e) && stopAndPrevent(e);
  }
  function shouldPreventScroll(e) {
    if (e.target === document.body || e.target.classList.contains("q-layout__backdrop"))
      return true;
    const t = getEventPath(e), o = e.shiftKey && !e.deltaX, n = !o && Math.abs(e.deltaX) <= Math.abs(e.deltaY), a = o || n ? e.deltaY : e.deltaX;
    for (let l = 0; l < t.length; l++) {
      const e2 = t[l];
      if (hasScrollbar(e2, n))
        return n ? a < 0 && e2.scrollTop === 0 || a > 0 && e2.scrollTop + e2.clientHeight === e2.scrollHeight : a < 0 && e2.scrollLeft === 0 || a > 0 && e2.scrollLeft + e2.clientWidth === e2.scrollWidth;
    }
    return true;
  }
  function onAppleScroll(e) {
    e.target === document && (document.scrollingElement.scrollTop = document.scrollingElement.scrollTop);
  }
  function onAppleResize(e) {
    vpPendingUpdate !== true && (vpPendingUpdate = true, requestAnimationFrame(() => {
      vpPendingUpdate = false;
      const { height: t } = e.target, { clientHeight: o, scrollTop: n } = document.scrollingElement;
      maxScrollTop !== void 0 && t === window.innerHeight || (maxScrollTop = o - t, document.scrollingElement.scrollTop = n), n > maxScrollTop && (document.scrollingElement.scrollTop -= Math.ceil((n - maxScrollTop) / 8));
    }));
  }
  function apply$1(e) {
    const t = document.body, o = window.visualViewport !== void 0;
    if (e === "add") {
      const { overflowY: e2, overflowX: n } = window.getComputedStyle(t);
      scrollPositionX = getHorizontalScrollPosition(window), scrollPositionY = getVerticalScrollPosition(window), bodyLeft = t.style.left, bodyTop = t.style.top, t.style.left = `-${scrollPositionX}px`, t.style.top = `-${scrollPositionY}px`, n !== "hidden" && (n === "scroll" || t.scrollWidth > window.innerWidth) && t.classList.add("q-body--force-scrollbar-x"), e2 !== "hidden" && (e2 === "scroll" || t.scrollHeight > window.innerHeight) && t.classList.add("q-body--force-scrollbar-y"), t.classList.add("q-body--prevent-scroll"), document.qScrollPrevented = true, client2.is.ios === true && (o === true ? (window.scrollTo(0, 0), window.visualViewport.addEventListener("resize", onAppleResize, listenOpts.passiveCapture), window.visualViewport.addEventListener("scroll", onAppleResize, listenOpts.passiveCapture), window.scrollTo(0, 0)) : window.addEventListener("scroll", onAppleScroll, listenOpts.passiveCapture));
    }
    client2.is.desktop === true && client2.is.mac === true && window[`${e}EventListener`]("wheel", onWheel, listenOpts.notPassive), e === "remove" && (client2.is.ios === true && (o === true ? (window.visualViewport.removeEventListener("resize", onAppleResize, listenOpts.passiveCapture), window.visualViewport.removeEventListener("scroll", onAppleResize, listenOpts.passiveCapture)) : window.removeEventListener("scroll", onAppleScroll, listenOpts.passiveCapture)), t.classList.remove("q-body--prevent-scroll"), t.classList.remove("q-body--force-scrollbar-x"), t.classList.remove("q-body--force-scrollbar-y"), document.qScrollPrevented = false, t.style.left = bodyLeft, t.style.top = bodyTop, window.scrollTo(scrollPositionX, scrollPositionY), maxScrollTop = void 0);
  }
  function preventScroll(e) {
    let t = "add";
    if (e === true) {
      if (registered++, closeTimer !== void 0)
        return clearTimeout(closeTimer), void (closeTimer = void 0);
      if (registered > 1)
        return;
    } else {
      if (registered === 0)
        return;
      if (registered--, registered > 0)
        return;
      if (t = "remove", client2.is.ios === true && client2.is.nativeMobile === true)
        return clearTimeout(closeTimer), void (closeTimer = setTimeout(() => {
          apply$1(t), closeTimer = void 0;
        }, 100));
    }
    apply$1(t);
  }
  function usePreventScroll() {
    let e;
    return { preventBodyScroll(t) {
      t === e || e === void 0 && t !== true || (e = t, preventScroll(t));
    } };
  }
  var maximizedModals = 0;
  var positionClass$1 = { standard: "fixed-full flex-center", top: "fixed-top justify-center", bottom: "fixed-bottom justify-center", right: "fixed-right items-center", left: "fixed-left items-center" };
  var transitions = { standard: ["scale", "scale"], top: ["slide-down", "slide-up"], bottom: ["slide-up", "slide-down"], right: ["slide-left", "slide-right"], left: ["slide-right", "slide-left"] };
  var QDialog = defineComponent2({ name: "QDialog", inheritAttrs: false, props: { ...useModelToggleProps, ...useTransitionProps, transitionShow: String, transitionHide: String, persistent: Boolean, autoClose: Boolean, noEscDismiss: Boolean, noBackdropDismiss: Boolean, noRouteDismiss: Boolean, noRefocus: Boolean, noFocus: Boolean, seamless: Boolean, maximized: Boolean, fullWidth: Boolean, fullHeight: Boolean, square: Boolean, position: { type: String, default: "standard", validator: (e) => e === "standard" || ["top", "bottom", "left", "right"].includes(e) } }, emits: [...useModelToggleEmits, "shake", "click", "escape-key"], setup(e, { slots: t, emit: o, attrs: n }) {
    const a = getCurrentInstance(), l = ref(null), i = ref(false), r = ref(false), s2 = ref(false);
    let u, c, d, p2 = null;
    const v = computed2(() => e.persistent !== true && e.noRouteDismiss !== true && e.seamless !== true), { preventBodyScroll: m } = usePreventScroll(), { registerTimeout: f, removeTimeout: g } = useTimeout(), { registerTick: b, removeTick: y, prepareTick: S } = useTick(), { showPortal: w, hidePortal: x, portalIsActive: C, renderPortal: k2 } = usePortal(a, l, j, true), { hide: _ } = useModelToggle({ showing: i, hideOnRouteChange: v, handleShow: z, handleHide: F, processOnMount: true }), { addToHistory: q, removeFromHistory: T } = useHistory(i, _, v), P = computed2(() => `q-dialog__inner flex no-pointer-events q-dialog__inner--${e.maximized === true ? "maximized" : "minimized"} q-dialog__inner--${e.position} ${positionClass$1[e.position]}` + (s2.value === true ? " q-dialog__inner--animating" : "") + (e.fullWidth === true ? " q-dialog__inner--fullwidth" : "") + (e.fullHeight === true ? " q-dialog__inner--fullheight" : "") + (e.square === true ? " q-dialog__inner--square" : "")), $ = computed2(() => "q-transition--" + (e.transitionShow === void 0 ? transitions[e.position][0] : e.transitionShow)), M = computed2(() => "q-transition--" + (e.transitionHide === void 0 ? transitions[e.position][1] : e.transitionHide)), B = computed2(() => r.value === true ? M.value : $.value), Q = computed2(() => i.value === true && e.seamless !== true), E = computed2(() => e.autoClose === true ? { onClick: D } : {}), O = computed2(() => [`q-dialog fullscreen no-pointer-events q-dialog--${Q.value === true ? "modal" : "seamless"}`, n.class]);
    function z(t2) {
      g(), y(), q(), p2 = e.noRefocus === false && document.activeElement !== null ? document.activeElement : null, A(e.maximized), w(), s2.value = true, e.noFocus !== true && (document.activeElement !== null && document.activeElement.blur(), b(L), S()), f(() => {
        if (a.proxy.$q.platform.is.ios === true) {
          if (e.seamless !== true && document.activeElement) {
            const { top: e2, bottom: t3 } = document.activeElement.getBoundingClientRect(), { innerHeight: o2 } = window, n2 = window.visualViewport !== void 0 ? window.visualViewport.height : o2;
            e2 > 0 && t3 > n2 / 2 && (document.scrollingElement.scrollTop = Math.min(document.scrollingElement.scrollHeight - n2, t3 >= o2 ? 1 / 0 : Math.ceil(document.scrollingElement.scrollTop + t3 - n2 / 2))), document.activeElement.scrollIntoView();
          }
          d = true, l.value.click(), d = false;
        }
        w(true), s2.value = false, o("show", t2);
      }, e.transitionDuration);
    }
    function F(t2) {
      g(), y(), T(), I(true), s2.value = true, p2 !== null && p2.focus(), f(() => {
        x(), s2.value = false, o("hide", t2);
      }, e.transitionDuration);
    }
    function L() {
      addFocusFn(() => {
        let e2 = l.value;
        e2 !== null && e2.contains(document.activeElement) !== true && (e2 = e2.querySelector("[autofocus], [data-autofocus]") || e2, e2.focus());
      });
    }
    function R() {
      L(), o("shake");
      const e2 = l.value;
      e2 !== null && (e2.classList.remove("q-animate--scale"), e2.classList.add("q-animate--scale"), clearTimeout(u), u = setTimeout(() => {
        l.value !== null && (e2.classList.remove("q-animate--scale"), L());
      }, 170));
    }
    function V() {
      e.seamless !== true && (e.persistent === true || e.noEscDismiss === true ? e.maximized !== true && R() : (o("escape-key"), _()));
    }
    function I(t2) {
      clearTimeout(u), t2 !== true && i.value !== true || (A(false), e.seamless !== true && (m(false), removeFocusout(H), removeEscapeKey(V)));
    }
    function A(e2) {
      e2 === true ? c !== true && (maximizedModals < 1 && document.body.classList.add("q-body--dialog"), maximizedModals++, c = true) : c === true && (maximizedModals < 2 && document.body.classList.remove("q-body--dialog"), maximizedModals--, c = false);
    }
    function D(e2) {
      d !== true && (_(e2), o("click", e2));
    }
    function N(t2) {
      e.persistent !== true && e.noBackdropDismiss !== true ? _(t2) : R();
    }
    function H(e2) {
      i.value === true && C.value === true && childHasFocus(l.value, e2.target) !== true && L();
    }
    function j() {
      return h("div", { ...n, class: O.value }, [h(Transition, { name: "q-transition--fade", appear: true }, () => Q.value === true ? h("div", { class: "q-dialog__backdrop fixed-full", "aria-hidden": "true", onMousedown: N }) : null), h(Transition, { name: B.value, appear: true }, () => i.value === true ? h("div", { ref: l, class: P.value, tabindex: -1, ...E.value }, hSlot(t.default)) : null)]);
    }
    return watch(i, (e2) => {
      nextTick2(() => {
        r.value = e2;
      });
    }), watch(() => e.maximized, (e2) => {
      i.value === true && A(e2);
    }), watch(Q, (e2) => {
      m(e2), e2 === true ? (addFocusout(H), addEscapeKey(V)) : (removeFocusout(H), removeEscapeKey(V));
    }), Object.assign(a.proxy, { focus: L, shake: R, __updateRefocusTarget(e2) {
      p2 = e2 || null;
    } }), onBeforeUnmount2(() => {
      I();
    }), k2;
  } });
  var duration = 150;
  var QDrawer = defineComponent2({ name: "QDrawer", inheritAttrs: false, props: { ...useModelToggleProps, ...useDarkProps, side: { type: String, default: "left", validator: (e) => ["left", "right"].includes(e) }, width: { type: Number, default: 300 }, mini: Boolean, miniToOverlay: Boolean, miniWidth: { type: Number, default: 57 }, breakpoint: { type: Number, default: 1023 }, showIfAbove: Boolean, behavior: { type: String, validator: (e) => ["default", "desktop", "mobile"].includes(e), default: "default" }, bordered: Boolean, elevated: Boolean, overlay: Boolean, persistent: Boolean, noSwipeOpen: Boolean, noSwipeClose: Boolean, noSwipeBackdrop: Boolean }, emits: [...useModelToggleEmits, "on-layout", "mini-state"], setup(e, { slots: t, emit: o, attrs: n }) {
    const a = getCurrentInstance(), { proxy: { $q: l } } = a, i = useDark(e, l), { preventBodyScroll: r } = usePreventScroll(), { registerTimeout: s2 } = useTimeout(), u = inject2(layoutKey, () => {
      console.error("QDrawer needs to be child of QLayout");
    });
    let c, d, p2;
    const v = ref(e.behavior === "mobile" || e.behavior !== "desktop" && u.totalWidth.value <= e.breakpoint), m = computed2(() => e.mini === true && v.value !== true), f = computed2(() => m.value === true ? e.miniWidth : e.width), g = ref(e.showIfAbove === true && v.value === false || e.modelValue === true), b = computed2(() => e.persistent !== true && (v.value === true || F.value === true));
    function y(e2, t2) {
      if (C(), e2 !== false && u.animate(), W(0), v.value === true) {
        const e3 = u.instances[Q.value];
        e3 !== void 0 && e3.belowBreakpoint === true && e3.hide(false), G(1), u.isContainer.value !== true && r(true);
      } else
        G(0), e2 !== false && X(false);
      s2(() => {
        e2 !== false && X(true), t2 !== true && o("show", e2);
      }, duration);
    }
    function S(e2, t2) {
      k2(), e2 !== false && u.animate(), G(0), W(T.value * f.value), te(), t2 !== true && s2(() => {
        o("hide", e2);
      }, duration);
    }
    const { show: w, hide: x } = useModelToggle({ showing: g, hideOnRouteChange: b, handleShow: y, handleHide: S }), { addToHistory: C, removeFromHistory: k2 } = useHistory(g, x, b), _ = { belowBreakpoint: v, hide: x }, q = computed2(() => e.side === "right"), T = computed2(() => (l.lang.rtl === true ? -1 : 1) * (q.value === true ? 1 : -1)), P = ref(0), $ = ref(false), M = ref(false), B = ref(f.value * T.value), Q = computed2(() => q.value === true ? "left" : "right"), E = computed2(() => g.value === true && v.value === false && e.overlay === false ? e.miniToOverlay === true ? e.miniWidth : f.value : 0), O = computed2(() => e.overlay === true || e.miniToOverlay === true || u.view.value.indexOf(q.value ? "R" : "L") > -1 || l.platform.is.ios === true && u.isContainer.value === true), z = computed2(() => e.overlay === false && g.value === true && v.value === false), F = computed2(() => e.overlay === true && g.value === true && v.value === false), L = computed2(() => "fullscreen q-drawer__backdrop" + (g.value === false && $.value === false ? " hidden" : "")), R = computed2(() => ({ backgroundColor: `rgba(0,0,0,${0.4 * P.value})` })), V = computed2(() => q.value === true ? u.rows.value.top[2] === "r" : u.rows.value.top[0] === "l"), I = computed2(() => q.value === true ? u.rows.value.bottom[2] === "r" : u.rows.value.bottom[0] === "l"), A = computed2(() => {
      const e2 = {};
      return u.header.space === true && V.value === false && (O.value === true ? e2.top = `${u.header.offset}px` : u.header.space === true && (e2.top = `${u.header.size}px`)), u.footer.space === true && I.value === false && (O.value === true ? e2.bottom = `${u.footer.offset}px` : u.footer.space === true && (e2.bottom = `${u.footer.size}px`)), e2;
    }), D = computed2(() => {
      const e2 = { width: `${f.value}px`, transform: `translateX(${B.value}px)` };
      return v.value === true ? e2 : Object.assign(e2, A.value);
    }), N = computed2(() => "q-drawer__content fit " + (u.isContainer.value !== true ? "scroll" : "overflow-auto")), H = computed2(() => `q-drawer q-drawer--${e.side}` + (M.value === true ? " q-drawer--mini-animate" : "") + (e.bordered === true ? " q-drawer--bordered" : "") + (i.value === true ? " q-drawer--dark q-dark" : "") + ($.value === true ? " no-transition" : g.value === true ? "" : " q-layout--prevent-focus") + (v.value === true ? " fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding" : ` q-drawer--${m.value === true ? "mini" : "standard"}` + (O.value === true || z.value !== true ? " fixed" : "") + (e.overlay === true || e.miniToOverlay === true ? " q-drawer--on-top" : "") + (V.value === true ? " q-drawer--top-padding" : ""))), j = computed2(() => {
      const t2 = l.lang.rtl === true ? e.side : Q.value;
      return [[TouchPan, J, void 0, { [t2]: true, mouse: true }]];
    }), U = computed2(() => {
      const t2 = l.lang.rtl === true ? Q.value : e.side;
      return [[TouchPan, ee, void 0, { [t2]: true, mouse: true }]];
    }), K = computed2(() => {
      const t2 = l.lang.rtl === true ? Q.value : e.side;
      return [[TouchPan, ee, void 0, { [t2]: true, mouse: true, mouseAllDir: true }]];
    });
    function W(e2) {
      e2 === void 0 ? nextTick2(() => {
        e2 = g.value === true ? 0 : f.value, W(T.value * e2);
      }) : (u.isContainer.value !== true || q.value !== true || v.value !== true && Math.abs(e2) !== f.value || (e2 += T.value * u.scrollbarWidth.value), B.value = e2);
    }
    function Y() {
      ne(v, e.behavior === "mobile" || e.behavior !== "desktop" && u.totalWidth.value <= e.breakpoint);
    }
    function G(e2) {
      P.value = e2;
    }
    function X(e2) {
      const t2 = e2 === true ? "remove" : u.isContainer.value !== true ? "add" : "";
      t2 !== "" && document.body.classList[t2]("q-body--drawer-toggle");
    }
    function Z() {
      clearTimeout(d), a.proxy && a.proxy.$el && a.proxy.$el.classList.add("q-drawer--mini-animate"), M.value = true, d = setTimeout(() => {
        M.value = false;
      }, 150);
    }
    function J(e2) {
      if (g.value !== false)
        return;
      const t2 = f.value, o2 = between(e2.distance.x, 0, t2);
      if (e2.isFinal === true) {
        const e3 = o2 >= Math.min(75, t2);
        return e3 === true ? w() : (u.animate(), G(0), W(T.value * t2)), void ($.value = false);
      }
      W((l.lang.rtl === true ? q.value !== true : q.value) ? Math.max(t2 - o2, 0) : Math.min(0, o2 - t2)), G(between(o2 / t2, 0, 1)), e2.isFirst === true && ($.value = true);
    }
    function ee(t2) {
      if (g.value !== true)
        return;
      const o2 = f.value, n2 = t2.direction === e.side, a2 = (l.lang.rtl === true ? n2 !== true : n2) ? between(t2.distance.x, 0, o2) : 0;
      if (t2.isFinal === true) {
        const e2 = Math.abs(a2) < Math.min(75, o2);
        return e2 === true ? (u.animate(), G(1), W(0)) : x(), void ($.value = false);
      }
      W(T.value * a2), G(between(1 - a2 / o2, 0, 1)), t2.isFirst === true && ($.value = true);
    }
    function te() {
      r(false), X(true);
    }
    function oe(t2, o2) {
      u.update(e.side, t2, o2);
    }
    function ne(e2, t2) {
      e2.value !== t2 && (e2.value = t2);
    }
    function ae(t2, o2) {
      oe("size", t2 === true ? e.miniWidth : o2);
    }
    return watch(v, (t2) => {
      t2 === true ? (c = g.value, g.value === true && x(false)) : e.overlay === false && e.behavior !== "mobile" && c !== false && (g.value === true ? (W(0), G(0), te()) : w(false));
    }), watch(u.totalWidth, (t2) => {
      ne(v, e.behavior === "mobile" || e.behavior !== "desktop" && t2 <= e.breakpoint);
    }), watch(() => e.side, (e2, t2) => {
      u.instances[t2] === _ && (u.instances[t2] = void 0, u[t2].space = false, u[t2].offset = 0), u.instances[e2] = _, u[e2].size = f.value, u[e2].space = z.value, u[e2].offset = E.value;
    }), watch(() => e.behavior + e.breakpoint, Y), watch(u.isContainer, (e2) => {
      g.value === true && r(e2 !== true);
    }), watch(u.scrollbarWidth, () => {
      W(g.value === true ? 0 : void 0);
    }), watch(E, (e2) => {
      oe("offset", e2);
    }), watch(z, (e2) => {
      o("on-layout", e2), oe("space", e2);
    }), watch(q, () => {
      W();
    }), watch(f, (t2) => {
      W(), ae(e.miniToOverlay, t2);
    }), watch(() => e.miniToOverlay, (e2) => {
      ae(e2, f.value);
    }), watch(() => l.lang.rtl, () => {
      W();
    }), watch(() => e.mini, () => {
      e.modelValue === true && (Z(), u.animate());
    }), watch(m, (e2) => {
      o("mini-state", e2);
    }), u.instances[e.side] = _, ae(e.miniToOverlay, f.value), oe("space", z.value), oe("offset", E.value), e.showIfAbove === true && e.modelValue !== true && g.value === true && e["onUpdate:modelValue"] !== void 0 && o("update:modelValue", true), onMounted2(() => {
      o("on-layout", z.value), o("mini-state", m.value), c = e.showIfAbove === true;
      const t2 = () => {
        const e2 = g.value === true ? y : S;
        e2(false, true);
      };
      u.totalWidth.value === 0 ? p2 = watch(u.totalWidth, () => {
        p2(), p2 = void 0, g.value === false && e.showIfAbove === true && v.value === false ? w(false) : t2();
      }) : nextTick2(t2);
    }), onBeforeUnmount2(() => {
      p2 !== void 0 && p2(), clearTimeout(d), g.value === true && te(), u.instances[e.side] === _ && (u.instances[e.side] = void 0, oe("size", 0), oe("offset", 0), oe("space", false));
    }), () => {
      const o2 = [];
      v.value === true && (e.noSwipeOpen === false && o2.push(withDirectives(h("div", { key: "open", class: `q-drawer__opener fixed-${e.side}`, "aria-hidden": "true" }), j.value)), o2.push(hDir("div", { ref: "backdrop", class: L.value, style: R.value, "aria-hidden": "true", onClick: x }, void 0, "backdrop", e.noSwipeBackdrop !== true && g.value === true, () => K.value)));
      const a2 = m.value === true && t.mini !== void 0, l2 = [h("div", { ...n, key: "" + a2, class: [N.value, n.class] }, a2 === true ? t.mini() : hSlot(t.default))];
      return e.elevated === true && g.value === true && l2.push(h("div", { class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events" })), o2.push(hDir("aside", { ref: "content", class: H.value, style: D.value }, l2, "contentclose", e.noSwipeClose !== true && v.value === true, () => U.value)), h("div", { class: "q-drawer-container" }, o2);
    };
  } });
  function getBlockElement(e, t) {
    if (t && e === t)
      return null;
    const o = e.nodeName.toLowerCase();
    if (["div", "li", "ul", "ol", "blockquote"].includes(o) === true)
      return e;
    const n = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, a = n.display;
    return a === "block" || a === "table" ? e : getBlockElement(e.parentNode);
  }
  function isChildOf(e, t, o) {
    return !(!e || e === document.body) && (o === true && e === t || (t === document ? document.body : t).contains(e.parentNode));
  }
  function createRange(e, t, o) {
    if (o || (o = document.createRange(), o.selectNode(e), o.setStart(e, 0)), t.count === 0)
      o.setEnd(e, t.count);
    else if (t.count > 0)
      if (e.nodeType === Node.TEXT_NODE)
        e.textContent.length < t.count ? t.count -= e.textContent.length : (o.setEnd(e, t.count), t.count = 0);
      else
        for (let n = 0; t.count !== 0 && n < e.childNodes.length; n++)
          o = createRange(e.childNodes[n], t, o);
    return o;
  }
  var urlRegex = /^https?:\/\//;
  var Caret = class {
    constructor(e, t) {
      this.el = e, this.eVm = t, this._range = null;
    }
    get selection() {
      if (this.el) {
        const e = document.getSelection();
        if (isChildOf(e.anchorNode, this.el, true) && isChildOf(e.focusNode, this.el, true))
          return e;
      }
      return null;
    }
    get hasSelection() {
      return this.selection !== null && this.selection.toString().length > 0;
    }
    get range() {
      const e = this.selection;
      return e !== null && e.rangeCount ? e.getRangeAt(0) : this._range;
    }
    get parent() {
      const e = this.range;
      if (e !== null) {
        const t = e.startContainer;
        return t.nodeType === document.ELEMENT_NODE ? t : t.parentNode;
      }
      return null;
    }
    get blockParent() {
      const e = this.parent;
      return e !== null ? getBlockElement(e, this.el) : null;
    }
    save(e = this.range) {
      e !== null && (this._range = e);
    }
    restore(e = this._range) {
      const t = document.createRange(), o = document.getSelection();
      e !== null ? (t.setStart(e.startContainer, e.startOffset), t.setEnd(e.endContainer, e.endOffset), o.removeAllRanges(), o.addRange(t)) : (o.selectAllChildren(this.el), o.collapseToEnd());
    }
    savePosition() {
      let e, t = -1;
      const o = document.getSelection(), n = this.el.parentNode;
      if (o.focusNode && isChildOf(o.focusNode, n)) {
        e = o.focusNode, t = o.focusOffset;
        while (e && e !== n)
          e !== this.el && e.previousSibling ? (e = e.previousSibling, t += e.textContent.length) : e = e.parentNode;
      }
      this.savedPos = t;
    }
    restorePosition(e = 0) {
      if (this.savedPos > 0 && this.savedPos < e) {
        const e2 = window.getSelection(), t = createRange(this.el, { count: this.savedPos });
        t && (t.collapse(false), e2.removeAllRanges(), e2.addRange(t));
      }
    }
    hasParent(e, t) {
      const o = t ? this.parent : this.blockParent;
      return o !== null && o.nodeName.toLowerCase() === e.toLowerCase();
    }
    hasParents(e, t, o = this.parent) {
      return o !== null && (o !== null && e.includes(o.nodeName.toLowerCase()) === true || t === true && this.hasParents(e, t, o.parentNode));
    }
    is(e, t) {
      if (this.selection === null)
        return false;
      switch (e) {
        case "formatBlock":
          return t === "DIV" && this.parent === this.el || this.hasParent(t, t === "PRE");
        case "link":
          return this.hasParent("A", true);
        case "fontSize":
          return document.queryCommandValue(e) === t;
        case "fontName":
          const o = document.queryCommandValue(e);
          return o === `"${t}"` || o === t;
        case "fullscreen":
          return this.eVm.inFullscreen.value;
        case "viewsource":
          return this.eVm.isViewingSource.value;
        case void 0:
          return false;
        default:
          const n = document.queryCommandState(e);
          return t !== void 0 ? n === t : n;
      }
    }
    getParentAttribute(e) {
      return this.parent !== null ? this.parent.getAttribute(e) : null;
    }
    can(e) {
      return e === "outdent" ? this.hasParents(["blockquote", "li"], true) : e === "indent" ? this.hasParents(["li"], true) : e === "link" ? this.selection !== null || this.is("link") : void 0;
    }
    apply(e, t, o = noop) {
      if (e === "formatBlock")
        ["BLOCKQUOTE", "H1", "H2", "H3", "H4", "H5", "H6"].includes(t) && this.is(e, t) && (e = "outdent", t = null), t === "PRE" && this.is(e, "PRE") && (t = "P");
      else {
        if (e === "print") {
          o();
          const e2 = window.open();
          return e2.document.write(`
        <!doctype html>
        <html>
          <head>
            <title>Print - ${document.title}</title>
          </head>
          <body>
            <div>${this.el.innerHTML}</div>
          </body>
        </html>
      `), e2.print(), void e2.close();
        }
        if (e === "link") {
          const e2 = this.getParentAttribute("href");
          if (e2 === null) {
            const e3 = this.selectWord(this.selection), t2 = e3 ? e3.toString() : "";
            if (!t2.length && (!this.range || !this.range.cloneContents().querySelector("img")))
              return;
            this.eVm.editLinkUrl.value = urlRegex.test(t2) ? t2 : "https://", document.execCommand("createLink", false, this.eVm.editLinkUrl.value), this.save(e3.getRangeAt(0));
          } else
            this.eVm.editLinkUrl.value = e2, this.range.selectNodeContents(this.parent), this.save();
          return;
        }
        if (e === "fullscreen")
          return this.eVm.toggleFullscreen(), void o();
        if (e === "viewsource")
          return this.eVm.isViewingSource.value = this.eVm.isViewingSource.value === false, this.eVm.setContent(this.eVm.props.modelValue), void o();
      }
      document.execCommand(e, false, t), o();
    }
    selectWord(e) {
      if (e === null || e.isCollapsed !== true || e.modify === void 0)
        return e;
      const t = document.createRange();
      t.setStart(e.anchorNode, e.anchorOffset), t.setEnd(e.focusNode, e.focusOffset);
      const o = t.collapsed ? ["backward", "forward"] : ["forward", "backward"];
      t.detach();
      const n = e.focusNode, a = e.focusOffset;
      return e.collapse(e.anchorNode, e.anchorOffset), e.modify("move", o[0], "character"), e.modify("move", o[1], "word"), e.extend(n, a), e.modify("extend", o[1], "character"), e.modify("extend", o[0], "word"), e;
    }
  };
  var QTooltip = defineComponent2({ name: "QTooltip", inheritAttrs: false, props: { ...useAnchorProps, ...useModelToggleProps, ...useTransitionProps, maxHeight: { type: String, default: null }, maxWidth: { type: String, default: null }, transitionShow: { default: "jump-down" }, transitionHide: { default: "jump-up" }, anchor: { type: String, default: "bottom middle", validator: validatePosition }, self: { type: String, default: "top middle", validator: validatePosition }, offset: { type: Array, default: () => [14, 14], validator: validateOffset }, scrollTarget: { default: void 0 }, delay: { type: Number, default: 0 }, hideDelay: { type: Number, default: 0 } }, emits: [...useModelToggleEmits], setup(e, { slots: t, emit: o, attrs: n }) {
    let a, l;
    const i = getCurrentInstance(), { proxy: { $q: r } } = i, s2 = ref(null), u = ref(false), c = computed2(() => parsePosition(e.anchor, r.lang.rtl)), d = computed2(() => parsePosition(e.self, r.lang.rtl)), p2 = computed2(() => e.persistent !== true), { registerTick: v, removeTick: m, prepareTick: f } = useTick(), { registerTimeout: g, removeTimeout: b } = useTimeout(), { transition: y, transitionStyle: S } = useTransition(e, u), { localScrollTarget: w, changeScrollEvent: x, unconfigureScrollTarget: C } = useScrollTarget(e, V), { anchorEl: k2, canShow: _, anchorEvents: q } = useAnchor({ showing: u, configureAnchorEl: R }), { show: T, hide: P } = useModelToggle({ showing: u, canShow: _, handleShow: Q, handleHide: E, hideOnRouteChange: p2, processOnMount: true });
    Object.assign(q, { delayShow: F, delayHide: L });
    const { showPortal: $, hidePortal: M, renderPortal: B } = usePortal(i, s2, A);
    if (r.platform.is.mobile === true) {
      const t2 = { anchorEl: k2, innerRef: s2, onClickOutside(e2) {
        return P(e2), e2.target.classList.contains("q-dialog__backdrop") && stopAndPrevent(e2), true;
      } }, o2 = computed2(() => e.modelValue === null && e.persistent !== true && u.value === true);
      watch(o2, (e2) => {
        const o3 = e2 === true ? addClickOutside : removeClickOutside;
        o3(t2);
      }), onBeforeUnmount2(() => {
        removeClickOutside(t2);
      });
    }
    function Q(t2) {
      m(), b(), $(), v(() => {
        l = new MutationObserver(() => z()), l.observe(s2.value, { attributes: false, childList: true, characterData: true, subtree: true }), z(), V();
      }), f(), a === void 0 && (a = watch(() => r.screen.width + "|" + r.screen.height + "|" + e.self + "|" + e.anchor + "|" + r.lang.rtl, z)), g(() => {
        $(true), o("show", t2);
      }, e.transitionDuration);
    }
    function E(t2) {
      m(), b(), O(), g(() => {
        M(), o("hide", t2);
      }, e.transitionDuration);
    }
    function O() {
      l !== void 0 && (l.disconnect(), l = void 0), a !== void 0 && (a(), a = void 0), C(), cleanEvt(q, "tooltipTemp");
    }
    function z() {
      const t2 = s2.value;
      k2.value !== void 0 && t2 && setPosition({ el: t2, offset: e.offset, anchorEl: k2.value, anchorOrigin: c.value, selfOrigin: d.value, maxHeight: e.maxHeight, maxWidth: e.maxWidth });
    }
    function F(t2) {
      if (r.platform.is.mobile === true) {
        clearSelection(), document.body.classList.add("non-selectable");
        const e2 = k2.value, t3 = ["touchmove", "touchcancel", "touchend", "click"].map((t4) => [e2, t4, "__delayHide", "passiveCapture"]);
        addEvt(q, "tooltipTemp", t3);
      }
      g(() => {
        T(t2);
      }, e.delay);
    }
    function L(t2) {
      b(), r.platform.is.mobile === true && (cleanEvt(q, "tooltipTemp"), clearSelection(), setTimeout(() => {
        document.body.classList.remove("non-selectable");
      }, 10)), g(() => {
        P(t2);
      }, e.hideDelay);
    }
    function R() {
      if (e.noParentEvent === true || k2.value === void 0)
        return;
      const t2 = r.platform.is.mobile === true ? [[k2.value, "touchstart", "delayShow", "passive"]] : [[k2.value, "mouseenter", "delayShow", "passive"], [k2.value, "mouseleave", "delayHide", "passive"]];
      addEvt(q, "anchor", t2);
    }
    function V() {
      if (k2.value !== void 0 || e.scrollTarget !== void 0) {
        w.value = getScrollTarget(k2.value, e.scrollTarget);
        const t2 = e.noParentEvent === true ? z : P;
        x(w.value, t2);
      }
    }
    function I() {
      return u.value === true ? h("div", { ...n, ref: s2, class: ["q-tooltip q-tooltip--style q-position-engine no-pointer-events", n.class], style: S.value, role: "complementary" }, hSlot(t.default)) : null;
    }
    function A() {
      return h(Transition, { name: y.value, appear: true }, I);
    }
    return onBeforeUnmount2(O), Object.assign(i.proxy, { updatePosition: z }), B;
  } });
  var QItem = defineComponent2({ name: "QItem", props: { ...useDarkProps, ...useRouterLinkProps, tag: { type: String, default: "div" }, active: Boolean, clickable: Boolean, dense: Boolean, insetLevel: Number, tabindex: [String, Number], focused: Boolean, manualFocus: Boolean }, emits: ["click", "keyup"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useDark(e, n), { hasLink: l, linkProps: i, linkClass: r, linkTag: s2, navigateToLink: u } = useRouterLink(), c = ref(null), d = ref(null), p2 = computed2(() => e.clickable === true || l.value === true || e.tag === "a" || e.tag === "label"), v = computed2(() => e.disable !== true && p2.value === true), m = computed2(() => "q-item q-item-type row no-wrap" + (e.dense === true ? " q-item--dense" : "") + (a.value === true ? " q-item--dark" : "") + (l.value === true ? r.value : e.active === true ? `${e.activeClass !== void 0 ? ` ${e.activeClass}` : ""} q-item--active` : "") + (e.disable === true ? " disabled" : "") + (v.value === true ? " q-item--clickable q-link cursor-pointer " + (e.manualFocus === true ? "q-manual-focusable" : "q-focusable q-hoverable") + (e.focused === true ? " q-manual-focusable--focused" : "") : "")), f = computed2(() => {
      if (e.insetLevel === void 0)
        return null;
      const t2 = n.lang.rtl === true ? "Right" : "Left";
      return { ["padding" + t2]: 16 + 56 * e.insetLevel + "px" };
    });
    function g(e2) {
      v.value === true && (d.value !== null && (e2.qKeyEvent !== true && document.activeElement === c.value ? d.value.focus() : document.activeElement === d.value && c.value.focus()), l.value === true && u(e2), o("click", e2));
    }
    function b(e2) {
      if (v.value === true && isKeyCode(e2, 13) === true) {
        stopAndPrevent(e2), e2.qKeyEvent = true;
        const t2 = new MouseEvent("click", e2);
        t2.qKeyEvent = true, c.value.dispatchEvent(t2);
      }
      o("keyup", e2);
    }
    function y() {
      const e2 = hUniqueSlot(t.default, []);
      return v.value === true && e2.unshift(h("div", { class: "q-focus-helper", tabindex: -1, ref: d })), e2;
    }
    return () => {
      const t2 = { ref: c, class: m.value, style: f.value, onClick: g, onKeyup: b };
      return v.value === true ? (t2.tabindex = e.tabindex || "0", Object.assign(t2, i.value)) : p2.value === true && (t2["aria-disabled"] = "true"), h(s2.value, t2, y());
    };
  } });
  var QItemSection = defineComponent2({ name: "QItemSection", props: { avatar: Boolean, thumbnail: Boolean, side: Boolean, top: Boolean, noWrap: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => `q-item__section column q-item__section--${e.avatar === true || e.side === true || e.thumbnail === true ? "side" : "main"}` + (e.top === true ? " q-item__section--top justify-start" : " justify-center") + (e.avatar === true ? " q-item__section--avatar" : "") + (e.thumbnail === true ? " q-item__section--thumbnail" : "") + (e.noWrap === true ? " q-item__section--nowrap" : ""));
    return () => h("div", { class: o.value }, hSlot(t.default));
  } });
  function run(e, t, o) {
    t.handler ? t.handler(e, o, o.caret) : o.runCmd(t.cmd, t.param);
  }
  function getGroup(e) {
    return h("div", { class: "q-editor__toolbar-group" }, e);
  }
  function getBtn(e, t, o, n = false) {
    const a = n || t.type === "toggle" && (t.toggled ? t.toggled(e) : t.cmd && e.caret.is(t.cmd, t.param)), l = [];
    if (t.tip && e.$q.platform.is.desktop) {
      const e2 = t.key ? h("div", [h("small", `(CTRL + ${String.fromCharCode(t.key)})`)]) : null;
      l.push(h(QTooltip, { delay: 1e3 }, () => [h("div", { innerHTML: t.tip }), e2]));
    }
    return h(QBtn, { ...e.buttonProps.value, icon: t.icon !== null ? t.icon : void 0, color: a ? t.toggleColor || e.props.toolbarToggleColor : t.color || e.props.toolbarColor, textColor: a && !e.props.toolbarPush ? null : t.textColor || e.props.toolbarTextColor, label: t.label, disable: !!t.disable && (typeof t.disable !== "function" || t.disable(e)), size: "sm", onClick(n2) {
      o && o(), run(n2, t, e);
    } }, () => l);
  }
  function getDropdown(e, t) {
    const o = t.list === "only-icons";
    let n, a, l = t.label, i = t.icon !== null ? t.icon : void 0;
    function r() {
      u.component.proxy.hide();
    }
    if (o)
      a = t.options.map((t2) => {
        const o2 = t2.type === void 0 && e.caret.is(t2.cmd, t2.param);
        return o2 && (l = t2.tip, i = t2.icon !== null ? t2.icon : void 0), getBtn(e, t2, r, o2);
      }), n = e.toolbarBackgroundClass.value, a = [getGroup(a)];
    else {
      const o2 = e.props.toolbarToggleColor !== void 0 ? `text-${e.props.toolbarToggleColor}` : null, s3 = e.props.toolbarTextColor !== void 0 ? `text-${e.props.toolbarTextColor}` : null, u2 = t.list === "no-icons";
      a = t.options.map((t2) => {
        const n2 = !!t2.disable && t2.disable(e), a2 = t2.type === void 0 && e.caret.is(t2.cmd, t2.param);
        a2 && (l = t2.tip, i = t2.icon !== null ? t2.icon : void 0);
        const c = t2.htmlTip;
        return h(QItem, { active: a2, activeClass: o2, clickable: true, disable: n2, dense: true, onClick(o3) {
          r(), e.contentRef.value !== null && e.contentRef.value.focus(), e.caret.restore(), run(o3, t2, e);
        } }, () => [u2 === true ? null : h(QItemSection, { class: a2 ? o2 : s3, side: true }, () => h(QIcon, { name: t2.icon !== null ? t2.icon : void 0 })), h(QItemSection, c ? () => h("div", { class: "text-no-wrap", innerHTML: t2.htmlTip }) : t2.tip ? () => h("div", { class: "text-no-wrap" }, t2.tip) : void 0)]);
      }), n = [e.toolbarBackgroundClass.value, s3];
    }
    const s2 = t.highlight && l !== t.label, u = h(QBtnDropdown, { ...e.buttonProps.value, noCaps: true, noWrap: true, color: s2 ? e.props.toolbarToggleColor : e.props.toolbarColor, textColor: s2 && !e.props.toolbarPush ? null : e.props.toolbarTextColor, label: t.fixedLabel ? t.label : l, icon: t.fixedIcon ? t.icon !== null ? t.icon : void 0 : i, contentClass: n }, () => a);
    return u;
  }
  function getToolbar(e) {
    if (e.caret)
      return e.buttons.value.filter((t) => {
        return !e.isViewingSource.value || t.find((e2) => e2.cmd === "viewsource");
      }).map((t) => getGroup(t.map((t2) => {
        return (!e.isViewingSource.value || t2.cmd === "viewsource") && (t2.type === "slot" ? hSlot(e.slots[t2.slot]) : t2.type === "dropdown" ? getDropdown(e, t2) : getBtn(e, t2));
      })));
  }
  function getFonts(e, t, o, n = {}) {
    const a = Object.keys(n);
    if (a.length === 0)
      return {};
    const l = { default_font: { cmd: "fontName", param: e, icon: o, tip: t } };
    return a.forEach((e2) => {
      const t2 = n[e2];
      l[e2] = { cmd: "fontName", param: t2, icon: o, tip: t2, htmlTip: `<font face="${t2}">${t2}</font>` };
    }), l;
  }
  function getLinkEditor(e) {
    if (e.caret) {
      const t = e.props.toolbarColor || e.props.toolbarTextColor;
      let o = e.editLinkUrl.value;
      const n = () => {
        e.caret.restore(), o !== e.editLinkUrl.value && document.execCommand("createLink", false, o === "" ? " " : o), e.editLinkUrl.value = null;
      };
      return [h("div", { class: `q-mx-xs text-${t}` }, `${e.$q.lang.editor.url}: `), h("input", { key: "qedt_btm_input", class: "col q-editor__link-input", value: o, onInput: (e2) => {
        stop2(e2), o = e2.target.value;
      }, onKeydown: (t2) => {
        if (shouldIgnoreKey(t2) !== true)
          switch (t2.keyCode) {
            case 13:
              return prevent(t2), n();
            case 27:
              prevent(t2), e.caret.restore(), e.editLinkUrl.value && e.editLinkUrl.value !== "https://" || document.execCommand("unlink"), e.editLinkUrl.value = null;
              break;
          }
      } }), getGroup([h(QBtn, { key: "qedt_btm_rem", tabindex: -1, ...e.buttonProps.value, label: e.$q.lang.label.remove, noCaps: true, onClick: () => {
        e.caret.restore(), document.execCommand("unlink"), e.editLinkUrl.value = null;
      } }), h(QBtn, { key: "qedt_btm_upd", ...e.buttonProps.value, label: e.$q.lang.label.update, noCaps: true, onClick: n })])];
    }
  }
  var listenerRE = /^on[A-Z]/;
  function useSplitAttrs(e) {
    const t = { listeners: ref({}), attributes: ref({}) };
    function o() {
      const o2 = {}, n = {};
      Object.keys(e).forEach((t2) => {
        listenerRE.test(t2) === true ? o2[t2] = e[t2] : t2 !== "class" && t2 !== "style" && (n[t2] = e[t2]);
      }), t.listeners.value = o2, t.attributes.value = n;
    }
    return onBeforeUpdate(o), o(), t;
  }
  var toString = Object.prototype.toString;
  var hasOwn2 = Object.prototype.hasOwnProperty;
  var class2type = {};
  function type(e) {
    return e === null ? String(e) : class2type[toString.call(e)] || "object";
  }
  function isPlainObject2(e) {
    if (!e || type(e) !== "object")
      return false;
    if (e.constructor && !hasOwn2.call(e, "constructor") && !hasOwn2.call(e.constructor.prototype, "isPrototypeOf"))
      return false;
    let t;
    for (t in e)
      ;
    return t === void 0 || hasOwn2.call(e, t);
  }
  function extend2() {
    let e, t, o, n, a, l, i = arguments[0] || {}, r = 1, s2 = false;
    const u = arguments.length;
    for (typeof i === "boolean" && (s2 = i, i = arguments[1] || {}, r = 2), Object(i) !== i && type(i) !== "function" && (i = {}), u === r && (i = this, r--); r < u; r++)
      if ((e = arguments[r]) !== null)
        for (t in e)
          o = i[t], n = e[t], i !== n && (s2 && n && (isPlainObject2(n) || (a = type(n) === "array")) ? (a ? (a = false, l = o && type(o) === "array" ? o : []) : l = o && isPlainObject2(o) ? o : {}, i[t] = extend2(s2, l, n)) : n !== void 0 && (i[t] = n));
    return i;
  }
  "Boolean Number String Function Array Date RegExp Object".split(" ").forEach((e) => {
    class2type["[object " + e + "]"] = e.toLowerCase();
  });
  var QEditor = defineComponent2({ name: "QEditor", props: { ...useDarkProps, ...useFullscreenProps, modelValue: { type: String, required: true }, readonly: Boolean, disable: Boolean, minHeight: { type: String, default: "10rem" }, maxHeight: String, height: String, definitions: Object, fonts: Object, placeholder: String, toolbar: { type: Array, validator: (e) => e.length === 0 || e.every((e2) => e2.length), default() {
    return [["left", "center", "right", "justify"], ["bold", "italic", "underline", "strike"], ["undo", "redo"]];
  } }, toolbarColor: String, toolbarBg: String, toolbarTextColor: String, toolbarToggleColor: { type: String, default: "primary" }, toolbarOutline: Boolean, toolbarPush: Boolean, toolbarRounded: Boolean, paragraphTag: { type: String, validator: (e) => ["div", "p"].includes(e), default: "div" }, contentStyle: Object, contentClass: [Object, Array, String], square: Boolean, flat: Boolean, dense: Boolean }, emits: [...useFullscreenEmits, "update:modelValue", "keydown", "click", "mouseup", "keyup", "touchend", "focus", "blur"], setup(e, { slots: t, emit: o, attrs: n }) {
    const { proxy: a } = getCurrentInstance(), { $q: l } = a, i = useDark(e, l), { inFullscreen: r, toggleFullscreen: s2 } = useFullscreen(), u = useSplitAttrs(n), c = ref(null), d = ref(null), p2 = ref(null), v = ref(false), m = computed2(() => !e.readonly && !e.disable);
    let f, g, b = e.modelValue;
    document.execCommand("defaultParagraphSeparator", false, e.paragraphTag), f = window.getComputedStyle(document.body).fontFamily;
    const y = computed2(() => e.toolbarBg ? ` bg-${e.toolbarBg}` : ""), S = computed2(() => {
      const t2 = e.toolbarOutline !== true && e.toolbarPush !== true;
      return { type: "a", flat: t2, noWrap: true, outline: e.toolbarOutline, push: e.toolbarPush, rounded: e.toolbarRounded, dense: true, color: e.toolbarColor, disable: !m.value, size: "sm" };
    }), w = computed2(() => {
      const t2 = l.lang.editor, o2 = l.iconSet.editor;
      return { bold: { cmd: "bold", icon: o2.bold, tip: t2.bold, key: 66 }, italic: { cmd: "italic", icon: o2.italic, tip: t2.italic, key: 73 }, strike: { cmd: "strikeThrough", icon: o2.strikethrough, tip: t2.strikethrough, key: 83 }, underline: { cmd: "underline", icon: o2.underline, tip: t2.underline, key: 85 }, unordered: { cmd: "insertUnorderedList", icon: o2.unorderedList, tip: t2.unorderedList }, ordered: { cmd: "insertOrderedList", icon: o2.orderedList, tip: t2.orderedList }, subscript: { cmd: "subscript", icon: o2.subscript, tip: t2.subscript, htmlTip: "x<subscript>2</subscript>" }, superscript: { cmd: "superscript", icon: o2.superscript, tip: t2.superscript, htmlTip: "x<superscript>2</superscript>" }, link: { cmd: "link", disable: (e2) => e2.caret && !e2.caret.can("link"), icon: o2.hyperlink, tip: t2.hyperlink, key: 76 }, fullscreen: { cmd: "fullscreen", icon: o2.toggleFullscreen, tip: t2.toggleFullscreen, key: 70 }, viewsource: { cmd: "viewsource", icon: o2.viewSource, tip: t2.viewSource }, quote: { cmd: "formatBlock", param: "BLOCKQUOTE", icon: o2.quote, tip: t2.quote, key: 81 }, left: { cmd: "justifyLeft", icon: o2.left, tip: t2.left }, center: { cmd: "justifyCenter", icon: o2.center, tip: t2.center }, right: { cmd: "justifyRight", icon: o2.right, tip: t2.right }, justify: { cmd: "justifyFull", icon: o2.justify, tip: t2.justify }, print: { type: "no-state", cmd: "print", icon: o2.print, tip: t2.print, key: 80 }, outdent: { type: "no-state", disable: (e2) => e2.caret && !e2.caret.can("outdent"), cmd: "outdent", icon: o2.outdent, tip: t2.outdent }, indent: { type: "no-state", disable: (e2) => e2.caret && !e2.caret.can("indent"), cmd: "indent", icon: o2.indent, tip: t2.indent }, removeFormat: { type: "no-state", cmd: "removeFormat", icon: o2.removeFormat, tip: t2.removeFormat }, hr: { type: "no-state", cmd: "insertHorizontalRule", icon: o2.hr, tip: t2.hr }, undo: { type: "no-state", cmd: "undo", icon: o2.undo, tip: t2.undo, key: 90 }, redo: { type: "no-state", cmd: "redo", icon: o2.redo, tip: t2.redo, key: 89 }, h1: { cmd: "formatBlock", param: "H1", icon: o2.heading1 || o2.heading, tip: t2.heading1, htmlTip: `<h1 class="q-ma-none">${t2.heading1}</h1>` }, h2: { cmd: "formatBlock", param: "H2", icon: o2.heading2 || o2.heading, tip: t2.heading2, htmlTip: `<h2 class="q-ma-none">${t2.heading2}</h2>` }, h3: { cmd: "formatBlock", param: "H3", icon: o2.heading3 || o2.heading, tip: t2.heading3, htmlTip: `<h3 class="q-ma-none">${t2.heading3}</h3>` }, h4: { cmd: "formatBlock", param: "H4", icon: o2.heading4 || o2.heading, tip: t2.heading4, htmlTip: `<h4 class="q-ma-none">${t2.heading4}</h4>` }, h5: { cmd: "formatBlock", param: "H5", icon: o2.heading5 || o2.heading, tip: t2.heading5, htmlTip: `<h5 class="q-ma-none">${t2.heading5}</h5>` }, h6: { cmd: "formatBlock", param: "H6", icon: o2.heading6 || o2.heading, tip: t2.heading6, htmlTip: `<h6 class="q-ma-none">${t2.heading6}</h6>` }, p: { cmd: "formatBlock", param: e.paragraphTag, icon: o2.heading, tip: t2.paragraph }, code: { cmd: "formatBlock", param: "PRE", icon: o2.code, htmlTip: `<code>${t2.code}</code>` }, "size-1": { cmd: "fontSize", param: "1", icon: o2.size1 || o2.size, tip: t2.size1, htmlTip: `<font size="1">${t2.size1}</font>` }, "size-2": { cmd: "fontSize", param: "2", icon: o2.size2 || o2.size, tip: t2.size2, htmlTip: `<font size="2">${t2.size2}</font>` }, "size-3": { cmd: "fontSize", param: "3", icon: o2.size3 || o2.size, tip: t2.size3, htmlTip: `<font size="3">${t2.size3}</font>` }, "size-4": { cmd: "fontSize", param: "4", icon: o2.size4 || o2.size, tip: t2.size4, htmlTip: `<font size="4">${t2.size4}</font>` }, "size-5": { cmd: "fontSize", param: "5", icon: o2.size5 || o2.size, tip: t2.size5, htmlTip: `<font size="5">${t2.size5}</font>` }, "size-6": { cmd: "fontSize", param: "6", icon: o2.size6 || o2.size, tip: t2.size6, htmlTip: `<font size="6">${t2.size6}</font>` }, "size-7": { cmd: "fontSize", param: "7", icon: o2.size7 || o2.size, tip: t2.size7, htmlTip: `<font size="7">${t2.size7}</font>` } };
    }), x = computed2(() => {
      const t2 = e.definitions || {}, o2 = e.definitions || e.fonts ? extend2(true, {}, w.value, t2, getFonts(f, l.lang.editor.defaultFont, l.iconSet.editor.font, e.fonts)) : w.value;
      return e.toolbar.map((e2) => e2.map((e3) => {
        if (e3.options)
          return { type: "dropdown", icon: e3.icon, label: e3.label, size: "sm", dense: true, fixedLabel: e3.fixedLabel, fixedIcon: e3.fixedIcon, highlight: e3.highlight, list: e3.list, options: e3.options.map((e4) => o2[e4]) };
        const n2 = o2[e3];
        return n2 ? n2.type === "no-state" || t2[e3] && (n2.cmd === void 0 || w.value[n2.cmd] && w.value[n2.cmd].type === "no-state") ? n2 : Object.assign({ type: "toggle" }, n2) : { type: "slot", slot: e3 };
      }));
    }), C = { $q: l, props: e, slots: t, inFullscreen: r, toggleFullscreen: s2, runCmd: N, isViewingSource: v, editLinkUrl: p2, toolbarBackgroundClass: y, buttonProps: S, contentRef: d, buttons: x, setContent: D };
    watch(() => e.modelValue, (e2) => {
      b !== e2 && (b = e2, D(e2, true));
    });
    const k2 = computed2(() => e.toolbar && e.toolbar.length > 0), _ = computed2(() => {
      const e2 = {}, t2 = (t3) => {
        t3.key && (e2[t3.key] = { cmd: t3.cmd, param: t3.param });
      };
      return x.value.forEach((e3) => {
        e3.forEach((e4) => {
          e4.options ? e4.options.forEach(t2) : t2(e4);
        });
      }), e2;
    }), q = computed2(() => r.value ? e.contentStyle : [{ minHeight: e.minHeight, height: e.height, maxHeight: e.maxHeight }, e.contentStyle]), T = computed2(() => `q-editor q-editor--${v.value === true ? "source" : "default"}` + (e.disable === true ? " disabled" : "") + (r.value === true ? " fullscreen column" : "") + (e.square === true ? " q-editor--square no-border-radius" : "") + (e.flat === true ? " q-editor--flat" : "") + (e.dense === true ? " q-editor--dense" : "") + (i.value === true ? " q-editor--dark q-dark" : "")), P = computed2(() => [e.contentClass, "q-editor__content", { col: r.value, "overflow-auto": r.value || e.maxHeight }]), $ = computed2(() => e.disable === true ? { "aria-disabled": "true" } : e.readonly === true ? { "aria-readonly": "true" } : {});
    function M() {
      if (d.value !== null) {
        const t2 = `inner${v.value === true ? "Text" : "HTML"}`, n2 = d.value[t2];
        n2 !== e.modelValue && (b = n2, o("update:modelValue", n2));
      }
    }
    function B(e2) {
      if (o("keydown", e2), e2.ctrlKey !== true || shouldIgnoreKey(e2) === true)
        return void H();
      const t2 = e2.keyCode, n2 = _.value[t2];
      if (n2 !== void 0) {
        const { cmd: t3, param: o2 } = n2;
        stopAndPrevent(e2), N(t3, o2, false);
      }
    }
    function Q(e2) {
      H(), o("click", e2);
    }
    function E(e2) {
      if (d.value !== null) {
        const { scrollTop: e3, scrollHeight: t2 } = d.value;
        g = t2 - e3;
      }
      C.caret.save(), o("blur", e2);
    }
    function O(e2) {
      nextTick2(() => {
        d.value !== null && g !== void 0 && (d.value.scrollTop = d.value.scrollHeight - g);
      }), o("focus", e2);
    }
    function z(e2) {
      if (c.value.contains(e2.target) === true && (e2.relatedTarget === null || c.value.contains(e2.relatedTarget) !== true)) {
        const e3 = `inner${v.value === true ? "Text" : "HTML"}`;
        C.caret.restorePosition(d.value[e3].length), H();
      }
    }
    function F(e2) {
      c.value.contains(e2.target) !== true || e2.relatedTarget !== null && c.value.contains(e2.relatedTarget) === true || (C.caret.savePosition(), H());
    }
    function L() {
      g = void 0;
    }
    function R(e2) {
      C.caret.save(), o("mouseup", e2);
    }
    function V() {
      g = void 0;
    }
    function I(e2) {
      C.caret.save(), o("keyup", e2);
    }
    function A(e2) {
      C.caret.save(), o("touchend", e2);
    }
    function D(e2, t2) {
      if (d.value !== null) {
        t2 === true && C.caret.savePosition();
        const o2 = `inner${v.value === true ? "Text" : "HTML"}`;
        d.value[o2] = e2, t2 === true && (C.caret.restorePosition(d.value[o2].length), H());
      }
    }
    function N(e2, t2, o2 = true) {
      j(), C.caret.restore(), C.caret.apply(e2, t2, () => {
        j(), C.caret.save(), o2 && H();
      });
    }
    function H() {
      setTimeout(() => {
        p2.value = null, a.$forceUpdate();
      }, 1);
    }
    function j() {
      addFocusFn(() => {
        d.value !== null && d.value.focus();
      });
    }
    function U() {
      return d.value;
    }
    return Object.assign(a, { runCmd: N, refreshToolbar: H, focus: j, getContentEl: U }), onMounted2(() => {
      C.caret = new Caret(d.value, C), D(e.modelValue), H();
    }), () => {
      let t2;
      if (k2.value) {
        const e2 = [h("div", { key: "qedt_top", class: "q-editor__toolbar row no-wrap scroll-x" + y.value }, getToolbar(C))];
        p2.value !== null && e2.push(h("div", { key: "qedt_btm", class: "q-editor__toolbar row no-wrap items-center scroll-x" + y.value }, getLinkEditor(C))), t2 = h("div", { key: "toolbar_ctainer", class: "q-editor__toolbars-container" }, e2);
      }
      return h("div", { ref: c, class: T.value, style: { height: r.value === true ? "100vh" : null }, ...$.value, onFocusin: z, onFocusout: F }, [t2, h("div", { ref: d, style: q.value, class: P.value, contenteditable: m.value, placeholder: e.placeholder, ...{}, ...u.listeners.value, onInput: M, onKeydown: B, onClick: Q, onBlur: E, onFocus: O, onMousedown: L, onTouchstartPassive: V, onMouseup: R, onKeyup: I, onTouchend: A })]);
    };
  } });
  var QItemLabel = defineComponent2({ name: "QItemLabel", props: { overline: Boolean, caption: Boolean, header: Boolean, lines: [Number, String] }, setup(e, { slots: t }) {
    const o = computed2(() => parseInt(e.lines, 10)), n = computed2(() => "q-item__label" + (e.overline === true ? " q-item__label--overline text-overline" : "") + (e.caption === true ? " q-item__label--caption text-caption" : "") + (e.header === true ? " q-item__label--header" : "") + (o.value === 1 ? " ellipsis" : "")), a = computed2(() => {
      return e.lines !== void 0 && o.value > 1 ? { overflow: "hidden", display: "-webkit-box", "-webkit-box-orient": "vertical", "-webkit-line-clamp": o.value } : null;
    });
    return () => h("div", { style: a.value, class: n.value }, hSlot(t.default));
  } });
  var QSlideTransition = defineComponent2({ name: "QSlideTransition", props: { appear: Boolean, duration: { type: Number, default: 300 } }, emits: ["show", "hide"], setup(e, { slots: t, emit: o }) {
    let n, a, l, i, r, s2, u = false;
    function c() {
      n && n(), n = null, u = false, clearTimeout(l), clearTimeout(i), a !== void 0 && a.removeEventListener("transitionend", r), r = null;
    }
    function d(t2, o2, a2) {
      t2.style.overflowY = "hidden", o2 !== void 0 && (t2.style.height = `${o2}px`), t2.style.transition = `height ${e.duration}ms cubic-bezier(.25, .8, .50, 1)`, u = true, n = a2;
    }
    function p2(e2, t2) {
      e2.style.overflowY = null, e2.style.height = null, e2.style.transition = null, c(), t2 !== s2 && o(t2);
    }
    function v(t2, o2) {
      let n2 = 0;
      a = t2, u === true ? (c(), n2 = t2.offsetHeight === t2.scrollHeight ? 0 : void 0) : s2 = "hide", d(t2, n2, o2), l = setTimeout(() => {
        t2.style.height = `${t2.scrollHeight}px`, r = (e2) => {
          Object(e2) === e2 && e2.target !== t2 || p2(t2, "show");
        }, t2.addEventListener("transitionend", r), i = setTimeout(r, 1.1 * e.duration);
      }, 100);
    }
    function m(t2, o2) {
      let n2;
      a = t2, u === true ? c() : (s2 = "show", n2 = t2.scrollHeight), d(t2, n2, o2), l = setTimeout(() => {
        t2.style.height = 0, r = (e2) => {
          Object(e2) === e2 && e2.target !== t2 || p2(t2, "hide");
        }, t2.addEventListener("transitionend", r), i = setTimeout(r, 1.1 * e.duration);
      }, 100);
    }
    return onBeforeUnmount2(() => {
      u === true && c();
    }), () => h(Transition, { css: false, appear: e.appear, onEnter: v, onLeave: m }, t.default);
  } });
  var insetMap = { true: "inset", item: "item-inset", "item-thumbnail": "item-thumbnail-inset" };
  var margins = { xs: 2, sm: 4, md: 8, lg: 16, xl: 24 };
  var QSeparator = defineComponent2({ name: "QSeparator", props: { ...useDarkProps, spaced: [Boolean, String], inset: [Boolean, String], vertical: Boolean, color: String, size: String }, setup(e) {
    const t = getCurrentInstance(), o = useDark(e, t.proxy.$q), n = computed2(() => e.vertical === true ? "vertical" : "horizontal"), a = computed2(() => ` q-separator--${n.value}`), l = computed2(() => e.inset !== false ? `${a.value}-${insetMap[e.inset]}` : ""), i = computed2(() => `q-separator${a.value}${l.value}` + (e.color !== void 0 ? ` bg-${e.color}` : "") + (o.value === true ? " q-separator--dark" : "")), r = computed2(() => {
      const t2 = {};
      if (e.size !== void 0 && (t2[e.vertical === true ? "width" : "height"] = e.size), e.spaced !== false) {
        const o2 = e.spaced === true ? `${margins.md}px` : e.spaced in margins ? `${margins[e.spaced]}px` : e.spaced, n2 = e.vertical === true ? ["Left", "Right"] : ["Top", "Bottom"];
        t2[`margin${n2[0]}`] = t2[`margin${n2[1]}`] = o2;
      }
      return t2;
    });
    return () => h("hr", { class: i.value, style: r.value, role: "separator", "aria-orientation": n.value });
  } });
  var buf;
  var bufIdx = 0;
  var hexBytes = new Array(256);
  for (let e = 0; e < 256; e++)
    hexBytes[e] = (e + 256).toString(16).substr(1);
  var randomBytes = (() => {
    const e = typeof crypto !== "undefined" ? crypto : typeof window !== "undefined" ? window.crypto || window.msCrypto : void 0;
    if (e !== void 0) {
      if (e.randomBytes !== void 0)
        return e.randomBytes;
      if (e.getRandomValues !== void 0)
        return (t) => {
          const o = new Uint8Array(t);
          return e.getRandomValues(o), o;
        };
    }
    return (e2) => {
      const t = [];
      for (let o = e2; o > 0; o--)
        t.push(Math.floor(256 * Math.random()));
      return t;
    };
  })();
  var BUFFER_SIZE = 4096;
  function uid$2() {
    (buf === void 0 || bufIdx + 16 > BUFFER_SIZE) && (bufIdx = 0, buf = randomBytes(BUFFER_SIZE));
    const e = Array.prototype.slice.call(buf, bufIdx, bufIdx += 16);
    return e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128, hexBytes[e[0]] + hexBytes[e[1]] + hexBytes[e[2]] + hexBytes[e[3]] + "-" + hexBytes[e[4]] + hexBytes[e[5]] + "-" + hexBytes[e[6]] + hexBytes[e[7]] + "-" + hexBytes[e[8]] + hexBytes[e[9]] + "-" + hexBytes[e[10]] + hexBytes[e[11]] + hexBytes[e[12]] + hexBytes[e[13]] + hexBytes[e[14]] + hexBytes[e[15]];
  }
  var itemGroups = shallowReactive({});
  var LINK_PROPS = Object.keys(useRouterLinkProps);
  var QExpansionItem = defineComponent2({ name: "QExpansionItem", props: { ...useRouterLinkProps, ...useModelToggleProps, ...useDarkProps, icon: String, label: String, labelLines: [Number, String], caption: String, captionLines: [Number, String], dense: Boolean, expandIcon: String, expandedIcon: String, expandIconClass: [Array, String, Object], duration: Number, headerInsetLevel: Number, contentInsetLevel: Number, expandSeparator: Boolean, defaultOpened: Boolean, expandIconToggle: Boolean, switchToggleSide: Boolean, denseToggle: Boolean, group: String, popup: Boolean, headerStyle: [Array, String, Object], headerClass: [Array, String, Object] }, emits: [...useModelToggleEmits, "click", "after-show", "after-hide"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useDark(e, n), l = ref(e.modelValue !== null ? e.modelValue : e.defaultOpened), i = ref(null), { hide: r, toggle: s2 } = useModelToggle({ showing: l });
    let u, c;
    const d = computed2(() => `q-expansion-item q-item-type q-expansion-item--${l.value === true ? "expanded" : "collapsed"} q-expansion-item--${e.popup === true ? "popup" : "standard"}`), p2 = computed2(() => {
      if (e.contentInsetLevel === void 0)
        return null;
      const t2 = n.lang.rtl === true ? "Right" : "Left";
      return { ["padding" + t2]: 56 * e.contentInsetLevel + "px" };
    }), v = computed2(() => e.disable !== true && e.to !== void 0 && e.to !== null && e.to !== ""), m = computed2(() => {
      const t2 = {};
      return LINK_PROPS.forEach((o2) => {
        t2[o2] = e[o2];
      }), t2;
    }), f = computed2(() => v.value === true || e.expandIconToggle !== true), g = computed2(() => e.expandedIcon !== void 0 && l.value === true ? e.expandedIcon : e.expandIcon || n.iconSet.expansionItem[e.denseToggle === true ? "denseIcon" : "icon"]), b = computed2(() => e.disable !== true && (v.value === true || e.expandIconToggle === true));
    function y(e2) {
      v.value !== true && s2(e2), o("click", e2);
    }
    function S(e2) {
      e2.keyCode === 13 && w(e2, true);
    }
    function w(e2, t2) {
      t2 !== true && i.value !== null && i.value.focus(), s2(e2), stopAndPrevent(e2);
    }
    function x() {
      o("after-show");
    }
    function C() {
      o("after-hide");
    }
    function k2() {
      u === void 0 && (u = uid$2()), l.value === true && (itemGroups[e.group] = u);
      const t2 = watch(l, (t3) => {
        t3 === true ? itemGroups[e.group] = u : itemGroups[e.group] === u && delete itemGroups[e.group];
      }), o2 = watch(() => itemGroups[e.group], (e2, t3) => {
        t3 === u && e2 !== void 0 && e2 !== u && r();
      });
      c = () => {
        t2(), o2(), itemGroups[e.group] === u && delete itemGroups[e.group], c = void 0;
      };
    }
    function _() {
      const t2 = { class: [`q-focusable relative-position cursor-pointer${e.denseToggle === true && e.switchToggleSide === true ? " items-end" : ""}`, e.expandIconClass], side: e.switchToggleSide !== true, avatar: e.switchToggleSide }, o2 = [h(QIcon, { class: "q-expansion-item__toggle-icon" + (e.expandedIcon === void 0 && l.value === true ? " q-expansion-item__toggle-icon--rotated" : ""), name: g.value })];
      return b.value === true && (Object.assign(t2, { tabindex: 0, onClick: w, onKeyup: S }), o2.unshift(h("div", { ref: i, class: "q-expansion-item__toggle-focus q-icon q-focus-helper q-focus-helper--rounded", tabindex: -1 }))), h(QItemSection, t2, () => o2);
    }
    function q() {
      let o2;
      return t.header !== void 0 ? o2 = t.header().slice() : (o2 = [h(QItemSection, () => [h(QItemLabel, { lines: e.labelLines }, () => e.label || ""), e.caption ? h(QItemLabel, { lines: e.captionLines, caption: true }, () => e.caption) : null])], e.icon && o2[e.switchToggleSide === true ? "push" : "unshift"](h(QItemSection, { side: e.switchToggleSide === true, avatar: e.switchToggleSide !== true }, () => h(QIcon, { name: e.icon })))), e.disable !== true && o2[e.switchToggleSide === true ? "unshift" : "push"](_()), o2;
    }
    function T() {
      const t2 = { ref: "item", style: e.headerStyle, class: e.headerClass, dark: a.value, disable: e.disable, dense: e.dense, insetLevel: e.headerInsetLevel };
      return f.value === true && (t2.clickable = true, t2.onClick = y, v.value === true && Object.assign(t2, m.value)), h(QItem, t2, q);
    }
    function P() {
      return withDirectives(h("div", { key: "e-content", class: "q-expansion-item__content relative-position", style: p2.value }, hSlot(t.default)), [[vShow, l.value]]);
    }
    function $() {
      const t2 = [T(), h(QSlideTransition, { duration: e.duration, onShow: x, onHide: C }, P)];
      return e.expandSeparator === true && t2.push(h(QSeparator, { class: "q-expansion-item__border q-expansion-item__border--top absolute-top", dark: a.value }), h(QSeparator, { class: "q-expansion-item__border q-expansion-item__border--bottom absolute-bottom", dark: a.value })), t2;
    }
    return watch(() => e.group, (e2) => {
      c !== void 0 && c(), e2 !== void 0 && k2();
    }), e.group !== void 0 && k2(), onBeforeUnmount2(() => {
      c !== void 0 && c();
    }), () => h("div", { class: d.value }, [h("div", { class: "q-expansion-item__container relative-position" }, $())]);
  } });
  var labelPositions = ["top", "right", "bottom", "left"];
  var useFabProps = { type: { type: String, default: "a" }, outline: Boolean, push: Boolean, flat: Boolean, unelevated: Boolean, color: String, textColor: String, glossy: Boolean, square: Boolean, padding: String, label: { type: [String, Number], default: "" }, labelPosition: { type: String, default: "right", validator: (e) => labelPositions.includes(e) }, externalLabel: Boolean, hideLabel: { type: Boolean }, labelClass: [Array, String, Object], labelStyle: [Array, String, Object], disable: Boolean, tabindex: [Number, String] };
  function useFab(e, t) {
    return { formClass: computed2(() => `q-fab--form-${e.square === true ? "square" : "rounded"}`), stacked: computed2(() => e.externalLabel === false && ["top", "bottom"].includes(e.labelPosition)), labelProps: computed2(() => {
      if (e.externalLabel === true) {
        const o = e.hideLabel === null ? t.value === false : e.hideLabel;
        return { action: "push", data: { class: [e.labelClass, `q-fab__label q-tooltip--style q-fab__label--external q-fab__label--external-${e.labelPosition}` + (o === true ? " q-fab__label--external-hidden" : "")], style: e.labelStyle } };
      }
      return { action: ["left", "top"].includes(e.labelPosition) ? "unshift" : "push", data: { class: [e.labelClass, `q-fab__label q-fab__label--internal q-fab__label--internal-${e.labelPosition}` + (e.hideLabel === true ? " q-fab__label--internal-hidden" : "")], style: e.labelStyle } };
    }) };
  }
  var directions = ["up", "right", "down", "left"];
  var alignValues = ["left", "center", "right"];
  var QFab = defineComponent2({ name: "QFab", props: { ...useFabProps, ...useModelToggleProps, icon: String, activeIcon: String, hideIcon: Boolean, hideLabel: { default: null }, direction: { type: String, default: "right", validator: (e) => directions.includes(e) }, persistent: Boolean, verticalActionsAlign: { type: String, default: "center", validator: (e) => alignValues.includes(e) } }, emits: useModelToggleEmits, setup(e, { slots: t }) {
    const o = ref(null), n = ref(e.modelValue === true), { proxy: { $q: a } } = getCurrentInstance(), { formClass: l, labelProps: i } = useFab(e, n), r = computed2(() => e.persistent !== true), { hide: s2, toggle: u } = useModelToggle({ showing: n, hideOnRouteChange: r }), c = computed2(() => `q-fab z-fab row inline justify-center q-fab--align-${e.verticalActionsAlign} ${l.value}` + (n.value === true ? " q-fab--opened" : "")), d = computed2(() => `q-fab__actions flex no-wrap inline q-fab__actions--${e.direction}`);
    function p2() {
      const o2 = [];
      return e.hideIcon !== true && o2.push(h("div", { class: "q-fab__icon-holder" }, [h(QIcon, { class: "q-fab__icon absolute-full", name: e.icon || a.iconSet.fab.icon }), h(QIcon, { class: "q-fab__active-icon absolute-full", name: e.activeIcon || a.iconSet.fab.activeIcon })])), e.label !== "" && o2[i.value.action](h("div", i.value.data, [e.label])), hMergeSlot(t.tooltip, o2);
    }
    return provide2(fabKey, { showing: n, onChildClick(e2) {
      s2(e2), o.value !== null && o.value.$el.focus();
    } }), () => h("div", { class: c.value }, [h(QBtn, { ref: o, class: l.value, ...e, noWrap: true, stack: e.stacked, align: void 0, icon: void 0, label: void 0, noCaps: true, fab: true, "aria-expanded": n.value === true ? "true" : "false", "aria-haspopup": "true", onClick: u }, p2), h("div", { class: d.value }, hSlot(t.default))]);
  } });
  var anchorMap = { start: "self-end", center: "self-center", end: "self-start" };
  var anchorValues = Object.keys(anchorMap);
  var QFabAction = defineComponent2({ name: "QFabAction", props: { ...useFabProps, icon: { type: String, default: "" }, anchor: { type: String, validator: (e) => anchorValues.includes(e) }, to: [String, Object], replace: Boolean }, emits: ["click"], setup(e, { slots: t, emit: o }) {
    const n = inject2(fabKey, () => ({ showing: { value: true }, onChildClick: noop })), { formClass: a, labelProps: l } = useFab(e, n.showing), i = computed2(() => {
      const t2 = anchorMap[e.anchor];
      return a.value + (t2 !== void 0 ? ` ${t2}` : "");
    }), r = computed2(() => e.disable === true || n.showing.value !== true);
    function s2(e2) {
      n.onChildClick(e2), o("click", e2);
    }
    function u() {
      const o2 = [];
      return e.icon !== "" && o2.push(h(QIcon, { name: e.icon })), e.label !== "" && o2[l.value.action](h("div", l.value.data, [e.label])), hMergeSlot(t.default, o2);
    }
    const c = getCurrentInstance();
    return Object.assign(c.proxy, { click: s2 }), () => h(QBtn, { class: i.value, ...e, noWrap: true, stack: e.stacked, icon: void 0, label: void 0, noCaps: true, fabMini: true, disable: r.value, onClick: s2 }, u);
  } });
  function useFormChild({ validate: e, resetValidation: t, requiresQForm: o }) {
    const n = inject2(formKey, false);
    if (n !== false) {
      const { props: o2, proxy: a } = getCurrentInstance();
      Object.assign(a, e), watch(() => o2.disable, (e2) => {
        e2 === true ? (typeof t === "function" && t(), n.unbindComponent(a)) : n.bindComponent(a);
      }), o2.disable !== true && n.bindComponent(a), onBeforeUnmount2(() => {
        o2.disable !== true && n.unbindComponent(a);
      });
    } else
      o !== true && console.error("Parent QForm not found on useFormChild()!");
  }
  var lazyRulesValues = [true, false, "ondemand"];
  var useValidateProps = { modelValue: {}, error: { type: Boolean, default: null }, errorMessage: String, noErrorIcon: Boolean, rules: Array, reactiveRules: Boolean, lazyRules: { type: [Boolean, String], validator: (e) => lazyRulesValues.includes(e) } };
  function useValidate(e, t) {
    const { props: o, proxy: n } = getCurrentInstance(), a = ref(false), l = ref(null), i = ref(null);
    useFormChild({ validate: v, resetValidation: p2, requiresQForm: true });
    let r, s2 = 0;
    const u = computed2(() => o.rules !== void 0 && o.rules !== null && o.rules.length > 0), c = computed2(() => o.error === true || a.value === true), d = computed2(() => typeof o.errorMessage === "string" && o.errorMessage.length > 0 ? o.errorMessage : l.value);
    function p2() {
      s2++, t.value = false, i.value = null, a.value = false, l.value = null;
    }
    function v(e2 = o.modelValue) {
      if (u.value !== true)
        return true;
      s2++, t.value !== true && o.lazyRules !== true && (i.value = true);
      const n2 = (e3, o2) => {
        a.value !== e3 && (a.value = e3);
        const n3 = o2 || void 0;
        l.value !== n3 && (l.value = n3), t.value !== false && (t.value = false);
      }, r2 = [];
      for (let t2 = 0; t2 < o.rules.length; t2++) {
        const a2 = o.rules[t2];
        let l2;
        if (typeof a2 === "function" ? l2 = a2(e2) : typeof a2 === "string" && testPattern[a2] !== void 0 && (l2 = testPattern[a2](e2)), l2 === false || typeof l2 === "string")
          return n2(true, l2), false;
        l2 !== true && l2 !== void 0 && r2.push(l2);
      }
      if (r2.length === 0)
        return n2(false), true;
      t.value !== true && (t.value = true);
      const c4 = s2;
      return Promise.all(r2).then((e3) => {
        if (c4 !== s2)
          return true;
        if (e3 === void 0 || Array.isArray(e3) === false || e3.length === 0)
          return n2(false), true;
        const t2 = e3.find((e4) => e4 === false || typeof e4 === "string");
        return n2(t2 !== void 0, t2), t2 === void 0;
      }, (e3) => {
        return c4 !== s2 || (console.error(e3), n2(true), false);
      });
    }
    function m(e2) {
      u.value === true && o.lazyRules !== "ondemand" && (i.value === true || o.lazyRules !== true && e2 !== true) && v();
    }
    return watch(() => o.modelValue, () => {
      m();
    }), watch(() => o.reactiveRules, (e2) => {
      e2 === true ? r === void 0 && (r = watch(() => o.rules, () => {
        m(true);
      })) : r !== void 0 && (r(), r = void 0);
    }, { immediate: true }), watch(e, (e2) => {
      o.lazyRules !== "ondemand" && (e2 === true ? i.value === null && (i.value = false) : i.value === false && u.value === true && (i.value = true, v()));
    }), onBeforeUnmount2(() => {
      r !== void 0 && r();
    }), Object.assign(n, { resetValidation: p2, validate: v }), Object.defineProperty(n, "hasError", { get: () => c.value }), { isDirtyModel: i, hasRules: u, hasError: c, computedErrorMessage: d, validate: v, resetValidation: p2 };
  }
  function getTargetUid(e) {
    return e === void 0 ? `f_${uid$2()}` : e;
  }
  function fieldValueIsFilled(e) {
    return e !== void 0 && e !== null && ("" + e).length > 0;
  }
  var useFieldProps = { ...useDarkProps, ...useValidateProps, label: String, stackLabel: Boolean, hint: String, hideHint: Boolean, prefix: String, suffix: String, labelColor: String, color: String, bgColor: String, filled: Boolean, outlined: Boolean, borderless: Boolean, standout: [Boolean, String], square: Boolean, loading: Boolean, labelSlot: Boolean, bottomSlots: Boolean, hideBottomSpace: Boolean, rounded: Boolean, dense: Boolean, itemAligned: Boolean, counter: Boolean, clearable: Boolean, clearIcon: String, disable: Boolean, readonly: Boolean, autofocus: Boolean, for: String, maxlength: [Number, String] };
  var useFieldEmits = ["update:modelValue", "clear", "focus", "blur", "popup-show", "popup-hide"];
  function useFieldState() {
    const { props: e, attrs: t, proxy: o } = getCurrentInstance(), n = useDark(e, o.$q);
    return { isDark: n, editable: computed2(() => e.disable !== true && e.readonly !== true), innerLoading: ref(false), focused: ref(false), hasPopupOpen: ref(false), splitAttrs: useSplitAttrs(t), targetUid: ref(getTargetUid(e.for)), rootRef: ref(null), targetRef: ref(null), controlRef: ref(null) };
  }
  function useField(e) {
    const { props: t, emit: o, slots: n, attrs: a, proxy: l } = getCurrentInstance(), { $q: i } = l;
    let r;
    e.hasValue === void 0 && (e.hasValue = computed2(() => fieldValueIsFilled(t.modelValue))), e.emitValue === void 0 && (e.emitValue = (e2) => {
      o("update:modelValue", e2);
    }), e.controlEvents === void 0 && (e.controlEvents = { onFocusin: q, onFocusout: T }), Object.assign(e, { clearValue: P, onControlFocusin: q, onControlFocusout: T, focus: k2 }), e.computedCounter === void 0 && (e.computedCounter = computed2(() => {
      if (t.counter !== false) {
        const e2 = typeof t.modelValue === "string" || typeof t.modelValue === "number" ? ("" + t.modelValue).length : Array.isArray(t.modelValue) === true ? t.modelValue.length : 0, o2 = t.maxlength !== void 0 ? t.maxlength : t.maxValues;
        return e2 + (o2 !== void 0 ? " / " + o2 : "");
      }
    }));
    const { isDirtyModel: s2, hasRules: u, hasError: c, computedErrorMessage: d, resetValidation: p2 } = useValidate(e.focused, e.innerLoading), v = e.floatingLabel !== void 0 ? computed2(() => t.stackLabel === true || e.focused.value === true || e.floatingLabel.value === true) : computed2(() => t.stackLabel === true || e.focused.value === true || e.hasValue.value === true), m = computed2(() => t.bottomSlots === true || t.hint !== void 0 || u.value === true || t.counter === true || t.error !== null), f = computed2(() => {
      return t.filled === true ? "filled" : t.outlined === true ? "outlined" : t.borderless === true ? "borderless" : t.standout ? "standout" : "standard";
    }), g = computed2(() => `q-field row no-wrap items-start q-field--${f.value}` + (e.fieldClass !== void 0 ? ` ${e.fieldClass.value}` : "") + (t.rounded === true ? " q-field--rounded" : "") + (t.square === true ? " q-field--square" : "") + (v.value === true ? " q-field--float" : "") + (y.value === true ? " q-field--labeled" : "") + (t.dense === true ? " q-field--dense" : "") + (t.itemAligned === true ? " q-field--item-aligned q-item-type" : "") + (e.isDark.value === true ? " q-field--dark" : "") + (e.getControl === void 0 ? " q-field--auto-height" : "") + (e.focused.value === true ? " q-field--focused" : "") + (c.value === true ? " q-field--error" : "") + (c.value === true || e.focused.value === true ? " q-field--highlighted" : "") + (t.hideBottomSpace !== true && m.value === true ? " q-field--with-bottom" : "") + (t.disable === true ? " q-field--disabled" : t.readonly === true ? " q-field--readonly" : "")), b = computed2(() => "q-field__control relative-position row no-wrap" + (t.bgColor !== void 0 ? ` bg-${t.bgColor}` : "") + (c.value === true ? " text-negative" : typeof t.standout === "string" && t.standout.length > 0 && e.focused.value === true ? ` ${t.standout}` : t.color !== void 0 ? ` text-${t.color}` : "")), y = computed2(() => t.labelSlot === true || t.label !== void 0), S = computed2(() => "q-field__label no-pointer-events absolute ellipsis" + (t.labelColor !== void 0 && c.value !== true ? ` text-${t.labelColor}` : "")), w = computed2(() => ({ id: e.targetUid.value, editable: e.editable.value, focused: e.focused.value, floatingLabel: v.value, modelValue: t.modelValue, emitValue: e.emitValue })), x = computed2(() => {
      const o2 = { for: e.targetUid.value };
      return t.disable === true ? o2["aria-disabled"] = "true" : t.readonly === true && (o2["aria-readonly"] = "true"), o2;
    });
    let C;
    function k2() {
      C !== void 0 && removeFocusFn(C), C = addFocusFn(() => {
        C = void 0;
        const t2 = document.activeElement;
        let o2 = e.targetRef !== void 0 && e.targetRef.value;
        !o2 || t2 !== null && t2.id === e.targetUid.value || (o2.hasAttribute("tabindex") === true || (o2 = o2.querySelector("[tabindex]")), o2 && o2 !== t2 && o2.focus());
      });
    }
    function _() {
      C !== void 0 && removeFocusFn(C);
      const t2 = document.activeElement;
      t2 !== null && e.rootRef.value.contains(t2) && t2.blur();
    }
    function q(t2) {
      e.editable.value === true && e.focused.value === false && (e.focused.value = true, o("focus", t2));
    }
    function T(t2, n2) {
      clearTimeout(r), r = setTimeout(() => {
        (document.hasFocus() !== true || e.hasPopupOpen.value !== true && (e.controlRef === void 0 || e.controlRef.value !== null && e.controlRef.value.contains(document.activeElement) === false)) && (e.focused.value === true && (e.focused.value = false, o("blur", t2)), n2 !== void 0 && n2());
      });
    }
    function P(n2) {
      if (stopAndPrevent(n2), i.platform.is.mobile !== true) {
        const t2 = e.targetRef !== void 0 && e.targetRef.value || e.rootRef.value;
        t2.focus();
      } else
        e.rootRef.value.contains(document.activeElement) === true && document.activeElement.blur();
      t.type === "file" && (e.inputRef.value.value = null), o("update:modelValue", null), o("clear", t.modelValue), nextTick2(() => {
        p2(), t.lazyRules !== "ondemand" && i.platform.is.mobile !== true && (s2.value = false);
      });
    }
    function $() {
      const o2 = [];
      return n.prepend !== void 0 && o2.push(h("div", { class: "q-field__prepend q-field__marginal row no-wrap items-center", key: "prepend", onClick: prevent }, n.prepend())), o2.push(h("div", { class: "q-field__control-container col relative-position row no-wrap q-anchor--skip" }, M())), n.append !== void 0 && o2.push(h("div", { class: "q-field__append q-field__marginal row no-wrap items-center", key: "append", onClick: prevent }, n.append())), c.value === true && t.noErrorIcon === false && o2.push(Q("error", [h(QIcon, { name: i.iconSet.field.error, color: "negative" })])), t.loading === true || e.innerLoading.value === true ? o2.push(Q("inner-loading-append", n.loading !== void 0 ? n.loading() : [h(QSpinner, { color: t.color })])) : t.clearable === true && e.hasValue.value === true && e.editable.value === true && o2.push(Q("inner-clearable-append", [h(QIcon, { class: "q-field__focusable-action", tag: "button", name: t.clearIcon || i.iconSet.field.clear, tabindex: 0, type: "button", onClick: P })])), e.getInnerAppend !== void 0 && o2.push(Q("inner-append", e.getInnerAppend())), e.getControlChild !== void 0 && o2.push(e.getControlChild()), o2;
    }
    function M() {
      const o2 = [];
      return t.prefix !== void 0 && t.prefix !== null && o2.push(h("div", { class: "q-field__prefix no-pointer-events row items-center" }, t.prefix)), e.getShadowControl !== void 0 && e.hasShadow.value === true && o2.push(e.getShadowControl()), e.getControl !== void 0 ? o2.push(e.getControl()) : n.rawControl !== void 0 ? o2.push(n.rawControl()) : n.control !== void 0 && o2.push(h("div", { ref: e.targetRef, class: "q-field__native row", ...e.splitAttrs.attributes.value, "data-autofocus": t.autofocus === true || void 0 }, n.control(w.value))), y.value === true && o2.push(h("div", { class: S.value }, hSlot(n.label, t.label))), t.suffix !== void 0 && t.suffix !== null && o2.push(h("div", { class: "q-field__suffix no-pointer-events row items-center" }, t.suffix)), o2.concat(hSlot(n.default));
    }
    function B() {
      let o2, a2;
      c.value === true ? d.value !== null ? (o2 = [h("div", d.value)], a2 = `q--slot-error-${d.value}`) : (o2 = hSlot(n.error), a2 = "q--slot-error") : t.hideHint === true && e.focused.value !== true || (t.hint !== void 0 ? (o2 = [h("div", t.hint)], a2 = `q--slot-hint-${t.hint}`) : (o2 = hSlot(n.hint), a2 = "q--slot-hint"));
      const l2 = t.counter === true || n.counter !== void 0;
      if (t.hideBottomSpace === true && l2 === false && o2 === void 0)
        return;
      const i2 = h("div", { key: a2, class: "q-field__messages col" }, o2);
      return h("div", { class: "q-field__bottom row items-start q-field__bottom--" + (t.hideBottomSpace !== true ? "animated" : "stale") }, [t.hideBottomSpace === true ? i2 : h(Transition, { name: "q-transition--field-message" }, () => i2), l2 === true ? h("div", { class: "q-field__counter" }, n.counter !== void 0 ? n.counter() : e.computedCounter.value) : null]);
    }
    function Q(e2, t2) {
      return t2 === null ? null : h("div", { key: e2, class: "q-field__append q-field__marginal row no-wrap items-center q-anchor--skip" }, t2);
    }
    return watch(() => t.for, (t2) => {
      e.targetUid.value = getTargetUid(t2);
    }), Object.assign(l, { focus: k2, blur: _ }), onMounted2(() => {
      isRuntimeSsrPreHydration.value === true && t.for === void 0 && (e.targetUid.value = getTargetUid()), t.autofocus === true && l.focus();
    }), onBeforeUnmount2(() => {
      clearTimeout(r);
    }), function() {
      return h("label", { ref: e.rootRef, class: e.inheritAttrs !== true ? [g.value, a.class] : g.value, style: a.style, ...x.value }, [n.before !== void 0 ? h("div", { class: "q-field__before q-field__marginal row no-wrap items-center", onClick: prevent }, n.before()) : null, h("div", { class: "q-field__inner relative-position col self-stretch" }, [h("div", { ref: e.controlRef, class: b.value, tabindex: -1, ...e.controlEvents }, $()), m.value === true ? B() : null]), n.after !== void 0 ? h("div", { class: "q-field__after q-field__marginal row no-wrap items-center", onClick: prevent }, n.after()) : null]);
    };
  }
  var QField = defineComponent2({ name: "QField", inheritAttrs: false, props: useFieldProps, emits: useFieldEmits, setup() {
    return useField(useFieldState());
  } });
  function filterFiles(e, t, o, n) {
    const a = [];
    return e.forEach((e2) => {
      n(e2) === true ? a.push(e2) : t.push({ failedPropValidation: o, file: e2 });
    }), a;
  }
  function stopAndPreventDrag(e) {
    e && e.dataTransfer && (e.dataTransfer.dropEffect = "copy"), stopAndPrevent(e);
  }
  var useFileProps = { multiple: Boolean, accept: String, capture: String, maxFileSize: [Number, String], maxTotalSize: [Number, String], maxFiles: [Number, String], filter: Function };
  var useFileEmits = ["rejected"];
  function useFile({ editable: e, dnd: t, getFileInput: o, addFilesToQueue: n }) {
    const { props: a, emit: l, proxy: i } = getCurrentInstance(), r = computed2(() => a.accept !== void 0 ? a.accept.split(",").map((e2) => {
      return e2 = e2.trim(), e2 === "*" ? "*/" : (e2.endsWith("/*") && (e2 = e2.slice(0, e2.length - 1)), e2.toUpperCase());
    }) : null), s2 = computed2(() => parseInt(a.maxFiles, 10)), u = computed2(() => parseInt(a.maxTotalSize, 10));
    function c(t2) {
      if (e.value) {
        const e2 = o();
        e2 && e2.click(t2);
      }
    }
    function d(t2) {
      e.value && t2 && n(null, t2);
    }
    function p2(e2, t2, o2, n2) {
      let i2 = Array.from(t2 || e2.target.files);
      const c4 = [], d2 = () => {
        c4.length > 0 && l("rejected", c4);
      };
      if (a.accept !== void 0 && r.value.indexOf("*/") === -1 && (i2 = filterFiles(i2, c4, "accept", (e3) => {
        return r.value.some((t3) => e3.type.toUpperCase().startsWith(t3) || e3.name.toUpperCase().endsWith(t3));
      }), i2.length === 0))
        return d2();
      if (a.maxFileSize !== void 0) {
        const e3 = parseInt(a.maxFileSize, 10);
        if (i2 = filterFiles(i2, c4, "max-file-size", (t3) => {
          return t3.size <= e3;
        }), i2.length === 0)
          return d2();
      }
      if (a.multiple !== true && (i2 = [i2[0]]), a.maxTotalSize !== void 0) {
        let e3 = n2 === true ? o2.reduce((e4, t3) => e4 + t3.size, 0) : 0;
        if (i2 = filterFiles(i2, c4, "max-total-size", (t3) => {
          return e3 += t3.size, e3 <= u.value;
        }), i2.length === 0)
          return d2();
      }
      if (typeof a.filter === "function") {
        const e3 = a.filter(i2);
        i2 = filterFiles(i2, c4, "filter", (t3) => {
          return e3.includes(t3);
        });
      }
      if (a.maxFiles !== void 0) {
        let e3 = n2 === true ? o2.length : 0;
        if (i2 = filterFiles(i2, c4, "max-files", () => {
          return e3++, e3 <= s2.value;
        }), i2.length === 0)
          return d2();
      }
      return d2(), i2.length > 0 ? i2 : void 0;
    }
    function v(e2) {
      stopAndPreventDrag(e2), t.value !== true && (t.value = true);
    }
    function m(e2) {
      stopAndPrevent(e2), t.value = false;
    }
    function f(e2) {
      stopAndPreventDrag(e2);
      const o2 = e2.dataTransfer.files;
      o2.length > 0 && n(null, o2), t.value = false;
    }
    function g(e2) {
      if (t.value === true)
        return h("div", { class: `q-${e2}__dnd absolute-full`, onDragenter: stopAndPreventDrag, onDragover: stopAndPreventDrag, onDragleave: m, onDrop: f });
    }
    return Object.assign(i, { pickFiles: c, addFiles: d }), { pickFiles: c, addFiles: d, onDragover: v, processFiles: p2, getDndNode: g, maxFilesNumber: s2, maxTotalSizeNumber: u };
  }
  function useFileFormDomProps(e, t) {
    function o() {
      const t2 = e.modelValue;
      try {
        const e2 = "DataTransfer" in window ? new DataTransfer() : "ClipboardEvent" in window ? new ClipboardEvent("").clipboardData : void 0;
        return Object(t2) === t2 && ("length" in t2 ? Array.from(t2) : [t2]).forEach((t3) => {
          e2.items.add(t3);
        }), { files: e2.files };
      } catch (e2) {
        return { files: void 0 };
      }
    }
    return computed2(t === true ? () => {
      if (e.type === "file")
        return o();
    } : o);
  }
  var QFile = defineComponent2({ name: "QFile", props: { ...useFieldProps, ...useFormProps, ...useFileProps, modelValue: [File, FileList, Array], append: Boolean, useChips: Boolean, displayValue: [String, Number], tabindex: { type: [String, Number], default: 0 }, counterLabel: Function, inputClass: [Array, String, Object], inputStyle: [Array, String, Object] }, emits: [...useFieldEmits, ...useFileEmits], setup(e, { slots: t, emit: o, attrs: n }) {
    const { proxy: a } = getCurrentInstance(), l = useFieldState(), i = ref(null), r = ref(false), s2 = useFormInputNameAttr(e), { pickFiles: u, onDragover: c, processFiles: d, getDndNode: p2 } = useFile({ editable: l.editable, dnd: r, getFileInput: q, addFilesToQueue: T }), v = useFileFormDomProps(e), m = computed2(() => Object(e.modelValue) === e.modelValue ? "length" in e.modelValue ? Array.from(e.modelValue) : [e.modelValue] : []), f = computed2(() => fieldValueIsFilled(m.value)), g = computed2(() => m.value.map((e2) => e2.name).join(", ")), b = computed2(() => humanStorageSize(m.value.reduce((e2, t2) => e2 + t2.size, 0))), y = computed2(() => ({ totalSize: b.value, filesNumber: m.value.length, maxFiles: e.maxFiles })), S = computed2(() => ({ tabindex: -1, type: "file", title: "", accept: e.accept, capture: e.capture, name: s2.value, ...n, id: l.targetUid.value, disabled: l.editable.value !== true })), w = computed2(() => e.multiple === true && e.append === true);
    function x(e2) {
      const t2 = m.value.slice();
      t2.splice(e2, 1), k2(t2);
    }
    function C(e2) {
      const t2 = m.value.findIndex(e2);
      t2 > -1 && x(t2);
    }
    function k2(t2) {
      o("update:modelValue", e.multiple === true ? t2 : t2[0]);
    }
    function _(e2) {
      e2.keyCode === 13 && u(e2);
    }
    function q() {
      return i.value;
    }
    function T(t2, o2) {
      const n2 = d(t2, o2, m.value, w.value);
      n2 !== void 0 && ((e.multiple === true ? e.modelValue && n2.every((e2) => m.value.includes(e2)) : e.modelValue === n2[0]) || k2(w.value === true ? m.value.concat(n2) : n2));
    }
    function P() {
      return [h("input", { class: [e.inputClass, "q-file__filler"], style: e.inputStyle, tabindex: -1 })];
    }
    function $() {
      if (t.file !== void 0)
        return m.value.length === 0 ? P() : m.value.map((e2, o3) => t.file({ index: o3, file: e2, ref: this }));
      if (t.selected !== void 0)
        return m.value.length === 0 ? P() : t.selected({ files: m.value, ref: this });
      if (e.useChips === true)
        return m.value.length === 0 ? P() : m.value.map((t2, o3) => h(QChip, { key: "file-" + o3, removable: l.editable.value, dense: true, textColor: e.color, tabindex: e.tabindex, onRemove: () => {
          x(o3);
        } }, () => h("span", { class: "ellipsis", textContent: t2.name })));
      const o2 = e.displayValue !== void 0 ? e.displayValue : g.value;
      return o2.length > 0 ? [h("div", { class: e.inputClass, style: e.inputStyle, textContent: o2 })] : P();
    }
    function M() {
      const t2 = { ref: i, ...S.value, ...v.value, class: "q-field__input fit absolute-full cursor-pointer", onChange: T };
      return e.multiple === true && (t2.multiple = true), h("input", t2);
    }
    return Object.assign(l, { inheritAttrs: true, fieldClass: { value: "q-file q-field--auto-height" }, emitValue: k2, hasValue: f, inputRef: i, innerValue: m, floatingLabel: computed2(() => f.value === true || fieldValueIsFilled(e.displayValue)), computedCounter: computed2(() => {
      if (e.counterLabel !== void 0)
        return e.counterLabel(y.value);
      const t2 = e.maxFiles;
      return `${m.value.length}${t2 !== void 0 ? " / " + t2 : ""} (${b.value})`;
    }), getControlChild: () => p2("file"), getControl: () => {
      const t2 = { ref: l.targetRef, class: "q-field__native row items-center cursor-pointer", tabindex: e.tabindex };
      return l.editable.value === true && Object.assign(t2, { onDragover: c, onKeyup: _ }), h("div", t2, [M()].concat($()));
    } }), Object.assign(a, { removeAtIndex: x, removeFile: C, getNativeElement: () => i.value }), useField(l);
  } });
  var QFooter = defineComponent2({ name: "QFooter", props: { modelValue: { type: Boolean, default: true }, reveal: Boolean, bordered: Boolean, elevated: Boolean, heightHint: { type: [String, Number], default: 50 } }, emits: ["reveal", "focusin"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = inject2(layoutKey, () => {
      console.error("QFooter needs to be child of QLayout");
    }), l = ref(parseInt(e.heightHint, 10)), i = ref(true), r = ref(isRuntimeSsrPreHydration.value === true || a.isContainer.value === true ? 0 : window.innerHeight), s2 = computed2(() => e.reveal === true || a.view.value.indexOf("F") > -1 || a.isContainer.value === true), u = computed2(() => a.isContainer.value === true ? a.containerHeight.value : r.value), c = computed2(() => {
      if (e.modelValue !== true)
        return 0;
      if (s2.value === true)
        return i.value === true ? l.value : 0;
      const t2 = a.scroll.value.position + u.value + l.value - a.height.value;
      return t2 > 0 ? t2 : 0;
    }), d = computed2(() => e.modelValue !== true || s2.value === true && i.value !== true), p2 = computed2(() => e.modelValue === true && d.value === true && e.reveal === true), v = computed2(() => "q-footer q-layout__section--marginal " + (s2.value === true ? "fixed" : "absolute") + "-bottom" + (e.bordered === true ? " q-footer--bordered" : "") + (d.value === true ? " q-footer--hidden" : "") + (e.modelValue !== true ? " q-layout--prevent-focus" + (s2.value !== true ? " hidden" : "") : "")), m = computed2(() => {
      const e2 = a.rows.value.bottom, t2 = {};
      return e2[0] === "l" && a.left.space === true && (t2[n.lang.rtl === true ? "right" : "left"] = `${a.left.size}px`), e2[2] === "r" && a.right.space === true && (t2[n.lang.rtl === true ? "left" : "right"] = `${a.right.size}px`), t2;
    });
    function f(e2, t2) {
      a.update("footer", e2, t2);
    }
    function g(e2, t2) {
      e2.value !== t2 && (e2.value = t2);
    }
    function b({ height: e2 }) {
      g(l, e2), f("size", e2);
    }
    function y() {
      if (e.reveal !== true)
        return;
      const { direction: t2, position: o2, inflectionPoint: n2 } = a.scroll.value;
      g(i, t2 === "up" || o2 - n2 < 100 || a.height.value - u.value - o2 - l.value < 300);
    }
    function S(e2) {
      p2.value === true && g(i, true), o("focusin", e2);
    }
    watch(() => e.modelValue, (e2) => {
      f("space", e2), g(i, true), a.animate();
    }), watch(c, (e2) => {
      f("offset", e2);
    }), watch(() => e.reveal, (t2) => {
      t2 === false && g(i, e.modelValue);
    }), watch(i, (e2) => {
      a.animate(), o("reveal", e2);
    }), watch([l, a.scroll, a.height], y), watch(() => n.screen.height, (e2) => {
      a.isContainer.value !== true && g(r, e2);
    });
    const w = {};
    return a.instances.footer = w, e.modelValue === true && f("size", l.value), f("space", e.modelValue), f("offset", c.value), onBeforeUnmount2(() => {
      a.instances.footer === w && (a.instances.footer = void 0, f("size", 0), f("offset", 0), f("space", false));
    }), () => {
      const o2 = hMergeSlot(t.default, [h(QResizeObserver, { debounce: 0, onResize: b })]);
      return e.elevated === true && o2.push(h("div", { class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events" })), h("footer", { class: v.value, style: m.value, onFocusin: S }, o2);
    };
  } });
  var QForm = defineComponent2({ name: "QForm", props: { autofocus: Boolean, noErrorFocus: Boolean, noResetFocus: Boolean, greedy: Boolean, onSubmit: Function }, emits: ["reset", "validation-success", "validation-error"], setup(e, { slots: t, emit: o }) {
    const n = getCurrentInstance(), a = ref(null);
    let l = 0;
    const i = [];
    function r(t2) {
      const n2 = [], a2 = typeof t2 === "boolean" ? t2 : e.noErrorFocus !== true;
      l++;
      const r2 = (e2, t3) => {
        o("validation-" + (e2 === true ? "success" : "error"), t3);
      };
      for (let o2 = 0; o2 < i.length; o2++) {
        const t3 = i[o2], l2 = t3.validate();
        if (typeof l2.then === "function")
          n2.push(l2.then((e2) => ({ valid: e2, comp: t3 }), (e2) => ({ valid: false, comp: t3, error: e2 })));
        else if (l2 !== true) {
          if (e.greedy === false)
            return r2(false, t3), a2 === true && typeof t3.focus === "function" && t3.focus(), Promise.resolve(false);
          n2.push({ valid: false, comp: t3 });
        }
      }
      if (n2.length === 0)
        return r2(true), Promise.resolve(true);
      const s3 = l;
      return Promise.all(n2).then((e2) => {
        if (s3 === l) {
          const t3 = e2.filter((e3) => e3.valid !== true);
          if (t3.length === 0)
            return r2(true), true;
          const { valid: o2, comp: n3 } = t3[0];
          return r2(false, n3), a2 === true && o2 !== true && typeof n3.focus === "function" && n3.focus(), false;
        }
      });
    }
    function s2() {
      l++, i.forEach((e2) => {
        typeof e2.resetValidation === "function" && e2.resetValidation();
      });
    }
    function u(t2) {
      t2 !== void 0 && stopAndPrevent(t2), r().then((n2) => {
        n2 === true && (e.onSubmit !== void 0 ? o("submit", t2) : t2 !== void 0 && t2.target !== void 0 && typeof t2.target.submit === "function" && t2.target.submit());
      });
    }
    function c(t2) {
      t2 !== void 0 && stopAndPrevent(t2), o("reset"), nextTick2(() => {
        s2(), e.autofocus === true && e.noResetFocus !== true && d();
      });
    }
    function d() {
      addFocusFn(() => {
        if (a.value === null)
          return;
        const e2 = a.value.querySelector("[autofocus], [data-autofocus]") || Array.prototype.find.call(a.value.querySelectorAll("[tabindex]"), (e3) => e3.tabIndex > -1);
        e2 !== null && e2 !== void 0 && e2.focus();
      });
    }
    return provide2(formKey, { bindComponent(e2) {
      i.push(e2);
    }, unbindComponent(e2) {
      const t2 = i.indexOf(e2);
      t2 > -1 && i.splice(t2, 1);
    } }), onMounted2(() => {
      e.autofocus === true && d();
    }), Object.assign(n.proxy, { validate: r, resetValidation: s2, submit: u, reset: c, focus: d, getValidationComponents: () => i }), () => h("form", { class: "q-form", ref: a, onSubmit: u, onReset: c }, hSlot(t.default));
  } });
  var QFormChildMixin = { inject: { [formKey]: { default: noop } }, watch: { disable(e) {
    const t = this.$.provides[formKey];
    t !== void 0 && (e === true ? (this.resetValidation(), t.unbindComponent(this)) : t.bindComponent(this));
  } }, methods: { validate() {
  }, resetValidation() {
  } }, created() {
    const e = this.$.provides[formKey];
    e !== void 0 && this.disable !== true && e.bindComponent(this);
  }, beforeUnmount() {
    const e = this.$.provides[formKey];
    e !== void 0 && this.disable !== true && e.unbindComponent(this);
  } };
  var QHeader = defineComponent2({ name: "QHeader", props: { modelValue: { type: Boolean, default: true }, reveal: Boolean, revealOffset: { type: Number, default: 250 }, bordered: Boolean, elevated: Boolean, heightHint: { type: [String, Number], default: 50 } }, emits: ["reveal", "focusin"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = inject2(layoutKey, () => {
      console.error("QHeader needs to be child of QLayout");
    }), l = ref(parseInt(e.heightHint, 10)), i = ref(true), r = computed2(() => e.reveal === true || a.view.value.indexOf("H") > -1 || a.isContainer.value === true), s2 = computed2(() => {
      if (e.modelValue !== true)
        return 0;
      if (r.value === true)
        return i.value === true ? l.value : 0;
      const t2 = l.value - a.scroll.value.position;
      return t2 > 0 ? t2 : 0;
    }), u = computed2(() => e.modelValue !== true || r.value === true && i.value !== true), c = computed2(() => e.modelValue === true && u.value === true && e.reveal === true), d = computed2(() => "q-header q-layout__section--marginal " + (r.value === true ? "fixed" : "absolute") + "-top" + (e.bordered === true ? " q-header--bordered" : "") + (u.value === true ? " q-header--hidden" : "") + (e.modelValue !== true ? " q-layout--prevent-focus" : "")), p2 = computed2(() => {
      const e2 = a.rows.value.top, t2 = {};
      return e2[0] === "l" && a.left.space === true && (t2[n.lang.rtl === true ? "right" : "left"] = `${a.left.size}px`), e2[2] === "r" && a.right.space === true && (t2[n.lang.rtl === true ? "left" : "right"] = `${a.right.size}px`), t2;
    });
    function v(e2, t2) {
      a.update("header", e2, t2);
    }
    function m(e2, t2) {
      e2.value !== t2 && (e2.value = t2);
    }
    function f({ height: e2 }) {
      m(l, e2), v("size", e2);
    }
    function g(e2) {
      c.value === true && m(i, true), o("focusin", e2);
    }
    watch(() => e.modelValue, (e2) => {
      v("space", e2), m(i, true), a.animate();
    }), watch(s2, (e2) => {
      v("offset", e2);
    }), watch(() => e.reveal, (t2) => {
      t2 === false && m(i, e.modelValue);
    }), watch(i, (e2) => {
      a.animate(), o("reveal", e2);
    }), watch(a.scroll, (t2) => {
      e.reveal === true && m(i, t2.direction === "up" || t2.position <= e.revealOffset || t2.position - t2.inflectionPoint < 100);
    });
    const b = {};
    return a.instances.header = b, e.modelValue === true && v("size", l.value), v("space", e.modelValue), v("offset", s2.value), onBeforeUnmount2(() => {
      a.instances.header === b && (a.instances.header = void 0, v("size", 0), v("offset", 0), v("space", false));
    }), () => {
      const o2 = hUniqueSlot(t.default, []);
      return e.elevated === true && o2.push(h("div", { class: "q-layout__shadow absolute-full overflow-hidden no-pointer-events" })), o2.push(h(QResizeObserver, { debounce: 0, onResize: f })), h("header", { class: d.value, style: p2.value, onFocusin: g }, o2);
    };
  } });
  var useRatioProps = { ratio: [String, Number] };
  function useRatio(e, t) {
    return computed2(() => {
      const o = Number(e.ratio || (t !== void 0 ? t.value : void 0));
      return isNaN(o) !== true && o > 0 ? { paddingBottom: `${100 / o}%` } : null;
    });
  }
  var crossoriginValues = ["anonymous", "use-credentials"];
  var loadingValues = ["eager", "lazy"];
  var fitValues = ["cover", "fill", "contain", "none", "scale-down"];
  var QImg = defineComponent2({ name: "QImg", props: { ...useRatioProps, src: String, srcset: String, sizes: String, alt: String, crossorigin: { type: String, validator: (e) => crossoriginValues.includes(e) }, draggable: Boolean, loading: { type: String, default: "lazy", validator: (e) => loadingValues.includes(e) }, width: String, height: String, placeholderSrc: String, fit: { type: String, default: "cover", validator: (e) => fitValues.includes(e) }, position: { type: String, default: "50% 50%" }, imgClass: String, imgStyle: Object, noSpinner: Boolean, noNativeMenu: Boolean, noTransition: Boolean, spinnerColor: String, spinnerSize: String }, emits: ["load", "error"], setup(e, { slots: t, attrs: o, emit: n }) {
    const a = ref(0.5), l = useRatio(e, a);
    let i;
    const r = [ref(null), ref(e.placeholderSrc !== void 0 ? { src: e.placeholderSrc } : null)], s2 = ref(0), u = ref(false), c = ref(false), d = computed2(() => `q-img q-img--${e.noNativeMenu === true ? "no-" : ""}menu`), p2 = computed2(() => ({ width: e.width, height: e.height })), v = computed2(() => `q-img__image ${e.imgClass !== void 0 ? e.imgClass + " " : ""}q-img__image--with${e.noTransition === true ? "out" : ""}-transition`), m = computed2(() => ({ ...e.imgStyle, objectFit: e.fit, objectPosition: e.position }));
    function f() {
      return e.src || e.srcset || e.sizes ? { src: e.src, srcset: e.srcset, sizes: e.sizes } : null;
    }
    function g(e2) {
      if (clearTimeout(i), c.value = false, e2 === null)
        return u.value = false, r[0].value = null, void (r[1].value = null);
      u.value = true, r[s2.value].value = e2;
    }
    function b({ target: e2 }) {
      i !== null && (clearTimeout(i), a.value = e2.naturalHeight === 0 ? 0.5 : e2.naturalWidth / e2.naturalHeight, y(e2, 1));
    }
    function y(e2, t2) {
      i !== null && t2 !== 1e3 && (e2.complete === true ? S(e2) : i = setTimeout(() => {
        y(e2, t2 + 1);
      }, 50));
    }
    function S(e2) {
      i !== null && (s2.value = s2.value === 1 ? 0 : 1, r[s2.value].value = null, u.value = false, c.value = false, n("load", e2.currentSrc || e2.src));
    }
    function w(e2) {
      clearTimeout(i), u.value = false, c.value = true, r[0].value = null, r[1].value = null, n("error", e2);
    }
    function x(e2, t2) {
      return h("div", { class: "q-img__container absolute-full", key: e2 }, t2);
    }
    function C(t2) {
      const n2 = r[t2].value, a2 = { key: "img_" + t2, ...o, class: v.value, style: m.value, crossorigin: e.crossorigin, height: e.height, width: e.width, loading: e.loading, "aria-hidden": "true", draggable: e.draggable, ...n2 };
      return s2.value === t2 ? (a2.class += " q-img__image--waiting", Object.assign(a2, { onLoad: b, onError: w })) : a2.class += " q-img__image--loaded", x("img" + t2, h("img", a2));
    }
    function k2() {
      return u.value !== true ? h("div", { key: "content", class: "q-img__content absolute-full q-anchor--skip" }, hSlot(t[c.value === true ? "error" : "default"])) : h("div", { key: "loading", class: "q-img__loading absolute-full flex flex-center" }, t.loading !== void 0 ? t.loading() : e.noSpinner === true ? void 0 : [h(QSpinner, { color: e.spinnerColor, size: e.spinnerSize })]);
    }
    return watch(() => f(), g), g(f()), onBeforeUnmount2(() => {
      clearTimeout(i), i = null;
    }), () => {
      const t2 = [];
      return l.value !== null && t2.push(h("div", { key: "filler", style: l.value })), c.value !== true && (r[0].value !== null && t2.push(C(0)), r[1].value !== null && t2.push(C(1))), t2.push(h(Transition, { name: "q-transition--fade" }, k2)), h("div", { class: d.value, style: p2.value, role: "img", "aria-label": e.alt }, t2);
    };
  } });
  var QInfiniteScroll = defineComponent2({ name: "QInfiniteScroll", props: { offset: { type: Number, default: 500 }, debounce: { type: [String, Number], default: 100 }, scrollTarget: { default: void 0 }, initialIndex: Number, disable: Boolean, reverse: Boolean }, emits: ["load"], setup(e, { slots: t, emit: o }) {
    const n = ref(false), a = ref(null);
    let l, i, r = e.initialIndex || 0, s2 = true;
    const u = computed2(() => "q-infinite-scroll__loading" + (n.value === true ? "" : " invisible"));
    function c() {
      if (e.disable === true || n.value === true || s2 === false)
        return;
      const t2 = getScrollHeight(l), o2 = getVerticalScrollPosition(l), a2 = height(l);
      e.reverse === false ? o2 + a2 + e.offset >= t2 && d() : o2 < e.offset && d();
    }
    function d() {
      if (e.disable === true || n.value === true || s2 === false)
        return;
      r++, n.value = true;
      const t2 = getScrollHeight(l);
      o("load", r, (o2) => {
        s2 === true && (n.value = false, nextTick2(() => {
          if (e.reverse === true) {
            const e2 = getScrollHeight(l), o3 = getVerticalScrollPosition(l), n2 = e2 - t2;
            setVerticalScrollPosition(l, o3 + n2);
          }
          o2 === true ? m() : a.value && a.value.closest("body") && i();
        }));
      });
    }
    function p2() {
      r = 0;
    }
    function v() {
      s2 === false && (s2 = true, l.addEventListener("scroll", i, listenOpts.passive)), c();
    }
    function m() {
      s2 === true && (s2 = false, n.value = false, l.removeEventListener("scroll", i, listenOpts.passive));
    }
    function f() {
      l && s2 === true && l.removeEventListener("scroll", i, listenOpts.passive), l = getScrollTarget(a.value, e.scrollTarget), s2 === true && l.addEventListener("scroll", i, listenOpts.passive);
    }
    function g(e2) {
      r = e2;
    }
    const b = getCurrentInstance();
    function y(e2) {
      e2 = parseInt(e2, 10);
      const t2 = i;
      i = e2 <= 0 ? c : debounce(c, isNaN(e2) === true ? 100 : e2), l && s2 === true && (t2 !== void 0 && l.removeEventListener("scroll", t2, listenOpts.passive), l.addEventListener("scroll", i, listenOpts.passive));
    }
    return Object.assign(b.proxy, { poll: () => i.apply(null, arguments), trigger: d, stop: m, reset: p2, resume: v, setIndex: g }), watch(() => e.disable, (e2) => {
      e2 === true ? m() : v();
    }), watch(() => e.scrollTarget, f), watch(() => e.debounce, y), onBeforeUnmount2(() => {
      s2 === true && l.removeEventListener("scroll", i, listenOpts.passive);
    }), onMounted2(() => {
      if (y(e.debounce), f(), e.reverse === true) {
        const e2 = getScrollHeight(l), t2 = height(l);
        setVerticalScrollPosition(l, e2 - t2);
      }
      c();
    }), () => {
      const o2 = hUniqueSlot(t.default, []);
      return e.disable !== true && s2 === true && o2[e.reverse === false ? "push" : "unshift"](h("div", { class: u.value }, hSlot(t.loading))), h("div", { class: "q-infinite-scroll", ref: a }, o2);
    };
  } });
  var QInnerLoading = defineComponent2({ name: "QInnerLoading", props: { ...useDarkProps, ...useTransitionProps, showing: Boolean, color: String, size: { type: [String, Number], default: 42 } }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), { transition: a, transitionStyle: l } = useTransition(e, computed2(() => e.showing)), i = computed2(() => "q-inner-loading absolute-full column flex-center" + (n.value === true ? " q-inner-loading--dark" : ""));
    function r() {
      return e.showing === true ? h("div", { class: i.value, style: l.value }, t.default !== void 0 ? t.default() : [h(QSpinner, { size: e.size, color: e.color })]) : null;
    }
    return () => h(Transition, { name: a.value, appear: true }, r);
  } });
  var NAMED_MASKS = { date: "####/##/##", datetime: "####/##/## ##:##", time: "##:##", fulltime: "##:##:##", phone: "(###) ### - ####", card: "#### #### #### ####" };
  var TOKENS = { "#": { pattern: "[\\d]", negate: "[^\\d]" }, S: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]" }, N: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]" }, A: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleUpperCase() }, a: { pattern: "[a-zA-Z]", negate: "[^a-zA-Z]", transform: (e) => e.toLocaleLowerCase() }, X: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleUpperCase() }, x: { pattern: "[0-9a-zA-Z]", negate: "[^0-9a-zA-Z]", transform: (e) => e.toLocaleLowerCase() } };
  var KEYS = Object.keys(TOKENS);
  KEYS.forEach((e) => {
    TOKENS[e].regex = new RegExp(TOKENS[e].pattern);
  });
  var tokenRegexMask = new RegExp("\\\\([^.*+?^${}()|([\\]])|([.*+?^${}()|[\\]])|([" + KEYS.join("") + "])|(.)", "g");
  var escRegex = /[.*+?^${}()|[\]\\]/g;
  var MARKER = String.fromCharCode(1);
  var useMaskProps = { mask: String, reverseFillMask: Boolean, fillMask: [Boolean, String], unmaskedValue: Boolean };
  function useMask(e, t, o, n) {
    let a, l, i, r;
    const s2 = ref(null), u = ref(c());
    function c() {
      if (p2(), s2.value === true) {
        const t2 = g(y(e.modelValue));
        return e.fillMask !== false ? S(t2) : t2;
      }
      return e.modelValue;
    }
    function d(e2) {
      if (e2 < a.length)
        return a.slice(-e2);
      let t2 = "", o2 = a;
      const n2 = o2.indexOf(MARKER);
      if (n2 > -1) {
        for (let n3 = e2 - o2.length; n3 > 0; n3--)
          t2 += MARKER;
        o2 = o2.slice(0, n2) + t2 + o2.slice(n2);
      }
      return o2;
    }
    function p2() {
      if (s2.value = e.mask !== void 0 && e.mask.length > 0 && ["text", "search", "url", "tel", "password"].includes(e.type), s2.value === false)
        return r = void 0, a = "", void (l = "");
      const t2 = NAMED_MASKS[e.mask] === void 0 ? e.mask : NAMED_MASKS[e.mask], o2 = typeof e.fillMask === "string" && e.fillMask.length > 0 ? e.fillMask.slice(0, 1) : "_", n2 = o2.replace(escRegex, "\\$&"), u2 = [], c4 = [], d2 = [];
      let p3 = e.reverseFillMask === true, v2 = "", m2 = "";
      t2.replace(tokenRegexMask, (e2, t3, o3, n3, a2) => {
        if (n3 !== void 0) {
          const e3 = TOKENS[n3];
          d2.push(e3), m2 = e3.negate, p3 === true && (c4.push("(?:" + m2 + "+)?(" + e3.pattern + "+)?(?:" + m2 + "+)?(" + e3.pattern + "+)?"), p3 = false), c4.push("(?:" + m2 + "+)?(" + e3.pattern + ")?");
        } else if (o3 !== void 0)
          v2 = "\\" + (o3 === "\\" ? "" : o3), d2.push(o3), u2.push("([^" + v2 + "]+)?" + v2 + "?");
        else {
          const e3 = t3 !== void 0 ? t3 : a2;
          v2 = e3 === "\\" ? "\\\\\\\\" : e3.replace(escRegex, "\\\\$&"), d2.push(e3), u2.push("([^" + v2 + "]+)?" + v2 + "?");
        }
      });
      const f2 = new RegExp("^" + u2.join("") + "(" + (v2 === "" ? "." : "[^" + v2 + "]") + "+)?$"), h4 = c4.length - 1, g2 = c4.map((t3, o3) => {
        return o3 === 0 && e.reverseFillMask === true ? new RegExp("^" + n2 + "*" + t3) : o3 === h4 ? new RegExp("^" + t3 + "(" + (m2 === "" ? "." : m2) + "+)?" + (e.reverseFillMask === true ? "$" : n2 + "*")) : new RegExp("^" + t3);
      });
      i = d2, r = (e2) => {
        const t3 = f2.exec(e2);
        t3 !== null && (e2 = t3.slice(1).join(""));
        const o3 = [], n3 = g2.length;
        for (let a2 = 0, l2 = e2; a2 < n3; a2++) {
          const e3 = g2[a2].exec(l2);
          if (e3 === null)
            break;
          l2 = l2.slice(e3.shift().length), o3.push(...e3);
        }
        return o3.length > 0 ? o3.join("") : e2;
      }, a = d2.map((e2) => typeof e2 === "string" ? e2 : MARKER).join(""), l = a.split(MARKER).join(o2);
    }
    function v(t2, i2, r2) {
      const s3 = n.value, c4 = s3.selectionEnd, d2 = s3.value.length - c4, v2 = y(t2);
      i2 === true && p2();
      const m2 = g(v2), h4 = e.fillMask !== false ? S(m2) : m2, b2 = u.value !== h4;
      s3.value !== h4 && (s3.value = h4), b2 === true && (u.value = h4), document.activeElement === s3 && nextTick2(() => {
        if (h4 !== l)
          if (r2 !== "insertFromPaste" || e.reverseFillMask === true)
            if (["deleteContentBackward", "deleteContentForward"].indexOf(r2) > -1) {
              const t3 = e.reverseFillMask === true ? c4 === 0 ? h4.length > m2.length ? 1 : 0 : Math.max(0, h4.length - (h4 === l ? 0 : Math.min(m2.length, d2) + 1)) + 1 : c4;
              s3.setSelectionRange(t3, t3, "forward");
            } else if (e.reverseFillMask === true)
              if (b2 === true) {
                const e2 = Math.max(0, h4.length - (h4 === l ? 0 : Math.min(m2.length, d2 + 1)));
                e2 === 1 && c4 === 1 ? s3.setSelectionRange(e2, e2, "forward") : f.rightReverse(s3, e2, e2);
              } else {
                const e2 = h4.length - d2;
                s3.setSelectionRange(e2, e2, "backward");
              }
            else if (b2 === true) {
              const e2 = Math.max(0, a.indexOf(MARKER), Math.min(m2.length, c4) - 1);
              f.right(s3, e2, e2);
            } else {
              const e2 = c4 - 1;
              f.right(s3, e2, e2);
            }
          else {
            const e2 = c4 - 1;
            f.right(s3, e2, e2);
          }
        else {
          const t3 = e.reverseFillMask === true ? l.length : 0;
          s3.setSelectionRange(t3, t3, "forward");
        }
      });
      const w = e.unmaskedValue === true ? y(h4) : h4;
      e.modelValue !== w && o(w, true);
    }
    function m(e2, t2, o2) {
      const n2 = g(y(e2.value));
      t2 = Math.max(0, a.indexOf(MARKER), Math.min(n2.length, t2)), e2.setSelectionRange(t2, o2, "forward");
    }
    watch(() => e.type, p2), watch(() => e.mask, (o2) => {
      if (o2 !== void 0)
        v(u.value, true);
      else {
        const o3 = y(u.value);
        p2(), e.modelValue !== o3 && t("update:modelValue", o3);
      }
    }), watch(() => e.fillMask + e.reverseFillMask, () => {
      s2.value === true && v(u.value, true);
    }), watch(() => e.unmaskedValue, () => {
      s2.value === true && v(u.value);
    });
    const f = { left(e2, t2, o2, n2) {
      const l2 = a.slice(t2 - 1).indexOf(MARKER) === -1;
      let i2 = Math.max(0, t2 - 1);
      for (; i2 >= 0; i2--)
        if (a[i2] === MARKER) {
          t2 = i2, l2 === true && t2++;
          break;
        }
      if (i2 < 0 && a[t2] !== void 0 && a[t2] !== MARKER)
        return f.right(e2, 0, 0);
      t2 >= 0 && e2.setSelectionRange(t2, n2 === true ? o2 : t2, "backward");
    }, right(e2, t2, o2, n2) {
      const l2 = e2.value.length;
      let i2 = Math.min(l2, o2 + 1);
      for (; i2 <= l2; i2++) {
        if (a[i2] === MARKER) {
          o2 = i2;
          break;
        }
        a[i2 - 1] === MARKER && (o2 = i2);
      }
      if (i2 > l2 && a[o2 - 1] !== void 0 && a[o2 - 1] !== MARKER)
        return f.left(e2, l2, l2);
      e2.setSelectionRange(n2 ? t2 : o2, o2, "forward");
    }, leftReverse(e2, t2, o2, n2) {
      const a2 = d(e2.value.length);
      let l2 = Math.max(0, t2 - 1);
      for (; l2 >= 0; l2--) {
        if (a2[l2 - 1] === MARKER) {
          t2 = l2;
          break;
        }
        if (a2[l2] === MARKER && (t2 = l2, l2 === 0))
          break;
      }
      if (l2 < 0 && a2[t2] !== void 0 && a2[t2] !== MARKER)
        return f.rightReverse(e2, 0, 0);
      t2 >= 0 && e2.setSelectionRange(t2, n2 === true ? o2 : t2, "backward");
    }, rightReverse(e2, t2, o2, n2) {
      const a2 = e2.value.length, l2 = d(a2), i2 = l2.slice(0, o2 + 1).indexOf(MARKER) === -1;
      let r2 = Math.min(a2, o2 + 1);
      for (; r2 <= a2; r2++)
        if (l2[r2 - 1] === MARKER) {
          o2 = r2, o2 > 0 && i2 === true && o2--;
          break;
        }
      if (r2 > a2 && l2[o2 - 1] !== void 0 && l2[o2 - 1] !== MARKER)
        return f.leftReverse(e2, a2, a2);
      e2.setSelectionRange(n2 === true ? t2 : o2, o2, "forward");
    } };
    function h3(t2) {
      if (shouldIgnoreKey(t2) === true)
        return;
      const o2 = n.value, a2 = o2.selectionStart, l2 = o2.selectionEnd;
      if (t2.keyCode === 37 || t2.keyCode === 39) {
        const n2 = f[(t2.keyCode === 39 ? "right" : "left") + (e.reverseFillMask === true ? "Reverse" : "")];
        t2.preventDefault(), n2(o2, a2, l2, t2.shiftKey);
      } else
        t2.keyCode === 8 && e.reverseFillMask !== true && a2 === l2 ? f.left(o2, a2, l2, true) : t2.keyCode === 46 && e.reverseFillMask === true && a2 === l2 && f.rightReverse(o2, a2, l2, true);
    }
    function g(t2) {
      if (t2 === void 0 || t2 === null || t2 === "")
        return "";
      if (e.reverseFillMask === true)
        return b(t2);
      const o2 = i;
      let n2 = 0, a2 = "";
      for (let e2 = 0; e2 < o2.length; e2++) {
        const l2 = t2[n2], i2 = o2[e2];
        if (typeof i2 === "string")
          a2 += i2, l2 === i2 && n2++;
        else {
          if (l2 === void 0 || !i2.regex.test(l2))
            return a2;
          a2 += i2.transform !== void 0 ? i2.transform(l2) : l2, n2++;
        }
      }
      return a2;
    }
    function b(e2) {
      const t2 = i, o2 = a.indexOf(MARKER);
      let n2 = e2.length - 1, l2 = "";
      for (let a2 = t2.length - 1; a2 >= 0 && n2 > -1; a2--) {
        const i2 = t2[a2];
        let r2 = e2[n2];
        if (typeof i2 === "string")
          l2 = i2 + l2, r2 === i2 && n2--;
        else {
          if (r2 === void 0 || !i2.regex.test(r2))
            return l2;
          do {
            l2 = (i2.transform !== void 0 ? i2.transform(r2) : r2) + l2, n2--, r2 = e2[n2];
          } while (o2 === a2 && r2 !== void 0 && i2.regex.test(r2));
        }
      }
      return l2;
    }
    function y(e2) {
      return typeof e2 !== "string" || r === void 0 ? typeof e2 === "number" ? r("" + e2) : e2 : r(e2);
    }
    function S(t2) {
      return l.length - t2.length <= 0 ? t2 : e.reverseFillMask === true && t2.length > 0 ? l.slice(0, -t2.length) + t2 : t2 + l.slice(t2.length);
    }
    return { innerValue: u, hasMask: s2, moveCursorForPaste: m, updateMaskValue: v, onMaskedKeydown: h3 };
  }
  var isJapanese = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\uff00-\uff9f\u4e00-\u9faf\u3400-\u4dbf]/;
  var isChinese = /[\u4e00-\u9fff\u3400-\u4dbf\u{20000}-\u{2a6df}\u{2a700}-\u{2b73f}\u{2b740}-\u{2b81f}\u{2b820}-\u{2ceaf}\uf900-\ufaff\u3300-\u33ff\ufe30-\ufe4f\uf900-\ufaff\u{2f800}-\u{2fa1f}]/u;
  var isKorean = /[\u3131-\u314e\u314f-\u3163\uac00-\ud7a3]/;
  function useKeyComposition(e) {
    return function(t) {
      if (t.type === "compositionend" || t.type === "change") {
        if (t.target.composing !== true)
          return;
        t.target.composing = false, e(t);
      } else
        t.type === "compositionupdate" ? typeof t.data === "string" && isJapanese.test(t.data) === false && isChinese.test(t.data) === false && isKorean.test(t.data) === false && (t.target.composing = false) : t.target.composing = true;
    };
  }
  var QInput = defineComponent2({ name: "QInput", inheritAttrs: false, props: { ...useFieldProps, ...useMaskProps, ...useFormProps, modelValue: { required: false }, shadowText: String, type: { type: String, default: "text" }, debounce: [String, Number], autogrow: Boolean, inputClass: [Array, String, Object], inputStyle: [Array, String, Object] }, emits: [...useFieldEmits, "paste", "change"], setup(e, { emit: t, attrs: o }) {
    const n = {};
    let a, l, i, r, s2 = NaN;
    const u = ref(null), c = useFormInputNameAttr(e), { innerValue: d, hasMask: p2, moveCursorForPaste: v, updateMaskValue: m, onMaskedKeydown: f } = useMask(e, t, P, u), g = useFileFormDomProps(e, true), b = computed2(() => fieldValueIsFilled(d.value)), y = useKeyComposition(T), S = useFieldState(), w = computed2(() => e.type === "textarea" || e.autogrow === true), x = computed2(() => {
      const t2 = { ...S.splitAttrs.listeners.value, onInput: T, onPaste: q, onChange: M, onBlur: B, onFocus: stop2 };
      return t2.onCompositionstart = t2.onCompositionupdate = t2.onCompositionend = y, p2.value === true && (t2.onKeydown = f), e.autogrow === true && (t2.onAnimationend = $), t2;
    }), C = computed2(() => {
      const t2 = { tabindex: 0, "data-autofocus": e.autofocus === true || void 0, rows: e.type === "textarea" ? 6 : void 0, "aria-label": e.label, name: c.value, ...S.splitAttrs.attributes.value, id: S.targetUid.value, maxlength: e.maxlength, disabled: e.disable === true, readonly: e.readonly === true };
      return w.value === false && (t2.type = e.type), e.autogrow === true && (t2.rows = 1), t2;
    });
    function k2() {
      addFocusFn(() => {
        const e2 = document.activeElement;
        u.value === null || u.value === e2 || e2 !== null && e2.id === S.targetUid.value || u.value.focus();
      });
    }
    function _() {
      u.value !== null && u.value.select();
    }
    function q(o2) {
      if (p2.value === true && e.reverseFillMask !== true) {
        const e2 = o2.target;
        v(e2, e2.selectionStart, e2.selectionEnd);
      }
      t("paste", o2);
    }
    function T(o2) {
      if (!o2 || !o2.target || o2.target.composing === true)
        return;
      if (e.type === "file")
        return void t("update:modelValue", o2.target.files);
      const n2 = o2.target.value;
      if (p2.value === true)
        m(n2, false, o2.inputType);
      else if (P(n2), ["text", "search", "url", "tel", "password"].includes(e.type) && o2.target === document.activeElement) {
        const { selectionStart: e2, selectionEnd: t2 } = o2.target;
        e2 !== void 0 && t2 !== void 0 && nextTick2(() => {
          o2.target === document.activeElement && n2.indexOf(o2.target.value) === 0 && o2.target.setSelectionRange(e2, t2);
        });
      }
      e.autogrow === true && $();
    }
    function P(o2, u2) {
      r = () => {
        e.type !== "number" && n.hasOwnProperty("value") === true && delete n.value, e.modelValue !== o2 && s2 !== o2 && (u2 === true && (l = true), t("update:modelValue", o2), nextTick2(() => {
          s2 === o2 && (s2 = NaN);
        })), r = void 0;
      }, e.type === "number" && (a = true, n.value = o2), e.debounce !== void 0 ? (clearTimeout(i), n.value = o2, i = setTimeout(r, e.debounce)) : r();
    }
    function $() {
      const e2 = u.value;
      if (e2 !== null) {
        const t2 = e2.parentNode.style;
        t2.marginBottom = e2.scrollHeight - 1 + "px", e2.style.height = "1px", e2.style.height = e2.scrollHeight + "px", t2.marginBottom = "";
      }
    }
    function M(e2) {
      y(e2), clearTimeout(i), r !== void 0 && r(), t("change", e2.target.value);
    }
    function B(t2) {
      t2 !== void 0 && stop2(t2), clearTimeout(i), r !== void 0 && r(), a = false, l = false, delete n.value, e.type !== "file" && setTimeout(() => {
        u.value !== null && (u.value.value = d.value !== void 0 ? d.value : "");
      });
    }
    function Q() {
      return n.hasOwnProperty("value") === true ? n.value : d.value !== void 0 ? d.value : "";
    }
    watch(() => e.modelValue, (t2) => {
      if (p2.value === true) {
        if (l === true)
          return void (l = false);
        m(t2);
      } else
        d.value !== t2 && (d.value = t2, e.type === "number" && n.hasOwnProperty("value") === true && (a === true ? a = false : delete n.value));
      e.autogrow === true && nextTick2($);
    }), watch(() => e.autogrow, (e2) => {
      e2 === true ? nextTick2($) : u.value !== null && o.rows > 0 && (u.value.style.height = "auto");
    }), watch(() => e.dense, () => {
      e.autogrow === true && nextTick2($);
    }), onBeforeUnmount2(() => {
      B();
    }), onMounted2(() => {
      e.autogrow === true && $();
    }), Object.assign(S, { innerValue: d, fieldClass: computed2(() => `q-${w.value === true ? "textarea" : "input"}` + (e.autogrow === true ? " q-textarea--autogrow" : "")), hasShadow: computed2(() => e.type !== "file" && typeof e.shadowText === "string" && e.shadowText.length > 0), inputRef: u, emitValue: P, hasValue: b, floatingLabel: computed2(() => b.value === true || fieldValueIsFilled(e.displayValue)), getControl: () => {
      return h(w.value === true ? "textarea" : "input", { ref: u, class: ["q-field__native q-placeholder", e.inputClass], style: e.inputStyle, ...C.value, ...x.value, ...e.type !== "file" ? { value: Q() } : g.value });
    }, getShadowControl: () => {
      return h("div", { class: "q-field__native q-field__shadow absolute-bottom no-pointer-events" + (w.value === true ? "" : " text-no-wrap") }, [h("span", { class: "invisible" }, Q()), h("span", e.shadowText)]);
    } });
    const E = useField(S), O = getCurrentInstance();
    return Object.assign(O.proxy, { focus: k2, select: _, getNativeElement: () => u.value }), E;
  } });
  var defaultCfg$1 = { threshold: 0, root: null, rootMargin: "0px" };
  function update$3(e, t, o) {
    let n, a, l;
    typeof o === "function" ? (n = o, a = defaultCfg$1, l = t.cfg === void 0) : (n = o.handler, a = Object.assign({}, defaultCfg$1, o.cfg), l = t.cfg === void 0 || isDeepEqual(t.cfg, a) === false), t.handler !== n && (t.handler = n), l === true && (t.cfg = a, t.observer !== void 0 && t.observer.unobserve(e), t.observer = new IntersectionObserver(([o2]) => {
      if (typeof t.handler === "function") {
        if (o2.rootBounds === null && document.body.contains(e) === true)
          return t.observer.unobserve(e), void t.observer.observe(e);
        const n2 = t.handler(o2, t.observer);
        (n2 === false || t.once === true && o2.isIntersecting === true) && destroy$1(e);
      }
    }, a), t.observer.observe(e));
  }
  function destroy$1(e) {
    const t = e.__qvisible;
    t !== void 0 && (t.observer !== void 0 && t.observer.unobserve(e), delete e.__qvisible);
  }
  var Intersection = { name: "intersection", mounted(e, { modifiers: t, value: o }) {
    const n = { once: t.once === true };
    update$3(e, n, o), e.__qvisible = n;
  }, updated(e, t) {
    const o = e.__qvisible;
    o !== void 0 && update$3(e, o, t.value);
  }, beforeUnmount: destroy$1 };
  var QIntersection = defineComponent2({ name: "QIntersection", props: { tag: { type: String, default: "div" }, once: Boolean, transition: String, ssrPrerender: Boolean, margin: String, threshold: [Number, Array], root: { default: null }, disable: Boolean, onVisibility: Function }, setup(e, { slots: t, emit: o }) {
    const n = ref(isRuntimeSsrPreHydration.value === true && e.ssrPrerender), a = computed2(() => e.root !== void 0 || e.margin !== void 0 || e.threshold !== void 0 ? { handler: r, cfg: { root: e.root, rootMargin: e.margin, threshold: e.threshold } } : r), l = computed2(() => e.disable !== true && (isRuntimeSsrPreHydration.value !== true || e.once !== true || e.ssrPrerender !== true)), i = computed2(() => {
      return [[Intersection, a.value, void 0, { once: e.once }]];
    });
    function r(t2) {
      n.value !== t2.isIntersecting && (n.value = t2.isIntersecting, e.onVisibility !== void 0 && o("visibility", n.value));
    }
    function s2() {
      return n.value === true ? [h("div", { key: "content" }, hSlot(t.default))] : void 0;
    }
    return () => {
      const t2 = e.transition ? [h(Transition, { name: "q-transition--" + e.transition }, s2)] : s2();
      return hDir(e.tag, { class: "q-intersection" }, t2, "main", l.value, () => i.value);
    };
  } });
  var QList = defineComponent2({ name: "QList", props: { ...useDarkProps, bordered: Boolean, dense: Boolean, separator: Boolean, padding: Boolean }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => "q-list" + (e.bordered === true ? " q-list--bordered" : "") + (e.dense === true ? " q-list--dense" : "") + (e.separator === true ? " q-list--separator" : "") + (n.value === true ? " q-list--dark" : "") + (e.padding === true ? " q-list--padding" : ""));
    return () => h("div", { class: a.value }, hSlot(t.default));
  } });
  var keyCodes$1 = [34, 37, 40, 33, 39, 38];
  var commonPropsName = Object.keys(useCircularCommonProps);
  var QKnob = defineComponent2({ name: "QKnob", props: { ...useFormProps, ...useCircularCommonProps, modelValue: { type: Number, required: true }, step: { type: Number, default: 1, validator: (e) => e >= 0 }, tabindex: { type: [Number, String], default: 0 }, disable: Boolean, readonly: Boolean }, emits: ["update:modelValue", "change", "drag-value"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = ref(e.modelValue), i = ref(false);
    let r, s2;
    watch(() => e.modelValue, (t2) => {
      if (t2 < e.min)
        l.value = e.min;
      else {
        if (!(t2 > e.max))
          return void (t2 !== l.value && (l.value = t2));
        l.value = e.max;
      }
      l.value !== e.modelValue && (o("update:modelValue", l.value), o("change", l.value));
    });
    const u = computed2(() => e.disable === false && e.readonly === false), c = computed2(() => "q-knob non-selectable" + (u.value === true ? " q-knob--editable" : e.disable === true ? " disabled" : "")), d = computed2(() => (String(e.step).trim("0").split(".")[1] || "").length), p2 = computed2(() => e.step === 0 ? 1 : e.step), v = computed2(() => e.instantFeedback === true || i.value === true), m = a.platform.is.mobile === true ? computed2(() => u.value === true ? { onClick: x } : {}) : computed2(() => u.value === true ? { onMousedown: w, onClick: x, onKeydown: C, onKeyup: _ } : {}), f = computed2(() => u.value === true ? { tabindex: e.tabindex } : { [`aria-${e.disable === true ? "disabled" : "readonly"}`]: "true" }), g = computed2(() => {
      const t2 = {};
      return commonPropsName.forEach((o2) => {
        t2[o2] = e[o2];
      }), t2;
    });
    function b(e2) {
      e2.isFinal ? (k2(e2.evt, true), i.value = false) : e2.isFirst ? (S(), i.value = true, k2(e2.evt)) : k2(e2.evt);
    }
    const y = computed2(() => {
      return [[TouchPan, b, void 0, { prevent: true, stop: true, mouse: true }]];
    });
    function S() {
      const { top: e2, left: t2, width: o2, height: n2 } = s2.getBoundingClientRect();
      r = { top: e2 + n2 / 2, left: t2 + o2 / 2 };
    }
    function w(e2) {
      S(), k2(e2);
    }
    function x(e2) {
      S(), k2(e2, true);
    }
    function C(t2) {
      if (!keyCodes$1.includes(t2.keyCode))
        return;
      stopAndPrevent(t2);
      const o2 = ([34, 33].includes(t2.keyCode) ? 10 : 1) * p2.value, n2 = [34, 37, 40].includes(t2.keyCode) ? -o2 : o2;
      l.value = between(parseFloat((l.value + n2).toFixed(d.value)), e.min, e.max), q();
    }
    function k2(t2, n2) {
      const i2 = position(t2), s3 = Math.abs(i2.top - r.top), u2 = Math.sqrt(s3 ** 2 + Math.abs(i2.left - r.left) ** 2);
      let c4 = Math.asin(s3 / u2) * (180 / Math.PI);
      c4 = i2.top < r.top ? r.left < i2.left ? 90 - c4 : 270 + c4 : r.left < i2.left ? c4 + 90 : 270 - c4, e.angle && (c4 = normalizeToInterval(c4 - e.angle, 0, 360)), a.lang.rtl === true && (c4 = 360 - c4);
      let v2 = e.min + c4 / 360 * (e.max - e.min);
      if (p2.value !== 0) {
        const e2 = v2 % p2.value;
        v2 = v2 - e2 + (Math.abs(e2) >= p2.value / 2 ? (e2 < 0 ? -1 : 1) * p2.value : 0), v2 = parseFloat(v2.toFixed(d.value));
      }
      v2 = between(v2, e.min, e.max), o("drag-value", v2), l.value !== v2 && (l.value = v2), q(n2);
    }
    function _(e2) {
      keyCodes$1.includes(e2.keyCode) && q(true);
    }
    function q(t2) {
      e.modelValue !== l.value && o("update:modelValue", l.value), t2 === true && o("change", l.value);
    }
    const T = useFormAttrs(e);
    function P() {
      return h("input", T.value);
    }
    return onMounted2(() => {
      s2 = n.$el;
    }), () => {
      const o2 = { class: c.value, role: "slider", "aria-valuemin": e.min, "aria-valuemax": e.max, "aria-valuenow": e.modelValue, ...f.value, ...g.value, value: l.value, instantFeedback: v.value, ...m.value }, n2 = { default: t.default };
      return u.value === true ? (e.name !== void 0 && (n2.internal = P), withDirectives(h(QCircularProgress, o2, n2), y.value)) : h(QCircularProgress, o2, n2);
    };
  } });
  var { passive: passive$2 } = listenOpts;
  var axisValues = ["both", "horizontal", "vertical"];
  var QScrollObserver = defineComponent2({ name: "QScrollObserver", props: { axis: { type: String, validator: (e) => axisValues.includes(e), default: "vertical" }, debounce: [String, Number], scrollTarget: { default: void 0 } }, emits: ["scroll"], setup(e, { emit: t }) {
    const o = { position: { top: 0, left: 0 }, direction: "down", directionChanged: false, delta: { top: 0, left: 0 }, inflectionPoint: { top: 0, left: 0 } };
    let n, a, l = null;
    function i() {
      l = null;
      const a2 = Math.max(0, getVerticalScrollPosition(n)), i2 = getHorizontalScrollPosition(n), r2 = { top: a2 - o.position.top, left: i2 - o.position.left };
      if (e.axis === "vertical" && r2.top === 0 || e.axis === "horizontal" && r2.left === 0)
        return;
      const s3 = Math.abs(r2.top) >= Math.abs(r2.left) ? r2.top < 0 ? "up" : "down" : r2.left < 0 ? "left" : "right";
      o.position = { top: a2, left: i2 }, o.directionChanged = o.direction !== s3, o.delta = r2, o.directionChanged === true && (o.direction = s3, o.inflectionPoint = o.position), t("scroll", { ...o });
    }
    function r() {
      n = getScrollTarget(a, e.scrollTarget), n.addEventListener("scroll", u, passive$2), u(true);
    }
    function s2() {
      n !== void 0 && (n.removeEventListener("scroll", u, passive$2), n = void 0);
    }
    function u(t2) {
      t2 === true || e.debounce === 0 || e.debounce === "0" ? i() : l === null && (l = e.debounce ? setTimeout(i, e.debounce) : requestAnimationFrame(i));
    }
    watch(() => e.scrollTarget, () => {
      s2(), r();
    });
    const c = getCurrentInstance();
    return onMounted2(() => {
      a = c.proxy.$el.parentNode, r();
    }), onBeforeUnmount2(() => {
      clearTimeout(l), cancelAnimationFrame(l), s2();
    }), Object.assign(c.proxy, { trigger: u, getPosition: () => o }), noop;
  } });
  var QLayout = defineComponent2({ name: "QLayout", props: { container: Boolean, view: { type: String, default: "hhh lpr fff", validator: (e) => /^(h|l)h(h|r) lpr (f|l)f(f|r)$/.test(e.toLowerCase()) }, onScroll: Function, onScrollHeight: Function, onResize: Function }, setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = ref(null), l = ref(n.screen.height), i = ref(e.container === true ? 0 : n.screen.width), r = ref({ position: 0, direction: "down", inflectionPoint: 0 }), s2 = ref(0), u = ref(isRuntimeSsrPreHydration.value === true ? 0 : getScrollbarWidth()), c = computed2(() => "q-layout q-layout--" + (e.container === true ? "containerized" : "standard")), d = computed2(() => e.container === false ? { minHeight: n.screen.height + "px" } : null), p2 = computed2(() => u.value !== 0 ? { [n.lang.rtl === true ? "left" : "right"]: `${u.value}px` } : null), v = computed2(() => u.value !== 0 ? { [n.lang.rtl === true ? "right" : "left"]: 0, [n.lang.rtl === true ? "left" : "right"]: `-${u.value}px`, width: `calc(100% + ${u.value}px)` } : null);
    function m(t2) {
      if (e.container === true || document.qScrollPrevented !== true) {
        const n2 = { position: t2.position.top, direction: t2.direction, directionChanged: t2.directionChanged, inflectionPoint: t2.inflectionPoint.top, delta: t2.delta.top };
        r.value = n2, e.onScroll !== void 0 && o("scroll", n2);
      }
    }
    function f(t2) {
      const { height: n2, width: a2 } = t2;
      let r2 = false;
      l.value !== n2 && (r2 = true, l.value = n2, e.onScrollHeight !== void 0 && o("scroll-height", n2), b()), i.value !== a2 && (r2 = true, i.value = a2), r2 === true && e.onResize !== void 0 && o("resize", t2);
    }
    function g({ height: e2 }) {
      s2.value !== e2 && (s2.value = e2, b());
    }
    function b() {
      if (e.container === true) {
        const e2 = l.value > s2.value ? getScrollbarWidth() : 0;
        u.value !== e2 && (u.value = e2);
      }
    }
    let y;
    const S = { instances: {}, view: computed2(() => e.view), isContainer: computed2(() => e.container), rootRef: a, height: l, containerHeight: s2, scrollbarWidth: u, totalWidth: computed2(() => i.value + u.value), rows: computed2(() => {
      const t2 = e.view.toLowerCase().split(" ");
      return { top: t2[0].split(""), middle: t2[1].split(""), bottom: t2[2].split("") };
    }), header: reactive2({ size: 0, offset: 0, space: false }), right: reactive2({ size: 300, offset: 0, space: false }), footer: reactive2({ size: 0, offset: 0, space: false }), left: reactive2({ size: 300, offset: 0, space: false }), scroll: r, animate() {
      y !== void 0 ? clearTimeout(y) : document.body.classList.add("q-body--layout-animate"), y = setTimeout(() => {
        document.body.classList.remove("q-body--layout-animate"), y = void 0;
      }, 155);
    }, update(e2, t2, o2) {
      S[e2][t2] = o2;
    } };
    return provide2(layoutKey, S), () => {
      const o2 = hMergeSlot(t.default, [h(QScrollObserver, { onScroll: m }), h(QResizeObserver, { onResize: f })]), n2 = h("div", { class: c.value, style: d.value, ref: e.container === true ? void 0 : a }, o2);
      return e.container === true ? h("div", { class: "q-layout-container overflow-hidden", ref: a }, [h(QResizeObserver, { onResize: g }), h("div", { class: "absolute-full", style: p2.value }, [h("div", { class: "scroll", style: v.value }, [n2])])]) : n2;
    };
  } });
  var separatorValues = ["horizontal", "vertical", "cell", "none"];
  var QMarkupTable = defineComponent2({ name: "QMarkupTable", props: { ...useDarkProps, dense: Boolean, flat: Boolean, bordered: Boolean, square: Boolean, wrapCells: Boolean, separator: { type: String, default: "horizontal", validator: (e) => separatorValues.includes(e) } }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => `q-markup-table q-table__container q-table__card q-table--${e.separator}-separator` + (n.value === true ? " q-table--dark q-table__card--dark q-dark" : "") + (e.dense === true ? " q-table--dense" : "") + (e.flat === true ? " q-table--flat" : "") + (e.bordered === true ? " q-table--bordered" : "") + (e.square === true ? " q-table--square" : "") + (e.wrapCells === false ? " q-table--no-wrap" : ""));
    return () => h("div", { class: a.value }, [h("table", { class: "q-table" }, hSlot(t.default))]);
  } });
  var QNoSsr = defineComponent2({ name: "QNoSsr", props: { tag: { type: String, default: "div" }, placeholder: String }, setup(e, { slots: t }) {
    const o = useCanRender();
    return () => {
      const n = {};
      if (o.value === true) {
        const o2 = hSlot(t.default);
        return o2 === void 0 ? o2 : o2.length > 1 ? h(e.tag, n, o2) : o2[0];
      }
      n.class = "q-no-ssr-placeholder";
      const a = hSlot(t.placeholder);
      return a !== void 0 ? a.length > 1 ? h(e.tag, n, a) : a[0] : e.placeholder !== void 0 ? h(e.tag, n, e.placeholder) : void 0;
    };
  } });
  var svg$m = h("svg", { class: "q-radio__bg absolute non-selectable", viewBox: "0 0 24 24", "aria-hidden": "true" }, [h("path", { d: "M12,22a10,10 0 0 1 -10,-10a10,10 0 0 1 10,-10a10,10 0 0 1 10,10a10,10 0 0 1 -10,10m0,-22a12,12 0 0 0 -12,12a12,12 0 0 0 12,12a12,12 0 0 0 12,-12a12,12 0 0 0 -12,-12" }), h("path", { class: "q-radio__check", d: "M12,6a6,6 0 0 0 -6,6a6,6 0 0 0 6,6a6,6 0 0 0 6,-6a6,6 0 0 0 -6,-6" })]);
  var QRadio = defineComponent2({ name: "QRadio", props: { ...useDarkProps, ...useSizeProps, ...useFormProps, modelValue: { required: true }, val: { required: true }, label: String, leftLabel: Boolean, color: String, keepColor: Boolean, dense: Boolean, disable: Boolean, tabindex: [String, Number] }, emits: ["update:modelValue"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), a = useDark(e, n.$q), l = useSize(e, optionSizes), i = ref(null), { refocusTargetEl: r, refocusTarget: s2 } = useRefocusTarget(e, i), u = computed2(() => e.modelValue === e.val), c = computed2(() => "q-radio cursor-pointer no-outline row inline no-wrap items-center" + (e.disable === true ? " disabled" : "") + (a.value === true ? " q-radio--dark" : "") + (e.dense === true ? " q-radio--dense" : "") + (e.leftLabel === true ? " reverse" : "")), d = computed2(() => {
      const t2 = e.color === void 0 || e.keepColor !== true && u.value !== true ? "" : ` text-${e.color}`;
      return `q-radio__inner relative-position q-radio__inner--${u.value === true ? "truthy" : "falsy"}${t2}`;
    }), p2 = computed2(() => e.disable === true ? -1 : e.tabindex || 0), v = computed2(() => {
      const t2 = { type: "radio" };
      return e.name !== void 0 && Object.assign(t2, { name: e.name, value: e.val }), t2;
    }), m = computed2(() => e.name !== void 0 && u.value === true ? { checked: true } : {}), f = useFormInject(v, m);
    function g(t2) {
      t2 !== void 0 && (stopAndPrevent(t2), s2(t2)), e.disable !== true && u.value !== true && o("update:modelValue", e.val, t2);
    }
    function b(e2) {
      e2.keyCode !== 13 && e2.keyCode !== 32 || stopAndPrevent(e2);
    }
    function y(e2) {
      e2.keyCode !== 13 && e2.keyCode !== 32 || g(e2);
    }
    return Object.assign(n, { set: g }), () => {
      const o2 = [svg$m];
      e.disable !== true && f(o2, "unshift", " q-radio__native q-ma-none q-pa-none");
      const n2 = [h("div", { class: d.value, style: l.value }, o2)];
      r.value !== null && n2.push(r.value);
      const a2 = e.label !== void 0 ? hMergeSlot(t.default, [e.label]) : hSlot(t.default);
      return a2 !== void 0 && n2.push(h("div", { class: "q-radio__label q-anchor--skip" }, a2)), h("div", { ref: i, class: c.value, tabindex: p2.value, role: "radio", "aria-label": e.label, "aria-checked": u.value === true ? "true" : "false", "aria-disabled": e.disable === true ? "true" : void 0, onClick: g, onKeydown: b, onKeyup: y }, n2);
    };
  } });
  var QToggle = defineComponent2({ name: "QToggle", props: { ...useCheckboxProps, icon: String, checkedIcon: String, uncheckedIcon: String, indeterminateIcon: String, iconColor: String }, emits: useCheckboxEmits, setup(e) {
    function t(t2, o) {
      const n = computed2(() => (t2.value === true ? e.checkedIcon : o.value === true ? e.indeterminateIcon : e.uncheckedIcon) || e.icon), a = computed2(() => {
        if (t2.value === true)
          return e.iconColor;
      });
      return () => [h("div", { class: "q-toggle__track" }), h("div", { class: "q-toggle__thumb absolute flex flex-center no-wrap" }, n.value !== void 0 ? [h(QIcon, { name: n.value, color: a.value })] : void 0)];
    }
    return useCheckbox("toggle", t);
  } });
  var components$1 = { radio: QRadio, checkbox: QCheckbox, toggle: QToggle };
  var typeValues = Object.keys(components$1);
  var QOptionGroup = defineComponent2({ name: "QOptionGroup", props: { ...useDarkProps, modelValue: { required: true }, options: { type: Array, validator: (e) => e.every((e2) => "value" in e2 && "label" in e2) }, name: String, type: { default: "radio", validator: (e) => typeValues.includes(e) }, color: String, keepColor: Boolean, dense: Boolean, size: String, leftLabel: Boolean, inline: Boolean, disable: Boolean }, emits: ["update:modelValue"], setup(e, { emit: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = Array.isArray(e.modelValue);
    e.type === "radio" ? n === true && console.error("q-option-group: model should not be array") : n === false && console.error("q-option-group: model should be array in your case");
    const a = useDark(e, o), l = computed2(() => components$1[e.type]), i = computed2(() => "q-option-group q-gutter-x-sm" + (e.inline === true ? " q-option-group--inline" : "")), r = computed2(() => {
      const t2 = {};
      return e.type === "radio" && (t2.role = "radiogroup", e.disable === true && (t2["aria-disabled"] = "true")), t2;
    });
    function s2(e2) {
      t("update:modelValue", e2);
    }
    return () => h("div", { class: i.value, ...r.value }, e.options.map((t2) => h("div", [h(l.value, { modelValue: e.modelValue, val: t2.value, name: t2.name === void 0 ? e.name : t2.name, disable: e.disable || t2.disable, label: t2.label, leftLabel: t2.leftLabel === void 0 ? e.leftLabel : t2.leftLabel, color: t2.color === void 0 ? e.color : t2.color, checkedIcon: t2.checkedIcon, uncheckedIcon: t2.uncheckedIcon, dark: t2.dark || a.value, size: t2.size === void 0 ? e.size : t2.size, dense: e.dense, keepColor: t2.keepColor === void 0 ? e.keepColor : t2.keepColor, "onUpdate:modelValue": s2 })])));
  } });
  var QPage = defineComponent2({ name: "QPage", props: { padding: Boolean, styleFn: Function }, setup(e, { slots: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = inject2(layoutKey);
    inject2(pageContainerKey, () => {
      console.error("QPage needs to be child of QPageContainer");
    });
    const a = computed2(() => {
      const t2 = (n.header.space === true ? n.header.size : 0) + (n.footer.space === true ? n.footer.size : 0);
      if (typeof e.styleFn === "function") {
        const a2 = n.isContainer.value === true ? n.containerHeight.value : o.screen.height;
        return e.styleFn(t2, a2);
      }
      return { minHeight: n.isContainer.value === true ? n.containerHeight.value - t2 + "px" : o.screen.height === 0 ? t2 !== 0 ? `calc(100vh - ${t2}px)` : "100vh" : o.screen.height - t2 + "px" };
    }), l = computed2(() => `q-page ${e.padding === true ? " q-layout-padding" : ""}`);
    return () => h("main", { class: l.value, style: a.value }, hSlot(t.default));
  } });
  var QPageContainer = defineComponent2({ name: "QPageContainer", setup(e, { slots: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = inject2(layoutKey, () => {
      console.error("QPageContainer needs to be child of QLayout");
    });
    provide2(pageContainerKey, true);
    const a = computed2(() => {
      const e2 = {};
      return n.header.space === true && (e2.paddingTop = `${n.header.size}px`), n.right.space === true && (e2[`padding${o.lang.rtl === true ? "Left" : "Right"}`] = `${n.right.size}px`), n.footer.space === true && (e2.paddingBottom = `${n.footer.size}px`), n.left.space === true && (e2[`padding${o.lang.rtl === true ? "Right" : "Left"}`] = `${n.left.size}px`), e2;
    });
    return () => h("div", { class: "q-page-container", style: a.value }, hSlot(t.default));
  } });
  var usePageStickyProps = { position: { type: String, default: "bottom-right", validator: (e) => ["top-right", "top-left", "bottom-right", "bottom-left", "top", "right", "bottom", "left"].includes(e) }, offset: { type: Array, validator: (e) => e.length === 2 }, expand: Boolean };
  function usePageSticky() {
    const { props: e, proxy: t } = getCurrentInstance(), { $q: o } = t, n = inject2(layoutKey, () => {
      console.error("QPageSticky needs to be child of QLayout");
    }), a = computed2(() => {
      const t2 = e.position;
      return { top: t2.indexOf("top") > -1, right: t2.indexOf("right") > -1, bottom: t2.indexOf("bottom") > -1, left: t2.indexOf("left") > -1, vertical: t2 === "top" || t2 === "bottom", horizontal: t2 === "left" || t2 === "right" };
    }), l = computed2(() => n.header.offset), i = computed2(() => n.right.offset), r = computed2(() => n.footer.offset), s2 = computed2(() => n.left.offset), u = computed2(() => {
      let t2 = 0, n2 = 0;
      const u2 = a.value, c4 = o.lang.rtl === true ? -1 : 1;
      u2.top === true && l.value !== 0 ? n2 = `${l.value}px` : u2.bottom === true && r.value !== 0 && (n2 = `${-r.value}px`), u2.left === true && s2.value !== 0 ? t2 = `${c4 * s2.value}px` : u2.right === true && i.value !== 0 && (t2 = `${-c4 * i.value}px`);
      const d2 = { transform: `translate(${t2}, ${n2})` };
      return e.offset && (d2.margin = `${e.offset[1]}px ${e.offset[0]}px`), u2.vertical === true ? (s2.value !== 0 && (d2[o.lang.rtl === true ? "right" : "left"] = `${s2.value}px`), i.value !== 0 && (d2[o.lang.rtl === true ? "left" : "right"] = `${i.value}px`)) : u2.horizontal === true && (l.value !== 0 && (d2.top = `${l.value}px`), r.value !== 0 && (d2.bottom = `${r.value}px`)), d2;
    }), c = computed2(() => `q-page-sticky row flex-center fixed-${e.position} q-page-sticky--${e.expand === true ? "expand" : "shrink"}`);
    function d(t2) {
      const o2 = hSlot(t2.default);
      return h("div", { class: c.value, style: u.value }, e.expand === true ? o2 : [h("div", o2)]);
    }
    return { $layout: n, getStickyContent: d };
  }
  var QPageScroller = defineComponent2({ name: "QPageScroller", props: { ...usePageStickyProps, scrollOffset: { type: Number, default: 1e3 }, reverse: Boolean, duration: { type: Number, default: 300 }, offset: { default: () => [18, 18] } }, emits: ["click"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), { $layout: a, getStickyContent: l } = usePageSticky(), i = ref(null);
    let r;
    const s2 = computed2(() => a.height.value - (a.isContainer.value === true ? a.containerHeight.value : n.screen.height));
    function u() {
      return e.reverse === true ? s2.value - a.scroll.value.position > e.scrollOffset : a.scroll.value.position > e.scrollOffset;
    }
    const c = ref(u());
    function d() {
      const e2 = u();
      c.value !== e2 && (c.value = e2);
    }
    function p2() {
      e.reverse === true ? r === void 0 && (r = watch(s2, d)) : v();
    }
    function v() {
      r !== void 0 && (r(), r = void 0);
    }
    function m(t2) {
      const n2 = getScrollTarget(a.isContainer.value === true ? i.value : a.rootRef.value);
      setVerticalScrollPosition(n2, e.reverse === true ? a.height.value : 0, e.duration), o("click", t2);
    }
    function f() {
      return c.value === true ? h("div", { ref: i, class: "q-page-scroller", onClick: m }, l(t)) : null;
    }
    return watch(a.scroll, d), watch(() => e.reverse, p2), p2(), onBeforeUnmount2(v), () => h(Transition, { name: "q-transition--fade" }, f);
  } });
  var QPageSticky = defineComponent2({ name: "QPageSticky", props: usePageStickyProps, setup(e, { slots: t }) {
    const { getStickyContent: o } = usePageSticky();
    return () => o(t);
  } });
  var QPagination = defineComponent2({ name: "QPagination", props: { ...useDarkProps, modelValue: { type: Number, required: true }, min: { type: Number, default: 1 }, max: { type: Number, required: true }, color: { type: String, default: "primary" }, textColor: String, activeColor: String, activeTextColor: String, inputStyle: [Array, String, Object], inputClass: [Array, String, Object], size: String, disable: Boolean, input: Boolean, iconPrev: String, iconNext: String, iconFirst: String, iconLast: String, toFn: Function, boundaryLinks: { type: Boolean, default: null }, boundaryNumbers: { type: Boolean, default: null }, directionLinks: { type: Boolean, default: null }, ellipses: { type: Boolean, default: null }, maxPages: { type: Number, default: 0, validator: (e) => e >= 0 }, ripple: { type: [Boolean, Object], default: null }, round: Boolean, rounded: Boolean, flat: Boolean, outline: Boolean, unelevated: Boolean, push: Boolean, glossy: Boolean, dense: Boolean, padding: { type: String, default: "3px 2px" } }, emits: ["update:modelValue"], setup(e, { emit: t }) {
    const { proxy: o } = getCurrentInstance(), { $q: n } = o, a = useDark(e, n), l = ref(null), i = computed2({ get: () => e.modelValue, set: (o2) => {
      if (o2 = parseInt(o2, 10), e.disable || isNaN(o2))
        return;
      const n2 = between(o2, e.min, e.max);
      e.modelValue !== n2 && t("update:modelValue", n2);
    } });
    function r(e2, t2) {
      return [true, false].includes(e2) ? e2 : t2;
    }
    watch(() => e.min + e.max, () => {
      i.value = e.modelValue;
    });
    const s2 = computed2(() => "q-pagination row no-wrap items-center" + (e.disable === true ? " disabled" : "")), u = computed2(() => i.value + " / " + e.max), c = computed2(() => r(e.boundaryLinks, e.input)), d = computed2(() => r(e.boundaryNumbers, !e.input)), p2 = computed2(() => r(e.directionLinks, e.input)), v = computed2(() => r(e.ellipses, !e.input)), m = computed2(() => {
      const t2 = [e.iconFirst || n.iconSet.pagination.first, e.iconPrev || n.iconSet.pagination.prev, e.iconNext || n.iconSet.pagination.next, e.iconLast || n.iconSet.pagination.last];
      return n.lang.rtl === true ? t2.reverse() : t2;
    }), f = computed2(() => e.disable === true ? { "aria-disabled": "true" } : {}), g = computed2(() => ({ round: e.round, rounded: e.rounded, outline: e.outline, unelevated: e.unelevated, push: e.push, glossy: e.glossy, dense: e.dense, padding: e.padding, color: e.color, flat: true, size: e.size, ripple: e.ripple === null || e.ripple })), b = computed2(() => ({ flat: e.flat, color: e.activeColor || e.color, textColor: e.activeTextColor || e.textColor }));
    function y(e2) {
      i.value = e2;
    }
    function S(e2) {
      i.value = i.value + e2;
    }
    function w() {
      i.value = l.value, l.value = null;
    }
    function x(e2, t2) {
      const o2 = { ...g.value, ...e2 };
      return t2 !== void 0 && (o2.toFn !== void 0 ? o2.to = o2.toFn(t2) : o2.onClick = () => y(t2)), h(QBtn, o2);
    }
    return Object.assign(o, { set: y, setByOffset: S }), () => {
      const t2 = [], o2 = [], n2 = [];
      if (c.value && (t2.push(x({ key: "bls", disable: e.disable || e.modelValue <= e.min, icon: m.value[0] }, e.min)), o2.unshift(x({ key: "ble", disable: e.disable || e.modelValue >= e.max, icon: m.value[3] }, e.max))), p2.value && (t2.push(x({ key: "bdp", disable: e.disable || e.modelValue <= e.min, icon: m.value[1] }, e.modelValue - 1)), o2.unshift(x({ key: "bdn", disable: e.disable || e.modelValue >= e.max, icon: m.value[2] }, e.modelValue + 1))), e.input === true)
        n2.push(h(QInput, { class: "inline", style: { width: `${u.value.length / 1.5}em` }, type: "number", dense: true, value: l.value, disable: e.disable, dark: a.value, borderless: true, inputClass: e.inputClass, inputStyle: e.inputStyle, placeholder: u.value, min: e.min, max: e.max, "onUpdate:modelValue"(e2) {
          l.value = e2;
        }, onKeyup(e2) {
          isKeyCode(e2, 13) === true && w();
        }, onBlur: w }));
      else {
        let a2 = Math.max(e.maxPages, 1 + (v.value ? 2 : 0) + (d.value ? 2 : 0)), l2 = e.min, i2 = e.max, r2 = false, s3 = false, u2 = false, c4 = false;
        e.maxPages && a2 < e.max - e.min + 1 && (a2 = 1 + 2 * Math.floor(a2 / 2), l2 = Math.max(e.min, Math.min(e.max - a2 + 1, e.modelValue - Math.floor(a2 / 2))), i2 = Math.min(e.max, l2 + a2 - 1), d.value && (u2 = true, l2 += 1), v.value && l2 > e.min + (d.value ? 1 : 0) && (r2 = true, l2 += 1), d.value && (c4 = true, i2 -= 1), v.value && i2 < e.max - (d.value ? 1 : 0) && (s3 = true, i2 -= 1));
        const p3 = { minWidth: `${Math.max(2, String(e.max).length)}em` };
        if (u2) {
          const o3 = e.min === e.modelValue;
          t2.push(x({ key: "bns", style: p3, disable: e.disable, flat: !o3, textColor: o3 ? e.textColor : void 0, label: e.min }, e.min));
        }
        if (c4) {
          const t3 = e.max === e.modelValue;
          o2.unshift(x({ key: "bne", style: p3, disable: e.disable, flat: !t3, textColor: t3 ? e.textColor : void 0, label: e.max }, e.max));
        }
        r2 && t2.push(x({ key: "bes", style: p3, disable: e.disable, label: "\u2026", ripple: false }, l2 - 1)), s3 && o2.unshift(x({ key: "bee", style: p3, disable: e.disable, label: "\u2026", ripple: false }, i2 + 1));
        for (let t3 = l2; t3 <= i2; t3++) {
          const o3 = { key: `bpg${t3}`, style: p3, disable: e.disable, label: t3 };
          t3 === e.modelValue && Object.assign(o3, b.value), n2.push(x(o3, t3));
        }
      }
      return h("div", { class: s2.value, ...f.value }, [t2, h("div", { class: "row justify-center" }, [n2]), o2]);
    };
  } });
  function frameDebounce(e) {
    let t, o, n = false;
    function a() {
      o = arguments, n !== true && (n = true, t = requestAnimationFrame(() => {
        e.apply(this, o), o = void 0, n = false;
      }));
    }
    return a.cancel = () => {
      window.cancelAnimationFrame(t), n = false;
    }, a;
  }
  var { passive: passive$1 } = listenOpts;
  var QParallax = defineComponent2({ name: "QParallax", props: { src: String, height: { type: Number, default: 500 }, speed: { type: Number, default: 1, validator: (e) => e >= 0 && e <= 1 }, scrollTarget: { default: void 0 }, onScroll: Function }, setup(e, { slots: t, emit: o }) {
    const n = ref(0), a = ref(null), l = ref(null), i = ref(null);
    let r, s2, u, c, d, p2;
    watch(() => e.height, () => {
      r === true && m();
    }), watch(() => e.scrollTarget, () => {
      r === true && (y(), b());
    });
    let v = (t2) => {
      n.value = t2, e.onScroll !== void 0 && o("scroll", t2);
    };
    function m() {
      let t2, o2, n2;
      p2 === window ? (t2 = 0, o2 = window.innerHeight, n2 = o2) : (t2 = offset(p2).top, o2 = height(p2), n2 = t2 + o2);
      const l2 = offset(a.value).top, i2 = l2 + e.height;
      if (d !== void 0 || i2 > t2 && l2 < n2) {
        const t3 = (n2 - l2) / (e.height + o2);
        f((u - e.height) * t3 * e.speed), v(t3);
      }
    }
    let f = (e2) => {
      s2.style.transform = `translate3d(-50%,${Math.round(e2)}px,0)`;
    };
    function g() {
      u = s2.naturalHeight || s2.videoHeight || height(s2), r === true && m();
    }
    function b() {
      r = true, p2 = getScrollTarget(a.value, e.scrollTarget), p2.addEventListener("scroll", m, passive$1), window.addEventListener("resize", c, passive$1), m();
    }
    function y() {
      r === true && (r = false, p2.removeEventListener("scroll", m, passive$1), window.removeEventListener("resize", c, passive$1), p2 = void 0);
    }
    return onMounted2(() => {
      f = frameDebounce(f), v = frameDebounce(v), c = frameDebounce(g), s2 = t.media !== void 0 ? l.value.children[0] : i.value, s2.onload = s2.onloadstart = s2.loadedmetadata = g, g(), s2.style.display = "initial", window.IntersectionObserver !== void 0 ? (d = new IntersectionObserver((e2) => {
        const t2 = e2[0].isIntersecting === true ? b : y;
        t2();
      }), d.observe(a.value)) : b();
    }), onBeforeUnmount2(() => {
      y(), d !== void 0 && d.disconnect(), s2.onload = s2.onloadstart = s2.loadedmetadata = null;
    }), () => {
      return h("div", { ref: a, class: "q-parallax", style: { height: `${e.height}px` } }, [h("div", { ref: l, class: "q-parallax__media absolute-full" }, t.media !== void 0 ? t.media() : [h("img", { ref: i, src: e.src })]), h("div", { class: "q-parallax__content absolute-full column flex-center" }, t.content !== void 0 ? t.content({ percentScrolled: n.value }) : hSlot(t.default))]);
    };
  } });
  function clone(e) {
    const t = JSON.stringify(e);
    if (t)
      return JSON.parse(t);
  }
  var QPopupEdit = defineComponent2({ name: "QPopupEdit", props: { modelValue: { required: true }, title: String, buttons: Boolean, labelSet: String, labelCancel: String, color: { type: String, default: "primary" }, validate: { type: Function, default: () => true }, autoSave: Boolean, cover: { type: Boolean, default: true }, disable: Boolean }, emits: ["update:modelValue", "save", "cancel", "before-show", "show", "before-hide", "hide"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = ref(null), i = ref(""), r = ref("");
    let s2 = false;
    const u = computed2(() => {
      const t2 = { initialValue: i.value, validate: e.validate, set: c, cancel: d, updatePosition: p2 };
      return Object.defineProperty(t2, "value", { get: () => r.value, set: (e2) => {
        r.value = e2;
      } }), t2;
    });
    function c() {
      e.validate(r.value) !== false && (v() === true && (o("save", r.value, i.value), o("update:modelValue", r.value)), m());
    }
    function d() {
      v() === true && o("cancel", r.value, i.value), m();
    }
    function p2() {
      nextTick2(() => {
        l.value.updatePosition();
      });
    }
    function v() {
      return isDeepEqual(r.value, i.value) === false;
    }
    function m() {
      s2 = true, l.value.hide();
    }
    function f() {
      s2 = false, i.value = clone(e.modelValue), r.value = clone(e.modelValue), o("before-show");
    }
    function g() {
      o("show");
    }
    function b() {
      s2 === false && v() === true && (e.autoSave === true && e.validate(r.value) === true ? (o("save", r.value, i.value), o("update:modelValue", r.value)) : o("cancel", r.value, i.value)), o("before-hide");
    }
    function y() {
      o("hide");
    }
    function S() {
      const o2 = t.default !== void 0 ? t.default(u.value).slice() : [];
      return e.title && o2.unshift(h("div", { class: "q-dialog__title q-mt-sm q-mb-sm" }, e.title)), e.buttons === true && o2.push(h("div", { class: "q-popup-edit__buttons row justify-center no-wrap" }, [h(QBtn, { flat: true, color: e.color, label: e.labelCancel || a.lang.label.cancel, onClick: d }), h(QBtn, { flat: true, color: e.color, label: e.labelSet || a.lang.label.set, onClick: c })])), o2;
    }
    return Object.assign(n, { set: c, cancel: d, show(e2) {
      l.value !== null && l.value.show(e2);
    }, hide(e2) {
      l.value !== null && l.value.hide(e2);
    }, updatePosition: p2 }), () => {
      if (e.disable !== true)
        return h(QMenu, { ref: l, class: "q-popup-edit", cover: e.cover, onBeforeShow: f, onShow: g, onBeforeHide: b, onHide: y, onEscapeKey: d }, S);
    };
  } });
  var QPopupProxy = defineComponent2({ name: "QPopupProxy", props: { ...useAnchorProps, breakpoint: { type: [String, Number], default: 450 } }, emits: ["show", "hide"], setup(e, { slots: t, emit: o, attrs: n }) {
    const { proxy: a } = getCurrentInstance(), { $q: l } = a, i = ref(false), r = ref(null), s2 = computed2(() => parseInt(e.breakpoint, 10)), { canShow: u } = useAnchor({ showing: i });
    function c() {
      return l.screen.width < s2.value || l.screen.height < s2.value ? "dialog" : "menu";
    }
    const d = ref(c());
    function p2(e2) {
      i.value = true, o("show", e2);
    }
    function v(e2) {
      i.value = false, d.value = c(), o("hide", e2);
    }
    return watch(() => c(), (e2) => {
      i.value !== true && (d.value = e2);
    }), Object.assign(a, { show(e2) {
      u(e2) === true && r.value.show(e2);
    }, hide(e2) {
      r.value.hide(e2);
    }, toggle(e2) {
      r.value.toggle(e2);
    } }), () => {
      const o2 = hSlot(t.default), a2 = d.value === "menu" && o2 !== void 0 && o2[0] !== void 0 && o2[0].type !== void 0 && ["QDate", "QTime", "QCarousel", "QColor"].includes(o2[0].type.name) ? { cover: true, maxHeight: "99vh" } : {}, l2 = { ref: r, ...a2, ...n, onShow: p2, onHide: v };
      let i2;
      return d.value === "dialog" ? i2 = QDialog : (i2 = QMenu, Object.assign(l2, { target: e.target, contextMenu: e.contextMenu, noParentEvent: true, separateClosePopup: true })), h(i2, l2, () => o2);
    };
  } });
  var defaultSizes = { xs: 2, sm: 4, md: 6, lg: 10, xl: 14 };
  function width(e, t, o) {
    return { transform: t === true ? `translateX(${o.lang.rtl === true ? "-" : ""}100%) scale3d(${-e},1,1)` : `scale3d(${e},1,1)` };
  }
  var QLinearProgress = defineComponent2({ name: "QLinearProgress", props: { ...useDarkProps, ...useSizeProps, value: { type: Number, default: 0 }, buffer: Number, color: String, trackColor: String, reverse: Boolean, stripe: Boolean, indeterminate: Boolean, query: Boolean, rounded: Boolean, instantFeedback: Boolean }, setup(e, { slots: t }) {
    const { proxy: o } = getCurrentInstance(), n = useDark(e, o.$q), a = useSize(e, defaultSizes), l = computed2(() => e.indeterminate === true || e.query === true), i = computed2(() => "q-linear-progress" + (e.color !== void 0 ? ` text-${e.color}` : "") + (e.reverse === true || e.query === true ? " q-linear-progress--reverse" : "") + (e.rounded === true ? " rounded-borders" : "")), r = computed2(() => width(e.buffer !== void 0 ? e.buffer : 1, e.reverse, o.$q)), s2 = computed2(() => `q-linear-progress__track absolute-full q-linear-progress__track--with${e.instantFeedback === true ? "out" : ""}-transition q-linear-progress__track--${n.value === true ? "dark" : "light"}` + (e.trackColor !== void 0 ? ` bg-${e.trackColor}` : "")), u = computed2(() => width(l.value === true ? 1 : e.value, e.reverse, o.$q)), c = computed2(() => `q-linear-progress__model absolute-full q-linear-progress__model--with${e.instantFeedback === true ? "out" : ""}-transition q-linear-progress__model--${l.value === true ? "in" : ""}determinate`), d = computed2(() => ({ width: `${100 * e.value}%` })), p2 = computed2(() => `q-linear-progress__stripe absolute-${e.reverse === true ? "right" : "left"}`);
    return () => {
      const o2 = [h("div", { class: s2.value, style: r.value }), h("div", { class: c.value, style: u.value })];
      return e.stripe === true && l.value === false && o2.push(h("div", { class: p2.value, style: d.value })), h("div", { class: i.value, style: a.value, role: "progressbar", "aria-valuemin": 0, "aria-valuemax": 1, "aria-valuenow": e.indeterminate === true ? void 0 : e.value }, hMergeSlot(t.default, o2));
    };
  } });
  var PULLER_HEIGHT = 40;
  var OFFSET_TOP = 20;
  var QPullToRefresh = defineComponent2({ name: "QPullToRefresh", props: { color: String, bgColor: String, icon: String, noMouse: Boolean, disable: Boolean, scrollTarget: { default: void 0 } }, emits: ["refresh"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = ref("pull"), i = ref(0), r = ref(false), s2 = ref(-PULLER_HEIGHT), u = ref(false), c = ref({}), d = computed2(() => ({ opacity: i.value, transform: `translateY(${s2.value}px) rotate(${360 * i.value}deg)` })), p2 = computed2(() => "q-pull-to-refresh__puller row flex-center" + (u.value === true ? " q-pull-to-refresh__puller--animating" : "") + (e.bgColor !== void 0 ? ` bg-${e.bgColor}` : ""));
    function v(e2) {
      if (e2.isFinal === true)
        return void (r.value === true && (r.value = false, l.value === "pulled" ? (l.value = "refreshing", b({ pos: OFFSET_TOP }), g()) : l.value === "pull" && b({ pos: -PULLER_HEIGHT, ratio: 0 })));
      if (u.value === true || l.value === "refreshing")
        return false;
      if (e2.isFirst === true) {
        if (getVerticalScrollPosition(S) !== 0 || e2.direction !== "down")
          return r.value === true && (r.value = false, l.value = "pull", b({ pos: -PULLER_HEIGHT, ratio: 0 })), false;
        r.value = true;
        const { top: t3, left: o3 } = y.getBoundingClientRect();
        c.value = { top: t3 + "px", left: o3 + "px", width: window.getComputedStyle(y).getPropertyValue("width") };
      }
      prevent(e2.evt);
      const t2 = Math.min(140, Math.max(0, e2.distance.y));
      s2.value = t2 - PULLER_HEIGHT, i.value = between(t2 / (OFFSET_TOP + PULLER_HEIGHT), 0, 1);
      const o2 = s2.value > OFFSET_TOP ? "pulled" : "pull";
      l.value !== o2 && (l.value = o2);
    }
    const m = computed2(() => {
      const t2 = { down: true, mightPrevent: true };
      return e.noMouse !== true && (t2.mouse = true), [[TouchPan, v, void 0, t2]];
    }), f = computed2(() => `q-pull-to-refresh__content${r.value === true ? " no-pointer-events" : ""}`);
    function g() {
      o("refresh", () => {
        b({ pos: -PULLER_HEIGHT, ratio: 0 }, () => {
          l.value = "pull";
        });
      });
    }
    function b({ pos: e2, ratio: t2 }, o2) {
      u.value = true, s2.value = e2, t2 !== void 0 && (i.value = t2), clearTimeout(w), w = setTimeout(() => {
        u.value = false, o2 && o2();
      }, 300);
    }
    let y, S, w;
    function x() {
      S = getScrollTarget(y, e.scrollTarget);
    }
    return Object.assign(n, { trigger: g, updateScrollTarget: x }), watch(() => e.scrollTarget, x), onMounted2(() => {
      y = n.$el, x();
    }), onBeforeUnmount2(() => {
      clearTimeout(w);
    }), () => {
      const o2 = [h("div", { class: f.value }, hSlot(t.default)), h("div", { class: "q-pull-to-refresh__puller-container fixed row flex-center no-pointer-events z-top", style: c.value }, [h("div", { class: p2.value, style: d.value }, [l.value !== "refreshing" ? h(QIcon, { name: e.icon || a.iconSet.pullToRefresh.icon, color: e.color, size: "32px" }) : h(QSpinner, { size: "24px", color: e.color })])])];
      return hDir("div", { class: "q-pull-to-refresh" }, o2, "main", e.disable === false, () => m.value);
    };
  } });
  var dragType = { MIN: 0, RANGE: 1, MAX: 2 };
  var QRange = defineComponent2({ name: "QRange", props: { ...useFormProps, ...useSliderProps, modelValue: { type: Object, default: () => ({ min: null, max: null }), validator(e) {
    return "min" in e && "max" in e;
  } }, name: String, dragRange: Boolean, dragOnlyRange: Boolean, leftLabelColor: String, leftLabelTextColor: String, rightLabelColor: String, rightLabelTextColor: String, leftLabelValue: [String, Number], rightLabelValue: [String, Number] }, emits: useSliderEmits, setup(e, { emit: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = computed2(() => {
      return { type: "hidden", name: e.name, value: `${e.modelValue.min}|${e.modelValue.max}` };
    }), a = useFormInject(n), l = ref(null), i = ref({ min: e.modelValue.min === null ? e.min : e.modelValue.min, max: e.modelValue.max === null ? e.max : e.modelValue.max }), r = ref(null), s2 = ref(0), u = ref(0), { state: c, methods: d } = useSlider({ updateValue: w, updatePosition: C, getDragging: x }), p2 = computed2(() => c.minMaxDiff.value === 0 ? 0 : (i.value.min - e.min) / c.minMaxDiff.value), v = computed2(() => c.active.value === true ? s2.value : p2.value), m = computed2(() => c.minMaxDiff.value === 0 ? 0 : (i.value.max - e.min) / c.minMaxDiff.value), f = computed2(() => c.active.value === true ? u.value : m.value), g = computed2(() => ({ [c.positionProp.value]: `${100 * v.value}%`, [c.sizeProp.value]: `${100 * (f.value - v.value)}%` })), b = computed2(() => {
      if (c.editable.value !== true)
        return {};
      if (o.platform.is.mobile === true)
        return { onClick: d.onMobileClick };
      const t2 = { onMousedown: d.onActivate };
      return e.dragOnlyRange === true && Object.assign(t2, { onFocus: () => {
        k2("both");
      }, onBlur: d.onBlur, onKeydown: _, onKeyup: d.onKeyup }), t2;
    }), y = { domRef: ref(null), events: computed2(() => c.editable.value === true && o.platform.is.mobile !== true && e.dragOnlyRange !== true ? { onFocus: () => {
      k2("min");
    }, onBlur: d.onBlur, onKeydown: _, onKeyup: d.onKeyup } : {}), thumbStyle: computed2(() => ({ [c.positionProp.value]: `${100 * v.value}%`, "z-index": r.value === "min" ? 2 : void 0 })), thumbClass: computed2(() => c.preventFocus.value === false && c.focus.value === "min" ? " q-slider--focus" : ""), pinClass: computed2(() => {
      const t2 = e.leftLabelColor || e.labelColor;
      return t2 ? ` text-${t2}` : "";
    }), pinTextClass: computed2(() => {
      const t2 = e.leftLabelTextColor || e.labelTextColor;
      return t2 ? ` text-${t2}` : "";
    }), pinStyle: computed2(() => {
      const t2 = e.reverse === true ? -v.value : v.value - 1;
      return d.getPinStyle(t2, v.value);
    }), label: computed2(() => e.leftLabelValue !== void 0 ? e.leftLabelValue : i.value.min) }, S = { domRef: ref(null), events: computed2(() => c.editable.value === true && o.platform.is.mobile !== true && e.dragOnlyRange !== true ? { onFocus: () => {
      k2("max");
    }, onBlur: d.onBlur, onKeydown: _, onKeyup: d.onKeyup } : {}), thumbStyle: computed2(() => ({ [c.positionProp.value]: `${100 * f.value}%` })), thumbClass: computed2(() => c.preventFocus.value === false && c.focus.value === "max" ? " q-slider--focus" : ""), pinClass: computed2(() => {
      const t2 = e.rightLabelColor || e.labelColor;
      return t2 ? ` text-${t2}` : "";
    }), pinTextClass: computed2(() => {
      const t2 = e.rightLabelTextColor || e.labelTextColor;
      return t2 ? ` text-${t2}` : "";
    }), pinStyle: computed2(() => {
      const t2 = e.reverse === true ? -f.value : f.value - 1;
      return d.getPinStyle(t2, f.value);
    }), label: computed2(() => e.rightLabelValue !== void 0 ? e.rightLabelValue : i.value.max) };
    function w(o2) {
      i.value.min === e.modelValue.min && i.value.max === e.modelValue.max || t("update:modelValue", { ...i.value }), o2 === true && t("change", { ...i.value });
    }
    function x(t2) {
      const { left: o2, top: n2, width: a2, height: s3 } = l.value.getBoundingClientRect(), u2 = e.dragOnlyRange === true ? 0 : e.vertical === true ? y.domRef.value.offsetHeight / (2 * s3) : y.domRef.value.offsetWidth / (2 * a2), d2 = { left: o2, top: n2, width: a2, height: s3, valueMin: i.value.min, valueMax: i.value.max, ratioMin: p2.value, ratioMax: m.value }, v2 = getRatio(t2, d2, c.isReversed.value, e.vertical);
      let f2;
      return e.dragOnlyRange !== true && v2 < d2.ratioMin + u2 ? f2 = dragType.MIN : e.dragOnlyRange === true || v2 < d2.ratioMax - u2 ? e.dragRange === true || e.dragOnlyRange === true ? (f2 = dragType.RANGE, Object.assign(d2, { offsetRatio: v2, offsetModel: getModel(v2, e.min, e.max, e.step, c.decimals.value), rangeValue: d2.valueMax - d2.valueMin, rangeRatio: d2.ratioMax - d2.ratioMin })) : f2 = d2.ratioMax - v2 < v2 - d2.ratioMin ? dragType.MAX : dragType.MIN : f2 = dragType.MAX, d2.type = f2, r.value = null, d2;
    }
    function C(t2, o2 = c.dragging.value) {
      const n2 = getRatio(t2, o2, c.isReversed.value, e.vertical), a2 = getModel(n2, e.min, e.max, e.step, c.decimals.value);
      let l2;
      switch (o2.type) {
        case dragType.MIN:
          n2 <= o2.ratioMax ? (l2 = { minR: n2, maxR: o2.ratioMax, min: a2, max: o2.valueMax }, r.value = "min") : (l2 = { minR: o2.ratioMax, maxR: n2, min: o2.valueMax, max: a2 }, r.value = "max");
          break;
        case dragType.MAX:
          n2 >= o2.ratioMin ? (l2 = { minR: o2.ratioMin, maxR: n2, min: o2.valueMin, max: a2 }, r.value = "max") : (l2 = { minR: n2, maxR: o2.ratioMin, min: a2, max: o2.valueMin }, r.value = "min");
          break;
        case dragType.RANGE:
          const t3 = n2 - o2.offsetRatio, i2 = between(o2.ratioMin + t3, 0, 1 - o2.rangeRatio), s3 = a2 - o2.offsetModel, u2 = between(o2.valueMin + s3, e.min, e.max - o2.rangeValue);
          l2 = { minR: i2, maxR: i2 + o2.rangeRatio, min: parseFloat(u2.toFixed(c.decimals.value)), max: parseFloat((u2 + o2.rangeValue).toFixed(c.decimals.value)) };
          break;
      }
      i.value = { min: l2.min, max: l2.max }, i.value.min !== null && i.value.max !== null || (i.value.min = l2.min || e.min, i.value.max = l2.max || e.max), e.snap !== true || e.step === 0 ? (s2.value = l2.minR, u.value = l2.maxR) : (s2.value = c.minMaxDiff.value === 0 ? 0 : (i.value.min - e.min) / c.minMaxDiff.value, u.value = c.minMaxDiff.value === 0 ? 0 : (i.value.max - e.min) / c.minMaxDiff.value);
    }
    function k2(e2) {
      c.focus.value = e2;
    }
    function _(t2) {
      if (!keyCodes$2.includes(t2.keyCode))
        return;
      stopAndPrevent(t2);
      const o2 = ([34, 33].includes(t2.keyCode) ? 10 : 1) * e.step, n2 = [34, 37, 40].includes(t2.keyCode) ? -o2 : o2;
      if (e.dragOnlyRange) {
        const t3 = e.dragOnlyRange ? i.value.max - i.value.min : 0, o3 = between(parseFloat((i.value.min + n2).toFixed(c.decimals.value)), e.min, e.max - t3);
        i.value = { min: o3, max: parseFloat((o3 + t3).toFixed(c.decimals.value)) };
      } else {
        if (c.focus.value === false)
          return;
        {
          const t3 = c.focus.value;
          i.value = { ...i.value, [t3]: between(parseFloat((i.value[t3] + n2).toFixed(c.decimals.value)), t3 === "min" ? e.min : i.value.min, t3 === "max" ? e.max : i.value.max) };
        }
      }
      w();
    }
    function q(t2) {
      const o2 = [d.getThumbSvg(), h("div", { class: "q-slider__focus-ring" })];
      return e.label !== true && e.labelAlways !== true || o2.push(h("div", { class: `q-slider__pin q-slider__pin${c.axis.value} absolute` + t2.pinClass.value, style: t2.pinStyle.value.pin }, [h("div", { class: `q-slider__pin-text-container q-slider__pin-text-container${c.axis.value}`, style: t2.pinStyle.value.pinTextContainer }, [h("span", { class: "q-slider__pin-text" + t2.pinTextClass.value }, t2.label.value)])]), h("div", { class: `q-slider__arrow q-slider__arrow${c.axis.value}` + t2.pinClass.value })), h("div", { ref: t2.domRef, class: `q-slider__thumb-container q-slider__thumb-container${c.axis.value} absolute non-selectable` + t2.thumbClass.value, style: t2.thumbStyle.value, ...t2.events.value, tabindex: e.dragOnlyRange !== true ? c.tabindex.value : null }, o2);
    }
    return watch(() => e.modelValue.min, (t2) => {
      i.value.min = t2 === null ? e.min : t2;
    }), watch(() => e.modelValue.max, (t2) => {
      i.value.max = t2 === null ? e.max : t2;
    }), watch(() => e.min, (e2) => {
      i.value.min < e2 && (i.value.min = e2), i.value.max < e2 && (i.value.max = e2);
    }), watch(() => e.max, (e2) => {
      i.value.min > e2 && (i.value.min = e2), i.value.max > e2 && (i.value.max = e2);
    }), () => {
      const t2 = [h("div", { class: `q-slider__track q-slider__track${c.axis.value} absolute`, style: g.value })];
      e.markers === true && t2.push(h("div", { class: `q-slider__track-markers q-slider__track-markers${c.axis.value} absolute-full fit`, style: c.markerStyle.value }));
      const n2 = [h("div", { class: `q-slider__track-container q-slider__track-container${c.axis.value} absolute` }, t2), q(y), q(S)];
      e.name !== void 0 && e.disable !== true && a(n2, "push");
      const i2 = { ref: l, class: "q-range " + c.classes.value + (e.modelValue.min === null || e.modelValue.max === null ? " q-slider--no-value" : ""), ...c.attributes.value, "aria-valuenow": e.modelValue.min + "|" + e.modelValue.max, tabindex: e.dragOnlyRange === true && o.platform.is.mobile !== true ? c.tabindex.value : null, ...b.value };
      return hDir("div", i2, n2, "slide", c.editable.value, () => c.panDirective.value);
    };
  } });
  var QRating = defineComponent2({ name: "QRating", props: { ...useSizeProps, ...useFormProps, modelValue: { type: Number, required: true }, max: { type: [String, Number], default: 5 }, icon: [String, Array], iconHalf: [String, Array], iconSelected: [String, Array], color: [String, Array], colorHalf: [String, Array], colorSelected: [String, Array], noReset: Boolean, noDimming: Boolean, readonly: Boolean, disable: Boolean }, emits: ["update:modelValue"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useSize(e), l = useFormAttrs(e), i = useFormInject(l), r = ref(0);
    let s2 = {};
    const u = computed2(() => e.readonly !== true && e.disable !== true), c = computed2(() => `q-rating row inline items-center q-rating--${u.value === true ? "" : "non-"}editable` + (e.noDimming === true ? " q-rating--no-dimming" : "") + (e.disable === true ? " disabled" : "") + (e.color !== void 0 && Array.isArray(e.color) === false ? ` text-${e.color}` : "")), d = computed2(() => {
      const t2 = Array.isArray(e.icon) === true ? e.icon.length : 0, o2 = Array.isArray(e.iconSelected) === true ? e.iconSelected.length : 0, n2 = Array.isArray(e.iconHalf) === true ? e.iconHalf.length : 0, a2 = Array.isArray(e.color) === true ? e.color.length : 0, l2 = Array.isArray(e.colorSelected) === true ? e.colorSelected.length : 0, i2 = Array.isArray(e.colorHalf) === true ? e.colorHalf.length : 0;
      return { iconLen: t2, icon: t2 > 0 ? e.icon[t2 - 1] : e.icon, selIconLen: o2, selIcon: o2 > 0 ? e.iconSelected[o2 - 1] : e.iconSelected, halfIconLen: n2, halfIcon: n2 > 0 ? e.iconHalf[o2 - 1] : e.iconHalf, colorLen: a2, color: a2 > 0 ? e.color[a2 - 1] : e.color, selColorLen: l2, selColor: l2 > 0 ? e.colorSelected[l2 - 1] : e.colorSelected, halfColorLen: i2, halfColor: i2 > 0 ? e.colorHalf[i2 - 1] : e.colorHalf };
    }), p2 = computed2(() => {
      return e.disable === true ? { "aria-disabled": "true" } : e.readonly === true ? { "aria-readonly": "true" } : void 0;
    });
    function v(t2) {
      if (u.value === true) {
        const n2 = between(parseInt(t2, 10), 1, parseInt(e.max, 10)), a2 = e.noReset !== true && e.modelValue === n2 ? 0 : n2;
        a2 !== e.modelValue && o("update:modelValue", a2), r.value = 0;
      }
    }
    function m(e2) {
      u.value === true && (r.value = e2);
    }
    function f(e2, t2) {
      switch (e2.keyCode) {
        case 13:
        case 32:
          return v(t2), stopAndPrevent(e2);
        case 37:
        case 40:
          return s2[`rt${t2 - 1}`] && s2[`rt${t2 - 1}`].$el.focus(), stopAndPrevent(e2);
        case 39:
        case 38:
          return s2[`rt${t2 + 1}`] && s2[`rt${t2 + 1}`].$el.focus(), stopAndPrevent(e2);
      }
    }
    function g() {
      r.value = 0;
    }
    return onBeforeUpdate(() => {
      s2 = {};
    }), () => {
      const o2 = [], l2 = u.value === true ? 0 : null, b = d.value, y = Math.ceil(e.modelValue), S = e.iconHalf === void 0 || y === e.modelValue ? -1 : y;
      for (let a2 = 1; a2 <= e.max; a2++) {
        const i2 = r.value === 0 && e.modelValue >= a2 || r.value > 0 && r.value >= a2, u2 = S === a2 && r.value < a2, c4 = r.value > 0 && (u2 === true ? y : e.modelValue) >= a2 && r.value < a2, d2 = u2 === true ? a2 <= b.halfIconLen ? e.iconHalf[a2 - 1] : b.halfIcon : b.selIcon === void 0 || i2 !== true && c4 !== true ? a2 <= b.iconLen ? e.icon[a2 - 1] : b.icon : a2 <= b.selIconLen ? e.iconSelected[a2 - 1] : b.selIcon, p3 = u2 === true ? a2 <= b.halfColorLen ? e.colorHalf[a2 - 1] : b.halfColor : b.selColor !== void 0 && i2 === true ? a2 <= b.selColorLen ? e.colorSelected[a2 - 1] : b.selColor : a2 <= b.colorLen ? e.color[a2 - 1] : b.color, w = "q-rating__icon" + (i2 === true || u2 === true ? " q-rating__icon--active" : "") + (c4 === true ? " q-rating__icon--exselected" : "") + (r.value === a2 ? " q-rating__icon--hovered" : "") + (p3 !== void 0 ? ` text-${p3}` : "");
        o2.push(h(QIcon, { key: a2, ref: (e2) => {
          s2[`rt${a2}`] = e2;
        }, class: w, name: d2 || n.iconSet.rating.icon, tabindex: l2, onClick() {
          v(a2);
        }, onMouseover() {
          m(a2);
        }, onMouseout: g, onFocus() {
          m(a2);
        }, onBlur: g, onKeyup(e2) {
          f(e2, a2);
        } }, t[`tip-${a2}`]));
      }
      return e.name !== void 0 && e.disable !== true && i(o2, "push"), h("div", { class: c.value, style: a.value, ...p2.value }, o2);
    };
  } });
  var QResponsive = defineComponent2({ name: "QResponsive", props: useRatioProps, setup(e, { slots: t }) {
    const o = useRatio(e);
    return () => h("div", { class: "q-responsive" }, [h("div", { class: "q-responsive__filler overflow-hidden" }, [h("div", { style: o.value })]), h("div", { class: "q-responsive__content absolute-full fit" }, hSlot(t.default))]);
  } });
  var axisList = ["vertical", "horizontal"];
  var dirProps = { vertical: { offset: "offsetY", scroll: "scrollTop", dir: "down", dist: "y" }, horizontal: { offset: "offsetX", scroll: "scrollLeft", dir: "right", dist: "x" } };
  var QScrollArea = defineComponent2({ name: "QScrollArea", props: { ...useDarkProps, thumbStyle: Object, verticalThumbStyle: Object, horizontalThumbStyle: Object, barStyle: [Array, String, Object], verticalBarStyle: [Array, String, Object], horizontalBarStyle: [Array, String, Object], contentStyle: [Array, String, Object], contentActiveStyle: [Array, String, Object], delay: { type: [String, Number], default: 1e3 }, visible: { type: Boolean, default: null }, tabindex: [String, Number], onScroll: Function }, setup(e, { slots: t, emit: o }) {
    const n = ref(false), a = ref(false), l = ref(false), i = { vertical: ref(0), horizontal: ref(0) }, r = { vertical: { ref: ref(null), position: ref(0), size: ref(0) }, horizontal: { ref: ref(null), position: ref(0), size: ref(0) } }, s2 = getCurrentInstance(), u = useDark(e, s2.proxy.$q);
    let c, d;
    const p2 = ref(null), v = computed2(() => "q-scrollarea" + (u.value === true ? " q-scrollarea--dark" : ""));
    r.vertical.percentage = computed2(() => {
      const e2 = r.vertical.size.value - i.vertical.value;
      if (e2 <= 0)
        return 0;
      const t2 = between(r.vertical.position.value / e2, 0, 1);
      return Math.round(1e4 * t2) / 1e4;
    }), r.vertical.thumbHidden = computed2(() => (e.visible === null ? l.value : e.visible) !== true && n.value === false && a.value === false || r.vertical.size.value <= i.vertical.value + 1), r.vertical.thumbSize = computed2(() => Math.round(between(i.vertical.value * i.vertical.value / r.vertical.size.value, 50, i.vertical.value))), r.vertical.style = computed2(() => {
      const t2 = r.vertical.thumbSize.value, o2 = r.vertical.percentage.value * (i.vertical.value - t2);
      return { ...e.thumbStyle, ...e.verticalThumbStyle, top: `${o2}px`, height: `${t2}px` };
    }), r.vertical.thumbClass = computed2(() => "q-scrollarea__thumb q-scrollarea__thumb--v absolute-right" + (r.vertical.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : "")), r.vertical.barClass = computed2(() => "q-scrollarea__bar q-scrollarea__bar--v absolute-right" + (r.vertical.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : "")), r.horizontal.percentage = computed2(() => {
      const e2 = r.horizontal.size.value - i.horizontal.value;
      if (e2 <= 0)
        return 0;
      const t2 = between(r.horizontal.position.value / e2, 0, 1);
      return Math.round(1e4 * t2) / 1e4;
    }), r.horizontal.thumbHidden = computed2(() => (e.visible === null ? l.value : e.visible) !== true && n.value === false && a.value === false || r.horizontal.size.value <= i.horizontal.value + 1), r.horizontal.thumbSize = computed2(() => Math.round(between(i.horizontal.value * i.horizontal.value / r.horizontal.size.value, 50, i.horizontal.value))), r.horizontal.style = computed2(() => {
      const t2 = r.horizontal.thumbSize.value, o2 = r.horizontal.percentage.value * (i.horizontal.value - t2);
      return { ...e.thumbStyle, ...e.horizontalThumbStyle, left: `${o2}px`, width: `${t2}px` };
    }), r.horizontal.thumbClass = computed2(() => "q-scrollarea__thumb q-scrollarea__thumb--h absolute-bottom" + (r.horizontal.thumbHidden.value === true ? " q-scrollarea__thumb--invisible" : "")), r.horizontal.barClass = computed2(() => "q-scrollarea__bar q-scrollarea__bar--h absolute-bottom" + (r.horizontal.thumbHidden.value === true ? " q-scrollarea__bar--invisible" : ""));
    const m = computed2(() => r.vertical.thumbHidden.value === true || r.horizontal.thumbHidden.value === true ? e.contentStyle : e.contentActiveStyle), f = [[TouchPan, (e2) => {
      k2(e2, "vertical");
    }, void 0, { vertical: true, prevent: true, mouse: true, mouseAllDir: true }]], g = [[TouchPan, (e2) => {
      k2(e2, "horizontal");
    }, void 0, { horizontal: true, prevent: true, mouse: true, mouseAllDir: true }]];
    function b() {
      const e2 = {};
      return axisList.forEach((t2) => {
        const o2 = r[t2];
        e2[t2 + "Position"] = o2.position.value, e2[t2 + "Percentage"] = o2.percentage.value, e2[t2 + "Size"] = o2.size.value, e2[t2 + "ContainerSize"] = i[t2].value;
      }), e2;
    }
    const y = debounce(() => {
      const e2 = b();
      e2.ref = s2.proxy, o("scroll", e2);
    }, 0);
    function S(e2, t2, o2) {
      if (axisList.includes(e2) === false)
        return void console.error("[QScrollArea]: wrong first param of setScrollPosition (vertical/horizontal)");
      const n2 = e2 === "vertical" ? setVerticalScrollPosition : setHorizontalScrollPosition;
      n2(p2.value, t2, o2);
    }
    function w({ height: e2, width: t2 }) {
      let o2 = false;
      i.vertical.value !== e2 && (i.vertical.value = e2, o2 = true), i.horizontal.value !== t2 && (i.horizontal.value = t2, o2 = true), o2 === true && P();
    }
    function x({ position: e2 }) {
      let t2 = false;
      r.vertical.position.value !== e2.top && (r.vertical.position.value = e2.top, t2 = true), r.horizontal.position.value !== e2.left && (r.horizontal.position.value = e2.left, t2 = true), t2 === true && P();
    }
    function C({ height: e2, width: t2 }) {
      r.horizontal.size.value !== t2 && (r.horizontal.size.value = t2, P()), r.vertical.size.value !== e2 && (r.vertical.size.value = e2, P());
    }
    function k2(e2, t2) {
      const o2 = r[t2];
      if (e2.isFirst === true) {
        if (o2.thumbHidden.value === true)
          return;
        d = o2.position.value, a.value = true;
      } else if (a.value !== true)
        return;
      e2.isFinal === true && (a.value = false);
      const n2 = dirProps[t2], l2 = i[t2].value, s3 = (o2.size.value - l2) / (l2 - o2.thumbSize.value), u2 = e2.distance[n2.dist], c4 = d + (e2.direction === n2.dir ? 1 : -1) * u2 * s3;
      $(c4, t2);
    }
    function _(e2, t2) {
      const o2 = r[t2];
      if (o2.thumbHidden.value !== true) {
        const n2 = e2[dirProps[t2].offset] - o2.thumbSize.value / 2;
        $(n2 / i[t2].value * o2.size.value, t2), o2.ref.value !== null && o2.ref.value.dispatchEvent(new MouseEvent(e2.type, e2));
      }
    }
    function q(e2) {
      _(e2, "vertical");
    }
    function T(e2) {
      _(e2, "horizontal");
    }
    function P() {
      n.value === true ? clearTimeout(c) : n.value = true, c = setTimeout(() => {
        n.value = false;
      }, e.delay), e.onScroll !== void 0 && y();
    }
    function $(e2, t2) {
      p2.value[dirProps[t2].scroll] = e2;
    }
    function M() {
      l.value = true;
    }
    function B() {
      l.value = false;
    }
    return Object.assign(s2.proxy, { getScrollTarget: () => p2.value, getScroll: b, getScrollPosition: () => ({ top: r.vertical.position.value, left: r.horizontal.position.value }), getScrollPercentage: () => ({ top: r.vertical.percentage.value, left: r.horizontal.percentage.value }), setScrollPosition: S, setScrollPercentage(e2, t2, o2) {
      S(e2, t2 * (r[e2].size.value - i[e2].value), o2);
    } }), () => {
      return h("div", { class: v.value, onMouseenter: M, onMouseleave: B }, [h("div", { ref: p2, class: "q-scrollarea__container scroll relative-position fit hide-scrollbar", tabindex: e.tabindex !== void 0 ? e.tabindex : void 0 }, [h("div", { class: "q-scrollarea__content absolute", style: m.value }, hMergeSlot(t.default, [h(QResizeObserver, { onResize: C })])), h(QScrollObserver, { axis: "both", onScroll: x })]), h(QResizeObserver, { onResize: w }), h("div", { class: r.vertical.barClass.value, style: [e.barStyle, e.verticalBarStyle], "aria-hidden": "true", onMousedown: q }), h("div", { class: r.horizontal.barClass.value, style: [e.barStyle, e.horizontalBarStyle], "aria-hidden": "true", onMousedown: T }), withDirectives(h("div", { ref: r.vertical.ref, class: r.vertical.thumbClass.value, style: r.vertical.style.value, "aria-hidden": "true" }), f), withDirectives(h("div", { ref: r.horizontal.ref, class: r.horizontal.thumbClass.value, style: r.horizontal.style.value, "aria-hidden": "true" }), g)]);
    };
  } });
  var aggBucketSize = 1e3;
  var scrollToEdges = ["start", "center", "end", "start-force", "center-force", "end-force"];
  var slice = Array.prototype.slice;
  var buggyRTL = void 0;
  {
    const e = document.createElement("div"), t = document.createElement("div");
    e.setAttribute("dir", "rtl"), e.style.width = "1px", e.style.height = "1px", e.style.overflow = "auto", t.style.width = "1000px", t.style.height = "1px", document.body.appendChild(e), e.appendChild(t), e.scrollLeft = -1e3, buggyRTL = e.scrollLeft >= 0, e.remove();
  }
  var id$1 = 1;
  var setOverflowAnchor = window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop : function(e, t) {
    const o = e + "_ss";
    let n = document.getElementById(o);
    n === null && (n = document.createElement("style"), n.type = "text/css", n.id = o, document.head.appendChild(n)), n.qChildIndex !== t && (n.qChildIndex = t, n.innerHTML = `#${e} > *:nth-child(${t}) { overflow-anchor: auto }`);
  };
  function sumFn(e, t) {
    return e + t;
  }
  function getScrollDetails(e, t, o, n, a, l, i, r) {
    const s2 = e === window ? document.scrollingElement || document.documentElement : e, u = a === true ? "offsetWidth" : "offsetHeight", c = { scrollStart: 0, scrollViewSize: -i - r, scrollMaxSize: 0, offsetStart: -i, offsetEnd: -r };
    if (a === true ? (e === window ? (c.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, c.scrollViewSize += window.innerWidth) : (c.scrollStart = s2.scrollLeft, c.scrollViewSize += s2.clientWidth), c.scrollMaxSize = s2.scrollWidth, l === true && (c.scrollStart = (buggyRTL === true ? c.scrollMaxSize - c.scrollViewSize : 0) - c.scrollStart)) : (e === window ? (c.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0, c.scrollViewSize += window.innerHeight) : (c.scrollStart = s2.scrollTop, c.scrollViewSize += s2.clientHeight), c.scrollMaxSize = s2.scrollHeight), o !== null)
      for (let d = o.previousElementSibling; d !== null; d = d.previousElementSibling)
        d.classList.contains("q-virtual-scroll--skip") === false && (c.offsetStart += d[u]);
    if (n !== null)
      for (let d = n.nextElementSibling; d !== null; d = d.nextElementSibling)
        d.classList.contains("q-virtual-scroll--skip") === false && (c.offsetEnd += d[u]);
    if (t !== e) {
      const o2 = s2.getBoundingClientRect(), n2 = t.getBoundingClientRect();
      a === true ? (c.offsetStart += n2.left - o2.left, c.offsetEnd -= n2.width) : (c.offsetStart += n2.top - o2.top, c.offsetEnd -= n2.height), e !== window && (c.offsetStart += c.scrollStart), c.offsetEnd += c.scrollMaxSize - c.offsetStart;
    }
    return c;
  }
  function setScroll(e, t, o, n) {
    e === window ? o === true ? (n === true && (t = (buggyRTL === true ? document.body.scrollWidth - window.innerWidth : 0) - t), window.scrollTo(t, window.pageYOffset || window.scrollY || document.body.scrollTop || 0)) : window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, t) : o === true ? (n === true && (t = (buggyRTL === true ? e.scrollWidth - e.offsetWidth : 0) - t), e.scrollLeft = t) : e.scrollTop = t;
  }
  function sumSize(e, t, o, n) {
    if (o >= n)
      return 0;
    const a = t.length, l = Math.floor(o / aggBucketSize), i = Math.floor((n - 1) / aggBucketSize) + 1;
    let r = e.slice(l, i).reduce(sumFn, 0);
    return o % aggBucketSize !== 0 && (r -= t.slice(l * aggBucketSize, o).reduce(sumFn, 0)), n % aggBucketSize !== 0 && n !== a && (r -= t.slice(n, i * aggBucketSize).reduce(sumFn, 0)), r;
  }
  var commonVirtScrollProps = { virtualScrollSliceSize: { type: [Number, String], default: null }, virtualScrollSliceRatioBefore: { type: [Number, String], default: 1 }, virtualScrollSliceRatioAfter: { type: [Number, String], default: 1 }, virtualScrollItemSize: { type: [Number, String], default: 24 }, virtualScrollStickySizeStart: { type: [Number, String], default: 0 }, virtualScrollStickySizeEnd: { type: [Number, String], default: 0 }, tableColspan: [Number, String] };
  var commonVirtPropsList = Object.keys(commonVirtScrollProps);
  var useVirtualScrollProps = { virtualScrollHorizontal: Boolean, onVirtualScroll: Function, ...commonVirtScrollProps };
  function useVirtualScroll({ virtualScrollLength: e, getVirtualScrollTarget: t, getVirtualScrollEl: o, virtualScrollItemSizeComputed: n }) {
    const a = getCurrentInstance(), { props: l, emit: i, proxy: r } = a, { $q: s2 } = r;
    let u, c, d, p2, v = [];
    const m = "qvs_" + id$1++, f = ref(0), g = ref(0), b = ref({}), y = ref(null), S = ref(null), w = ref(null), x = ref({ from: 0, to: 0 }), C = computed2(() => l.tableColspan !== void 0 ? l.tableColspan : 100);
    n === void 0 && (n = computed2(() => l.virtualScrollItemSize));
    const k2 = computed2(() => n.value + ";" + l.virtualScrollHorizontal), _ = computed2(() => k2.value + ";" + l.virtualScrollSliceRatioBefore + ";" + l.virtualScrollSliceRatioAfter);
    function q() {
      Q(c, true);
    }
    function T(e2) {
      Q(e2 === void 0 ? c : e2);
    }
    function P(n2, a2) {
      const i2 = t();
      if (i2 === void 0 || i2 === null || i2.nodeType === 8)
        return;
      const r2 = getScrollDetails(i2, o(), y.value, S.value, l.virtualScrollHorizontal, s2.lang.rtl, l.virtualScrollStickySizeStart, l.virtualScrollStickySizeEnd);
      d !== r2.scrollViewSize && E(r2.scrollViewSize), M(i2, r2, Math.min(e.value - 1, Math.max(0, parseInt(n2, 10) || 0)), 0, scrollToEdges.indexOf(a2) > -1 ? a2 : c > -1 && n2 > c ? "end" : "start");
    }
    function $() {
      const n2 = t();
      if (n2 === void 0 || n2 === null || n2.nodeType === 8)
        return;
      const a2 = getScrollDetails(n2, o(), y.value, S.value, l.virtualScrollHorizontal, s2.lang.rtl, l.virtualScrollStickySizeStart, l.virtualScrollStickySizeEnd), i2 = e.value - 1, r2 = a2.scrollMaxSize - a2.offsetStart - a2.offsetEnd - g.value;
      if (u === a2.scrollStart)
        return;
      if (a2.scrollMaxSize <= 0)
        return void M(n2, a2, 0, 0);
      d !== a2.scrollViewSize && E(a2.scrollViewSize), B(x.value.from);
      const c4 = Math.floor(a2.scrollMaxSize - Math.max(a2.scrollViewSize, a2.offsetEnd) - Math.min(p2[i2], a2.scrollViewSize / 2));
      if (c4 > 0 && Math.ceil(a2.scrollStart) >= c4)
        return void M(n2, a2, i2, a2.scrollMaxSize - a2.offsetEnd - v.reduce(sumFn, 0));
      let m2 = 0, h3 = a2.scrollStart - a2.offsetStart, b2 = h3;
      if (h3 <= r2 && h3 + a2.scrollViewSize >= f.value)
        h3 -= f.value, m2 = x.value.from, b2 = h3;
      else
        for (let e2 = 0; h3 >= v[e2] && m2 < i2; e2++)
          h3 -= v[e2], m2 += aggBucketSize;
      while (h3 > 0 && m2 < i2)
        h3 -= p2[m2], h3 > -a2.scrollViewSize ? (m2++, b2 = h3) : b2 = p2[m2] + h3;
      M(n2, a2, m2, b2);
    }
    function M(t2, o2, n2, a2, i2) {
      const r2 = typeof i2 === "string" && i2.indexOf("-force") > -1, c4 = r2 === true ? i2.replace("-force", "") : i2, d2 = c4 !== void 0 ? c4 : "start";
      let h3 = Math.max(0, n2 - b.value[d2]), y2 = h3 + b.value.total;
      y2 > e.value && (y2 = e.value, h3 = Math.max(0, y2 - b.value.total)), u = o2.scrollStart;
      const S2 = h3 !== x.value.from || y2 !== x.value.to;
      if (S2 === false && c4 === void 0)
        return void z(n2);
      const { activeElement: C2 } = document;
      if (S2 === true && w.value !== null && w.value !== C2 && w.value.contains(C2) === true) {
        const e2 = () => {
          w.value.focus();
        };
        C2.addEventListener("blur", e2, true), requestAnimationFrame(() => {
          C2.removeEventListener("blur", e2, true);
        });
      }
      setOverflowAnchor(m, n2 - h3 + 1);
      const k3 = c4 !== void 0 ? p2.slice(h3, n2).reduce(sumFn, 0) : 0;
      if (S2 === true) {
        const t3 = y2 >= x.value.from && h3 <= x.value.to ? x.value.to : y2;
        x.value = { from: h3, to: t3 }, f.value = sumSize(v, p2, 0, h3), g.value = sumSize(v, p2, y2, e.value), requestAnimationFrame(() => {
          x.value.to !== y2 && u === o2.scrollStart && (x.value = { from: x.value.from, to: y2 }, g.value = sumSize(v, p2, y2, e.value));
        });
      }
      requestAnimationFrame(() => {
        if (u !== o2.scrollStart)
          return;
        S2 === true && B(h3);
        const e2 = p2.slice(h3, n2).reduce(sumFn, 0), i3 = e2 + o2.offsetStart + f.value, d3 = i3 + p2[n2];
        let v2 = i3 + a2;
        if (c4 !== void 0) {
          const t3 = e2 - k3, a3 = o2.scrollStart + t3;
          v2 = r2 !== true && a3 < i3 && d3 < a3 + o2.scrollViewSize ? a3 : c4 === "end" ? d3 - o2.scrollViewSize : i3 - (c4 === "start" ? 0 : Math.round((o2.scrollViewSize - p2[n2]) / 2));
        }
        u = v2, setScroll(t2, v2, l.virtualScrollHorizontal, s2.lang.rtl), z(n2);
      });
    }
    function B(e2) {
      const t2 = w.value;
      if (t2) {
        const o2 = slice.call(t2.children).filter((e3) => e3.classList.contains("q-virtual-scroll--skip") === false), n2 = o2.length, a2 = l.virtualScrollHorizontal === true ? (e3) => e3.getBoundingClientRect().width : (e3) => e3.offsetHeight;
        let i2, r2, s3 = e2;
        for (let e3 = 0; e3 < n2; ) {
          i2 = a2(o2[e3]), e3++;
          while (e3 < n2 && o2[e3].classList.contains("q-virtual-scroll--with-prev") === true)
            i2 += a2(o2[e3]), e3++;
          r2 = i2 - p2[s3], r2 !== 0 && (p2[s3] += r2, v[Math.floor(s3 / aggBucketSize)] += r2), s3++;
        }
      }
    }
    function Q(t2, o2) {
      const a2 = 1 * n.value;
      o2 !== true && Array.isArray(p2) !== false || (p2 = []);
      const l2 = p2.length;
      p2.length = e.value;
      for (let n2 = e.value - 1; n2 >= l2; n2--)
        p2[n2] = a2;
      const i2 = Math.floor((e.value - 1) / aggBucketSize);
      v = [];
      for (let n2 = 0; n2 <= i2; n2++) {
        let t3 = 0;
        const o3 = Math.min((n2 + 1) * aggBucketSize, e.value);
        for (let e2 = n2 * aggBucketSize; e2 < o3; e2++)
          t3 += p2[e2];
        v.push(t3);
      }
      c = -1, u = void 0, t2 >= 0 ? (B(x.value.from), nextTick2(() => {
        P(t2);
      })) : (f.value = sumSize(v, p2, 0, x.value.from), g.value = sumSize(v, p2, x.value.to, e.value), F());
    }
    function E(e2) {
      if (e2 === void 0 && typeof window !== "undefined") {
        const n2 = t();
        n2 !== void 0 && n2 !== null && n2.nodeType !== 8 && (e2 = getScrollDetails(n2, o(), y.value, S.value, l.virtualScrollHorizontal, s2.lang.rtl, l.virtualScrollStickySizeStart, l.virtualScrollStickySizeEnd).scrollViewSize);
      }
      d = e2;
      const a2 = 1 + l.virtualScrollSliceRatioBefore + l.virtualScrollSliceRatioAfter, i2 = e2 === void 0 || e2 <= 0 ? 1 : Math.ceil(e2 / n.value), r2 = Math.max(10, i2, Math.ceil(l.virtualScrollSliceSize / a2));
      b.value = { total: Math.ceil(r2 * a2), start: Math.ceil(r2 * l.virtualScrollSliceRatioBefore), center: Math.ceil(r2 * (0.5 + l.virtualScrollSliceRatioBefore)), end: Math.ceil(r2 * (1 + l.virtualScrollSliceRatioBefore)), view: i2 };
    }
    function O(e2, t2) {
      const o2 = l.virtualScrollHorizontal === true ? "width" : "height", a2 = { ["--q-virtual-scroll-item-" + o2]: n.value + "px" };
      return [e2 === "tbody" ? h(e2, { class: "q-virtual-scroll__padding", key: "before", ref: y }, [h("tr", [h("td", { style: { [o2]: `${f.value}px`, ...a2 }, colspan: C.value })])]) : h(e2, { class: "q-virtual-scroll__padding", key: "before", ref: y, style: { [o2]: `${f.value}px`, ...a2 } }), h(e2, { class: "q-virtual-scroll__content", key: "content", ref: w, id: m, tabindex: -1 }, t2.flat()), e2 === "tbody" ? h(e2, { class: "q-virtual-scroll__padding", key: "after", ref: S }, [h("tr", [h("td", { style: { [o2]: `${g.value}px`, ...a2 }, colspan: C.value })])]) : h(e2, { class: "q-virtual-scroll__padding", key: "after", ref: S, style: { [o2]: `${g.value}px`, ...a2 } })];
    }
    function z(e2) {
      c !== e2 && (l.onVirtualScroll !== void 0 && i("virtual-scroll", { index: e2, from: x.value.from, to: x.value.to - 1, direction: e2 < c ? "decrease" : "increase", ref: r }), c = e2);
    }
    watch(_, () => {
      E();
    }), watch(k2, q), E();
    const F = debounce($, s2.platform.is.ios === true ? 120 : 35);
    return onBeforeMount(() => {
      E();
    }), setOverflowAnchor !== noop && onBeforeUnmount2(() => {
      const e2 = document.getElementById(m + "_ss");
      e2 !== null && e2.remove();
    }), Object.assign(r, { scrollTo: P, reset: q, refresh: T }), { virtualScrollSliceRange: x, virtualScrollSliceSizeComputed: b, setVirtualScrollSize: E, onVirtualScrollEvt: F, localResetVirtualScroll: Q, padVirtualScroll: O, scrollTo: P, reset: q, refresh: T };
  }
  var validateNewValueMode = (e) => ["add", "add-unique", "toggle"].includes(e);
  var reEscapeList = ".*+?^${}()|[]\\";
  var fieldPropsList = Object.keys(useFieldProps);
  var QSelect = defineComponent2({ name: "QSelect", inheritAttrs: false, props: { ...useVirtualScrollProps, ...useFormProps, ...useFieldProps, modelValue: { required: true }, multiple: Boolean, displayValue: [String, Number], displayValueHtml: Boolean, dropdownIcon: String, options: { type: Array, default: () => [] }, optionValue: [Function, String], optionLabel: [Function, String], optionDisable: [Function, String], hideSelected: Boolean, hideDropdownIcon: Boolean, fillInput: Boolean, maxValues: [Number, String], optionsDense: Boolean, optionsDark: { type: Boolean, default: null }, optionsSelectedClass: String, optionsHtml: Boolean, optionsCover: Boolean, menuShrink: Boolean, menuAnchor: String, menuSelf: String, menuOffset: Array, popupContentClass: String, popupContentStyle: [String, Array, Object], useInput: Boolean, useChips: Boolean, newValueMode: { type: String, validator: validateNewValueMode }, mapOptions: Boolean, emitValue: Boolean, inputDebounce: { type: [Number, String], default: 500 }, inputClass: [Array, String, Object], inputStyle: [Array, String, Object], tabindex: { type: [String, Number], default: 0 }, autocomplete: String, transitionShow: String, transitionHide: String, transitionDuration: [String, Number], behavior: { type: String, validator: (e) => ["default", "menu", "dialog"].includes(e), default: "default" }, virtualScrollItemSize: { type: [Number, String], default: void 0 }, onNewValue: Function, onFilter: Function }, emits: [...useFieldEmits, "add", "remove", "input-value", "keyup", "keypress", "keydown", "filter-abort"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = ref(false), i = ref(false), r = ref(-1), s2 = ref(""), u = ref(false), c = ref(false);
    let d, p2, v, m, f, g, b, y, S, w;
    const x = ref(null), C = ref(null), k2 = ref(null), _ = ref(null), q = ref(null), T = useFormInputNameAttr(e), P = useKeyComposition(qe), $ = computed2(() => Array.isArray(e.options) ? e.options.length : 0), M = computed2(() => e.virtualScrollItemSize === void 0 ? e.dense === true ? 24 : 48 : e.virtualScrollItemSize), { virtualScrollSliceRange: B, virtualScrollSliceSizeComputed: Q, localResetVirtualScroll: E, padVirtualScroll: O, onVirtualScrollEvt: z, scrollTo: F, setVirtualScrollSize: L } = useVirtualScroll({ virtualScrollLength: $, getVirtualScrollTarget: xe, getVirtualScrollEl: we, virtualScrollItemSizeComputed: M }), R = useFieldState(), V = computed2(() => {
      const t2 = e.mapOptions === true && e.multiple !== true, o2 = e.modelValue === void 0 || e.modelValue === null && t2 !== true ? [] : e.multiple === true && Array.isArray(e.modelValue) ? e.modelValue : [e.modelValue];
      if (e.mapOptions === true && Array.isArray(e.options) === true) {
        const n2 = e.mapOptions === true && p2 !== void 0 ? p2 : [], a2 = o2.map((e2) => ve(e2, n2));
        return e.modelValue === null && t2 === true ? a2.filter((e2) => e2 !== null) : a2;
      }
      return o2;
    }), I = computed2(() => {
      const t2 = {};
      return fieldPropsList.forEach((t3) => e[t3]), t2;
    }), A = computed2(() => e.optionsDark === null ? R.isDark.value : e.optionsDark), D = computed2(() => fieldValueIsFilled(V.value)), N = computed2(() => {
      let t2 = "q-field__input q-placeholder col";
      return e.hideSelected === true || V.value.length === 0 ? [t2, e.inputClass] : (t2 += " q-field__input--padding", e.inputClass === void 0 ? t2 : [t2, e.inputClass]);
    }), H = computed2(() => (e.virtualScrollHorizontal === true ? "q-virtual-scroll--horizontal" : "") + (e.popupContentClass ? " " + e.popupContentClass : "")), j = computed2(() => $.value === 0), U = computed2(() => V.value.map((e2) => oe.value(e2)).join(", ")), K = computed2(() => e.optionsHtml === true ? () => true : (e2) => e2 !== void 0 && e2 !== null && e2.html === true), W = computed2(() => e.displayValueHtml === true || e.displayValue === void 0 && (e.optionsHtml === true || V.value.some(K.value))), Y = computed2(() => R.focused.value === true ? e.tabindex : -1), G = computed2(() => {
      return V.value.map((e2, t2) => ({ index: t2, opt: e2, html: K.value(e2), selected: true, removeAtIndex: se, toggleOption: ce, tabindex: Y.value }));
    }), X = computed2(() => {
      if ($.value === 0)
        return [];
      const { from: t2, to: o2 } = B.value, { options: n2, optionEls: l2 } = v;
      return e.options.slice(t2, o2).map((o3, i2) => {
        const s3 = ne.value(o3) === true, u2 = t2 + i2, c4 = { clickable: true, active: false, activeClass: ee.value, manualFocus: true, focused: false, disable: s3, tabindex: -1, dense: e.optionsDense, dark: A.value, onClick: () => {
          ce(o3);
        } };
        s3 !== true && (fe(o3) === true && (c4.active = true), r.value === u2 && (c4.focused = true), a.platform.is.desktop === true && (c4.onMousemove = () => {
          de(u2);
        }));
        const d2 = { index: u2, opt: o3, html: K.value(o3), label: oe.value(o3), selected: c4.active, focused: c4.focused, toggleOption: ce, setOptionIndex: de, itemProps: c4 }, p3 = { ...d2, itemProps: { ...c4, onClick: void 0, onMousemove: void 0 } };
        return n2[i2] !== void 0 && isDeepEqual(p3, n2[i2]) === true || (n2[i2] = p3, l2[i2] = void 0), d2;
      });
    }), Z = computed2(() => e.dropdownIcon !== void 0 ? e.dropdownIcon : a.iconSet.arrow.dropdown), J = computed2(() => e.optionsCover === false && e.outlined !== true && e.standout !== true && e.borderless !== true && e.rounded !== true), ee = computed2(() => e.optionsSelectedClass !== void 0 ? e.optionsSelectedClass : e.color !== void 0 ? `text-${e.color}` : ""), te = computed2(() => me(e.optionValue, "value")), oe = computed2(() => me(e.optionLabel, "label")), ne = computed2(() => me(e.optionDisable, "disable")), ae = computed2(() => V.value.map((e2) => te.value(e2))), le = computed2(() => {
      const e2 = { onInput: qe, onChange: P, onKeydown: Se, onKeyup: be, onKeypress: ye, onFocus: he, onClick(e3) {
        m === true && stop2(e3);
      } };
      return e2.onCompositionstart = e2.onCompositionupdate = e2.onCompositionend = P, e2;
    });
    function ie(t2) {
      return e.emitValue === true ? te.value(t2) : t2;
    }
    function re(t2) {
      if (t2 > -1 && t2 < V.value.length)
        if (e.multiple === true) {
          const n2 = e.modelValue.slice();
          o("remove", { index: t2, value: n2.splice(t2, 1)[0] }), o("update:modelValue", n2);
        } else
          o("update:modelValue", null);
    }
    function se(e2) {
      re(e2), R.focus();
    }
    function ue(t2, n2) {
      const a2 = ie(t2);
      if (e.multiple !== true)
        return e.fillInput === true && Pe(oe.value(t2), true, true), void o("update:modelValue", a2);
      if (V.value.length === 0)
        return o("add", { index: 0, value: a2 }), void o("update:modelValue", e.multiple === true ? [a2] : a2);
      if (n2 === true && fe(t2) === true)
        return;
      if (e.maxValues !== void 0 && e.modelValue.length >= e.maxValues)
        return;
      const l2 = e.modelValue.slice();
      o("add", { index: l2.length, value: a2 }), l2.push(a2), o("update:modelValue", l2);
    }
    function ce(t2, n2) {
      if (R.editable.value !== true || t2 === void 0 || ne.value(t2) === true)
        return;
      const a2 = te.value(t2);
      if (e.multiple !== true)
        return n2 !== true && (Pe(e.fillInput === true ? oe.value(t2) : "", true, true), Ae()), C.value !== null && C.value.focus(), void (isDeepEqual(te.value(V.value[0]), a2) !== true && o("update:modelValue", e.emitValue === true ? a2 : t2));
      if ((m !== true || u.value === true) && R.focus(), he(), V.value.length === 0) {
        const n3 = e.emitValue === true ? a2 : t2;
        return o("add", { index: 0, value: n3 }), void o("update:modelValue", e.multiple === true ? [n3] : n3);
      }
      const l2 = e.modelValue.slice(), i2 = ae.value.findIndex((e2) => isDeepEqual(e2, a2));
      if (i2 > -1)
        o("remove", { index: i2, value: l2.splice(i2, 1)[0] });
      else {
        if (e.maxValues !== void 0 && l2.length >= e.maxValues)
          return;
        const n3 = e.emitValue === true ? a2 : t2;
        o("add", { index: l2.length, value: n3 }), l2.push(n3);
      }
      o("update:modelValue", l2);
    }
    function de(e2) {
      if (a.platform.is.desktop !== true)
        return;
      const t2 = e2 > -1 && e2 < $.value ? e2 : -1;
      r.value !== t2 && (r.value = t2);
    }
    function pe(t2 = 1, o2) {
      if (l.value === true) {
        let n2 = r.value;
        do {
          n2 = normalizeToInterval(n2 + t2, -1, $.value - 1);
        } while (n2 !== -1 && n2 !== r.value && ne.value(e.options[n2]) === true);
        r.value !== n2 && (de(n2), F(n2), o2 !== true && e.useInput === true && e.fillInput === true && Te(n2 >= 0 ? oe.value(e.options[n2]) : b));
      }
    }
    function ve(t2, o2) {
      const n2 = (e2) => isDeepEqual(te.value(e2), t2);
      return e.options.find(n2) || o2.find(n2) || t2;
    }
    function me(e2, t2) {
      const o2 = e2 !== void 0 ? e2 : t2;
      return typeof o2 === "function" ? o2 : (e3) => Object(e3) === e3 && o2 in e3 ? e3[o2] : e3;
    }
    function fe(e2) {
      const t2 = te.value(e2);
      return ae.value.find((e3) => isDeepEqual(e3, t2)) !== void 0;
    }
    function he() {
      e.useInput === true && C.value !== null && C.value.select();
    }
    function ge(e2) {
      isKeyCode(e2, 27) === true && l.value === true && (stop2(e2), Ae(), De()), o("keyup", e2);
    }
    function be(t2) {
      const { value: o2 } = t2.target;
      if (t2.keyCode === void 0)
        if (t2.target.value = "", clearTimeout(d), De(), typeof o2 === "string" && o2.length > 0) {
          const t3 = o2.toLocaleLowerCase();
          let n2 = (e2) => te.value(e2).toLocaleLowerCase() === t3, a2 = e.options.find(n2);
          a2 !== void 0 ? V.value.indexOf(a2) === -1 ? ce(a2) : Ae() : (n2 = (e2) => oe.value(e2).toLocaleLowerCase() === t3, a2 = e.options.find(n2), a2 !== void 0 ? V.value.indexOf(a2) === -1 ? ce(a2) : Ae() : $e(o2, true));
        } else
          R.clearValue(t2);
      else
        ge(t2);
    }
    function ye(e2) {
      o("keypress", e2);
    }
    function Se(t2) {
      if (o("keydown", t2), shouldIgnoreKey(t2) === true)
        return;
      const n2 = s2.value.length > 0 && (e.newValueMode !== void 0 || e.onNewValue !== void 0), a2 = t2.shiftKey !== true && e.multiple !== true && (r.value > -1 || n2 === true);
      if (t2.keyCode === 27)
        return void prevent(t2);
      if (t2.keyCode === 9 && a2 === false)
        return void Ve();
      if (t2.target === void 0 || t2.target.id !== R.targetUid.value)
        return;
      if (t2.keyCode === 40 && R.innerLoading.value !== true && l.value === false)
        return stopAndPrevent(t2), void Ie();
      if (t2.keyCode === 8 && e.hideSelected !== true && s2.value.length === 0)
        return void (e.multiple === true && Array.isArray(e.modelValue) === true ? re(e.modelValue.length - 1) : e.multiple !== true && e.modelValue !== null && o("update:modelValue", null));
      t2.keyCode !== 35 && t2.keyCode !== 36 || typeof s2.value === "string" && s2.value.length !== 0 || (stopAndPrevent(t2), r.value = -1, pe(t2.keyCode === 36 ? 1 : -1, e.multiple)), t2.keyCode !== 33 && t2.keyCode !== 34 || Q.value === void 0 || (stopAndPrevent(t2), r.value = Math.max(-1, Math.min($.value, r.value + (t2.keyCode === 33 ? -1 : 1) * Q.value.view)), pe(t2.keyCode === 33 ? 1 : -1, e.multiple)), t2.keyCode !== 38 && t2.keyCode !== 40 || (stopAndPrevent(t2), pe(t2.keyCode === 38 ? -1 : 1, e.multiple));
      const i2 = $.value;
      if ((S === void 0 || w < Date.now()) && (S = ""), i2 > 0 && e.useInput !== true && t2.key !== void 0 && t2.key.length === 1 && t2.altKey === t2.ctrlKey && (t2.keyCode !== 32 || S.length > 0)) {
        l.value !== true && Ie(t2);
        const o2 = t2.key.toLocaleLowerCase(), n3 = S.length === 1 && S[0] === o2;
        w = Date.now() + 1500, n3 === false && (stopAndPrevent(t2), S += o2);
        const a3 = new RegExp("^" + S.split("").map((e2) => reEscapeList.indexOf(e2) > -1 ? "\\" + e2 : e2).join(".*"), "i");
        let s3 = r.value;
        if (n3 === true || s3 < 0 || a3.test(oe.value(e.options[s3])) !== true)
          do {
            s3 = normalizeToInterval(s3 + 1, -1, i2 - 1);
          } while (s3 !== r.value && (ne.value(e.options[s3]) === true || a3.test(oe.value(e.options[s3])) !== true));
        r.value !== s3 && nextTick2(() => {
          de(s3), F(s3), s3 >= 0 && e.useInput === true && e.fillInput === true && Te(oe.value(e.options[s3]));
        });
      } else if (t2.keyCode === 13 || t2.keyCode === 32 && e.useInput !== true && S === "" || t2.keyCode === 9 && a2 !== false)
        if (t2.keyCode !== 9 && stopAndPrevent(t2), r.value > -1 && r.value < i2)
          ce(e.options[r.value]);
        else {
          if (n2 === true) {
            const t3 = (t4, o2) => {
              if (o2) {
                if (validateNewValueMode(o2) !== true)
                  return;
              } else
                o2 = e.newValueMode;
              if (t4 === void 0 || t4 === null)
                return;
              Pe("", e.multiple !== true, true);
              const n3 = o2 === "toggle" ? ce : ue;
              n3(t4, o2 === "add-unique"), e.multiple !== true && (C.value !== null && C.value.focus(), Ae());
            };
            if (e.onNewValue !== void 0 ? o("new-value", s2.value, t3) : t3(s2.value), e.multiple !== true)
              return;
          }
          l.value === true ? Ve() : R.innerLoading.value !== true && Ie();
        }
    }
    function we() {
      return m === true ? q.value : k2.value !== null && k2.value.__qPortalInnerRef.value !== null ? k2.value.__qPortalInnerRef.value : void 0;
    }
    function xe() {
      return we();
    }
    function Ce() {
      return e.hideSelected === true ? [] : t["selected-item"] !== void 0 ? G.value.map((e2) => t["selected-item"](e2)).slice() : t.selected !== void 0 ? t.selected().slice() : e.useChips === true ? G.value.map((t2, o2) => h(QChip, { key: "option-" + o2, removable: R.editable.value === true && ne.value(t2.opt) !== true, dense: true, textColor: e.color, tabindex: Y.value, onRemove() {
        t2.removeAtIndex(o2);
      } }, () => h("span", { class: "ellipsis", [t2.html === true ? "innerHTML" : "textContent"]: oe.value(t2.opt) }))) : [h("span", { [W.value === true ? "innerHTML" : "textContent"]: e.displayValue !== void 0 ? e.displayValue : U.value })];
    }
    function ke() {
      t.option !== void 0 && v.optionSlot !== t.option && (v.optionSlot = t.option, v.optionEls = []);
      const e2 = t.option !== void 0 ? t.option : (e3) => {
        return h(QItem, { key: e3.index, ...e3.itemProps }, () => {
          return h(QItemSection, () => h(QItemLabel, () => h("span", { [e3.html === true ? "innerHTML" : "textContent"]: e3.label })));
        });
      }, { optionEls: o2 } = v;
      let n2 = O("div", X.value.map((t2, n3) => {
        return o2[n3] === void 0 && (o2[n3] = e2(t2)), o2[n3];
      }));
      return t["before-options"] !== void 0 && (n2 = t["before-options"]().concat(n2)), hMergeSlot(t["after-options"], n2);
    }
    function _e(t2, o2) {
      const n2 = { ref: o2 === true ? C : void 0, key: "i_t", class: N.value, style: e.inputStyle, value: s2.value !== void 0 ? s2.value : "", type: "search", ...R.splitAttrs.attributes.value, id: R.targetUid.value, maxlength: e.maxlength, tabindex: e.tabindex, autocomplete: e.autocomplete, "data-autofocus": t2 !== true && e.autofocus === true || void 0, disabled: e.disable === true, readonly: e.readonly === true, ...le.value };
      return t2 !== true && m === true && (Array.isArray(n2.class) === true ? n2.class[0] += " no-pointer-events" : n2.class += " no-pointer-events"), h("input", n2);
    }
    function qe(t2) {
      clearTimeout(d), t2 && t2.target && t2.target.composing === true || (Te(t2.target.value || ""), f = true, b = s2.value, R.focused.value === true || m === true && u.value !== true || R.focus(), e.onFilter !== void 0 && (d = setTimeout(() => {
        $e(s2.value);
      }, e.inputDebounce)));
    }
    function Te(e2) {
      s2.value !== e2 && (s2.value = e2, o("input-value", e2));
    }
    function Pe(t2, o2, n2) {
      f = n2 !== true, e.useInput === true && (Te(t2), o2 !== true && n2 === true || (b = t2), o2 !== true && $e(t2));
    }
    function $e(t2, a2) {
      if (e.onFilter === void 0 || a2 !== true && R.focused.value !== true)
        return;
      R.innerLoading.value === true ? o("filter-abort") : (R.innerLoading.value = true, c.value = true), t2 !== "" && e.multiple !== true && V.value.length > 0 && f !== true && t2 === oe.value(V.value[0]) && (t2 = "");
      const i2 = setTimeout(() => {
        l.value === true && (l.value = false);
      }, 10);
      clearTimeout(g), g = i2, o("filter", t2, (e2, t3) => {
        a2 !== true && R.focused.value !== true || g !== i2 || (clearTimeout(g), typeof e2 === "function" && e2(), c.value = false, nextTick2(() => {
          R.innerLoading.value = false, R.editable.value === true && (a2 === true ? l.value === true && Ae() : l.value === true ? Ne(true) : l.value = true), typeof t3 === "function" && nextTick2(() => {
            t3(n);
          });
        }));
      }, () => {
        R.focused.value === true && g === i2 && (clearTimeout(g), R.innerLoading.value = false, c.value = false), l.value === true && (l.value = false);
      });
    }
    function Me() {
      const o2 = j.value === true ? t["no-option"] !== void 0 ? () => t["no-option"]({ inputValue: s2.value }) : void 0 : ke;
      return h(QMenu, { ref: k2, class: H.value, style: e.popupContentStyle, modelValue: l.value, fit: e.menuShrink !== true, cover: e.optionsCover === true && j.value !== true && e.useInput !== true, anchor: e.menuAnchor, self: e.menuSelf, offset: e.menuOffset, dark: A.value, noParentEvent: true, noRefocus: true, noFocus: true, square: J.value, transitionShow: e.transitionShow, transitionHide: e.transitionHide, transitionDuration: e.transitionDuration, separateClosePopup: true, onScrollPassive: z, onBeforeShow: je, onBeforeHide: Be, onShow: Qe }, o2);
    }
    function Be(e2) {
      Ue(e2), Ve();
    }
    function Qe() {
      L();
    }
    function Ee(e2) {
      stop2(e2), C.value !== null && C.value.focus(), u.value = true, window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, 0);
    }
    function Oe(e2) {
      stop2(e2), nextTick2(() => {
        u.value = false;
      });
    }
    function ze() {
      const o2 = [h(QField, { class: `col-auto ${R.fieldClass}`, ...I.value, for: R.targetUid.value, dark: A.value, square: true, loading: c.value, itemAligned: false, filled: true, stackLabel: s2.value.length > 0, ...R.splitAttrs.listeners.value, onFocus: Ee, onBlur: Oe }, { ...t, rawControl: () => R.getControl(true), before: void 0, after: void 0 })];
      return l.value === true && o2.push(h("div", { ref: q, class: H.value + " scroll", style: e.popupContentStyle, onClick: prevent, onScrollPassive: z }, j.value === true ? t["no-option"] !== void 0 ? t["no-option"]({ inputValue: s2.value }) : null : ke())), h(QDialog, { ref: _, modelValue: i.value, position: e.useInput === true ? "top" : void 0, transitionShow: y, transitionHide: e.transitionHide, transitionDuration: e.transitionDuration, onBeforeShow: je, onBeforeHide: Fe, onHide: Le, onShow: Re }, () => h("div", { class: "q-select__dialog" + (A.value === true ? " q-select__dialog--dark q-dark" : "") + (u.value === true ? " q-select__dialog--focused" : "") }, o2));
    }
    function Fe(e2) {
      Ue(e2), _.value !== null && _.value.__updateRefocusTarget(R.rootRef.value.querySelector(".q-field__native > [tabindex]:last-child")), R.focused.value = false;
    }
    function Le(e2) {
      Ae(), R.focused.value === false && o("blur", e2), De();
    }
    function Re() {
      const e2 = document.activeElement;
      e2 !== null && e2.id === R.targetUid.value || C.value === null || C.value === e2 || C.value.focus(), L();
    }
    function Ve() {
      v !== void 0 && (v.optionEls = []), i.value !== true && (r.value = -1, l.value === true && (l.value = false), R.focused.value === false && (clearTimeout(g), g = void 0, R.innerLoading.value === true && (o("filter-abort"), R.innerLoading.value = false, c.value = false)));
    }
    function Ie(o2) {
      R.editable.value === true && (m === true ? (R.onControlFocusin(o2), i.value = true, nextTick2(() => {
        R.focus();
      })) : R.focus(), e.onFilter !== void 0 ? $e(s2.value) : j.value === true && t["no-option"] === void 0 || (l.value = true));
    }
    function Ae() {
      i.value = false, Ve();
    }
    function De() {
      e.useInput === true && Pe(e.multiple !== true && e.fillInput === true && V.value.length > 0 && oe.value(V.value[0]) || "", true, true);
    }
    function Ne(t2) {
      let o2 = -1;
      if (t2 === true) {
        if (V.value.length > 0) {
          const t3 = te.value(V.value[0]);
          o2 = e.options.findIndex((e2) => isDeepEqual(te.value(e2), t3));
        }
        E(o2);
      }
      de(o2);
    }
    function He() {
      i.value === false && k2.value !== null && k2.value.updatePosition();
    }
    function je(e2) {
      e2 !== void 0 && stop2(e2), o("popup-show", e2), R.hasPopupOpen.value = true, R.onControlFocusin(e2);
    }
    function Ue(e2) {
      e2 !== void 0 && stop2(e2), o("popup-hide", e2), R.hasPopupOpen.value = false, R.onControlFocusout(e2);
    }
    function Ke() {
      m = (a.platform.is.mobile === true || e.behavior === "dialog") && (e.behavior !== "menu" && (e.useInput !== true || (t["no-option"] !== void 0 || e.onFilter !== void 0 || j.value === false))), y = a.platform.is.ios === true && m === true && e.useInput === true ? "fade" : e.transitionShow;
    }
    return watch(V, (t2) => {
      p2 = t2, e.useInput === true && e.fillInput === true && e.multiple !== true && R.innerLoading.value !== true && (i.value !== true && l.value !== true || D.value !== true) && (f !== true && De(), i.value !== true && l.value !== true || $e(""));
    }, { immediate: true }), watch(() => e.fillInput, De), watch(l, Ne), onBeforeUpdate(Ke), onUpdated(He), Ke(), onBeforeMount(() => {
      v = { optionSlot: t.option, options: [], optionEls: [] };
    }), onBeforeUnmount2(() => {
      v = void 0, clearTimeout(d);
    }), Object.assign(n, { showPopup: Ie, hidePopup: Ae, removeAtIndex: re, add: ue, toggleOption: ce, setOptionIndex: de, moveOptionSelection: pe, filter: $e, updateMenuPosition: He, updateInputValue: Pe, isOptionSelected: fe, getEmittingOptionValue: ie, isOptionDisabled: () => ne.value.apply(null, arguments), getOptionValue: () => te.value.apply(null, arguments), getOptionLabel: () => oe.value.apply(null, arguments) }), Object.assign(R, { innerValue: V, fieldClass: computed2(() => `q-select q-field--auto-height q-select--with${e.useInput !== true ? "out" : ""}-input q-select--with${e.useChips !== true ? "out" : ""}-chips q-select--${e.multiple === true ? "multiple" : "single"}`), inputRef: x, targetRef: C, hasValue: D, showPopup: Ie, floatingLabel: computed2(() => (e.hideSelected === true ? s2.value.length > 0 : D.value === true) || fieldValueIsFilled(e.displayValue)), getControlChild: () => {
      if (R.editable.value !== false && (i.value === true || j.value !== true || t["no-option"] !== void 0))
        return m === true ? ze() : Me();
    }, controlEvents: { onFocusin(e2) {
      R.onControlFocusin(e2);
    }, onFocusout(e2) {
      R.onControlFocusout(e2, () => {
        De(), Ve();
      });
    }, onClick(e2) {
      if (m !== true && (prevent(e2), l.value === true))
        return Ve(), void (C.value !== null && C.value.focus());
      Ie(e2);
    } }, getControl: (t2) => {
      const o2 = Ce(), n2 = t2 === true || i.value !== true || m !== true;
      if (e.useInput === true ? o2.push(_e(t2, n2)) : R.editable.value === true && n2 === true && (o2.push(h("div", { ref: C, key: "d_t", class: "no-outline", id: R.targetUid.value, tabindex: e.tabindex, onKeydown: Se, onKeyup: ge, onKeypress: ye })), typeof e.autocomplete === "string" && e.autocomplete.length > 0 && o2.push(h("input", { class: "q-select__autocomplete-input no-outline", autocomplete: e.autocomplete, onKeyup: be }))), T.value !== void 0 && e.disable !== true && ae.value.length > 0) {
        const t3 = ae.value.map((e2) => h("option", { value: e2, selected: true }));
        o2.push(h("select", { class: "hidden", name: T.value, multiple: e.multiple }, t3));
      }
      return h("div", { class: "q-field__native row items-center", ...R.splitAttrs.attributes.value }, o2);
    }, getInnerAppend: () => e.loading !== true && c.value !== true && e.hideDropdownIcon !== true ? [h(QIcon, { class: "q-select__dropdown-icon" + (l.value === true ? " rotate-180" : ""), name: Z.value })] : null }), useField(R);
  } });
  var skeletonTypes = ["text", "rect", "circle", "QBtn", "QBadge", "QChip", "QToolbar", "QCheckbox", "QRadio", "QToggle", "QSlider", "QRange", "QInput", "QAvatar"];
  var skeletonAnimations = ["wave", "pulse", "pulse-x", "pulse-y", "fade", "blink", "none"];
  var QSkeleton = defineComponent2({ name: "QSkeleton", props: { ...useDarkProps, tag: { type: String, default: "div" }, type: { type: String, validator: (e) => skeletonTypes.includes(e), default: "rect" }, animation: { type: String, validator: (e) => skeletonAnimations.includes(e), default: "wave" }, square: Boolean, bordered: Boolean, size: String, width: String, height: String }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), a = computed2(() => e.size !== void 0 ? { width: e.size, height: e.size } : { width: e.width, height: e.height }), l = computed2(() => `q-skeleton q-skeleton--${n.value === true ? "dark" : "light"} q-skeleton--type-${e.type}` + (e.animation !== "none" ? ` q-skeleton--anim q-skeleton--anim-${e.animation}` : "") + (e.square === true ? " q-skeleton--square" : "") + (e.bordered === true ? " q-skeleton--bordered" : ""));
    return () => h(e.tag, { class: l.value, style: a.value }, hSlot(t.default));
  } });
  var slotsDef = [["left", "center", "start", "width"], ["right", "center", "end", "width"], ["top", "start", "center", "height"], ["bottom", "end", "center", "height"]];
  var QSlideItem = defineComponent2({ name: "QSlideItem", props: { ...useDarkProps, leftColor: String, rightColor: String, topColor: String, bottomColor: String, onSlide: Function }, emits: ["action", "top", "right", "bottom", "left"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = useDark(e, a), { getCacheWithFn: i } = useCache(), r = ref(null);
    let s2, u = {}, c = {}, d = {};
    const p2 = computed2(() => a.lang.rtl === true ? { left: "right", right: "left" } : { left: "left", right: "right" }), v = computed2(() => "q-slide-item q-item-type overflow-hidden" + (l.value === true ? " q-slide-item--dark q-dark" : ""));
    function m() {
      r.value.style.transform = "translate(0,0)";
    }
    function f(t2, n2, a2) {
      e.onSlide !== void 0 && o("slide", { side: t2, ratio: n2, isReset: a2 });
    }
    function g(e2) {
      const n2 = r.value;
      if (e2.isFirst)
        u = { dir: null, size: { left: 0, right: 0, top: 0, bottom: 0 }, scale: 0 }, n2.classList.add("no-transition"), slotsDef.forEach((e3) => {
          if (t[e3[0]] !== void 0) {
            const t2 = d[e3[0]];
            t2.style.transform = "scale(1)", u.size[e3[0]] = t2.getBoundingClientRect()[e3[3]];
          }
        }), u.axis = e2.direction === "up" || e2.direction === "down" ? "Y" : "X";
      else {
        if (e2.isFinal)
          return n2.classList.remove("no-transition"), void (u.scale === 1 ? (n2.style.transform = `translate${u.axis}(${100 * u.dir}%)`, s2 = setTimeout(() => {
            o(u.showing, { reset: m }), o("action", { side: u.showing, reset: m });
          }, 230)) : (n2.style.transform = "translate(0,0)", f(u.showing, 0, true)));
        e2.direction = u.axis === "X" ? e2.offset.x < 0 ? "left" : "right" : e2.offset.y < 0 ? "up" : "down";
      }
      if (t.left === void 0 && e2.direction === p2.value.right || t.right === void 0 && e2.direction === p2.value.left || t.top === void 0 && e2.direction === "down" || t.bottom === void 0 && e2.direction === "up")
        return void (n2.style.transform = "translate(0,0)");
      let a2, l2, i2;
      u.axis === "X" ? (l2 = e2.direction === "left" ? -1 : 1, a2 = l2 === 1 ? p2.value.left : p2.value.right, i2 = e2.distance.x) : (l2 = e2.direction === "up" ? -2 : 2, a2 = l2 === 2 ? "top" : "bottom", i2 = e2.distance.y), u.dir !== null && Math.abs(l2) !== Math.abs(u.dir) || (u.dir !== l2 && (["left", "right", "top", "bottom"].forEach((e3) => {
        c[e3] && (c[e3].style.visibility = a2 === e3 ? "visible" : "hidden");
      }), u.showing = a2, u.dir = l2), u.scale = Math.max(0, Math.min(1, (i2 - 40) / u.size[a2])), n2.style.transform = `translate${u.axis}(${i2 * l2 / Math.abs(l2)}px)`, d[a2].style.transform = `scale(${u.scale})`, f(a2, u.scale, false));
    }
    return onBeforeUpdate(() => {
      c = {}, d = {};
    }), onBeforeUnmount2(() => {
      clearTimeout(s2);
    }), Object.assign(n, { reset: m }), () => {
      const o2 = [], n2 = { left: t[p2.value.right] !== void 0, right: t[p2.value.left] !== void 0, up: t.bottom !== void 0, down: t.top !== void 0 }, a2 = Object.keys(n2).filter((e2) => n2[e2] === true);
      slotsDef.forEach((n3) => {
        const a3 = n3[0];
        t[a3] !== void 0 && o2.push(h("div", { ref: (e2) => {
          c[a3] = e2;
        }, class: `q-slide-item__${a3} absolute-full row no-wrap items-${n3[1]} justify-${n3[2]}` + (e[a3 + "Color"] !== void 0 ? ` bg-${e[a3 + "Color"]}` : "") }, [h("div", { ref: (e2) => {
          d[a3] = e2;
        } }, t[a3]())]));
      });
      const l2 = h("div", { key: "content", ref: r, class: "q-slide-item__content" }, hSlot(t.default));
      return o2.push(withDirectives(l2, i("dir#" + a2.join(""), () => {
        const e2 = { prevent: true, stop: true, mouse: true };
        return a2.forEach((t2) => {
          e2[t2] = true;
        }), [[TouchPan, g, void 0, e2]];
      }))), h("div", { class: v.value }, o2);
    };
  } });
  var space = h("div", { class: "q-space" });
  var QSpace = defineComponent2({ name: "QSpace", setup() {
    return () => space;
  } });
  var svg$l = [h("g", { transform: "matrix(1 0 0 -1 0 80)" }, [h("rect", { width: "10", height: "20", rx: "3" }, [h("animate", { attributeName: "height", begin: "0s", dur: "4.3s", values: "20;45;57;80;64;32;66;45;64;23;66;13;64;56;34;34;2;23;76;79;20", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "15", width: "10", height: "80", rx: "3" }, [h("animate", { attributeName: "height", begin: "0s", dur: "2s", values: "80;55;33;5;75;23;73;33;12;14;60;80", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "30", width: "10", height: "50", rx: "3" }, [h("animate", { attributeName: "height", begin: "0s", dur: "1.4s", values: "50;34;78;23;56;23;34;76;80;54;21;50", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "45", width: "10", height: "30", rx: "3" }, [h("animate", { attributeName: "height", begin: "0s", dur: "2s", values: "30;45;13;80;56;72;45;76;34;23;67;30", calcMode: "linear", repeatCount: "indefinite" })])])];
  var QSpinnerAudio = defineComponent2({ name: "QSpinnerAudio", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, fill: "currentColor", width: t.value, height: t.value, viewBox: "0 0 55 80", xmlns: "http://www.w3.org/2000/svg" }, svg$l);
  } });
  var svg$k = [h("g", { transform: "translate(1 1)", "stroke-width": "2", fill: "none", "fill-rule": "evenodd" }, [h("circle", { cx: "5", cy: "50", r: "5" }, [h("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", values: "50;5;50;50", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "cx", begin: "0s", dur: "2.2s", values: "5;27;49;5", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "27", cy: "5", r: "5" }, [h("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", from: "5", to: "5", values: "5;50;50;5", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "cx", begin: "0s", dur: "2.2s", from: "27", to: "27", values: "27;49;5;27", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "49", cy: "50", r: "5" }, [h("animate", { attributeName: "cy", begin: "0s", dur: "2.2s", values: "50;50;5;50", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "cx", from: "49", to: "49", begin: "0s", dur: "2.2s", values: "49;5;27;49", calcMode: "linear", repeatCount: "indefinite" })])])];
  var QSpinnerBall = defineComponent2({ name: "QSpinnerBall", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, stroke: "currentColor", width: t.value, height: t.value, viewBox: "0 0 57 57", xmlns: "http://www.w3.org/2000/svg" }, svg$k);
  } });
  var svg$j = [h("rect", { y: "10", width: "15", height: "120", rx: "6" }, [h("animate", { attributeName: "height", begin: "0.5s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "y", begin: "0.5s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "30", y: "10", width: "15", height: "120", rx: "6" }, [h("animate", { attributeName: "height", begin: "0.25s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "y", begin: "0.25s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "60", width: "15", height: "140", rx: "6" }, [h("animate", { attributeName: "height", begin: "0s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "y", begin: "0s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "90", y: "10", width: "15", height: "120", rx: "6" }, [h("animate", { attributeName: "height", begin: "0.25s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "y", begin: "0.25s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })]), h("rect", { x: "120", y: "10", width: "15", height: "120", rx: "6" }, [h("animate", { attributeName: "height", begin: "0.5s", dur: "1s", values: "120;110;100;90;80;70;60;50;40;140;120", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "y", begin: "0.5s", dur: "1s", values: "10;15;20;25;30;35;40;45;50;0;10", calcMode: "linear", repeatCount: "indefinite" })])];
  var QSpinnerBars = defineComponent2({ name: "QSpinnerBars", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, fill: "currentColor", width: t.value, height: t.value, viewBox: "0 0 135 140", xmlns: "http://www.w3.org/2000/svg" }, svg$j);
  } });
  var svg$i = [h("rect", { x: "25", y: "25", width: "50", height: "50", fill: "none", "stroke-width": "4", stroke: "currentColor" }, [h("animateTransform", { id: "spinnerBox", attributeName: "transform", type: "rotate", from: "0 50 50", to: "180 50 50", dur: "0.5s", begin: "rectBox.end" })]), h("rect", { x: "27", y: "27", width: "46", height: "50", fill: "currentColor" }, [h("animate", { id: "rectBox", attributeName: "height", begin: "0s;spinnerBox.end", dur: "1.3s", from: "50", to: "0", fill: "freeze" })])];
  var QSpinnerBox = defineComponent2({ name: "QSpinnerBox", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$i);
  } });
  var svg$h = [h("circle", { cx: "50", cy: "50", r: "48", fill: "none", "stroke-width": "4", "stroke-miterlimit": "10", stroke: "currentColor" }), h("line", { "stroke-linecap": "round", "stroke-width": "4", "stroke-miterlimit": "10", stroke: "currentColor", x1: "50", y1: "50", x2: "85", y2: "50.5" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "2s", repeatCount: "indefinite" })]), h("line", { "stroke-linecap": "round", "stroke-width": "4", "stroke-miterlimit": "10", stroke: "currentColor", x1: "50", y1: "50", x2: "49.5", y2: "74" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "15s", repeatCount: "indefinite" })])];
  var QSpinnerClock = defineComponent2({ name: "QSpinnerClock", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$h);
  } });
  var svg$g = [h("rect", { x: "0", y: "0", width: " 100", height: "100", fill: "none" }), h("path", { d: "M78,19H22c-6.6,0-12,5.4-12,12v31c0,6.6,5.4,12,12,12h37.2c0.4,3,1.8,5.6,3.7,7.6c2.4,2.5,5.1,4.1,9.1,4 c-1.4-2.1-2-7.2-2-10.3c0-0.4,0-0.8,0-1.3h8c6.6,0,12-5.4,12-12V31C90,24.4,84.6,19,78,19z", fill: "currentColor" }), h("circle", { cx: "30", cy: "47", r: "5", fill: "#fff" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", values: "0;1;1", keyTimes: "0;0.2;1", dur: "1s", repeatCount: "indefinite" })]), h("circle", { cx: "50", cy: "47", r: "5", fill: "#fff" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", values: "0;0;1;1", keyTimes: "0;0.2;0.4;1", dur: "1s", repeatCount: "indefinite" })]), h("circle", { cx: "70", cy: "47", r: "5", fill: "#fff" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", values: "0;0;1;1", keyTimes: "0;0.4;0.6;1", dur: "1s", repeatCount: "indefinite" })])];
  var QSpinnerComment = defineComponent2({ name: "QSpinnerComment", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" }, svg$g);
  } });
  var svg$f = [h("rect", { x: "0", y: "0", width: " 100", height: "100", fill: "none" }), h("g", { transform: "translate(25 25)" }, [h("rect", { x: "-20", y: "-20", width: " 40", height: "40", fill: "currentColor", opacity: "0.9" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "1.5", to: "1", repeatCount: "indefinite", begin: "0s", dur: "1s", calcMode: "spline", keySplines: "0.2 0.8 0.2 0.8", keyTimes: "0;1" })])]), h("g", { transform: "translate(75 25)" }, [h("rect", { x: "-20", y: "-20", width: " 40", height: "40", fill: "currentColor", opacity: "0.8" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "1.5", to: "1", repeatCount: "indefinite", begin: "0.1s", dur: "1s", calcMode: "spline", keySplines: "0.2 0.8 0.2 0.8", keyTimes: "0;1" })])]), h("g", { transform: "translate(25 75)" }, [h("rect", { x: "-20", y: "-20", width: " 40", height: "40", fill: "currentColor", opacity: "0.7" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "1.5", to: "1", repeatCount: "indefinite", begin: "0.3s", dur: "1s", calcMode: "spline", keySplines: "0.2 0.8 0.2 0.8", keyTimes: "0;1" })])]), h("g", { transform: "translate(75 75)" }, [h("rect", { x: "-20", y: "-20", width: " 40", height: "40", fill: "currentColor", opacity: "0.6" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "1.5", to: "1", repeatCount: "indefinite", begin: "0.2s", dur: "1s", calcMode: "spline", keySplines: "0.2 0.8 0.2 0.8", keyTimes: "0;1" })])])];
  var QSpinnerCube = defineComponent2({ name: "QSpinnerCube", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" }, svg$f);
  } });
  var svg$e = [h("circle", { cx: "15", cy: "15", r: "15" }, [h("animate", { attributeName: "r", from: "15", to: "15", begin: "0s", dur: "0.8s", values: "15;9;15", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "fill-opacity", from: "1", to: "1", begin: "0s", dur: "0.8s", values: "1;.5;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "60", cy: "15", r: "9", "fill-opacity": ".3" }, [h("animate", { attributeName: "r", from: "9", to: "9", begin: "0s", dur: "0.8s", values: "9;15;9", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "fill-opacity", from: ".5", to: ".5", begin: "0s", dur: "0.8s", values: ".5;1;.5", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "105", cy: "15", r: "15" }, [h("animate", { attributeName: "r", from: "15", to: "15", begin: "0s", dur: "0.8s", values: "15;9;15", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "fill-opacity", from: "1", to: "1", begin: "0s", dur: "0.8s", values: "1;.5;1", calcMode: "linear", repeatCount: "indefinite" })])];
  var QSpinnerDots = defineComponent2({ name: "QSpinnerDots", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, fill: "currentColor", width: t.value, height: t.value, viewBox: "0 0 120 30", xmlns: "http://www.w3.org/2000/svg" }, svg$e);
  } });
  var svg$d = [h("g", { transform: "translate(20 50)" }, [h("rect", { x: "-10", y: "-30", width: " 20", height: "60", fill: "currentColor", opacity: "0.6" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "2", to: "1", begin: "0s", repeatCount: "indefinite", dur: "1s", calcMode: "spline", keySplines: "0.1 0.9 0.4 1", keyTimes: "0;1", values: "2;1" })])]), h("g", { transform: "translate(50 50)" }, [h("rect", { x: "-10", y: "-30", width: " 20", height: "60", fill: "currentColor", opacity: "0.8" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "2", to: "1", begin: "0.1s", repeatCount: "indefinite", dur: "1s", calcMode: "spline", keySplines: "0.1 0.9 0.4 1", keyTimes: "0;1", values: "2;1" })])]), h("g", { transform: "translate(80 50)" }, [h("rect", { x: "-10", y: "-30", width: " 20", height: "60", fill: "currentColor", opacity: "0.9" }, [h("animateTransform", { attributeName: "transform", type: "scale", from: "2", to: "1", begin: "0.2s", repeatCount: "indefinite", dur: "1s", calcMode: "spline", keySplines: "0.1 0.9 0.4 1", keyTimes: "0;1", values: "2;1" })])])];
  var QSpinnerFacebook = defineComponent2({ name: "QSpinnerFacebook", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", preserveAspectRatio: "xMidYMid" }, svg$d);
  } });
  var svg$c = [h("g", { transform: "translate(-20,-20)" }, [h("path", { d: "M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z", fill: "currentColor" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "90 50 50", to: "0 50 50", dur: "1s", repeatCount: "indefinite" })])]), h("g", { transform: "translate(20,20) rotate(15 50 50)" }, [h("path", { d: "M79.9,52.6C80,51.8,80,50.9,80,50s0-1.8-0.1-2.6l-5.1-0.4c-0.3-2.4-0.9-4.6-1.8-6.7l4.2-2.9c-0.7-1.6-1.6-3.1-2.6-4.5 L70,35c-1.4-1.9-3.1-3.5-4.9-4.9l2.2-4.6c-1.4-1-2.9-1.9-4.5-2.6L59.8,27c-2.1-0.9-4.4-1.5-6.7-1.8l-0.4-5.1C51.8,20,50.9,20,50,20 s-1.8,0-2.6,0.1l-0.4,5.1c-2.4,0.3-4.6,0.9-6.7,1.8l-2.9-4.1c-1.6,0.7-3.1,1.6-4.5,2.6l2.1,4.6c-1.9,1.4-3.5,3.1-5,4.9l-4.5-2.1 c-1,1.4-1.9,2.9-2.6,4.5l4.1,2.9c-0.9,2.1-1.5,4.4-1.8,6.8l-5,0.4C20,48.2,20,49.1,20,50s0,1.8,0.1,2.6l5,0.4 c0.3,2.4,0.9,4.7,1.8,6.8l-4.1,2.9c0.7,1.6,1.6,3.1,2.6,4.5l4.5-2.1c1.4,1.9,3.1,3.5,5,4.9l-2.1,4.6c1.4,1,2.9,1.9,4.5,2.6l2.9-4.1 c2.1,0.9,4.4,1.5,6.7,1.8l0.4,5.1C48.2,80,49.1,80,50,80s1.8,0,2.6-0.1l0.4-5.1c2.3-0.3,4.6-0.9,6.7-1.8l2.9,4.2 c1.6-0.7,3.1-1.6,4.5-2.6L65,69.9c1.9-1.4,3.5-3,4.9-4.9l4.6,2.2c1-1.4,1.9-2.9,2.6-4.5L73,59.8c0.9-2.1,1.5-4.4,1.8-6.7L79.9,52.6 z M50,65c-8.3,0-15-6.7-15-15c0-8.3,6.7-15,15-15s15,6.7,15,15C65,58.3,58.3,65,50,65z", fill: "currentColor" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "90 50 50", dur: "1s", repeatCount: "indefinite" })])])];
  var QSpinnerGears = defineComponent2({ name: "QSpinnerGears", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$c);
  } });
  var svg$b = [h("circle", { cx: "12.5", cy: "12.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "0s", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "12.5", cy: "52.5", r: "12.5", "fill-opacity": ".5" }, [h("animate", { attributeName: "fill-opacity", begin: "100ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "52.5", cy: "12.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "300ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "52.5", cy: "52.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "600ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "92.5", cy: "12.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "800ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "92.5", cy: "52.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "400ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "12.5", cy: "92.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "700ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "52.5", cy: "92.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "500ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "92.5", cy: "92.5", r: "12.5" }, [h("animate", { attributeName: "fill-opacity", begin: "200ms", dur: "1s", values: "1;.2;1", calcMode: "linear", repeatCount: "indefinite" })])];
  var QSpinnerGrid = defineComponent2({ name: "QSpinnerGrid", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, fill: "currentColor", width: t.value, height: t.value, viewBox: "0 0 105 105", xmlns: "http://www.w3.org/2000/svg" }, svg$b);
  } });
  var svg$a = [h("path", { d: "M30.262 57.02L7.195 40.723c-5.84-3.976-7.56-12.06-3.842-18.063 3.715-6 11.467-7.65 17.306-3.68l4.52 3.76 2.6-5.274c3.716-6.002 11.47-7.65 17.304-3.68 5.84 3.97 7.56 12.054 3.842 18.062L34.49 56.118c-.897 1.512-2.793 1.915-4.228.9z", "fill-opacity": ".5" }, [h("animate", { attributeName: "fill-opacity", begin: "0s", dur: "1.4s", values: "0.5;1;0.5", calcMode: "linear", repeatCount: "indefinite" })]), h("path", { d: "M105.512 56.12l-14.44-24.272c-3.716-6.008-1.996-14.093 3.843-18.062 5.835-3.97 13.588-2.322 17.306 3.68l2.6 5.274 4.52-3.76c5.84-3.97 13.593-2.32 17.308 3.68 3.718 6.003 1.998 14.088-3.842 18.064L109.74 57.02c-1.434 1.014-3.33.61-4.228-.9z", "fill-opacity": ".5" }, [h("animate", { attributeName: "fill-opacity", begin: "0.7s", dur: "1.4s", values: "0.5;1;0.5", calcMode: "linear", repeatCount: "indefinite" })]), h("path", { d: "M67.408 57.834l-23.01-24.98c-5.864-6.15-5.864-16.108 0-22.248 5.86-6.14 15.37-6.14 21.234 0L70 16.168l4.368-5.562c5.863-6.14 15.375-6.14 21.235 0 5.863 6.14 5.863 16.098 0 22.247l-23.007 24.98c-1.43 1.556-3.757 1.556-5.188 0z" })];
  var QSpinnerHearts = defineComponent2({ name: "QSpinnerHearts", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, fill: "currentColor", width: t.value, height: t.value, viewBox: "0 0 140 64", xmlns: "http://www.w3.org/2000/svg" }, svg$a);
  } });
  var svg$9 = [h("g", [h("path", { fill: "none", stroke: "currentColor", "stroke-width": "5", "stroke-miterlimit": "10", d: "M58.4,51.7c-0.9-0.9-1.4-2-1.4-2.3s0.5-0.4,1.4-1.4 C70.8,43.8,79.8,30.5,80,15.5H70H30H20c0.2,15,9.2,28.1,21.6,32.3c0.9,0.9,1.4,1.2,1.4,1.5s-0.5,1.6-1.4,2.5 C29.2,56.1,20.2,69.5,20,85.5h10h40h10C79.8,69.5,70.8,55.9,58.4,51.7z" }), h("clipPath", { id: "uil-hourglass-clip1" }, [h("rect", { x: "15", y: "20", width: " 70", height: "25" }, [h("animate", { attributeName: "height", from: "25", to: "0", dur: "1s", repeatCount: "indefinite", values: "25;0;0", keyTimes: "0;0.5;1" }), h("animate", { attributeName: "y", from: "20", to: "45", dur: "1s", repeatCount: "indefinite", values: "20;45;45", keyTimes: "0;0.5;1" })])]), h("clipPath", { id: "uil-hourglass-clip2" }, [h("rect", { x: "15", y: "55", width: " 70", height: "25" }, [h("animate", { attributeName: "height", from: "0", to: "25", dur: "1s", repeatCount: "indefinite", values: "0;25;25", keyTimes: "0;0.5;1" }), h("animate", { attributeName: "y", from: "80", to: "55", dur: "1s", repeatCount: "indefinite", values: "80;55;55", keyTimes: "0;0.5;1" })])]), h("path", { d: "M29,23c3.1,11.4,11.3,19.5,21,19.5S67.9,34.4,71,23H29z", "clip-path": "url(#uil-hourglass-clip1)", fill: "currentColor" }), h("path", { d: "M71.6,78c-3-11.6-11.5-20-21.5-20s-18.5,8.4-21.5,20H71.6z", "clip-path": "url(#uil-hourglass-clip2)", fill: "currentColor" }), h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "180 50 50", repeatCount: "indefinite", dur: "1s", values: "0 50 50;0 50 50;180 50 50", keyTimes: "0;0.7;1" })])];
  var QSpinnerHourglass = defineComponent2({ name: "QSpinnerHourglass", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$9);
  } });
  var svg$8 = [h("path", { d: "M24.3,30C11.4,30,5,43.3,5,50s6.4,20,19.3,20c19.3,0,32.1-40,51.4-40C88.6,30,95,43.3,95,50s-6.4,20-19.3,20C56.4,70,43.6,30,24.3,30z", fill: "none", stroke: "currentColor", "stroke-width": "8", "stroke-dasharray": "10.691205342610678 10.691205342610678", "stroke-dashoffset": "0" }, [h("animate", { attributeName: "stroke-dashoffset", from: "0", to: "21.382410685221355", begin: "0", dur: "2s", repeatCount: "indefinite", fill: "freeze" })])];
  var QSpinnerInfinity = defineComponent2({ name: "QSpinnerInfinity", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid" }, svg$8);
  } });
  var svg$7 = [h("g", { "stroke-width": "4", "stroke-linecap": "round" }, [h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(180)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(210)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: "0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(240)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".1;0;1;.85;.7;.65;.55;.45;.35;.25;.15;.1", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(270)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".15;.1;0;1;.85;.7;.65;.55;.45;.35;.25;.15", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(300)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".25;.15;.1;0;1;.85;.7;.65;.55;.45;.35;.25", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(330)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".35;.25;.15;.1;0;1;.85;.7;.65;.55;.45;.35", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(0)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".45;.35;.25;.15;.1;0;1;.85;.7;.65;.55;.45", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(30)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".55;.45;.35;.25;.15;.1;0;1;.85;.7;.65;.55", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(60)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".65;.55;.45;.35;.25;.15;.1;0;1;.85;.7;.65", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(90)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".7;.65;.55;.45;.35;.25;.15;.1;0;1;.85;.7", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(120)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: ".85;.7;.65;.55;.45;.35;.25;.15;.1;0;1;.85", repeatCount: "indefinite" })]), h("line", { y1: "17", y2: "29", transform: "translate(32,32) rotate(150)" }, [h("animate", { attributeName: "stroke-opacity", dur: "750ms", values: "1;.85;.7;.65;.55;.45;.35;.25;.15;.1;0;1", repeatCount: "indefinite" })])])];
  var QSpinnerIos = defineComponent2({ name: "QSpinnerIos", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, stroke: "currentColor", fill: "currentColor", viewBox: "0 0 64 64" }, svg$7);
  } });
  var svg$6 = [h("circle", { cx: "50", cy: "50", r: "44", fill: "none", "stroke-width": "4", "stroke-opacity": ".5", stroke: "currentColor" }), h("circle", { cx: "8", cy: "54", r: "6", fill: "currentColor", "stroke-width": "3", stroke: "currentColor" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 48", to: "360 50 52", dur: "2s", repeatCount: "indefinite" })])];
  var QSpinnerOrbit = defineComponent2({ name: "QSpinnerOrbit", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$6);
  } });
  var svg$5 = [h("g", { transform: "translate(1 1)", "stroke-width": "2", fill: "none", "fill-rule": "evenodd" }, [h("circle", { "stroke-opacity": ".5", cx: "18", cy: "18", r: "18" }), h("path", { d: "M36 18c0-9.94-8.06-18-18-18" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "1s", repeatCount: "indefinite" })])])];
  var QSpinnerOval = defineComponent2({ name: "QSpinnerOval", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, stroke: "currentColor", width: t.value, height: t.value, viewBox: "0 0 38 38", xmlns: "http://www.w3.org/2000/svg" }, svg$5);
  } });
  var svg$4 = [h("path", { d: "M0 50A50 50 0 0 1 50 0L50 50L0 50", fill: "currentColor", opacity: "0.5" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "0.8s", repeatCount: "indefinite" })]), h("path", { d: "M50 0A50 50 0 0 1 100 50L50 50L50 0", fill: "currentColor", opacity: "0.5" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "1.6s", repeatCount: "indefinite" })]), h("path", { d: "M100 50A50 50 0 0 1 50 100L50 50L100 50", fill: "currentColor", opacity: "0.5" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "2.4s", repeatCount: "indefinite" })]), h("path", { d: "M50 100A50 50 0 0 1 0 50L50 50L50 100", fill: "currentColor", opacity: "0.5" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 50 50", to: "360 50 50", dur: "3.2s", repeatCount: "indefinite" })])];
  var QSpinnerPie = defineComponent2({ name: "QSpinnerPie", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$4);
  } });
  var svg$3 = [h("g", { fill: "none", "fill-rule": "evenodd", "stroke-width": "2" }, [h("circle", { cx: "22", cy: "22", r: "1" }, [h("animate", { attributeName: "r", begin: "0s", dur: "1.8s", values: "1; 20", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.165, 0.84, 0.44, 1", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-opacity", begin: "0s", dur: "1.8s", values: "1; 0", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.3, 0.61, 0.355, 1", repeatCount: "indefinite" })]), h("circle", { cx: "22", cy: "22", r: "1" }, [h("animate", { attributeName: "r", begin: "-0.9s", dur: "1.8s", values: "1; 20", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.165, 0.84, 0.44, 1", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-opacity", begin: "-0.9s", dur: "1.8s", values: "1; 0", calcMode: "spline", keyTimes: "0; 1", keySplines: "0.3, 0.61, 0.355, 1", repeatCount: "indefinite" })])])];
  var QSpinnerPuff = defineComponent2({ name: "QSpinnerPuff", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, stroke: "currentColor", width: t.value, height: t.value, viewBox: "0 0 44 44", xmlns: "http://www.w3.org/2000/svg" }, svg$3);
  } });
  var svg$2 = [h("g", { transform: "scale(0.55)" }, [h("circle", { cx: "30", cy: "150", r: "30", fill: "currentColor" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", dur: "1s", begin: "0", repeatCount: "indefinite", keyTimes: "0;0.5;1", values: "0;1;1" })]), h("path", { d: "M90,150h30c0-49.7-40.3-90-90-90v30C63.1,90,90,116.9,90,150z", fill: "currentColor" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", dur: "1s", begin: "0.1", repeatCount: "indefinite", keyTimes: "0;0.5;1", values: "0;1;1" })]), h("path", { d: "M150,150h30C180,67.2,112.8,0,30,0v30C96.3,30,150,83.7,150,150z", fill: "currentColor" }, [h("animate", { attributeName: "opacity", from: "0", to: "1", dur: "1s", begin: "0.2", repeatCount: "indefinite", keyTimes: "0;0.5;1", values: "0;1;1" })])])];
  var QSpinnerRadio = defineComponent2({ name: "QSpinnerRadio", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 100 100", preserveAspectRatio: "xMidYMid", xmlns: "http://www.w3.org/2000/svg" }, svg$2);
  } });
  var svg$1 = [h("g", { fill: "none", "fill-rule": "evenodd", transform: "translate(1 1)", "stroke-width": "2" }, [h("circle", { cx: "22", cy: "22", r: "6" }, [h("animate", { attributeName: "r", begin: "1.5s", dur: "3s", values: "6;22", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-opacity", begin: "1.5s", dur: "3s", values: "1;0", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-width", begin: "1.5s", dur: "3s", values: "2;0", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "22", cy: "22", r: "6" }, [h("animate", { attributeName: "r", begin: "3s", dur: "3s", values: "6;22", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-opacity", begin: "3s", dur: "3s", values: "1;0", calcMode: "linear", repeatCount: "indefinite" }), h("animate", { attributeName: "stroke-width", begin: "3s", dur: "3s", values: "2;0", calcMode: "linear", repeatCount: "indefinite" })]), h("circle", { cx: "22", cy: "22", r: "8" }, [h("animate", { attributeName: "r", begin: "0s", dur: "1.5s", values: "6;1;2;3;4;5;6", calcMode: "linear", repeatCount: "indefinite" })])])];
  var QSpinnerRings = defineComponent2({ name: "QSpinnerRings", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, stroke: "currentColor", width: t.value, height: t.value, viewBox: "0 0 45 45", xmlns: "http://www.w3.org/2000/svg" }, svg$1);
  } });
  var svg = [h("defs", [h("linearGradient", { x1: "8.042%", y1: "0%", x2: "65.682%", y2: "23.865%", id: "a" }, [h("stop", { "stop-color": "currentColor", "stop-opacity": "0", offset: "0%" }), h("stop", { "stop-color": "currentColor", "stop-opacity": ".631", offset: "63.146%" }), h("stop", { "stop-color": "currentColor", offset: "100%" })])]), h("g", { transform: "translate(1 1)", fill: "none", "fill-rule": "evenodd" }, [h("path", { d: "M36 18c0-9.94-8.06-18-18-18", stroke: "url(#a)", "stroke-width": "2" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })]), h("circle", { fill: "currentColor", cx: "36", cy: "18", r: "1" }, [h("animateTransform", { attributeName: "transform", type: "rotate", from: "0 18 18", to: "360 18 18", dur: "0.9s", repeatCount: "indefinite" })])])];
  var QSpinnerTail = defineComponent2({ name: "QSpinnerTail", props: useSpinnerProps, setup(e) {
    const { cSize: t, classes: o } = useSpinner(e);
    return () => h("svg", { class: o.value, width: t.value, height: t.value, viewBox: "0 0 38 38", xmlns: "http://www.w3.org/2000/svg" }, svg);
  } });
  var QSplitter = defineComponent2({ name: "QSplitter", props: { ...useDarkProps, modelValue: { type: Number, required: true }, reverse: Boolean, unit: { type: String, default: "%", validator: (e) => ["%", "px"].includes(e) }, limits: { type: Array, validator: (e) => {
    return e.length === 2 && (typeof e[0] === "number" && typeof e[1] === "number" && (e[0] >= 0 && e[0] <= e[1]));
  } }, emitImmediately: Boolean, horizontal: Boolean, disable: Boolean, beforeClass: [Array, String, Object], afterClass: [Array, String, Object], separatorClass: [Array, String, Object], separatorStyle: [Array, String, Object] }, emits: ["update:modelValue"], setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useDark(e, n), l = ref(null), i = { before: ref(null), after: ref(null) }, r = computed2(() => `q-splitter no-wrap ${e.horizontal === true ? "q-splitter--horizontal column" : "q-splitter--vertical row"} q-splitter--${e.disable === true ? "disabled" : "workable"}` + (a.value === true ? " q-splitter--dark" : "")), s2 = computed2(() => e.horizontal === true ? "height" : "width"), u = computed2(() => e.reverse !== true ? "before" : "after"), c = computed2(() => e.limits !== void 0 ? e.limits : e.unit === "%" ? [10, 90] : [50, 1 / 0]);
    function d(t2) {
      return (e.unit === "%" ? t2 : Math.round(t2)) + e.unit;
    }
    const p2 = computed2(() => ({ [u.value]: { [s2.value]: d(e.modelValue) } }));
    let v, m, f, g, b;
    function y(t2) {
      if (t2.isFirst === true) {
        const t3 = l.value.getBoundingClientRect()[s2.value];
        return v = e.horizontal === true ? "up" : "left", m = e.unit === "%" ? 100 : t3, f = Math.min(m, c.value[1], Math.max(c.value[0], e.modelValue)), g = (e.reverse !== true ? 1 : -1) * (e.horizontal === true ? 1 : n.lang.rtl === true ? -1 : 1) * (e.unit === "%" ? t3 === 0 ? 0 : 100 / t3 : 1), void l.value.classList.add("q-splitter--active");
      }
      if (t2.isFinal === true)
        return b !== e.modelValue && o("update:modelValue", b), void l.value.classList.remove("q-splitter--active");
      const a2 = f + g * (t2.direction === v ? -1 : 1) * t2.distance[e.horizontal === true ? "y" : "x"];
      b = Math.min(m, c.value[1], Math.max(c.value[0], a2)), i[u.value].value.style[s2.value] = d(b), e.emitImmediately === true && e.modelValue !== b && o("update:modelValue", b);
    }
    const S = computed2(() => {
      return [[TouchPan, y, void 0, { [e.horizontal === true ? "vertical" : "horizontal"]: true, prevent: true, stop: true, mouse: true, mouseAllDir: true }]];
    });
    function w(e2, t2) {
      e2 < t2[0] ? o("update:modelValue", t2[0]) : e2 > t2[1] && o("update:modelValue", t2[1]);
    }
    return watch(() => e.modelValue, (e2) => {
      w(e2, c.value);
    }), watch(() => e.limits, () => {
      nextTick2(() => {
        w(e.modelValue, c.value);
      });
    }), () => {
      const o2 = [h("div", { ref: i.before, class: ["q-splitter__panel q-splitter__before" + (e.reverse === true ? " col" : ""), e.beforeClass], style: p2.value.before }, hSlot(t.before)), h("div", { class: ["q-splitter__separator", e.separatorClass], style: e.separatorStyle, "aria-disabled": e.disable === true ? "true" : void 0 }, [hDir("div", { class: "q-splitter__separator-area absolute-full" }, hSlot(t.separator), "sep", e.disable !== true, () => S.value)]), h("div", { ref: i.after, class: ["q-splitter__panel q-splitter__after" + (e.reverse === true ? "" : " col"), e.afterClass], style: p2.value.after }, hSlot(t.after))];
      return h("div", { class: r.value, ref: l }, hMergeSlot(t.default, o2));
    };
  } });
  var StepHeader = defineComponent2({ name: "StepHeader", props: { stepper: {}, step: {}, goToPanel: Function }, setup(e, { attrs: t }) {
    const { proxy: { $q: o } } = getCurrentInstance(), n = ref(null), a = computed2(() => e.stepper.modelValue === e.step.name), l = computed2(() => {
      const t2 = e.step.disable;
      return t2 === true || t2 === "";
    }), i = computed2(() => {
      const t2 = e.step.error;
      return t2 === true || t2 === "";
    }), r = computed2(() => {
      const t2 = e.step.done;
      return l.value === false && (t2 === true || t2 === "");
    }), s2 = computed2(() => {
      const t2 = e.step.headerNav, o2 = t2 === true || t2 === "" || t2 === void 0;
      return l.value === false && e.stepper.headerNav && o2;
    }), u = computed2(() => {
      return e.step.prefix && a.value === false && i.value === false && r.value === false;
    }), c = computed2(() => {
      return a.value === true ? e.step.activeIcon || e.stepper.activeIcon || o.iconSet.stepper.active : i.value === true ? e.step.errorIcon || e.stepper.errorIcon || o.iconSet.stepper.error : l.value === false && r.value === true ? e.step.doneIcon || e.stepper.doneIcon || o.iconSet.stepper.done : e.step.icon || e.stepper.inactiveIcon;
    }), d = computed2(() => {
      const t2 = i.value === true ? e.step.errorColor || e.stepper.errorColor : void 0;
      if (a.value === true) {
        const o2 = e.step.activeColor || e.stepper.activeColor || e.step.color;
        return o2 !== void 0 ? o2 : t2;
      }
      return t2 !== void 0 ? t2 : l.value === false && r.value === true ? e.step.doneColor || e.stepper.doneColor || e.step.color || e.stepper.inactiveColor : e.step.color || e.stepper.inactiveColor;
    }), p2 = computed2(() => {
      return "q-stepper__tab col-grow flex items-center no-wrap relative-position" + (d.value !== void 0 ? ` text-${d.value}` : "") + (i.value === true ? " q-stepper__tab--error" : "") + (a.value === true ? " q-stepper__tab--active" : "") + (r.value === true ? " q-stepper__tab--done" : "") + (s2.value === true ? " q-stepper__tab--navigation q-focusable q-hoverable" : "") + (l.value === true ? " q-stepper__tab--disabled" : "");
    });
    function v() {
      n.value !== null && n.value.focus(), a.value === false && e.goToPanel(e.step.name);
    }
    function m(t2) {
      t2.keyCode === 13 && a.value === false && e.goToPanel(e.step.name);
    }
    return () => {
      const o2 = { class: p2.value };
      s2.value === true && (o2.onClick = v, o2.onKeyup = m, Object.assign(o2, l.value === true ? { tabindex: -1, "aria-disabled": "true" } : { tabindex: t.tabindex || 0 }));
      const a2 = [h("div", { class: "q-focus-helper", tabindex: -1, ref: n }), h("div", { class: "q-stepper__dot row flex-center q-stepper__line relative-position" }, [h("span", { class: "row flex-center" }, [u.value === true ? e.step.prefix : h(QIcon, { name: c.value })])])];
      if (e.step.title !== void 0 && e.step.title !== null) {
        const t2 = [h("div", { class: "q-stepper__title" }, e.step.title)];
        e.step.caption !== void 0 && e.step.caption !== null && t2.push(h("div", { class: "q-stepper__caption" }, e.step.caption)), a2.push(h("div", { class: "q-stepper__label q-stepper__line relative-position" }, t2));
      }
      return hDir("div", o2, a2, "head", e.stepper.headerNav === true && s2.value !== false, () => [[Ripple, s2.value]]);
    };
  } });
  function getStepWrapper(e) {
    return h("div", { class: "q-stepper__step-content" }, [h("div", { class: "q-stepper__step-inner" }, hSlot(e.default))]);
  }
  var PanelWrapper = { setup(e, { slots: t }) {
    return () => getStepWrapper(t);
  } };
  var QStep = defineComponent2({ name: "QStep", props: { ...usePanelChildProps, icon: String, color: String, title: { type: String, required: true }, caption: String, prefix: [String, Number], doneIcon: String, doneColor: String, activeIcon: String, activeColor: String, errorIcon: String, errorColor: String, headerNav: { type: Boolean, default: true }, done: Boolean, error: Boolean }, setup(e, { slots: t }) {
    const o = inject2(stepperKey, () => {
      console.error("QStep needs to be child of QStepper");
    }), { getCacheWithFn: n } = useCache(), a = ref(null), l = computed2(() => o.value.modelValue === e.name);
    watch(l, (e2) => {
      e2 === true && o.value.vertical === true && nextTick2(() => {
        a.value !== null && (a.value.scrollTop = 0);
      });
    });
    const i = computed2(() => typeof e.name === "string" || typeof e.name === "number" ? e.name : String(e.name));
    function r() {
      const e2 = o.value.vertical;
      return e2 === true && o.value.keepAlive === true ? h(KeepAlive, o.value.keepAliveProps.value, l.value === true ? [h(o.value.needsUniqueKeepAliveWrapper.value === true ? n(i.value, () => ({ ...PanelWrapper, name: i.value })) : PanelWrapper, { key: i.value }, t.default)] : void 0) : e2 !== true || l.value === true ? getStepWrapper(t) : void 0;
    }
    return () => h("div", { ref: a, class: "q-stepper__step" }, o.value.vertical === true ? [h(StepHeader, { stepper: o.value, step: e, goToPanel: o.value.goToPanel }), o.value.animated === true ? h(QSlideTransition, r) : r()] : [r()]);
  } });
  var camelRE = /(-\w)/g;
  function camelizeProps(e) {
    const t = {};
    return Object.keys(e).forEach((o) => {
      const n = o.replace(camelRE, (e2) => e2[1].toUpperCase());
      t[n] = e[o];
    }), t;
  }
  var QStepper = defineComponent2({ name: "QStepper", props: { ...useDarkProps, ...usePanelProps, flat: Boolean, bordered: Boolean, alternativeLabels: Boolean, headerNav: Boolean, contracted: Boolean, headerClass: String, inactiveColor: String, inactiveIcon: String, doneIcon: String, doneColor: String, activeIcon: String, activeColor: String, errorIcon: String, errorColor: String }, emits: usePanelEmits, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q), { updatePanelsList: a, isValidPanelName: l, updatePanelIndex: i, getPanelContent: r, getPanels: s2, panelDirectives: u, goToPanel: c, keepAliveProps: d, needsUniqueKeepAliveWrapper: p2 } = usePanel();
    provide2(stepperKey, computed2(() => ({ goToPanel: c, keepAliveProps: d, needsUniqueKeepAliveWrapper: p2, ...e })));
    const v = computed2(() => `q-stepper q-stepper--${e.vertical === true ? "vertical" : "horizontal"}` + (e.flat === true || n.value === true ? " q-stepper--flat no-shadow" : "") + (e.bordered === true || n.value === true && e.flat === false ? " q-stepper--bordered" : "") + (e.contracted === true ? " q-stepper--contracted" : "") + (n.value === true ? " q-stepper--dark q-dark" : "")), m = computed2(() => `q-stepper__header row items-stretch justify-between q-stepper__header--${e.alternativeLabels === true ? "alternative" : "standard"}-labels` + (e.flat === false || e.bordered === true ? " q-stepper__header--border" : "") + (e.headerClass !== void 0 ? ` ${e.headerClass}` : ""));
    function f() {
      const o2 = hSlot(t.message, []);
      if (e.vertical === true) {
        l(e.modelValue) && i();
        const n2 = h("div", { class: "q-stepper__content" }, hSlot(t.default));
        return o2 === void 0 ? [n2] : o2.concat(n2);
      }
      return [h("div", { class: m.value }, s2().map((t2) => {
        const o3 = camelizeProps(t2.props);
        return h(StepHeader, { key: o3.name, stepper: e, step: o3, goToPanel: c });
      })), o2, hDir("div", { class: "q-stepper__content q-panel-parent" }, r(), "cont", e.swipeable, () => u.value)];
    }
    return () => {
      return a(t), h("div", { class: v.value }, hMergeSlot(t.navigation, f()));
    };
  } });
  var QStepperNavigation = defineComponent2({ name: "QStepperNavigation", setup(e, { slots: t }) {
    return () => h("div", { class: "q-stepper__nav" }, hSlot(t.default));
  } });
  var QTh = defineComponent2({ name: "QTh", props: { props: Object, autoWidth: Boolean }, emits: ["click"], setup(e, { slots: t, emit: o }) {
    const n = getCurrentInstance(), { proxy: { $q: a } } = n;
    return () => {
      if (e.props === void 0)
        return h("th", { class: e.autoWidth === true ? "q-table--col-auto-width" : "" }, hSlot(t.default));
      let l, i;
      const r = n.vnode.key;
      if (r) {
        if (l = e.props.colsMap[r], l === void 0)
          return;
      } else
        l = e.props.col;
      if (l.sortable === true) {
        const e2 = l.align === "right" ? "unshift" : "push";
        i = hUniqueSlot(t.default, []), i[e2](h(QIcon, { class: l.__iconClass, name: a.iconSet.table.arrowUp }));
      } else
        i = hSlot(t.default);
      const s2 = { class: l.__thClass + (e.autoWidth === true ? " q-table--col-auto-width" : ""), style: l.headerStyle };
      return l.sortable === true && (s2.onClick = (t2) => {
        e.props.sort(l), o("click", t2);
      }), h("th", s2, i);
    };
  } });
  function getTableMiddle(e, t) {
    return h("div", e, [h("table", { class: "q-table" }, t)]);
  }
  var comps = { list: QList, table: QMarkupTable };
  var typeOptions = ["list", "table", "__qtable"];
  var QVirtualScroll = defineComponent2({ name: "QVirtualScroll", props: { ...useVirtualScrollProps, type: { type: String, default: "list", validator: (e) => typeOptions.includes(e) }, items: { type: Array, default: () => [] }, itemsFn: Function, itemsSize: Number, scrollTarget: { default: void 0 } }, setup(e, { slots: t, attrs: o }) {
    let n;
    const a = ref(null), l = computed2(() => e.itemsSize >= 0 && e.itemsFn !== void 0 ? parseInt(e.itemsSize, 10) : Array.isArray(e.items) ? e.items.length : 0), { virtualScrollSliceRange: i, localResetVirtualScroll: r, padVirtualScroll: s2, onVirtualScrollEvt: u } = useVirtualScroll({ virtualScrollLength: l, getVirtualScrollTarget: m, getVirtualScrollEl: v }), c = computed2(() => {
      if (l.value === 0)
        return [];
      const t2 = (e2, t3) => ({ index: i.value.from + t3, item: e2 });
      return e.itemsFn === void 0 ? e.items.slice(i.value.from, i.value.to).map(t2) : e.itemsFn(i.value.from, i.value.to - i.value.from).map(t2);
    }), d = computed2(() => "q-virtual-scroll q-virtual-scroll" + (e.virtualScrollHorizontal === true ? "--horizontal" : "--vertical") + (e.scrollTarget !== void 0 ? "" : " scroll")), p2 = computed2(() => e.scrollTarget !== void 0 ? {} : { tabindex: 0 });
    function v() {
      return a.value.$el || a.value;
    }
    function m() {
      return n;
    }
    function f() {
      n = getScrollTarget(v(), e.scrollTarget), n.addEventListener("scroll", u, listenOpts.passive);
    }
    function g() {
      n !== void 0 && (n.removeEventListener("scroll", u, listenOpts.passive), n = void 0);
    }
    function b() {
      let o2 = s2(e.type === "list" ? "div" : "tbody", c.value.map(t.default));
      return t.before !== void 0 && (o2 = t.before().concat(o2)), hMergeSlot(t.after, o2);
    }
    return watch(l, () => {
      r();
    }), watch(() => e.scrollTarget, () => {
      g(), f();
    }), onBeforeMount(() => {
      r();
    }), onMounted2(() => {
      f();
    }), onBeforeUnmount2(() => {
      g();
    }), () => {
      if (t.default !== void 0)
        return e.type === "__qtable" ? getTableMiddle({ ref: a, class: "q-table__middle " + d.value }, b()) : h(comps[e.type], { ...o, ref: a, class: [o.class, d.value], ...p2.value }, b);
      console.error("QVirtualScroll: default scoped slot is required for rendering");
    };
  } });
  function sortDate(e, t) {
    return new Date(e) - new Date(t);
  }
  var useTableSortProps = { sortMethod: Function, binaryStateSort: Boolean, columnSortOrder: { type: String, validator: (e) => e === "ad" || e === "da", default: "ad" } };
  function useTableSort(e, t, o, n) {
    const a = computed2(() => {
      const { sortBy: e2 } = t.value;
      return e2 && o.value.find((t2) => t2.name === e2) || null;
    }), l = computed2(() => e.sortMethod !== void 0 ? e.sortMethod : (e2, t2, n2) => {
      const a2 = o.value.find((e3) => e3.name === t2);
      if (a2 === void 0 || a2.field === void 0)
        return e2;
      const l2 = n2 === true ? -1 : 1, i2 = typeof a2.field === "function" ? (e3) => a2.field(e3) : (e3) => e3[a2.field];
      return e2.sort((e3, t3) => {
        let o2 = i2(e3), n3 = i2(t3);
        return o2 === null || o2 === void 0 ? -1 * l2 : n3 === null || n3 === void 0 ? 1 * l2 : a2.sort !== void 0 ? a2.sort(o2, n3, e3, t3) * l2 : isNumber(o2) === true && isNumber(n3) === true ? (o2 - n3) * l2 : isDate2(o2) === true && isDate2(n3) === true ? sortDate(o2, n3) * l2 : typeof o2 === "boolean" && typeof n3 === "boolean" ? (o2 - n3) * l2 : ([o2, n3] = [o2, n3].map((e4) => (e4 + "").toLocaleString().toLowerCase()), o2 < n3 ? -1 * l2 : o2 === n3 ? 0 : l2);
      });
    });
    function i(a2) {
      let l2 = e.columnSortOrder;
      if (a2 === Object(a2))
        a2.sortOrder && (l2 = a2.sortOrder), a2 = a2.name;
      else {
        const e2 = o.value.find((e3) => e3.name === a2);
        e2 !== void 0 && e2.sortOrder && (l2 = e2.sortOrder);
      }
      let { sortBy: i2, descending: r } = t.value;
      i2 !== a2 ? (i2 = a2, r = l2 === "da") : e.binaryStateSort === true ? r = !r : r === true ? l2 === "ad" ? i2 = null : r = false : l2 === "ad" ? r = true : i2 = null, n({ sortBy: i2, descending: r, page: 1 });
    }
    return { columnToSort: a, computedSortMethod: l, sort: i };
  }
  var useTableFilterProps = { filter: [String, Object], filterMethod: Function };
  function useTableFilter(e, t) {
    const o = computed2(() => e.filterMethod !== void 0 ? e.filterMethod : (e2, t2, o2, n) => {
      const a = t2 ? t2.toLowerCase() : "";
      return e2.filter((e3) => o2.some((t3) => {
        const o3 = n(t3, e3) + "", l = o3 === "undefined" || o3 === "null" ? "" : o3.toLowerCase();
        return l.indexOf(a) !== -1;
      }));
    });
    return watch(() => e.filter, () => {
      nextTick2(() => {
        t({ page: 1 }, true);
      });
    }, { deep: true }), { computedFilterMethod: o };
  }
  function samePagination(e, t) {
    for (const o in t)
      if (t[o] !== e[o])
        return false;
    return true;
  }
  function fixPagination(e) {
    return e.page < 1 && (e.page = 1), e.rowsPerPage !== void 0 && e.rowsPerPage < 1 && (e.rowsPerPage = 0), e;
  }
  var useTablePaginationProps = { pagination: Object, rowsPerPageOptions: { type: Array, default: () => [5, 7, 10, 15, 20, 25, 50, 0] }, "onUpdate:pagination": Function };
  function useTablePaginationState(e, t) {
    const { props: o, emit: n } = e, a = ref(Object.assign({ sortBy: null, descending: false, page: 1, rowsPerPage: o.rowsPerPageOptions.length > 0 ? o.rowsPerPageOptions[0] : 5 }, o.pagination)), l = computed2(() => {
      const e2 = o["onUpdate:pagination"] !== void 0 ? { ...a.value, ...o.pagination } : a.value;
      return fixPagination(e2);
    }), i = computed2(() => l.value.rowsNumber !== void 0);
    function r(e2) {
      s2({ pagination: e2, filter: o.filter });
    }
    function s2(e2 = {}) {
      nextTick2(() => {
        n("request", { pagination: e2.pagination || l.value, filter: e2.filter || o.filter, getCellValue: t });
      });
    }
    function u(e2, t2) {
      const s3 = fixPagination({ ...l.value, ...e2 });
      samePagination(l.value, s3) ? i.value === true && t2 === true && r(s3) : i.value !== true ? o.pagination !== void 0 && o["onUpdate:pagination"] !== void 0 ? n("update:pagination", s3) : a.value = s3 : r(s3);
    }
    return { innerPagination: a, computedPagination: l, isServerSide: i, requestServerInteraction: s2, setPagination: u };
  }
  function useTablePagination(e, t, o, n, a, l) {
    const { props: i, emit: r, proxy: { $q: s2 } } = e, u = computed2(() => n.value === true ? o.value.rowsNumber || 0 : l.value), c = computed2(() => {
      const { page: e2, rowsPerPage: t2 } = o.value;
      return (e2 - 1) * t2;
    }), d = computed2(() => {
      const { page: e2, rowsPerPage: t2 } = o.value;
      return e2 * t2;
    }), p2 = computed2(() => o.value.page === 1), v = computed2(() => o.value.rowsPerPage === 0 ? 1 : Math.max(1, Math.ceil(u.value / o.value.rowsPerPage))), m = computed2(() => d.value === 0 || o.value.page >= v.value), f = computed2(() => {
      const e2 = i.rowsPerPageOptions.includes(t.value.rowsPerPage) ? i.rowsPerPageOptions : [t.value.rowsPerPage].concat(i.rowsPerPageOptions);
      return e2.map((e3) => ({ label: e3 === 0 ? s2.lang.table.allRows : "" + e3, value: e3 }));
    });
    function h3() {
      a({ page: 1 });
    }
    function g() {
      const { page: e2 } = o.value;
      e2 > 1 && a({ page: e2 - 1 });
    }
    function b() {
      const { page: e2, rowsPerPage: t2 } = o.value;
      d.value > 0 && e2 * t2 < u.value && a({ page: e2 + 1 });
    }
    function y() {
      a({ page: v.value });
    }
    return watch(v, (e2, t2) => {
      if (e2 === t2)
        return;
      const n2 = o.value.page;
      e2 && !n2 ? a({ page: 1 }) : e2 < n2 && a({ page: e2 });
    }), i["onUpdate:pagination"] !== void 0 && r("update:pagination", { ...o.value }), { firstRowIndex: c, lastRowIndex: d, isFirstPage: p2, isLastPage: m, pagesNumber: v, computedRowsPerPageOptions: f, computedRowsNumber: u, firstPage: h3, prevPage: g, nextPage: b, lastPage: y };
  }
  var useTableRowSelectionProps = { selection: { type: String, default: "none", validator: (e) => ["single", "multiple", "none"].includes(e) }, selected: { type: Array, default: () => [] } };
  var useTableRowSelectionEmits = ["update:selected", "selection"];
  function useTableRowSelection(e, t, o, n) {
    const a = computed2(() => {
      const t2 = {};
      return e.selected.map(n.value).forEach((e2) => {
        t2[e2] = true;
      }), t2;
    }), l = computed2(() => {
      return e.selection !== "none";
    }), i = computed2(() => {
      return e.selection === "single";
    }), r = computed2(() => {
      return e.selection === "multiple";
    }), s2 = computed2(() => o.value.length > 0 && o.value.every((e2) => a.value[n.value(e2)] === true)), u = computed2(() => s2.value !== true && o.value.some((e2) => a.value[n.value(e2)] === true)), c = computed2(() => e.selected.length);
    function d(e2) {
      return a.value[e2] === true;
    }
    function p2() {
      t("update:selected", []);
    }
    function v(o2, a2, l2, r2) {
      t("selection", { rows: a2, added: l2, keys: o2, evt: r2 });
      const s3 = i.value === true ? l2 === true ? a2 : [] : l2 === true ? e.selected.concat(a2) : e.selected.filter((e2) => o2.includes(n.value(e2)) === false);
      t("update:selected", s3);
    }
    return { hasSelectionMode: l, singleSelection: i, multipleSelection: r, allRowsSelected: s2, someRowsSelected: u, rowsSelectedNumber: c, isRowSelected: d, clearSelection: p2, updateSelection: v };
  }
  function getVal(e) {
    return Array.isArray(e) ? e.slice() : [];
  }
  var useTableRowExpandProps = { expanded: Array };
  var useTableRowExpandEmits = ["update:expanded"];
  function useTableRowExpand(e, t) {
    const o = ref(getVal(e.expanded));
    function n(e2) {
      return o.value.includes(e2);
    }
    function a(n2) {
      e.expanded !== void 0 ? t("update:expanded", n2) : o.value = n2;
    }
    function l(e2, t2) {
      const n2 = o.value.slice(), l2 = n2.indexOf(e2);
      t2 === true ? l2 === -1 && (n2.push(e2), a(n2)) : l2 !== -1 && (n2.splice(l2, 1), a(n2));
    }
    return watch(() => e.expanded, (e2) => {
      o.value = getVal(e2);
    }), { isRowExpanded: n, setExpanded: a, updateExpanded: l };
  }
  var useTableColumnSelectionProps = { visibleColumns: Array };
  function useTableColumnSelection(e, t, o) {
    const n = computed2(() => {
      if (e.columns !== void 0)
        return e.columns;
      const t2 = e.rows[0];
      return t2 !== void 0 ? Object.keys(t2).map((e2) => ({ name: e2, label: e2.toUpperCase(), field: e2, align: isNumber(t2[e2]) ? "right" : "left", sortable: true })) : [];
    }), a = computed2(() => {
      const { sortBy: o2, descending: a2 } = t.value, l2 = e.visibleColumns !== void 0 ? n.value.filter((t2) => t2.required === true || e.visibleColumns.includes(t2.name) === true) : n.value;
      return l2.map((e2) => {
        const t2 = e2.align || "right", n2 = `text-${t2}`;
        return { ...e2, align: t2, __iconClass: `q-table__sort-icon q-table__sort-icon--${t2}`, __thClass: n2 + (e2.headerClasses !== void 0 ? " " + e2.headerClasses : "") + (e2.sortable === true ? " sortable" : "") + (e2.name === o2 ? ` sorted ${a2 === true ? "sort-desc" : ""}` : ""), __tdStyle: e2.style !== void 0 ? typeof e2.style !== "function" ? () => e2.style : e2.style : () => null, __tdClass: e2.classes !== void 0 ? typeof e2.classes !== "function" ? () => n2 + " " + e2.classes : (t3) => n2 + " " + e2.classes(t3) : () => n2 };
      });
    }), l = computed2(() => {
      const e2 = {};
      return a.value.forEach((t2) => {
        e2[t2.name] = t2;
      }), e2;
    }), i = computed2(() => {
      return e.tableColspan !== void 0 ? e.tableColspan : a.value.length + (o.value === true ? 1 : 0);
    });
    return { colList: n, computedCols: a, computedColsMap: l, computedColspan: i };
  }
  var bottomClass = "q-table__bottom row items-center";
  var commonVirtPropsObj = {};
  commonVirtPropsList.forEach((e) => {
    commonVirtPropsObj[e] = {};
  });
  var QTable = defineComponent2({ name: "QTable", props: { rows: { type: Array, default: () => [] }, rowKey: { type: [String, Function], default: "id" }, columns: Array, loading: Boolean, iconFirstPage: String, iconPrevPage: String, iconNextPage: String, iconLastPage: String, title: String, hideHeader: Boolean, grid: Boolean, gridHeader: Boolean, dense: Boolean, flat: Boolean, bordered: Boolean, square: Boolean, separator: { type: String, default: "horizontal", validator: (e) => ["horizontal", "vertical", "cell", "none"].includes(e) }, wrapCells: Boolean, virtualScroll: Boolean, ...commonVirtPropsObj, noDataLabel: String, noResultsLabel: String, loadingLabel: String, selectedRowsLabel: Function, rowsPerPageLabel: String, paginationLabel: Function, color: { type: String, default: "grey-8" }, titleClass: [String, Array, Object], tableStyle: [String, Array, Object], tableClass: [String, Array, Object], tableHeaderStyle: [String, Array, Object], tableHeaderClass: [String, Array, Object], cardContainerClass: [String, Array, Object], cardContainerStyle: [String, Array, Object], cardStyle: [String, Array, Object], cardClass: [String, Array, Object], hideBottom: Boolean, hideSelectedBanner: Boolean, hideNoData: Boolean, hidePagination: Boolean, onRowClick: Function, onRowDblclick: Function, onRowContextmenu: Function, ...useDarkProps, ...useFullscreenProps, ...useTableColumnSelectionProps, ...useTableFilterProps, ...useTablePaginationProps, ...useTableRowExpandProps, ...useTableRowSelectionProps, ...useTableSortProps }, emits: ["request", "virtual-scroll", ...useFullscreenEmits, ...useTableRowExpandEmits, ...useTableRowSelectionEmits], setup(e, { slots: t, emit: o }) {
    const n = getCurrentInstance(), { proxy: { $q: a } } = n, l = useDark(e, a), { inFullscreen: i, toggleFullscreen: r } = useFullscreen(), s2 = computed2(() => typeof e.rowKey === "function" ? e.rowKey : (t2) => t2[e.rowKey]), u = ref(null), c = ref(null), d = computed2(() => e.grid !== true && e.virtualScroll === true), p2 = computed2(() => " q-table__card" + (l.value === true ? " q-table__card--dark q-dark" : "") + (e.square === true ? " q-table--square" : "") + (e.flat === true ? " q-table--flat" : "") + (e.bordered === true ? " q-table--bordered" : "")), v = computed2(() => `q-table__container q-table--${e.separator}-separator column no-wrap` + (e.loading === true ? " q-table--loading" : "") + (e.grid === true ? " q-table--grid" : p2.value) + (l.value === true ? " q-table--dark" : "") + (e.dense === true ? " q-table--dense" : "") + (e.wrapCells === false ? " q-table--no-wrap" : "") + (i.value === true ? " fullscreen scroll" : "")), m = computed2(() => v.value + (e.loading === true ? " q-table--loading" : ""));
    watch(() => e.tableStyle + e.tableClass + e.tableHeaderStyle + e.tableHeaderClass + v.value, () => {
      d.value === true && c.value !== null && c.value.reset();
    });
    const { innerPagination: f, computedPagination: g, isServerSide: b, requestServerInteraction: y, setPagination: S } = useTablePaginationState(n, me), { computedFilterMethod: w } = useTableFilter(e, S), { isRowExpanded: x, setExpanded: C, updateExpanded: k2 } = useTableRowExpand(e, o), _ = computed2(() => {
      let t2 = e.rows;
      if (b.value === true || t2.length === 0)
        return t2;
      const { sortBy: o2, descending: n2 } = g.value;
      return e.filter && (t2 = w.value(t2, e.filter, R.value, me)), A.value !== null && (t2 = D.value(e.rows === t2 ? t2.slice() : t2, o2, n2)), t2;
    }), q = computed2(() => _.value.length), T = computed2(() => {
      let t2 = _.value;
      if (b.value === true)
        return t2;
      const { rowsPerPage: o2 } = g.value;
      return o2 !== 0 && (H.value === 0 && e.rows !== t2 ? t2.length > j.value && (t2 = t2.slice(0, j.value)) : t2 = t2.slice(H.value, j.value)), t2;
    }), { hasSelectionMode: P, singleSelection: $, multipleSelection: M, allRowsSelected: B, someRowsSelected: Q, rowsSelectedNumber: E, isRowSelected: O, clearSelection: z, updateSelection: F } = useTableRowSelection(e, o, T, s2), { colList: L, computedCols: R, computedColsMap: V, computedColspan: I } = useTableColumnSelection(e, g, P), { columnToSort: A, computedSortMethod: D, sort: N } = useTableSort(e, g, L, S), { firstRowIndex: H, lastRowIndex: j, isFirstPage: U, isLastPage: K, pagesNumber: W, computedRowsPerPageOptions: Y, computedRowsNumber: G, firstPage: X, prevPage: Z, nextPage: J, lastPage: ee } = useTablePagination(n, f, g, b, S, q), te = computed2(() => T.value.length === 0), oe = computed2(() => {
      const t2 = {};
      return commonVirtPropsList.forEach((o2) => {
        t2[o2] = e[o2];
      }), t2.virtualScrollItemSize === void 0 && (t2.virtualScrollItemSize = e.dense === true ? 28 : 48), t2;
    });
    function ne() {
      d.value === true && c.value.reset();
    }
    function ae() {
      if (e.grid === true)
        return Te();
      const o2 = e.hideHeader !== true ? be : null;
      if (d.value === true) {
        const n3 = t["top-row"], a2 = t["bottom-row"], l2 = { default: (e2) => se(e2.item, t.body, e2.index) };
        if (n3 !== void 0) {
          const e2 = h("tbody", n3({ cols: R.value }));
          l2.before = o2 === null ? () => e2 : () => [o2()].concat(e2);
        } else
          o2 !== null && (l2.before = o2);
        return a2 !== void 0 && (l2.after = () => h("tbody", a2({ cols: R.value }))), h(QVirtualScroll, { ref: c, class: e.tableClass, style: e.tableStyle, ...oe.value, items: T.value, type: "__qtable", tableColspan: I.value, onVirtualScroll: ie }, l2);
      }
      const n2 = [ue()];
      return o2 !== null && n2.unshift(o2()), getTableMiddle({ class: ["q-table__middle scroll", e.tableClass], style: e.tableStyle }, n2);
    }
    function le(e2, t2) {
      if (c.value !== null)
        return void c.value.scrollTo(e2, t2);
      e2 = parseInt(e2, 10);
      const n2 = u.value.querySelector(`tbody tr:nth-of-type(${e2 + 1})`);
      if (n2 !== null) {
        const t3 = u.value.querySelector(".q-table__middle.scroll"), { offsetTop: a2 } = n2, l2 = a2 < t3.scrollTop ? "decrease" : "increase";
        t3.scrollTop = a2, o("virtual-scroll", { index: e2, from: 0, to: f.value.rowsPerPage - 1, direction: l2 });
      }
    }
    function ie(e2) {
      o("virtual-scroll", e2);
    }
    function re() {
      return [h(QLinearProgress, { class: "q-table__linear-progress", color: e.color, dark: l.value, indeterminate: true, trackColor: "transparent" })];
    }
    function se(n2, a2, i2) {
      const r2 = s2.value(n2), u2 = O(r2);
      if (a2 !== void 0)
        return a2(ce({ key: r2, row: n2, pageIndex: i2, __trClass: u2 ? "selected" : "" }));
      const c4 = t["body-cell"], d2 = R.value.map((e2) => {
        const o2 = t[`body-cell-${e2.name}`], a3 = o2 !== void 0 ? o2 : c4;
        return a3 !== void 0 ? a3(de({ key: r2, row: n2, pageIndex: i2, col: e2 })) : h("td", { class: e2.__tdClass(n2), style: e2.__tdStyle(n2) }, me(e2, n2));
      });
      if (P.value === true) {
        const o2 = t["body-selection"], a3 = o2 !== void 0 ? o2(pe({ key: r2, row: n2, pageIndex: i2 })) : [h(QCheckbox, { modelValue: u2, color: e.color, dark: l.value, dense: e.dense, "onUpdate:modelValue": (e2, t2) => {
          F([r2], [n2], e2, t2);
        } })];
        d2.unshift(h("td", { class: "q-table--col-auto-width" }, a3));
      }
      const p3 = { key: r2, class: { selected: u2 } };
      return e.onRowClick !== void 0 && (p3.class["cursor-pointer"] = true, p3.onClick = (e2) => {
        o("RowClick", e2, n2, i2);
      }), e.onRowDblclick !== void 0 && (p3.class["cursor-pointer"] = true, p3.onDblclick = (e2) => {
        o("RowDblclick", e2, n2, i2);
      }), e.onRowContextmenu !== void 0 && (p3.class["cursor-pointer"] = true, p3.onContextmenu = (e2) => {
        o("RowContextmenu", e2, n2, i2);
      }), h("tr", p3, d2);
    }
    function ue() {
      const e2 = t.body, o2 = t["top-row"], n2 = t["bottom-row"];
      let a2 = T.value.map((t2, o3) => se(t2, e2, o3));
      return o2 !== void 0 && (a2 = o2({ cols: R.value }).concat(a2)), n2 !== void 0 && (a2 = a2.concat(n2({ cols: R.value }))), h("tbody", a2);
    }
    function ce(e2) {
      return ve(e2), e2.cols = e2.cols.map((t2) => {
        const o2 = { ...t2 };
        return Object.defineProperty(o2, "value", { get: () => me(t2, e2.row), configurable: true, enumerable: true }), o2;
      }), e2;
    }
    function de(e2) {
      return ve(e2), Object.defineProperty(e2, "value", { get: () => me(e2.col, e2.row), configurable: true, enumerable: true }), e2;
    }
    function pe(e2) {
      return ve(e2), e2;
    }
    function ve(t2) {
      Object.assign(t2, { cols: R.value, colsMap: V.value, sort: N, rowIndex: H.value + t2.pageIndex, color: e.color, dark: l.value, dense: e.dense }), P.value === true && Object.defineProperty(t2, "selected", { get: () => O(t2.key), set: (e2, o2) => {
        F([t2.key], [t2.row], e2, o2);
      }, configurable: true, enumerable: true }), Object.defineProperty(t2, "expand", { get: () => x(t2.key), set: (e2) => {
        k2(t2.key, e2);
      }, configurable: true, enumerable: true });
    }
    function me(e2, t2) {
      const o2 = typeof e2.field === "function" ? e2.field(t2) : t2[e2.field];
      return e2.format !== void 0 ? e2.format(o2, t2) : o2;
    }
    const fe = computed2(() => ({ pagination: g.value, pagesNumber: W.value, isFirstPage: U.value, isLastPage: K.value, firstPage: X, prevPage: Z, nextPage: J, lastPage: ee, inFullscreen: i.value, toggleFullscreen: r }));
    function he() {
      const o2 = t.top, n2 = t["top-left"], a2 = t["top-right"], l2 = t["top-selection"], i2 = P.value === true && l2 !== void 0 && E.vaue > 0, r2 = "q-table__top relative-position row items-center";
      if (o2 !== void 0)
        return h("div", { class: r2 }, [o2(fe.value)]);
      let s3;
      return i2 === true ? s3 = l2(fe.value).slice() : (s3 = [], n2 !== void 0 ? s3.push(h("div", { class: "q-table-control" }, [n2(fe.value)])) : e.title && s3.push(h("div", { class: "q-table__control" }, [h("div", { class: ["q-table__title", e.titleClass] }, e.title)]))), a2 !== void 0 && (s3.push(h("div", { class: "q-table__separator col" })), s3.push(h("div", { class: "q-table__control" }, [a2(fe.value)]))), s3.length !== 0 ? h("div", { class: r2 }, s3) : void 0;
    }
    const ge = computed2(() => Q.value === true ? null : B.value);
    function be() {
      const o2 = ye();
      return e.loading === true && t.loading === void 0 && o2.push(h("tr", { class: "q-table__progress" }, [h("th", { class: "relative-position", colspan: I.value }, re())])), h("thead", o2);
    }
    function ye() {
      const o2 = t.header, n2 = t["header-cell"];
      if (o2 !== void 0)
        return o2(Se({ header: true })).slice();
      const a2 = R.value.map((e2) => {
        const o3 = t[`header-cell-${e2.name}`], a3 = o3 !== void 0 ? o3 : n2, l2 = Se({ col: e2 });
        return a3 !== void 0 ? a3(l2) : h(QTh, { key: e2.name, props: l2 }, () => e2.label);
      });
      if ($.value === true && e.grid !== true)
        a2.unshift(h("th", { class: "q-table--col-auto-width" }, " "));
      else if (M.value === true) {
        const o3 = t["header-selection"], n3 = o3 !== void 0 ? o3(Se({})) : [h(QCheckbox, { color: e.color, modelValue: ge.value, dark: l.value, dense: e.dense, "onUpdate:modelValue": we })];
        a2.unshift(h("th", { class: "q-table--col-auto-width" }, n3));
      }
      return [h("tr", { class: e.tableHeaderClass, style: e.tableHeaderStyle }, a2)];
    }
    function Se(t2) {
      return Object.assign(t2, { cols: R.value, sort: N, colsMap: V.value, color: e.color, dark: l.value, dense: e.dense }), M.value === true && Object.defineProperty(t2, "selected", { get: () => ge.value, set: we, configurable: true, enumerable: true }), t2;
    }
    function we(e2) {
      Q.value === true && (e2 = false), F(T.value.map(s2.value), T.value, e2);
    }
    const xe = computed2(() => {
      const t2 = [e.iconFirstPage || a.iconSet.table.firstPage, e.iconPrevPage || a.iconSet.table.prevPage, e.iconNextPage || a.iconSet.table.nextPage, e.iconLastPage || a.iconSet.table.lastPage];
      return a.lang.rtl === true ? t2.reverse() : t2;
    });
    function Ce() {
      if (e.hideBottom === true)
        return;
      if (te.value === true) {
        if (e.hideNoData === true)
          return;
        const o3 = e.loading === true ? e.loadingLabel || a.lang.table.loading : e.filter ? e.noResultsLabel || a.lang.table.noResults : e.noDataLabel || a.lang.table.noData, n3 = t["no-data"], l2 = n3 !== void 0 ? [n3({ message: o3, icon: a.iconSet.table.warning, filter: e.filter })] : [h(QIcon, { class: "q-table__bottom-nodata-icon", name: a.iconSet.table.warning }), o3];
        return h("div", { class: bottomClass + " q-table__bottom--nodata" }, l2);
      }
      const o2 = t.bottom;
      if (o2 !== void 0)
        return h("div", { class: bottomClass }, [o2(fe.value)]);
      const n2 = e.hideSelectedBanner !== true && P.value === true && E.value > 0 ? [h("div", { class: "q-table__control" }, [h("div", [(e.selectedRowsLabel || a.lang.table.selectedRecords)(E.value)])])] : [];
      return e.hidePagination !== true ? h("div", { class: bottomClass + " justify-end" }, _e(n2)) : n2.length > 0 ? h("div", { class: bottomClass }, n2) : void 0;
    }
    function ke(e2) {
      S({ page: 1, rowsPerPage: e2.value });
    }
    function _e(o2) {
      let n2;
      const { rowsPerPage: i2 } = g.value, r2 = e.paginationLabel || a.lang.table.pagination, s3 = t.pagination, u2 = e.rowsPerPageOptions.length > 1;
      if (o2.push(h("div", { class: "q-table__separator col" })), u2 === true && o2.push(h("div", { class: "q-table__control" }, [h("span", { class: "q-table__bottom-item" }, [e.rowsPerPageLabel || a.lang.table.recordsPerPage]), h(QSelect, { class: "q-table__select inline q-table__bottom-item", color: e.color, modelValue: i2, options: Y.value, displayValue: i2 === 0 ? a.lang.table.allRows : i2, dark: l.value, borderless: true, dense: true, optionsDense: true, optionsCover: true, "onUpdate:modelValue": ke })])), s3 !== void 0)
        n2 = s3(fe.value);
      else if (n2 = [h("span", i2 !== 0 ? { class: "q-table__bottom-item" } : {}, [i2 ? r2(H.value + 1, Math.min(j.value, G.value), G.value) : r2(1, q.value, G.value)])], i2 !== 0 && W.value > 1) {
        const t2 = { color: e.color, round: true, dense: true, flat: true };
        e.dense === true && (t2.size = "sm"), W.value > 2 && n2.push(h(QBtn, { key: "pgFirst", ...t2, icon: xe.value[0], disable: U.value, onClick: X })), n2.push(h(QBtn, { key: "pgPrev", ...t2, icon: xe.value[1], disable: U.value, onClick: Z }), h(QBtn, { key: "pgNext", ...t2, icon: xe.value[2], disable: K.value, onClick: J })), W.value > 2 && n2.push(h(QBtn, { key: "pgLast", ...t2, icon: xe.value[3], disable: K.value, onClick: ee }));
      }
      return o2.push(h("div", { class: "q-table__control" }, n2)), o2;
    }
    function qe() {
      const o2 = e.gridHeader === true ? [h("table", { class: "q-table" }, [be()])] : e.loading === true && t.loading === void 0 ? re() : void 0;
      return h("div", { class: "q-table__middle" }, o2);
    }
    function Te() {
      const n2 = t.item !== void 0 ? t.item : (n3) => {
        const a2 = n3.cols.map((e2) => h("div", { class: "q-table__grid-item-row" }, [h("div", { class: "q-table__grid-item-title" }, [e2.label]), h("div", { class: "q-table__grid-item-value" }, [e2.value])]));
        if (P.value === true) {
          const o2 = t["body-selection"], i3 = o2 !== void 0 ? o2(n3) : [h(QCheckbox, { modelValue: n3.selected, color: e.color, dark: l.value, dense: e.dense, "onUpdate:modelValue": (e2, t2) => {
            F([n3.key], [n3.row], e2, t2);
          } })];
          a2.unshift(h("div", { class: "q-table__grid-item-row" }, i3), h(QSeparator, { dark: l.value }));
        }
        const i2 = { class: ["q-table__grid-item-card" + p2.value, e.cardClass], style: e.cardStyle };
        return e.onRowClick === void 0 && e.onRowDblclick === void 0 || (i2.class[0] += " cursor-pointer", e.onRowClick !== void 0 && (i2.onClick = (e2) => {
          o("RowClick", e2, n3.row, n3.pageIndex);
        }), e.onRowDblclick !== void 0 && (i2.onDblclick = (e2) => {
          o("RowDblclick", e2, n3.row, n3.pageIndex);
        })), h("div", { class: "q-table__grid-item col-xs-12 col-sm-6 col-md-4 col-lg-3" + (n3.selected === true ? "q-table__grid-item--selected" : "") }, [h("div", i2, a2)]);
      };
      return h("div", { class: ["q-table__grid-content row", e.cardContainerClass], style: e.cardContainerStyle }, T.value.map((e2, t2) => {
        return n2(ce({ key: s2.value(e2), row: e2, pageIndex: t2 }));
      }));
    }
    return Object.assign(n.proxy, { requestServerInteraction: y, setPagination: S, firstPage: X, prevPage: Z, nextPage: J, lastPage: ee, isRowSelected: O, clearSelection: z, isRowExpanded: x, setExpanded: C, sort: N, resetVirtualScroll: ne, scrollTo: le, getCellValue: me }), Object.defineProperty(n.proxy, "filteredSortedRows", { get: () => _.value, enumerable: true }), Object.defineProperty(n.proxy, "computedRows", { get: () => T.value, enumerable: true }), Object.defineProperty(n.proxy, "computedRowsNumber", { get: () => G.value, enumerable: true }), () => {
      const o2 = [he()], n2 = { ref: u, class: m.value };
      return e.grid === true ? o2.push(qe()) : Object.assign(n2, { class: [n2.class, e.cardClass], style: e.cardStyle }), o2.push(ae(), Ce()), e.loading === true && t.loading !== void 0 && o2.push(t.loading()), h("div", n2, o2);
    };
  } });
  var QTr = defineComponent2({ name: "QTr", props: { props: Object, noHover: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => "q-tr" + (e.props === void 0 || e.props.header === true ? "" : " " + e.props.__trClass) + (e.noHover === true ? " q-tr--no-hover" : ""));
    return () => h("tr", { class: o.value }, hSlot(t.default));
  } });
  var QTd = defineComponent2({ name: "QTd", props: { props: Object, autoWidth: Boolean, noHover: Boolean }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = computed2(() => "q-td" + (e.autoWidth === true ? " q-table--col-auto-width" : "") + (e.noHover === true ? " q-td--no-hover" : "") + " ");
    return () => {
      if (e.props === void 0)
        return h("td", { class: n.value }, hSlot(t.default));
      const a = o.vnode.key, l = (e.props.colsMap !== void 0 ? e.props.colsMap[a] : null) || e.props.col;
      if (l === void 0)
        return;
      const { row: i } = e.props;
      return h("td", { class: n.value + l.__tdClass(i), style: l.__tdStyle(i) }, hSlot(t.default));
    };
  } });
  var QRouteTab = defineComponent2({ name: "QRouteTab", props: { ...useRouterLinkProps, ...useTabProps, to: { required: true } }, emits: useTabEmits, setup(e, { slots: t, emit: o }) {
    const n = useRouterLink(), { renderTab: a, $tabs: l } = useTab(e, t, o, { exact: computed2(() => e.exact), ...n });
    return watch(() => e.name + e.exact + (n.linkRoute.value || {}).href, () => {
      l.verifyRouteModel();
    }), () => a(n.linkTag.value, n.linkProps.value);
  } });
  function getViewByModel(e, t) {
    if (e.hour !== null) {
      if (e.minute === null)
        return "minute";
      if (t === true && e.second === null)
        return "second";
    }
    return "hour";
  }
  function getCurrentTime() {
    const e = new Date();
    return { hour: e.getHours(), minute: e.getMinutes(), second: e.getSeconds(), millisecond: e.getMilliseconds() };
  }
  var QTime = defineComponent2({ name: "QTime", props: { ...useDarkProps, ...useFormProps, ...useDatetimeProps, mask: { default: null }, format24h: { type: Boolean, default: null }, defaultDate: { type: String, validator: (e) => /^-?[\d]+\/[0-1]\d\/[0-3]\d$/.test(e) }, options: Function, hourOptions: Array, minuteOptions: Array, secondOptions: Array, withSeconds: Boolean, nowBtn: Boolean }, emits: useDatetimeEmits, setup(e, { slots: t, emit: o }) {
    const { proxy: { $q: n } } = getCurrentInstance(), a = useDark(e, n), { tabindex: l, headerClass: i, getLocale: r, getCurrentDate: s2 } = useDatetime(e, n), u = useFormAttrs(e), c = useFormInject(u);
    let d, p2;
    const v = ref(null), m = computed2(() => A()), f = computed2(() => r()), g = __splitDate(e.modelValue, A(), r(), e.calendar, D()), b = ref(getViewByModel(g)), y = ref(g), S = ref(g.hour === null || g.hour < 12), w = computed2(() => `q-time q-time--${e.landscape === true ? "landscape" : "portrait"}` + (a.value === true ? " q-time--dark q-dark" : "") + (e.disable === true ? " disabled" : e.readonly === true ? " q-time--readonly" : "") + (e.bordered === true ? " q-time--bordered" : "") + (e.square === true ? " q-time--square no-border-radius" : "") + (e.flat === true ? " q-time--flat no-shadow" : "")), x = computed2(() => {
      const e2 = y.value;
      return { hour: e2.hour === null ? "--" : k2.value === true ? pad(e2.hour) : String(S.value === true ? e2.hour === 0 ? 12 : e2.hour : e2.hour > 12 ? e2.hour - 12 : e2.hour), minute: e2.minute === null ? "--" : pad(e2.minute), second: e2.second === null ? "--" : pad(e2.second) };
    }), C = computed2(() => D()), k2 = computed2(() => e.format24h !== null ? e.format24h : n.lang.date.format24h), _ = computed2(() => {
      const e2 = b.value === "hour", t2 = e2 === true ? 12 : 60, o2 = y.value[b.value], n2 = Math.round(o2 * (360 / t2)) - 180;
      let a2 = `rotate(${n2}deg) translateX(-50%)`;
      return e2 === true && k2.value === true && y.value.hour >= 12 && (a2 += " scale(.7)"), { transform: a2 };
    }), q = computed2(() => y.value.hour !== null), T = computed2(() => q.value === true && y.value.minute !== null), P = computed2(() => e.hourOptions !== void 0 ? (t2) => e.hourOptions.includes(t2) : e.options !== void 0 ? (t2) => e.options(t2, null, null) : null), $ = computed2(() => e.minuteOptions !== void 0 ? (t2) => e.minuteOptions.includes(t2) : e.options !== void 0 ? (t2) => e.options(y.value.hour, t2, null) : null), M = computed2(() => e.secondOptions !== void 0 ? (t2) => e.secondOptions.includes(t2) : e.options !== void 0 ? (t2) => e.options(y.value.hour, y.value.minute, t2) : null), B = computed2(() => {
      if (P.value === null)
        return null;
      const e2 = R(0, 11, P.value), t2 = R(12, 11, P.value);
      return { am: e2, pm: t2, values: e2.values.concat(t2.values) };
    }), Q = computed2(() => $.value !== null ? R(0, 59, $.value) : null), E = computed2(() => M.value !== null ? R(0, 59, M.value) : null), O = computed2(() => {
      switch (b.value) {
        case "hour":
          return B.value;
        case "minute":
          return Q.value;
        case "second":
          return E.value;
      }
    }), z = computed2(() => {
      let e2, t2, o2 = 0, n2 = 1;
      const a2 = O.value !== null ? O.value.values : void 0;
      b.value === "hour" ? k2.value === true ? (e2 = 0, t2 = 23) : (e2 = 0, t2 = 11, S.value === false && (o2 = 12)) : (e2 = 0, t2 = 55, n2 = 5);
      const l2 = [];
      for (let i2 = e2, r2 = e2; i2 <= t2; i2 += n2, r2++) {
        const e3 = i2 + o2, t3 = a2 !== void 0 && a2.includes(e3) === false, n3 = b.value === "hour" && i2 === 0 ? k2.value === true ? "00" : "12" : i2;
        l2.push({ val: e3, index: r2, disable: t3, label: n3 });
      }
      return l2;
    }), F = computed2(() => {
      return [[TouchPan, j, void 0, { stop: true, prevent: true, mouse: true }]];
    });
    function L() {
      ue({ ...s2(), ...getCurrentTime() }), b.value = "hour";
    }
    function R(e2, t2, o2) {
      const n2 = Array.apply(null, { length: t2 + 1 }).map((t3, n3) => {
        const a2 = n3 + e2;
        return { index: a2, val: o2(a2) === true };
      }).filter((e3) => e3.val === true).map((e3) => e3.index);
      return { min: n2[0], max: n2[n2.length - 1], values: n2, threshold: t2 + 1 };
    }
    function V(e2, t2, o2) {
      const n2 = Math.abs(e2 - t2);
      return Math.min(n2, o2 - n2);
    }
    function I(e2, { min: t2, max: o2, values: n2, threshold: a2 }) {
      if (e2 === t2)
        return t2;
      if (e2 < t2 || e2 > o2)
        return V(e2, t2, a2) <= V(e2, o2, a2) ? t2 : o2;
      const l2 = n2.findIndex((t3) => e2 <= t3), i2 = n2[l2 - 1], r2 = n2[l2];
      return e2 - i2 <= r2 - e2 ? i2 : r2;
    }
    function A() {
      return e.calendar !== "persian" && e.mask !== null ? e.mask : `HH:mm${e.withSeconds === true ? ":ss" : ""}`;
    }
    function D() {
      if (typeof e.defaultDate !== "string") {
        const e2 = s2(true);
        return e2.dateHash = getDayHash(e2), e2;
      }
      return __splitDate(e.defaultDate, "YYYY/MM/DD", void 0, e.calendar);
    }
    function N() {
      return ce.isDeactivated === true || ce.isUnmounted === true || O.value !== null && (O.value.values.length === 0 || b.value === "hour" && k2.value !== true && B.value[S.value === true ? "am" : "pm"].values.length === 0);
    }
    function H() {
      const e2 = v.value, { top: t2, left: o2, width: n2 } = e2.getBoundingClientRect(), a2 = n2 / 2;
      return { top: t2 + a2, left: o2 + a2, dist: 0.7 * a2 };
    }
    function j(e2) {
      if (N() !== true) {
        if (e2.isFirst === true)
          return d = H(), void (p2 = K(e2.evt, d));
        p2 = K(e2.evt, d, p2), e2.isFinal === true && (d = false, p2 = null, U());
      }
    }
    function U() {
      b.value === "hour" ? b.value = "minute" : e.withSeconds && b.value === "minute" && (b.value = "second");
    }
    function K(e2, t2, o2) {
      const n2 = position(e2), a2 = Math.abs(n2.top - t2.top), l2 = Math.sqrt(Math.pow(Math.abs(n2.top - t2.top), 2) + Math.pow(Math.abs(n2.left - t2.left), 2));
      let i2, r2 = Math.asin(a2 / l2) * (180 / Math.PI);
      if (r2 = n2.top < t2.top ? t2.left < n2.left ? 90 - r2 : 270 + r2 : t2.left < n2.left ? r2 + 90 : 270 - r2, b.value === "hour") {
        if (i2 = r2 / 30, B.value !== null) {
          const e3 = k2.value !== true ? S.value === true : B.value.am.values.length > 0 && B.value.pm.values.length > 0 ? l2 >= t2.dist : B.value.am.values.length > 0;
          i2 = I(i2 + (e3 === true ? 0 : 12), B.value[e3 === true ? "am" : "pm"]);
        } else
          i2 = Math.round(i2), k2.value === true ? l2 < t2.dist ? i2 < 12 && (i2 += 12) : i2 === 12 && (i2 = 0) : S.value === true && i2 === 12 ? i2 = 0 : S.value === false && i2 !== 12 && (i2 += 12);
        k2.value === true && (S.value = i2 < 12);
      } else
        i2 = Math.round(r2 / 6) % 60, b.value === "minute" && Q.value !== null ? i2 = I(i2, Q.value) : b.value === "second" && E.value !== null && (i2 = I(i2, E.value));
      return o2 !== i2 && le[b.value](i2), i2;
    }
    watch(() => e.modelValue, (t2) => {
      const o2 = __splitDate(t2, m.value, f.value, e.calendar, C.value);
      o2.dateHash === y.value.dateHash && o2.timeHash === y.value.timeHash || (y.value = o2, o2.hour === null ? b.value = "hour" : S.value = o2.hour < 12);
    }), watch([m, f], () => {
      nextTick2(() => {
        ue();
      });
    });
    const W = { hour() {
      b.value = "hour";
    }, minute() {
      b.value = "minute";
    }, second() {
      b.value = "second";
    } };
    function Y(e2) {
      e2.keyCode === 13 && ie();
    }
    function G(e2) {
      e2.keyCode === 13 && re();
    }
    function X(e2) {
      N() !== true && (n.platform.is.desktop !== true && K(e2, H()), U());
    }
    function Z(e2) {
      N() !== true && K(e2, H());
    }
    function J(e2) {
      if (e2.keyCode === 13)
        b.value = "hour";
      else if ([37, 39].includes(e2.keyCode)) {
        const t2 = e2.keyCode === 37 ? -1 : 1;
        if (B.value !== null) {
          const e3 = k2.value === true ? B.value.values : B.value[S.value === true ? "am" : "pm"].values;
          if (e3.length === 0)
            return;
          if (y.value.hour === null)
            oe(e3[0]);
          else {
            const o2 = (e3.length + e3.indexOf(y.value.hour) + t2) % e3.length;
            oe(e3[o2]);
          }
        } else {
          const e3 = k2.value === true ? 24 : 12, o2 = k2.value !== true && S.value === false ? 12 : 0, n2 = y.value.hour === null ? -t2 : y.value.hour;
          oe(o2 + (24 + n2 + t2) % e3);
        }
      }
    }
    function ee(e2) {
      if (e2.keyCode === 13)
        b.value = "minute";
      else if ([37, 39].includes(e2.keyCode)) {
        const t2 = e2.keyCode === 37 ? -1 : 1;
        if (Q.value !== null) {
          const e3 = Q.value.values;
          if (e3.length === 0)
            return;
          if (y.value.minute === null)
            ne(e3[0]);
          else {
            const o2 = (e3.length + e3.indexOf(y.value.minute) + t2) % e3.length;
            ne(e3[o2]);
          }
        } else {
          const e3 = y.value.minute === null ? -t2 : y.value.minute;
          ne((60 + e3 + t2) % 60);
        }
      }
    }
    function te(e2) {
      if (e2.keyCode === 13)
        b.value = "second";
      else if ([37, 39].includes(e2.keyCode)) {
        const t2 = e2.keyCode === 37 ? -1 : 1;
        if (E.value !== null) {
          const e3 = E.value.values;
          if (e3.length === 0)
            return;
          if (y.value.seconds === null)
            ae(e3[0]);
          else {
            const o2 = (e3.length + e3.indexOf(y.value.second) + t2) % e3.length;
            ae(e3[o2]);
          }
        } else {
          const e3 = y.value.second === null ? -t2 : y.value.second;
          ae((60 + e3 + t2) % 60);
        }
      }
    }
    function oe(e2) {
      y.value.hour !== e2 && (y.value.hour = e2, y.value.minute = null, y.value.second = null);
    }
    function ne(t2) {
      y.value.minute !== t2 && (y.value.minute = t2, y.value.second = null, e.withSeconds !== true && ue({ minute: t2 }));
    }
    function ae(e2) {
      y.value.second !== e2 && ue({ second: e2 });
    }
    const le = { hour: oe, minute: ne, second: ae };
    function ie() {
      S.value === false && (S.value = true, y.value.hour !== null && (y.value.hour -= 12, se()));
    }
    function re() {
      S.value === true && (S.value = false, y.value.hour !== null && (y.value.hour += 12, se()));
    }
    function se() {
      return P.value !== null && P.value(y.value.hour) !== true ? (y.value = __splitDate(), void (b.value = "hour")) : $.value !== null && $.value(y.value.minute) !== true ? (y.value.minute = null, y.value.second = null, void (b.value = "minute")) : e.withSeconds === true && M.value !== null && M.value(y.value.second) !== true ? (y.value.second = null, void (b.value = "second")) : void (y.value.hour === null || y.value.minute === null || e.withSeconds === true && y.value.second === null || ue());
    }
    function ue(t2) {
      const n2 = Object.assign({ ...y.value }, t2), a2 = e.calendar === "persian" ? pad(n2.hour) + ":" + pad(n2.minute) + (e.withSeconds === true ? ":" + pad(n2.second) : "") : formatDate(new Date(n2.year, n2.month === null ? null : n2.month - 1, n2.day, n2.hour, n2.minute, n2.second, n2.millisecond), m.value, f.value, n2.year, n2.timezoneOffset);
      n2.changed = a2 !== e.modelValue, o("update:modelValue", a2, n2);
    }
    const ce = getCurrentInstance();
    function de() {
      const t2 = [h("div", { class: "q-time__link " + (b.value === "hour" ? "q-time__link--active" : "cursor-pointer"), tabindex: l.value, onClick: W.hour, onKeyup: J }, x.value.hour), h("div", ":"), h("div", q.value === true ? { class: "q-time__link " + (b.value === "minute" ? "q-time__link--active" : "cursor-pointer"), tabindex: l.value, onKeyup: ee, onClick: W.minute } : { class: "q-time__link" }, x.value.minute)];
      e.withSeconds === true && t2.push(h("div", ":"), h("div", T.value === true ? { class: "q-time__link " + (b.value === "second" ? "q-time__link--active" : "cursor-pointer"), tabindex: l.value, onKeyup: te, onClick: W.second } : { class: "q-time__link" }, x.value.second));
      const o2 = [h("div", { class: "q-time__header-label row items-center no-wrap", dir: "ltr" }, t2)];
      return k2.value === false && o2.push(h("div", { class: "q-time__header-ampm column items-between no-wrap" }, [h("div", { class: "q-time__link " + (S.value === true ? "q-time__link--active" : "cursor-pointer"), tabindex: l.value, onClick: ie, onKeyup: Y }, "AM"), h("div", { class: "q-time__link " + (S.value !== true ? "q-time__link--active" : "cursor-pointer"), tabindex: l.value, onClick: re, onKeyup: G }, "PM")])), h("div", { class: "q-time__header flex flex-center no-wrap " + i.value }, o2);
    }
    function pe() {
      const t2 = y.value[b.value];
      return h("div", { class: "q-time__content col relative-position" }, [h(Transition, { name: "q-transition--scale" }, () => h("div", { key: "clock" + b.value, class: "q-time__container-parent absolute-full" }, [h("div", { ref: v, class: "q-time__container-child fit overflow-hidden" }, [withDirectives(h("div", { class: "q-time__clock cursor-pointer non-selectable", onClick: X, onMousedown: Z }, [h("div", { class: "q-time__clock-circle fit" }, [h("div", { class: "q-time__clock-pointer" + (y.value[b.value] === null ? " hidden" : e.color !== void 0 ? ` text-${e.color}` : ""), style: _.value }), z.value.map((e2) => h("div", { class: `q-time__clock-position row flex-center q-time__clock-pos-${e2.index}` + (e2.val === t2 ? " q-time__clock-position--active " + i.value : e2.disable === true ? " q-time__clock-position--disable" : "") }, [h("span", e2.label)]))])]), F.value)])])), e.nowBtn === true ? h(QBtn, { class: "q-time__now-button absolute", icon: n.iconSet.datetime.now, unelevated: true, size: "sm", round: true, color: e.color, textColor: e.textColor, tabindex: l.value, onClick: L }) : null]);
    }
    return Object.assign(ce.proxy, { setNow: L }), () => {
      const o2 = [pe()], n2 = hSlot(t.default);
      return n2 !== void 0 && o2.push(h("div", { class: "q-time__actions" }, n2)), e.name !== void 0 && e.disable !== true && c(o2, "push"), h("div", { class: w.value, tabindex: -1 }, [de(), h("div", { class: "q-time__main col overflow-auto" }, o2)]);
    };
  } });
  var QTimeline = defineComponent2({ name: "QTimeline", props: { ...useDarkProps, color: { type: String, default: "primary" }, side: { type: String, default: "right", validator: (e) => ["left", "right"].includes(e) }, layout: { type: String, default: "dense", validator: (e) => ["dense", "comfortable", "loose"].includes(e) } }, setup(e, { slots: t }) {
    const o = getCurrentInstance(), n = useDark(e, o.proxy.$q);
    provide2(timelineKey, e);
    const a = computed2(() => `q-timeline q-timeline--${e.layout} q-timeline--${e.layout}--${e.side}` + (n.value === true ? " q-timeline--dark" : ""));
    return () => h("ul", { class: a.value }, hSlot(t.default));
  } });
  var QTimelineEntry = defineComponent2({ name: "QTimelineEntry", props: { heading: Boolean, tag: { type: String, default: "h3" }, side: { type: String, default: "right", validator: (e) => ["left", "right"].includes(e) }, icon: String, avatar: String, color: String, title: String, subtitle: String, body: String }, setup(e, { slots: t }) {
    const o = inject2(timelineKey, () => {
      console.error("QTimelineEntry needs to be child of QTimeline");
    }), n = computed2(() => `q-timeline__entry q-timeline__entry--${e.side}` + (e.icon !== void 0 || e.avatar !== void 0 ? " q-timeline__entry--icon" : "")), a = computed2(() => `q-timeline__dot text-${e.color || o.color}`), l = computed2(() => o.layout === "comfortable" && o.side === "left");
    return () => {
      const o2 = hUniqueSlot(t.default, []);
      if (e.body !== void 0 && o2.unshift(e.body), e.heading === true) {
        const t2 = [h("div"), h("div"), h(e.tag, { class: "q-timeline__heading-title" }, o2)];
        return h("div", { class: "q-timeline__heading" }, l.value === true ? t2.reverse() : t2);
      }
      let i;
      e.icon !== void 0 ? i = [h(QIcon, { class: "row items-center justify-center", name: e.icon })] : e.avatar !== void 0 && (i = [h("img", { class: "q-timeline__dot-img", src: e.avatar })]);
      const r = [h("div", { class: "q-timeline__subtitle" }, [h("span", {}, hSlot(t.subtitle, [e.subtitle]))]), h("div", { class: a.value }, i), h("div", { class: "q-timeline__content" }, [h("h6", { class: "q-timeline__title" }, hSlot(t.title, [e.title]))].concat(o2))];
      return h("li", { class: n.value }, l.value === true ? r.reverse() : r);
    };
  } });
  var QToolbar = defineComponent2({ name: "QToolbar", props: { inset: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => "q-toolbar row no-wrap items-center" + (e.inset === true ? " q-toolbar--inset" : ""));
    return () => h("div", { class: o.value }, hSlot(t.default));
  } });
  var QToolbarTitle = defineComponent2({ name: "QToolbarTitle", props: { shrink: Boolean }, setup(e, { slots: t }) {
    const o = computed2(() => "q-toolbar__title ellipsis" + (e.shrink === true ? " col-shrink" : ""));
    return () => h("div", { class: o.value }, hSlot(t.default));
  } });
  var QTree = defineComponent2({ name: "QTree", props: { ...useDarkProps, nodes: { type: Array, required: true }, nodeKey: { type: String, required: true }, labelKey: { type: String, default: "label" }, childrenKey: { type: String, default: "children" }, color: String, controlColor: String, textColor: String, selectedColor: String, icon: String, tickStrategy: { type: String, default: "none", validator: (e) => ["none", "strict", "leaf", "leaf-filtered"].includes(e) }, ticked: Array, expanded: Array, selected: {}, defaultExpandAll: Boolean, accordion: Boolean, filter: String, filterMethod: Function, duration: Number, noConnectors: Boolean, noNodesLabel: String, noResultsLabel: String }, emits: ["update:expanded", "update:ticked", "update:selected", "lazy-load", "after-show", "after-hide"], setup(e, { slots: t, emit: o }) {
    const { proxy: n } = getCurrentInstance(), { $q: a } = n, l = useDark(e, a), i = ref({}), r = ref(e.ticked || []), s2 = ref(e.expanded || []);
    let u = {};
    onBeforeUpdate(() => {
      u = {};
    });
    const c = computed2(() => "q-tree" + (e.noConnectors === true ? " q-tree--no-connectors" : "") + (l.value === true ? " q-tree--dark" : "") + (e.color !== void 0 ? ` text-${e.color}` : "")), d = computed2(() => e.selected !== void 0), p2 = computed2(() => e.icon || a.iconSet.tree.icon), v = computed2(() => e.controlColor || e.color), m = computed2(() => e.textColor !== void 0 ? ` text-${e.textColor}` : ""), f = computed2(() => {
      const t2 = e.selectedColor || e.color;
      return t2 ? ` text-${t2}` : "";
    }), g = computed2(() => e.filterMethod !== void 0 ? e.filterMethod : (t2, o2) => {
      const n2 = o2.toLowerCase();
      return t2[e.labelKey] && t2[e.labelKey].toLowerCase().indexOf(n2) > -1;
    }), b = computed2(() => {
      const t2 = {}, o2 = (n2, a2) => {
        const l2 = n2.tickStrategy || (a2 ? a2.tickStrategy : e.tickStrategy), u2 = n2[e.nodeKey], c4 = n2[e.childrenKey] && n2[e.childrenKey].length > 0, p3 = c4 !== true, v2 = n2.disabled !== true && d.value === true && n2.selectable !== false, m2 = n2.disabled !== true && n2.expandable !== false, f2 = l2 !== "none", h3 = l2 === "strict", b2 = l2 === "leaf-filtered", y2 = l2 === "leaf" || l2 === "leaf-filtered";
        let S2 = n2.disabled !== true && n2.tickable !== false;
        y2 === true && S2 === true && a2 && a2.tickable !== true && (S2 = false);
        let w2 = n2.lazy;
        w2 === true && i.value[u2] !== void 0 && Array.isArray(n2[e.childrenKey]) === true && (w2 = i.value[u2]);
        const x2 = { key: u2, parent: a2, isParent: c4, isLeaf: p3, lazy: w2, disabled: n2.disabled, link: n2.disabled !== true && (v2 === true || m2 === true && (c4 === true || w2 === true)), children: [], matchesFilter: !e.filter || g.value(n2, e.filter), selected: u2 === e.selected && v2 === true, selectable: v2, expanded: c4 === true && s2.value.includes(u2), expandable: m2, noTick: n2.noTick === true || h3 !== true && w2 && w2 !== "loaded", tickable: S2, tickStrategy: l2, hasTicking: f2, strictTicking: h3, leafFilteredTicking: b2, leafTicking: y2, ticked: h3 === true ? r.value.includes(u2) : p3 === true && r.value.includes(u2) };
        if (t2[u2] = x2, c4 === true && (x2.children = n2[e.childrenKey].map((e2) => o2(e2, x2)), e.filter && (x2.matchesFilter !== true ? x2.matchesFilter = x2.children.some((e2) => e2.matchesFilter) : x2.noTick !== true && x2.disabled !== true && x2.tickable === true && b2 === true && x2.children.every((e2) => e2.matchesFilter !== true || e2.noTick === true || e2.tickable !== true) === true && (x2.tickable = false)), x2.matchesFilter === true && (x2.noTick !== true && h3 !== true && x2.children.every((e2) => e2.noTick) === true && (x2.noTick = true), y2))) {
          if (x2.ticked = false, x2.indeterminate = x2.children.some((e2) => e2.indeterminate === true), x2.tickable = x2.tickable === true && x2.children.some((e2) => e2.tickable), x2.indeterminate !== true) {
            const e2 = x2.children.reduce((e3, t3) => t3.ticked === true ? e3 + 1 : e3, 0);
            e2 === x2.children.length ? x2.ticked = true : e2 > 0 && (x2.indeterminate = true);
          }
          x2.indeterminate === true && (x2.indeterminateNextState = x2.children.every((e2) => e2.tickable !== true || e2.ticked !== true));
        }
        return x2;
      };
      return e.nodes.forEach((e2) => o2(e2, null)), t2;
    });
    function y(t2) {
      const o2 = [].reduce, n2 = (a2, l2) => {
        return a2 || !l2 ? a2 : Array.isArray(l2) === true ? o2.call(Object(l2), n2, a2) : l2[e.nodeKey] === t2 ? l2 : l2[e.childrenKey] ? n2(null, l2[e.childrenKey]) : void 0;
      };
      return n2(null, e.nodes);
    }
    function S() {
      return r.value.map((e2) => y(e2));
    }
    function w() {
      return s2.value.map((e2) => y(e2));
    }
    function x(e2) {
      return !(!e2 || !b.value[e2]) && b.value[e2].expanded;
    }
    function C() {
      e.expanded !== void 0 ? o("update:expanded", []) : s2.value = [];
    }
    function k2() {
      const t2 = s2.value, n2 = (o2) => {
        o2[e.childrenKey] && o2[e.childrenKey].length > 0 && o2.expandable !== false && o2.disabled !== true && (t2.push(o2[e.nodeKey]), o2[e.childrenKey].forEach(n2));
      };
      e.nodes.forEach(n2), e.expanded !== void 0 ? o("update:expanded", t2) : s2.value = t2;
    }
    function _(t2, n2, a2 = y(t2), l2 = b.value[t2]) {
      if (l2.lazy && l2.lazy !== "loaded") {
        if (l2.lazy === "loading")
          return;
        i.value[t2] = "loading", Array.isArray(a2[e.childrenKey]) !== true && (a2[e.childrenKey] = []), o("lazy-load", { node: a2, key: t2, done: (o2) => {
          i.value[t2] = "loaded", a2[e.childrenKey] = Array.isArray(o2) === true ? o2 : [], nextTick2(() => {
            const e2 = b.value[t2];
            e2 && e2.isParent === true && q(t2, true);
          });
        }, fail: () => {
          delete i.value[t2], a2[e.childrenKey].length === 0 && delete a2[e.childrenKey];
        } });
      } else
        l2.isParent === true && l2.expandable === true && q(t2, n2);
    }
    function q(t2, n2) {
      let a2 = s2.value;
      const l2 = e.expanded !== void 0;
      if (l2 === true && (a2 = a2.slice()), n2) {
        if (e.accordion && b.value[t2]) {
          const o2 = [];
          b.value[t2].parent ? b.value[t2].parent.children.forEach((e2) => {
            e2.key !== t2 && e2.expandable === true && o2.push(e2.key);
          }) : e.nodes.forEach((n3) => {
            const a3 = n3[e.nodeKey];
            a3 !== t2 && o2.push(a3);
          }), o2.length > 0 && (a2 = a2.filter((e2) => o2.includes(e2) === false));
        }
        a2 = a2.concat([t2]).filter((e2, t3, o2) => o2.indexOf(e2) === t3);
      } else
        a2 = a2.filter((e2) => e2 !== t2);
      l2 === true ? o("update:expanded", a2) : s2.value = a2;
    }
    function T(e2) {
      return !(!e2 || !b.value[e2]) && b.value[e2].ticked;
    }
    function P(t2, n2) {
      let a2 = r.value;
      const l2 = e.ticked !== void 0;
      l2 === true && (a2 = a2.slice()), a2 = n2 ? a2.concat(t2).filter((e2, t3, o2) => o2.indexOf(e2) === t3) : a2.filter((e2) => t2.includes(e2) === false), l2 === true && o("update:ticked", a2);
    }
    function $(t2, o2, a2) {
      const i2 = { tree: n, node: t2, key: a2, color: e.color, dark: l.value };
      return Object.defineProperty(i2, "expanded", { get: () => {
        return o2.expanded;
      }, set: (e2) => {
        e2 !== o2.expanded && _(a2, e2);
      }, configurable: true, enumerable: true }), Object.defineProperty(i2, "ticked", { get: () => {
        return o2.ticked;
      }, set: (e2) => {
        e2 !== o2.ticked && P([a2], e2);
      }, configurable: true, enumerable: true }), i2;
    }
    function M(t2) {
      return (e.filter ? t2.filter((t3) => b.value[t3[e.nodeKey]].matchesFilter) : t2).map((e2) => O(e2));
    }
    function B(e2) {
      if (e2.icon !== void 0)
        return h(QIcon, { class: "q-tree__icon q-mr-sm", name: e2.icon, color: e2.iconColor });
      const t2 = e2.img || e2.avatar;
      return t2 ? h("img", { class: `q-tree__${e2.img ? "img" : "avatar"} q-mr-sm`, src: t2 }) : void 0;
    }
    function Q() {
      o("after-show");
    }
    function E() {
      o("after-hide");
    }
    function O(o2) {
      const n2 = o2[e.nodeKey], a2 = b.value[n2], i2 = o2.header && t[`header-${o2.header}`] || t["default-header"], r2 = a2.isParent === true ? M(o2[e.childrenKey]) : [], s3 = r2.length > 0 || a2.lazy && a2.lazy !== "loaded";
      let c4 = o2.body && t[`body-${o2.body}`] || t["default-body"];
      const d2 = i2 !== void 0 || c4 !== void 0 ? $(o2, a2, n2) : null;
      return c4 !== void 0 && (c4 = h("div", { class: "q-tree__node-body relative-position" }, [h("div", { class: m.value }, [c4(d2)])])), h("div", { key: n2, class: `q-tree__node relative-position q-tree__node--${s3 === true ? "parent" : "child"}` }, [h("div", { class: "q-tree__node-header relative-position row no-wrap items-center" + (a2.link === true ? " q-tree__node--link q-hoverable q-focusable" : "") + (a2.selected === true ? " q-tree__node--selected" : "") + (a2.disabled === true ? " q-tree__node--disabled" : ""), tabindex: a2.link === true ? 0 : -1, onClick: (e2) => {
        F(o2, a2, e2);
      }, onKeypress(e2) {
        shouldIgnoreKey(e2) !== true && (e2.keyCode === 13 ? F(o2, a2, e2, true) : e2.keyCode === 32 && L(o2, a2, e2, true));
      } }, [h("div", { class: "q-focus-helper", tabindex: -1, ref: (e2) => {
        u[a2.key] = e2;
      } }), a2.lazy === "loading" ? h(QSpinner, { class: "q-tree__spinner q-mr-xs", color: v.value }) : s3 === true ? h(QIcon, { class: "q-tree__arrow q-mr-xs" + (a2.expanded === true ? " q-tree__arrow--rotate" : ""), name: p2.value, onClick(e2) {
        L(o2, a2, e2);
      } }) : null, a2.hasTicking === true && a2.noTick !== true ? h(QCheckbox, { class: "q-mr-xs", modelValue: a2.indeterminate === true ? null : a2.ticked, color: v.value, dark: l.value, dense: true, keepColor: true, disable: a2.tickable !== true, onKeydown: stopAndPrevent, "onUpdate:modelValue": (e2) => {
        R(a2, e2);
      } }) : null, h("div", { class: "q-tree__node-header-content col row no-wrap items-center" + (a2.selected === true ? f.value : m.value) }, [i2 ? i2(d2) : [B(o2), h("div", o2[e.labelKey])]])]), s3 === true ? h(QSlideTransition, { duration: e.duration, onShow: Q, onHide: E }, () => withDirectives(h("div", { class: "q-tree__node-collapsible" + m.value, key: `${n2}__q` }, [c4, h("div", { class: "q-tree__children" + (a2.disabled === true ? " q-tree__node--disabled" : "") }, r2)]), [[vShow, a2.expanded]])) : c4]);
    }
    function z(e2) {
      const t2 = u[e2];
      t2 && t2.focus();
    }
    function F(t2, n2, a2, l2) {
      l2 !== true && z(n2.key), d.value ? n2.selectable && o("update:selected", n2.key !== e.selected ? n2.key : null) : L(t2, n2, a2, l2), typeof t2.handler === "function" && t2.handler(t2);
    }
    function L(e2, t2, o2, n2) {
      o2 !== void 0 && stopAndPrevent(o2), n2 !== true && z(t2.key), _(t2.key, !t2.expanded, e2, t2);
    }
    function R(e2, t2) {
      if (e2.indeterminate === true && (t2 = e2.indeterminateNextState), e2.strictTicking)
        P([e2.key], t2);
      else if (e2.leafTicking) {
        const o2 = [], n2 = (e3) => {
          e3.isParent ? (t2 !== true && e3.noTick !== true && e3.tickable === true && o2.push(e3.key), e3.leafTicking === true && e3.children.forEach(n2)) : e3.noTick === true || e3.tickable !== true || e3.leafFilteredTicking === true && e3.matchesFilter !== true || o2.push(e3.key);
        };
        n2(e2), P(o2, t2);
      }
    }
    return watch(() => e.ticked, (e2) => {
      r.value = e2;
    }), watch(() => e.expanded, (e2) => {
      s2.value = e2;
    }), Object.assign(n, { getNodeByKey: y, getTickedNodes: S, getExpandedNodes: w, isExpanded: x, collapseAll: C, expandAll: k2, setExpanded: _, isTicked: T, setTicked: P }), e.defaultExpandAll === true && k2(), () => {
      const t2 = M(e.nodes);
      return h("div", { class: c.value }, t2.length === 0 ? e.filter ? e.noResultsLabel || a.lang.tree.noResults : e.noNodesLabel || a.lang.tree.noNodes : t2);
    };
  } });
  function getProgressLabel(e) {
    return (100 * e).toFixed(2) + "%";
  }
  var coreProps = { ...useDarkProps, ...useFileProps, label: String, color: String, textColor: String, square: Boolean, flat: Boolean, bordered: Boolean, noThumbnails: Boolean, autoUpload: Boolean, hideUploadBtn: Boolean, disable: Boolean, readonly: Boolean };
  var coreEmits = [...useFileEmits, "start", "finish", "added", "removed"];
  function getRenderer(e) {
    const t = getCurrentInstance(), { props: o, slots: n, emit: a, proxy: l } = t, { $q: i } = l, r = useDark(o, i);
    function s2(e2, t2, o2) {
      if (e2.__status = t2, t2 === "idle")
        return e2.__uploaded = 0, e2.__progress = 0, e2.__sizeLabel = humanStorageSize(e2.size), void (e2.__progressLabel = "0.00%");
      t2 !== "failed" ? (e2.__uploaded = t2 === "uploaded" ? e2.size : o2, e2.__progress = t2 === "uploaded" ? 1 : Math.min(0.9999, e2.__uploaded / e2.size), e2.__progressLabel = getProgressLabel(e2.__progress), l.$forceUpdate()) : l.$forceUpdate();
    }
    const u = { files: ref([]), queuedFiles: ref([]), uploadedFiles: ref([]), uploadedSize: ref(0), updateFileStatus: s2, isAlive() {
      return t.isDeactivated !== true && t.isUnmounted !== true;
    } };
    Object.assign(u, e({ props: o, slots: n, emit: a, helpers: u }));
    const c = ref(0), d = computed2(() => o.disable !== true && o.readonly !== true);
    u.isBusy === void 0 && (u.isBusy = ref(false));
    const p2 = ref(false), v = ref(null), m = ref(null);
    provide2(uploaderKey, I);
    const { pickFiles: f, addFiles: g, onDragover: b, processFiles: y, getDndNode: S, maxFilesNumber: w, maxTotalSizeNumber: x } = useFile({ editable: d, dnd: p2, getFileInput: F, addFilesToQueue: L }), C = computed2(() => d.value === true && u.isUploading.value !== true && (o.multiple === true || u.queuedFiles.value.length === 0) && (o.maxFiles === void 0 || u.files.value.length < w.value) && (o.maxTotalSize === void 0 || c.value < x.value)), k2 = computed2(() => d.value === true && u.isBusy.value !== true && u.isUploading.value !== true && u.queuedFiles.value.length > 0), _ = computed2(() => c.value === 0 ? 0 : u.uploadedSize.value / c.value), q = computed2(() => getProgressLabel(_.value)), T = computed2(() => humanStorageSize(c.value)), P = computed2(() => "q-uploader column no-wrap" + (r.value === true ? " q-uploader--dark q-dark" : "") + (o.bordered === true ? " q-uploader--bordered" : "") + (o.square === true ? " q-uploader--square no-border-radius" : "") + (o.flat === true ? " q-uploader--flat no-shadow" : "") + (o.disable === true ? " disabled q-uploader--disable" : "")), $ = computed2(() => "q-uploader__header" + (o.color !== void 0 ? ` bg-${o.color}` : "") + (o.textColor !== void 0 ? ` text-${o.textColor}` : ""));
    function M() {
      o.disable === false && (u.abort(), u.uploadedSize.value = 0, c.value = 0, z(), u.files.value = [], u.queuedFiles.value = [], u.uploadedFiles.value = []);
    }
    function B() {
      o.disable === false && E(["uploaded"], () => {
        u.uploadedFiles.value = [];
      });
    }
    function Q() {
      E(["idle", "failed"], ({ size: e2 }) => {
        c.value -= e2, u.queuedFiles.value = [];
      });
    }
    function E(e2, t2) {
      if (o.disable === true)
        return;
      const n2 = { files: [], size: 0 }, l2 = u.files.value.filter((t3) => {
        return e2.indexOf(t3.__status) === -1 || (n2.size += t3.size, n2.files.push(t3), t3._img !== void 0 && window.URL.revokeObjectURL(t3._img.src), false);
      });
      n2.files.length > 0 && (u.files.value = l2, t2(n2), a("removed", n2.files));
    }
    function O(e2) {
      o.disable || (e2.__status === "uploaded" ? u.uploadedFiles.value = u.uploadedFiles.value.filter((t2) => t2.name !== e2.name) : e2.__status === "uploading" ? e2.__abort() : c.value -= e2.size, u.files.value = u.files.value.filter((t2) => {
        return t2.name !== e2.name || (t2._img !== void 0 && window.URL.revokeObjectURL(t2._img.src), false);
      }), u.queuedFiles.value = u.queuedFiles.value.filter((t2) => t2.name !== e2.name), a("removed", [e2]));
    }
    function z() {
      u.files.value.forEach((e2) => {
        e2._img !== void 0 && window.URL.revokeObjectURL(e2._img.src);
      });
    }
    function F() {
      return m.value || v.value.getElementsByClassName("q-uploader__input")[0];
    }
    function L(e2, t2) {
      const n2 = y(e2, t2, u.files.value, true);
      if (n2 === void 0)
        return;
      const l2 = n2.filter((e3) => u.files.value.findIndex((t3) => e3.name === t3.name) === -1), i2 = F();
      i2 !== void 0 && i2 !== null && (i2.value = ""), l2 !== void 0 && (l2.forEach((e3) => {
        if (u.updateFileStatus(e3, "idle"), c.value += e3.size, o.noThumbnails !== true && e3.type.toUpperCase().startsWith("IMAGE")) {
          const t3 = new Image();
          t3.src = window.URL.createObjectURL(e3), e3.__img = t3;
        }
      }), u.files.value = u.files.value.concat(l2), u.queuedFiles.value = u.queuedFiles.value.concat(l2), a("added", l2), o.autoUpload === true && u.upload());
    }
    function R() {
      k2.value === true && u.upload();
    }
    function V(e2, t2, o2) {
      if (e2 === true) {
        const e3 = { type: "a", key: t2, icon: i.iconSet.uploader[t2], flat: true, dense: true };
        let n2 = void 0;
        return t2 === "add" ? n2 = I : e3.onClick = o2, h(QBtn, e3, n2);
      }
    }
    function I() {
      return h("input", { ref: m, class: "q-uploader__input overflow-hidden absolute-full", tabindex: -1, type: "file", title: "", accept: o.accept, multiple: o.multiple === true ? "multiple" : void 0, capture: o.capture, onMousedown: stop2, onChange: L });
    }
    function A() {
      return n.header !== void 0 ? n.header(H.value) : [h("div", { class: "q-uploader__header-content flex flex-center no-wrap q-gutter-xs" }, [V(u.queuedFiles.value.length > 0, "removeQueue", Q), V(u.uploadedFiles.value.length > 0, "removeUploaded", B), u.isUploading.value === true ? h(QSpinner, { class: "q-uploader__spinner" }) : null, h("div", { class: "col column justify-center" }, [o.label !== void 0 ? h("div", { class: "q-uploader__title" }, [o.label]) : null, h("div", { class: "q-uploader__subtitle" }, [T.value + " / " + q.value])]), V(C.value, "add"), V(o.hideUploadBtn === false && k2.value === true, "upload", u.upload), V(u.isUploading.value, "clear", u.abort)])];
    }
    function D() {
      return n.list !== void 0 ? n.list(H.value) : u.files.value.map((e2) => h("div", { key: e2.name, class: "q-uploader__file relative-position" + (o.noThumbnails !== true && e2.__img !== void 0 ? " q-uploader__file--img" : "") + (e2.__status === "failed" ? " q-uploader__file--failed" : e2.__status === "uploaded" ? " q-uploader__file--uploaded" : ""), style: o.noThumbnails !== true && e2.__img !== void 0 ? { backgroundImage: 'url("' + e2.__img.src + '")' } : null }, [h("div", { class: "q-uploader__file-header row flex-center no-wrap" }, [e2.__status === "failed" ? h(QIcon, { class: "q-uploader__file-status", name: i.iconSet.type.negative, color: "negative" }) : null, h("div", { class: "q-uploader__file-header-content col" }, [h("div", { class: "q-uploader__title" }, [e2.name]), h("div", { class: "q-uploader__subtitle row items-center no-wrap" }, [e2.__sizeLabel + " / " + e2.__progressLabel])]), e2.__status === "uploading" ? h(QCircularProgress, { value: e2.__progress, min: 0, max: 1, indeterminate: e2.__progress === 0 }) : h(QBtn, { round: true, dense: true, flat: true, icon: i.iconSet.uploader[e2.__status === "uploaded" ? "done" : "clear"], onClick: () => {
        O(e2);
      } })])]));
    }
    watch(u.isUploading, (e2, t2) => {
      t2 === false && e2 === true ? a("start") : t2 === true && e2 === false && a("finish");
    }), onBeforeUnmount2(() => {
      u.isUploading.value === true && u.abort(), u.files.value.length > 0 && z();
    });
    const N = { pickFiles: f, addFiles: g, reset: M, removeUploadedFiles: B, removeQueuedFiles: Q, removeFile: O, upload: R, abort: u.abort }, H = computed2(() => {
      const e2 = { canAddFiles: C.value, canUpload: k2.value, uploadSizeLabel: T.value, uploadProgressLabel: q.value };
      return Object.keys(u).forEach((t2) => {
        e2[t2] = isRef(u[t2]) === true ? u[t2].value : u[t2];
      }), { ...e2, ...N };
    });
    return Object.assign(l, N), () => {
      const e2 = [h("div", { class: $.value }, A()), h("div", { class: "q-uploader__list scroll" }, D()), S("uploader")];
      u.isBusy.value === true && e2.push(h("div", { class: "q-uploader__overlay absolute-full flex flex-center" }, [h(QSpinner)]));
      const t2 = { ref: v, class: P.value };
      return C.value === true && (t2.onDragover = b), h("div", t2, e2);
    };
  }
  var createUploaderComponent = ({ name: e, props: t, emits: o, injectPlugin: n }) => defineComponent2({ name: e, props: { ...coreProps, ...t }, emits: [...coreEmits, ...o], setup() {
    return getRenderer(n);
  } });
  function getFn(e) {
    return typeof e === "function" ? e : () => e;
  }
  var props$2 = { url: [Function, String], method: { type: [Function, String], default: "POST" }, fieldName: { type: [Function, String], default: (e) => e.name }, headers: [Function, Array], formFields: [Function, Array], withCredentials: [Function, Boolean], sendRaw: [Function, Boolean], batch: [Function, Boolean], factory: Function };
  var emits = ["factory-failed", "uploaded", "failed", "uploading"];
  function injectPlugin({ props: e, emit: t, helpers: o }) {
    const n = ref([]), a = ref([]), l = ref(0), i = computed2(() => ({ url: getFn(e.url), method: getFn(e.method), headers: getFn(e.headers), formFields: getFn(e.formFields), fieldName: getFn(e.fieldName), withCredentials: getFn(e.withCredentials), sendRaw: getFn(e.sendRaw), batch: getFn(e.batch) })), r = computed2(() => l.value > 0), s2 = computed2(() => a.value.length > 0);
    let u;
    function c() {
      n.value.forEach((e2) => {
        e2.abort();
      }), a.value.length > 0 && (u = true);
    }
    function d() {
      const e2 = o.queuedFiles.value.slice(0);
      o.queuedFiles.value = [], i.value.batch(e2) ? p2(e2) : e2.forEach((e3) => {
        p2([e3]);
      });
    }
    function p2(n2) {
      if (l.value++, typeof e.factory !== "function")
        return void v(n2, {});
      const i2 = e.factory(n2);
      if (i2)
        if (typeof i2.catch === "function" && typeof i2.then === "function") {
          a.value.push(i2);
          const e2 = (e3) => {
            o.isAlive() === true && (a.value = a.value.filter((e4) => e4 !== i2), a.value.length === 0 && (u = false), o.queuedFiles.value = o.queuedFiles.value.concat(n2), n2.forEach((e4) => {
              o.updateFileStatus(e4, "failed");
            }), t("factory-failed", e3, n2), l.value--);
          };
          i2.then((t2) => {
            u === true ? e2(new Error("Aborted")) : o.isAlive() === true && (a.value = a.value.filter((e3) => e3 !== i2), v(n2, t2));
          }).catch(e2);
        } else
          v(n2, i2 || {});
      else
        t("factory-failed", new Error("QUploader: factory() does not return properly"), n2), l.value--;
    }
    function v(e2, a2) {
      const r2 = new FormData(), s3 = new XMLHttpRequest(), u2 = (e3, t2) => {
        return a2[e3] !== void 0 ? getFn(a2[e3])(t2) : i.value[e3](t2);
      }, c4 = u2("url", e2);
      if (!c4)
        return console.error("q-uploader: invalid or no URL specified"), void l.value--;
      const d2 = u2("formFields", e2);
      d2 !== void 0 && d2.forEach((e3) => {
        r2.append(e3.name, e3.value);
      });
      let p3, v2 = 0, m = 0, f = 0, h3 = 0;
      s3.upload.addEventListener("progress", (t2) => {
        if (p3 === true)
          return;
        const n2 = Math.min(h3, t2.loaded);
        o.uploadedSize.value += n2 - f, f = n2;
        let a3 = f - m;
        for (let l2 = v2; a3 > 0 && l2 < e2.length; l2++) {
          const t3 = e2[l2], n3 = a3 > t3.size;
          if (!n3)
            return void o.updateFileStatus(t3, "uploading", a3);
          a3 -= t3.size, v2++, m += t3.size, o.updateFileStatus(t3, "uploading", t3.size);
        }
      }, false), s3.onreadystatechange = () => {
        s3.readyState < 4 || (s3.status && s3.status < 400 ? (o.uploadedFiles.value = o.uploadedFiles.value.concat(e2), e2.forEach((e3) => {
          o.updateFileStatus(e3, "uploaded");
        }), t("uploaded", { files: e2, xhr: s3 })) : (p3 = true, o.uploadedSize.value -= f, o.queuedFiles.value = o.queuedFiles.value.concat(e2), e2.forEach((e3) => {
          o.updateFileStatus(e3, "failed");
        }), t("failed", { files: e2, xhr: s3 })), l.value--, n.value = n.value.filter((e3) => e3 !== s3));
      }, s3.open(u2("method", e2), c4), u2("withCredentials", e2) === true && (s3.withCredentials = true);
      const g = u2("headers", e2);
      g !== void 0 && g.forEach((e3) => {
        s3.setRequestHeader(e3.name, e3.value);
      });
      const b = u2("sendRaw", e2);
      e2.forEach((e3) => {
        o.updateFileStatus(e3, "uploading", 0), b !== true && r2.append(u2("fieldName", e3), e3, e3.name), e3.xhr = s3, e3.__abort = () => {
          s3.abort();
        }, h3 += e3.size;
      }), t("uploading", { files: e2, xhr: s3 }), n.value.push(s3), b === true ? s3.send(new Blob(e2)) : s3.send(r2);
    }
    return { isUploading: r, isBusy: s2, abort: c, upload: d };
  }
  var xhrUploaderPlugin = { name: "QUploader", props: props$2, emits, injectPlugin };
  var QUploader = createUploaderComponent(xhrUploaderPlugin);
  var QUploaderAddTrigger = defineComponent2({ name: "QUploaderAddTrigger", setup() {
    return inject2(uploaderKey, () => {
      console.error("QUploaderAddTrigger needs to be child of QUploader");
    });
  } });
  var QVideo = defineComponent2({ name: "QVideo", props: { ...useRatioProps, src: { type: String, required: true } }, setup(e) {
    const t = useRatio(e), o = computed2(() => "q-video" + (e.ratio !== void 0 ? " q-video--responsive" : ""));
    return () => h("div", { class: o.value, style: t.value }, [h("iframe", { src: e.src, frameborder: "0", allowfullscreen: true })]);
  } });
  var components = Object.freeze({ __proto__: null, QAjaxBar, QAvatar, QBadge, QBanner, QBar, QBreadcrumbs, QBreadcrumbsEl, QBtn, QBtnDropdown, QBtnGroup, QBtnToggle, QCard, QCardSection, QCardActions, QCarousel, QCarouselSlide, QCarouselControl, QChatMessage, QCheckbox, QChip, QCircularProgress, QColor, QDate, QDialog, QDrawer, QEditor, QExpansionItem, QFab, QFabAction, QField, QFile, QFooter, QForm, QFormChildMixin, QHeader, QIcon, QImg, QInfiniteScroll, QInnerLoading, QInput, QIntersection, QList, QItem, QItemSection, QItemLabel, QKnob, QLayout, QMarkupTable, QMenu, QNoSsr, QOptionGroup, QPage, QPageContainer, QPageScroller, QPageSticky, QPagination, QParallax, QPopupEdit, QPopupProxy, QLinearProgress, QPullToRefresh, QRadio, QRange, QRating, QResizeObserver, QResponsive, QScrollArea, QScrollObserver, QSelect, QSeparator, QSkeleton, QSlideItem, QSlideTransition, QSlider, QSpace, QSpinner, QSpinnerAudio, QSpinnerBall, QSpinnerBars, QSpinnerBox, QSpinnerClock, QSpinnerComment, QSpinnerCube, QSpinnerDots, QSpinnerFacebook, QSpinnerGears, QSpinnerGrid, QSpinnerHearts, QSpinnerHourglass, QSpinnerInfinity, QSpinnerIos, QSpinnerOrbit, QSpinnerOval, QSpinnerPie, QSpinnerPuff, QSpinnerRadio, QSpinnerRings, QSpinnerTail, QSplitter, QStep, QStepper, QStepperNavigation, QTabPanels, QTabPanel, QTable, QTh, QTr, QTd, QTabs, QTab, QRouteTab, QTime, QTimeline, QTimelineEntry, QToggle, QToolbar, QToolbarTitle, QTooltip, QTree, QUploader, QUploaderAddTrigger, QVideo, QVirtualScroll });
  function getDepth(e) {
    if (e === false)
      return 0;
    if (e === true || e === void 0)
      return 1;
    const t = parseInt(e, 10);
    return isNaN(t) ? 0 : t;
  }
  var ClosePopup = { name: "close-popup", beforeMount(e, { value: t }) {
    const o = { depth: getDepth(t), handler(t2) {
      o.depth !== 0 && setTimeout(() => {
        const n = getPortalVm(e);
        n !== void 0 && closePortals(n, t2, o.depth);
      });
    }, handlerKey(e2) {
      isKeyCode(e2, 13) === true && o.handler(e2);
    } };
    e.__qclosepopup = o, e.addEventListener("click", o.handler), e.addEventListener("keyup", o.handlerKey);
  }, updated(e, { value: t, oldValue: o }) {
    t !== o && (e.__qclosepopup.depth = getDepth(t));
  }, beforeUnmount(e) {
    const t = e.__qclosepopup;
    e.removeEventListener("click", t.handler), e.removeEventListener("keyup", t.handlerKey), delete e.__qclosepopup;
  } };
  var id = 0;
  var offsetBase = void 0;
  function getAbsolutePosition(e, t) {
    offsetBase === void 0 && (offsetBase = document.createElement("div"), offsetBase.style.cssText = "position: absolute; left: 0; top: 0", document.body.appendChild(offsetBase));
    const o = e.getBoundingClientRect(), n = offsetBase.getBoundingClientRect(), { marginLeft: a, marginRight: l, marginTop: i, marginBottom: r } = window.getComputedStyle(e), s2 = parseInt(a, 10) + parseInt(l, 10), u = parseInt(i, 10) + parseInt(r, 10);
    return { left: o.left - n.left, top: o.top - n.top, width: o.right - o.left, height: o.bottom - o.top, widthM: o.right - o.left + (t === true ? 0 : s2), heightM: o.bottom - o.top + (t === true ? 0 : u), marginH: t === true ? s2 : 0, marginV: t === true ? u : 0 };
  }
  function getAbsoluteSize(e) {
    return { width: e.scrollWidth, height: e.scrollHeight };
  }
  var styleEdges = ["Top", "Right", "Bottom", "Left"];
  var styleBorderRadiuses = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"];
  var reStyleSkipKey = /-block|-inline|block-|inline-/;
  var reStyleSkipRule = /(-block|-inline|block-|inline-).*:/;
  function getComputedStyle$1(e, t) {
    const o = window.getComputedStyle(e), n = {};
    for (let a = 0; a < t.length; a++) {
      const e2 = t[a];
      if (o[e2] === "")
        if (e2 === "cssText") {
          const t2 = o.length;
          let a2 = "";
          for (let e3 = 0; e3 < t2; e3++)
            reStyleSkipKey.test(o[e3]) !== true && (a2 += o[e3] + ": " + o[o[e3]] + "; ");
          n[e2] = a2;
        } else if (["borderWidth", "borderStyle", "borderColor"].indexOf(e2) > -1) {
          const t2 = e2.replace("border", "");
          let a2 = "";
          for (let e3 = 0; e3 < styleEdges.length; e3++) {
            const n2 = "border" + styleEdges[e3] + t2;
            a2 += o[n2] + " ";
          }
          n[e2] = a2;
        } else if (e2 === "borderRadius") {
          let t2 = "", a2 = "";
          for (let e3 = 0; e3 < styleBorderRadiuses.length; e3++) {
            const n2 = o[styleBorderRadiuses[e3]].split(" ");
            t2 += n2[0] + " ", a2 += (n2[1] === void 0 ? n2[0] : n2[1]) + " ";
          }
          n[e2] = t2 + "/ " + a2;
        } else
          n[e2] = o[e2];
      else
        n[e2] = e2 === "cssText" ? o[e2].split(";").filter((e3) => reStyleSkipRule.test(e3) !== true).join(";") : o[e2];
    }
    return n;
  }
  var zIndexPositions = ["absolute", "fixed", "relative", "sticky"];
  function getMaxZIndex(e) {
    let t = e, o = 0;
    while (t !== null && t !== document) {
      const { position: n, zIndex: a } = window.getComputedStyle(t), l = Number(a);
      l > o && (t === e || zIndexPositions.includes(n) === true) && (o = l), t = t.parentNode;
    }
    return o;
  }
  function normalizeElements(e) {
    return { from: e.from, to: e.to !== void 0 ? e.to : e.from };
  }
  function normalizeOptions(e) {
    return typeof e === "number" ? e = { duration: e } : typeof e === "function" && (e = { onEnd: e }), { ...e, waitFor: e.waitFor === void 0 ? 0 : e.waitFor, duration: isNaN(e.duration) === true ? 300 : parseInt(e.duration, 10), easing: typeof e.easing === "string" && e.easing.length > 0 ? e.easing : "ease-in-out", delay: isNaN(e.delay) === true ? 0 : parseInt(e.delay, 10), fill: typeof e.fill === "string" && e.fill.length > 0 ? e.fill : "none", resize: e.resize === true, useCSS: e.useCSS === true, hideFromClone: e.hideFromClone === true, keepToClone: e.keepToClone === true, tween: e.tween === true, tweenFromOpacity: isNaN(e.tweenFromOpacity) === true ? 0.6 : parseFloat(e.tweenFromOpacity), tweenToOpacity: isNaN(e.tweenToOpacity) === true ? 0.5 : parseFloat(e.tweenToOpacity) };
  }
  function getElement(e) {
    const t = typeof e;
    return t === "function" ? e() : t === "string" ? document.querySelector(e) : e;
  }
  function isValidElement(e) {
    return e && e.ownerDocument === document && e.parentNode !== null;
  }
  function morph(e) {
    let t = () => false, o = false, n = true;
    const a = normalizeElements(e), l = normalizeOptions(e), i = getElement(a.from);
    if (isValidElement(i) !== true)
      return t;
    typeof i.qMorphCancel === "function" && i.qMorphCancel();
    let r = void 0, s2 = void 0, u = void 0, c = void 0;
    const d = i.parentNode, p2 = i.nextElementSibling, v = getAbsolutePosition(i, l.resize), { width: m, height: f } = getAbsoluteSize(d), { borderWidth: h3, borderStyle: g, borderColor: b, borderRadius: y, backgroundColor: S, transform: w, position: x, cssText: C } = getComputedStyle$1(i, ["borderWidth", "borderStyle", "borderColor", "borderRadius", "backgroundColor", "transform", "position", "cssText"]), k2 = i.classList.toString(), _ = i.style.cssText, q = i.cloneNode(true), T = l.tween === true ? i.cloneNode(true) : void 0;
    T !== void 0 && (T.className = T.classList.toString().split(" ").filter((e2) => /^bg-/.test(e2) === false).join(" ")), l.hideFromClone === true && q.classList.add("q-morph--internal"), q.setAttribute("aria-hidden", "true"), q.style.transition = "none", q.style.animation = "none", q.style.pointerEvents = "none", d.insertBefore(q, p2), i.qMorphCancel = () => {
      o = true, q.remove(), T !== void 0 && T.remove(), l.hideFromClone === true && q.classList.remove("q-morph--internal"), i.qMorphCancel = void 0;
    };
    const P = () => {
      const e2 = getElement(a.to);
      if (o === true || isValidElement(e2) !== true)
        return void (typeof i.qMorphCancel === "function" && i.qMorphCancel());
      i !== e2 && typeof e2.qMorphCancel === "function" && e2.qMorphCancel(), l.keepToClone !== true && e2.classList.add("q-morph--internal"), q.classList.add("q-morph--internal");
      const { width: p3, height: P2 } = getAbsoluteSize(d), { width: $, height: M } = getAbsoluteSize(e2.parentNode);
      l.hideFromClone !== true && q.classList.remove("q-morph--internal"), e2.qMorphCancel = () => {
        o = true, q.remove(), T !== void 0 && T.remove(), l.hideFromClone === true && q.classList.remove("q-morph--internal"), l.keepToClone !== true && e2.classList.remove("q-morph--internal"), i.qMorphCancel = void 0, e2.qMorphCancel = void 0;
      };
      const B = () => {
        if (o === true)
          return void (typeof e2.qMorphCancel === "function" && e2.qMorphCancel());
        l.hideFromClone !== true && (q.classList.add("q-morph--internal"), q.innerHTML = "", q.style.left = 0, q.style.right = "unset", q.style.top = 0, q.style.bottom = "unset", q.style.transform = "none"), l.keepToClone !== true && e2.classList.remove("q-morph--internal");
        const a2 = e2.parentNode, { width: B2, height: Q } = getAbsoluteSize(a2), E = e2.cloneNode(l.keepToClone);
        E.setAttribute("aria-hidden", "true"), l.keepToClone !== true && (E.style.left = 0, E.style.right = "unset", E.style.top = 0, E.style.bottom = "unset", E.style.transform = "none", E.style.pointerEvents = "none"), E.classList.add("q-morph--internal");
        const O = e2 === i && d === a2 ? q : e2.nextElementSibling;
        a2.insertBefore(E, O);
        const { borderWidth: z, borderStyle: F, borderColor: L, borderRadius: R, backgroundColor: V, transform: I, position: A, cssText: D } = getComputedStyle$1(e2, ["borderWidth", "borderStyle", "borderColor", "borderRadius", "backgroundColor", "transform", "position", "cssText"]), N = e2.classList.toString(), H = e2.style.cssText;
        e2.style.cssText = D, e2.style.transform = "none", e2.style.animation = "none", e2.style.transition = "none", e2.className = N.split(" ").filter((e3) => /^bg-/.test(e3) === false).join(" ");
        const j = getAbsolutePosition(e2, l.resize), U = v.left - j.left, K = v.top - j.top, W = v.width / (j.width > 0 ? j.width : 10), Y = v.height / (j.height > 0 ? j.height : 100), G = m - p3, X = f - P2, Z = B2 - $, J = Q - M, ee = Math.max(v.widthM, G), te = Math.max(v.heightM, X), oe = Math.max(j.widthM, Z), ne = Math.max(j.heightM, J), ae = i === e2 && ["absolute", "fixed"].includes(A) === false && ["absolute", "fixed"].includes(x) === false;
        let le = A === "fixed", ie = a2;
        while (le !== true && ie !== document)
          le = window.getComputedStyle(ie).position === "fixed", ie = ie.parentNode;
        if (l.hideFromClone !== true && (q.style.display = "block", q.style.flex = "0 0 auto", q.style.opacity = 0, q.style.minWidth = "unset", q.style.maxWidth = "unset", q.style.minHeight = "unset", q.style.maxHeight = "unset", q.classList.remove("q-morph--internal")), l.keepToClone !== true && (E.style.display = "block", E.style.flex = "0 0 auto", E.style.opacity = 0, E.style.minWidth = "unset", E.style.maxWidth = "unset", E.style.minHeight = "unset", E.style.maxHeight = "unset"), E.classList.remove("q-morph--internal"), typeof l.classes === "string" && (e2.className += " " + l.classes), typeof l.style === "string")
          e2.style.cssText += " " + l.style;
        else if (l.style === Object(l.style))
          for (const t2 in l.style)
            e2.style[t2] = l.style[t2];
        const re = getMaxZIndex(q), se = getMaxZIndex(e2), ue = le === true ? document.documentElement : { scrollLeft: 0, scrollTop: 0 };
        e2.style.position = le === true ? "fixed" : "absolute", e2.style.left = `${j.left - ue.scrollLeft}px`, e2.style.right = "unset", e2.style.top = `${j.top - ue.scrollTop}px`, e2.style.margin = 0, l.resize === true && (e2.style.minWidth = "unset", e2.style.maxWidth = "unset", e2.style.minHeight = "unset", e2.style.maxHeight = "unset", e2.style.overflow = "hidden", e2.style.overflowX = "hidden", e2.style.overflowY = "hidden"), document.body.appendChild(e2), T !== void 0 && (T.style.cssText = C, T.style.transform = "none", T.style.animation = "none", T.style.transition = "none", T.style.position = e2.style.position, T.style.left = `${v.left - ue.scrollLeft}px`, T.style.right = "unset", T.style.top = `${v.top - ue.scrollTop}px`, T.style.margin = 0, T.style.pointerEvents = "none", l.resize === true && (T.style.minWidth = "unset", T.style.maxWidth = "unset", T.style.minHeight = "unset", T.style.maxHeight = "unset", T.style.overflow = "hidden", T.style.overflowX = "hidden", T.style.overflowY = "hidden"), document.body.appendChild(T));
        const ce = (o2) => {
          i === e2 && n !== true ? (e2.style.cssText = _, e2.className = k2) : (e2.style.cssText = H, e2.className = N), E.parentNode === a2 && a2.insertBefore(e2, E), q.remove(), E.remove(), T !== void 0 && T.remove(), t = () => false, i.qMorphCancel = void 0, e2.qMorphCancel = void 0, typeof l.onEnd === "function" && l.onEnd(n === true ? "to" : "from", o2 === true);
        };
        if (l.useCSS !== true && typeof e2.animate === "function") {
          const a3 = l.resize === true ? { transform: `translate(${U}px, ${K}px)`, width: `${ee}px`, height: `${te}px` } : { transform: `translate(${U}px, ${K}px) scale(${W}, ${Y})` }, d2 = l.resize === true ? { width: `${oe}px`, height: `${ne}px` } : {}, p4 = l.resize === true ? { width: `${ee}px`, height: `${te}px` } : {}, m2 = l.resize === true ? { transform: `translate(${-1 * U}px, ${-1 * K}px)`, width: `${oe}px`, height: `${ne}px` } : { transform: `translate(${-1 * U}px, ${-1 * K}px) scale(${1 / W}, ${1 / Y})` }, f2 = T !== void 0 ? { opacity: l.tweenToOpacity } : { backgroundColor: S }, x2 = T !== void 0 ? { opacity: 1 } : { backgroundColor: V };
          c = e2.animate([{ margin: 0, borderWidth: h3, borderStyle: g, borderColor: b, borderRadius: y, zIndex: re, transformOrigin: "0 0", ...a3, ...f2 }, { margin: 0, borderWidth: z, borderStyle: F, borderColor: L, borderRadius: R, zIndex: se, transformOrigin: "0 0", transform: I, ...d2, ...x2 }], { duration: l.duration, easing: l.easing, fill: l.fill, delay: l.delay }), s2 = T === void 0 ? void 0 : T.animate([{ opacity: l.tweenFromOpacity, margin: 0, borderWidth: h3, borderStyle: g, borderColor: b, borderRadius: y, zIndex: re, transformOrigin: "0 0", transform: w, ...p4 }, { opacity: 0, margin: 0, borderWidth: z, borderStyle: F, borderColor: L, borderRadius: R, zIndex: se, transformOrigin: "0 0", ...m2 }], { duration: l.duration, easing: l.easing, fill: l.fill, delay: l.delay }), r = l.hideFromClone === true || ae === true ? void 0 : q.animate([{ margin: `${X < 0 ? X / 2 : 0}px ${G < 0 ? G / 2 : 0}px`, width: `${ee + v.marginH}px`, height: `${te + v.marginV}px` }, { margin: 0, width: 0, height: 0 }], { duration: l.duration, easing: l.easing, fill: l.fill, delay: l.delay }), u = l.keepToClone === true ? void 0 : E.animate([ae === true ? { margin: `${X < 0 ? X / 2 : 0}px ${G < 0 ? G / 2 : 0}px`, width: `${ee + v.marginH}px`, height: `${te + v.marginV}px` } : { margin: 0, width: 0, height: 0 }, { margin: `${J < 0 ? J / 2 : 0}px ${Z < 0 ? Z / 2 : 0}px`, width: `${oe + j.marginH}px`, height: `${ne + j.marginV}px` }], { duration: l.duration, easing: l.easing, fill: l.fill, delay: l.delay });
          const C2 = (e3) => {
            r !== void 0 && r.cancel(), s2 !== void 0 && s2.cancel(), u !== void 0 && u.cancel(), c.cancel(), c.removeEventListener("finish", C2), c.removeEventListener("cancel", C2), ce(e3), r = void 0, s2 = void 0, u = void 0, c = void 0;
          };
          i.qMorphCancel = () => {
            i.qMorphCancel = void 0, o = true, C2();
          }, e2.qMorphCancel = () => {
            e2.qMorphCancel = void 0, o = true, C2();
          }, c.addEventListener("finish", C2), c.addEventListener("cancel", C2), t = (e3) => {
            return o !== true && c !== void 0 && (e3 === true ? (C2(true), true) : (n = n !== true, r !== void 0 && r.reverse(), s2 !== void 0 && s2.reverse(), u !== void 0 && u.reverse(), c.reverse(), true));
          };
        } else {
          const a3 = `q-morph-anim-${++id}`, r2 = document.createElement("style"), s3 = l.resize === true ? `
            transform: translate(${U}px, ${K}px);
            width: ${ee}px;
            height: ${te}px;
          ` : `transform: translate(${U}px, ${K}px) scale(${W}, ${Y});`, u2 = l.resize === true ? `
            width: ${oe}px;
            height: ${ne}px;
          ` : "", c4 = l.resize === true ? `
            width: ${ee}px;
            height: ${te}px;
          ` : "", d2 = l.resize === true ? `
            transform: translate(${-1 * U}px, ${-1 * K}px);
            width: ${oe}px;
            height: ${ne}px;
          ` : `transform: translate(${-1 * U}px, ${-1 * K}px) scale(${1 / W}, ${1 / Y});`, p4 = T !== void 0 ? `opacity: ${l.tweenToOpacity};` : `background-color: ${S};`, m2 = T !== void 0 ? "opacity: 1;" : `background-color: ${V};`, f2 = T === void 0 ? "" : `
            @keyframes ${a3}-from-tween {
              0% {
                opacity: ${l.tweenFromOpacity};
                margin: 0;
                border-width: ${h3};
                border-style: ${g};
                border-color: ${b};
                border-radius: ${y};
                z-index: ${re};
                transform-origin: 0 0;
                transform: ${w};
                ${c4}
              }

              100% {
                opacity: 0;
                margin: 0;
                border-width: ${z};
                border-style: ${F};
                border-color: ${L};
                border-radius: ${R};
                z-index: ${se};
                transform-origin: 0 0;
                ${d2}
              }
            }
          `, x2 = l.hideFromClone === true || ae === true ? "" : `
            @keyframes ${a3}-from {
              0% {
                margin: ${X < 0 ? X / 2 : 0}px ${G < 0 ? G / 2 : 0}px;
                width: ${ee + v.marginH}px;
                height: ${te + v.marginV}px;
              }

              100% {
                margin: 0;
                width: 0;
                height: 0;
              }
            }
          `, C2 = ae === true ? `
            margin: ${X < 0 ? X / 2 : 0}px ${G < 0 ? G / 2 : 0}px;
            width: ${ee + v.marginH}px;
            height: ${te + v.marginV}px;
          ` : "\n            margin: 0;\n            width: 0;\n            height: 0;\n          ", k3 = l.keepToClone === true ? "" : `
            @keyframes ${a3}-to {
              0% {
                ${C2}
              }

              100% {
                margin: ${J < 0 ? J / 2 : 0}px ${Z < 0 ? Z / 2 : 0}px;
                width: ${oe + j.marginH}px;
                height: ${ne + j.marginV}px;
              }
            }
          `;
          r2.innerHTML = `
          @keyframes ${a3} {
            0% {
              margin: 0;
              border-width: ${h3};
              border-style: ${g};
              border-color: ${b};
              border-radius: ${y};
              background-color: ${S};
              z-index: ${re};
              transform-origin: 0 0;
              ${s3}
              ${p4}
            }

            100% {
              margin: 0;
              border-width: ${z};
              border-style: ${F};
              border-color: ${L};
              border-radius: ${R};
              background-color: ${V};
              z-index: ${se};
              transform-origin: 0 0;
              transform: ${I};
              ${u2}
              ${m2}
            }
          }

          ${x2}

          ${f2}

          ${k3}
        `, document.head.appendChild(r2);
          let _2 = "normal";
          q.style.animation = `${l.duration}ms ${l.easing} ${l.delay}ms ${_2} ${l.fill} ${a3}-from`, T !== void 0 && (T.style.animation = `${l.duration}ms ${l.easing} ${l.delay}ms ${_2} ${l.fill} ${a3}-from-tween`), E.style.animation = `${l.duration}ms ${l.easing} ${l.delay}ms ${_2} ${l.fill} ${a3}-to`, e2.style.animation = `${l.duration}ms ${l.easing} ${l.delay}ms ${_2} ${l.fill} ${a3}`;
          const P3 = (t2) => {
            t2 === Object(t2) && t2.animationName !== a3 || (e2.removeEventListener("animationend", P3), e2.removeEventListener("animationcancel", P3), ce(), r2.remove());
          };
          i.qMorphCancel = () => {
            i.qMorphCancel = void 0, o = true, P3();
          }, e2.qMorphCancel = () => {
            e2.qMorphCancel = void 0, o = true, P3();
          }, e2.addEventListener("animationend", P3), e2.addEventListener("animationcancel", P3), t = (t2) => {
            return !!(o !== true && e2 && q && E) && (t2 === true ? (P3(), true) : (n = n !== true, _2 = _2 === "normal" ? "reverse" : "normal", q.style.animationDirection = _2, T.style.animationDirection = _2, E.style.animationDirection = _2, e2.style.animationDirection = _2, true));
          };
        }
      };
      if (l.waitFor > 0 || l.waitFor === "transitionend" || l.waitFor === Object(l.waitFor) && typeof l.waitFor.then === "function") {
        const t2 = l.waitFor > 0 ? new Promise((e3) => setTimeout(e3, l.waitFor)) : l.waitFor === "transitionend" ? new Promise((t3) => {
          const o2 = setTimeout(() => {
            n2();
          }, 400), n2 = (a2) => {
            clearTimeout(o2), e2 && (e2.removeEventListener("transitionend", n2), e2.removeEventListener("transitioncancel", n2)), t3();
          };
          e2.addEventListener("transitionend", n2), e2.addEventListener("transitioncancel", n2);
        }) : l.waitFor;
        t2.then(B).catch(() => {
          typeof e2.qMorphCancel === "function" && e2.qMorphCancel();
        });
      } else
        B();
    };
    return typeof e.onToggle === "function" && e.onToggle(), requestAnimationFrame(P), (e2) => t(e2);
  }
  var morphGroups = {};
  var props$1 = ["duration", "delay", "easing", "fill", "classes", "style", "duration", "resize", "useCSS", "hideFromClone", "keepToClone", "tween", "tweenFromOpacity", "tweenToOpacity", "waitFor", "onEnd"];
  var mods = ["resize", "useCSS", "hideFromClone", "keepToClone", "tween"];
  function changeClass(e, t) {
    e.clsAction !== t && (e.clsAction = t, e.el.classList[t]("q-morph--invisible"));
  }
  function trigger3(e) {
    if (e.animating === true || e.queue.length < 2)
      return;
    const [t, o] = e.queue;
    e.animating = true, t.animating = true, o.animating = true, changeClass(t, "remove"), changeClass(o, "remove");
    const n = morph({ from: t.el, to: o.el, onToggle() {
      changeClass(t, "add"), changeClass(o, "remove");
    }, ...o.opts, onEnd(n2, a) {
      o.opts.onEnd !== void 0 && o.opts.onEnd(n2, a), a !== true && (t.animating = false, o.animating = false, e.animating = false, e.cancel = void 0, e.queue.shift(), trigger3(e));
    } });
    e.cancel = () => {
      n(true), e.cancel = void 0;
    };
  }
  function updateModifiers(e, t) {
    const o = t.opts;
    mods.forEach((t2) => {
      o[t2] = e[t2] === true;
    });
  }
  function insertArgs(e, t) {
    const o = typeof e === "string" && e.length > 0 ? e.split(":") : [];
    t.name = o[0], t.group = o[1], Object.assign(t.opts, { duration: isNaN(o[2]) === true ? 300 : parseFloat(o[2]), waitFor: o[3] });
  }
  function updateArgs(e, t) {
    e.group !== void 0 && (t.group = e.group), e.name !== void 0 && (t.name = e.name);
    const o = t.opts;
    props$1.forEach((t2) => {
      e[t2] !== void 0 && (o[t2] = e[t2]);
    });
  }
  function updateModel(e, t) {
    if (t.name !== e)
      t.animating === false && changeClass(t, "add");
    else {
      const o = morphGroups[t.group];
      o === void 0 ? (morphGroups[t.group] = { name: t.group, model: e, queue: [t], animating: false }, changeClass(t, "remove")) : o.model !== e && (o.model = e, o.queue.push(t), o.animating === false && o.queue.length === 2 && trigger3(o));
    }
  }
  function updateValue(e, t) {
    let o;
    Object(t) === t ? (o = "" + t.model, updateArgs(t, e), updateModifiers(t, e)) : o = "" + t, o !== e.model ? (e.model = o, updateModel(o, e)) : e.animating === false && e.clsAction !== void 0 && e.el.classList[e.clsAction]("q-morph--invisible");
  }
  var Morph = { name: "morph", mounted(e, t) {
    const o = { el: e, animating: false, opts: {} };
    updateModifiers(t.modifiers, o), insertArgs(t.arg, o), updateValue(o, t.value), e.__qmorph = o;
  }, updated(e, t) {
    updateValue(e.__qmorph, t.value);
  }, beforeUnmount(e) {
    const t = e.__qmorph, o = morphGroups[t.group];
    if (o !== void 0) {
      const e2 = o.queue.indexOf(t);
      e2 !== -1 && (o.queue = o.queue.filter((e3) => e3 !== t), o.queue.length === 0 && (o.cancel !== void 0 && o.cancel(), delete morphGroups[t.group]));
    }
    t.clsAction === "add" && e.classList.remove("q-morph--invisible"), delete e.__qmorph;
  } };
  var defaultCfg = { childList: true, subtree: true, attributes: true, characterData: true, attributeOldValue: true, characterDataOldValue: true };
  function update$2(e, t, o) {
    t.handler = o, t.observer !== void 0 && t.observer.disconnect(), t.observer = new MutationObserver((o2) => {
      if (typeof t.handler === "function") {
        const n = t.handler(o2);
        n !== false && t.once !== true || destroy(e);
      }
    }), t.observer.observe(e, t.opts);
  }
  function destroy(e) {
    const t = e.__qmutation;
    t !== void 0 && (t.observer !== void 0 && t.observer.disconnect(), delete e.__qmutation);
  }
  var Mutation = { name: "mutation", mounted(e, { modifiers: { once: t, ...o }, value: n }) {
    const a = { once: t, opts: Object.keys(o).length === 0 ? defaultCfg : o };
    update$2(e, a, n), e.__qmutation = a;
  }, updated(e, { oldValue: t, value: o }) {
    const n = e.__qmutation;
    n !== void 0 && t !== o && update$2(e, n, o);
  }, beforeUnmount: destroy };
  var { passive } = listenOpts;
  function update$1(e, { value: t, oldValue: o }) {
    typeof t === "function" ? (e.handler = t, typeof o !== "function" && (e.scrollTarget.addEventListener("scroll", e.scroll, passive), e.scroll())) : e.scrollTarget.removeEventListener("scroll", e.scroll, passive);
  }
  var ScrollFire = { name: "scroll-fire", mounted(e, t) {
    const o = { scrollTarget: getScrollTarget(e), scroll: debounce(() => {
      let t2, n;
      o.scrollTarget === window ? (n = e.getBoundingClientRect().bottom, t2 = window.innerHeight) : (n = offset(e).top + height(e), t2 = offset(o.scrollTarget).top + height(o.scrollTarget)), n > 0 && n < t2 && (o.scrollTarget.removeEventListener("scroll", o.scroll, passive), o.handler(e));
    }, 25) };
    update$1(o, t), e.__qscrollfire = o;
  }, updated(e, t) {
    t.value !== t.oldValue && update$1(e.__qscrollfire, t);
  }, beforeUnmount(e) {
    const t = e.__qscrollfire;
    t.scrollTarget.removeEventListener("scroll", t.scroll, passive), delete e.__qscrollfire;
  } };
  function update(e, { value: t, oldValue: o }) {
    typeof t === "function" ? (e.handler = t, typeof o !== "function" && e.scrollTarget.addEventListener("scroll", e.scroll, listenOpts.passive)) : e.scrollTarget.removeEventListener("scroll", e.scroll, listenOpts.passive);
  }
  var Scroll = { name: "scroll", mounted(e, t) {
    const o = { scrollTarget: getScrollTarget(e), scroll() {
      o.handler(getVerticalScrollPosition(o.scrollTarget), getHorizontalScrollPosition(o.scrollTarget));
    } };
    update(o, t), e.__qscroll = o;
  }, updated(e, t) {
    e.__qscroll !== void 0 && t.oldValue !== t.value && update(e.__qscroll, t);
  }, beforeUnmount(e) {
    const t = e.__qscroll;
    t.scrollTarget.removeEventListener("scroll", t.scroll, listenOpts.passive), delete e.__qscroll;
  } };
  var TouchHold = { name: "touch-hold", beforeMount(e, t) {
    const { modifiers: o } = t;
    if (o.mouse !== true && client2.has.touch !== true)
      return;
    const n = { handler: t.value, noop, mouseStart(e2) {
      typeof n.handler === "function" && leftClick(e2) === true && (addEvt(n, "temp", [[document, "mousemove", "move", "passiveCapture"], [document, "click", "end", "notPassiveCapture"]]), n.start(e2, true));
    }, touchStart(e2) {
      if (e2.target !== void 0 && typeof n.handler === "function") {
        const t2 = e2.target;
        addEvt(n, "temp", [[t2, "touchmove", "move", "passiveCapture"], [t2, "touchcancel", "end", "notPassiveCapture"], [t2, "touchend", "end", "notPassiveCapture"]]), n.start(e2);
      }
    }, start(e2, t2) {
      n.origin = position(e2);
      const o2 = Date.now();
      client2.is.mobile === true && (document.body.classList.add("non-selectable"), clearSelection(), n.styleCleanup = (e3) => {
        n.styleCleanup = void 0;
        const t3 = () => {
          document.body.classList.remove("non-selectable");
        };
        e3 === true ? (clearSelection(), setTimeout(t3, 10)) : t3();
      }), n.triggered = false, n.sensitivity = t2 === true ? n.mouseSensitivity : n.touchSensitivity, n.timer = setTimeout(() => {
        clearSelection(), n.triggered = true, n.handler({ evt: e2, touch: t2 !== true, mouse: t2 === true, position: n.origin, duration: Date.now() - o2 });
      }, n.duration);
    }, move(e2) {
      const { top: t2, left: o2 } = position(e2);
      (Math.abs(o2 - n.origin.left) >= n.sensitivity || Math.abs(t2 - n.origin.top) >= n.sensitivity) && clearTimeout(n.timer);
    }, end(e2) {
      cleanEvt(n, "temp"), n.styleCleanup !== void 0 && n.styleCleanup(n.triggered), n.triggered === true ? e2 !== void 0 && stopAndPrevent(e2) : clearTimeout(n.timer);
    } }, a = [600, 5, 7];
    typeof t.arg === "string" && t.arg.length > 0 && t.arg.split(":").forEach((e2, t2) => {
      const o2 = parseInt(e2, 10);
      o2 && (a[t2] = o2);
    }), [n.duration, n.touchSensitivity, n.mouseSensitivity] = a, e.__qtouchhold = n, o.mouse === true && addEvt(n, "main", [[e, "mousedown", "mouseStart", `passive${o.mouseCapture === true ? "Capture" : ""}`]]), client2.has.touch === true && addEvt(n, "main", [[e, "touchstart", "touchStart", `passive${o.capture === true ? "Capture" : ""}`], [e, "touchend", "noop", "notPassiveCapture"]]);
  }, updated(e, t) {
    const o = e.__qtouchhold;
    o !== void 0 && t.oldValue !== t.value && (typeof t.value !== "function" && o.end(), o.handler = t.value);
  }, beforeUnmount(e) {
    const t = e.__qtouchhold;
    t !== void 0 && (cleanEvt(t, "main"), cleanEvt(t, "temp"), clearTimeout(t.timer), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchhold);
  } };
  var keyCodes = { esc: 27, tab: 9, enter: 13, space: 32, up: 38, left: 37, right: 39, down: 40, delete: [8, 46] };
  var keyRegex = new RegExp(`^([\\d+]+|${Object.keys(keyCodes).join("|")})$`, "i");
  function shouldEnd(e, t) {
    const { top: o, left: n } = position(e);
    return Math.abs(n - t.left) >= 7 || Math.abs(o - t.top) >= 7;
  }
  var TouchRepeat = { name: "touch-repeat", beforeMount(e, { modifiers: t, value: o, arg: n }) {
    const a = Object.keys(t).reduce((e2, t2) => {
      if (keyRegex.test(t2) === true) {
        const o2 = isNaN(parseInt(t2, 10)) ? keyCodes[t2.toLowerCase()] : parseInt(t2, 10);
        o2 >= 0 && e2.push(o2);
      }
      return e2;
    }, []);
    if (t.mouse !== true && client2.has.touch !== true && a.length === 0)
      return;
    const l = typeof n === "string" && n.length > 0 ? n.split(":").map((e2) => parseInt(e2, 10)) : [0, 600, 300], i = l.length - 1, r = { keyboard: a, handler: o, noop, mouseStart(e2) {
      r.event === void 0 && typeof r.handler === "function" && leftClick(e2) === true && (addEvt(r, "temp", [[document, "mousemove", "move", "passiveCapture"], [document, "click", "end", "notPassiveCapture"]]), r.start(e2, true));
    }, keyboardStart(t2) {
      if (typeof r.handler === "function" && isKeyCode(t2, a) === true) {
        if ((l[0] === 0 || r.event !== void 0) && (stopAndPrevent(t2), e.focus(), r.event !== void 0))
          return;
        addEvt(r, "temp", [[document, "keyup", "end", "notPassiveCapture"], [document, "click", "end", "notPassiveCapture"]]), r.start(t2, false, true);
      }
    }, touchStart(e2) {
      if (e2.target !== void 0 && typeof r.handler === "function") {
        const t2 = e2.target;
        addEvt(r, "temp", [[t2, "touchmove", "move", "passiveCapture"], [t2, "touchcancel", "end", "notPassiveCapture"], [t2, "touchend", "end", "notPassiveCapture"]]), r.start(e2);
      }
    }, start(e2, t2, o2) {
      function n2(e3) {
        r.styleCleanup = void 0, document.documentElement.style.cursor = "";
        const t3 = () => {
          document.body.classList.remove("non-selectable");
        };
        e3 === true ? (clearSelection(), setTimeout(t3, 10)) : t3();
      }
      o2 !== true && (r.origin = position(e2)), client2.is.mobile === true && (document.body.classList.add("non-selectable"), clearSelection(), r.styleCleanup = n2), r.event = { touch: t2 !== true && o2 !== true, mouse: t2 === true, keyboard: o2 === true, startTime: Date.now(), repeatCount: 0 };
      const a2 = () => {
        if (r.event === void 0)
          return;
        r.event.repeatCount === 0 && (r.event.evt = e2, o2 === true ? r.event.keyCode = e2.keyCode : r.event.position = position(e2), client2.is.mobile !== true && (document.documentElement.style.cursor = "pointer", document.body.classList.add("non-selectable"), clearSelection(), r.styleCleanup = n2)), r.event.duration = Date.now() - r.event.startTime, r.event.repeatCount += 1, r.handler(r.event);
        const t3 = i < r.event.repeatCount ? i : r.event.repeatCount;
        r.timer = setTimeout(a2, l[t3]);
      };
      l[0] === 0 ? a2() : r.timer = setTimeout(a2, l[0]);
    }, move(e2) {
      r.event !== void 0 && shouldEnd(e2, r.origin) === true && clearTimeout(r.timer);
    }, end(e2) {
      r.event !== void 0 && (r.styleCleanup !== void 0 && r.styleCleanup(true), e2 !== void 0 && r.event.repeatCount > 0 && stopAndPrevent(e2), cleanEvt(r, "temp"), clearTimeout(r.timer), r.event = void 0);
    } };
    e.__qtouchrepeat = r, t.mouse === true && addEvt(r, "main", [[e, "mousedown", "mouseStart", `passive${t.mouseCapture === true ? "Capture" : ""}`]]), client2.has.touch === true && addEvt(r, "main", [[e, "touchstart", "touchStart", `passive${t.capture === true ? "Capture" : ""}`], [e, "touchend", "noop", "notPassiveCapture"]]), a.length > 0 && addEvt(r, "main", [[e, "keydown", "keyboardStart", `notPassive${t.keyCapture === true ? "Capture" : ""}`]]);
  }, updated(e, { oldValue: t, value: o }) {
    const n = e.__qtouchrepeat;
    n !== void 0 && t !== o && (typeof o !== "function" && n.end(), n.handler = o);
  }, beforeUnmount(e) {
    const t = e.__qtouchrepeat;
    t !== void 0 && (clearTimeout(t.timer), cleanEvt(t, "main"), cleanEvt(t, "temp"), t.styleCleanup !== void 0 && t.styleCleanup(), delete e.__qtouchrepeat);
  } };
  var directives = Object.freeze({ __proto__: null, ClosePopup, Intersection, Morph, Mutation, Ripple, ScrollFire, Scroll, TouchHold, TouchPan, TouchRepeat, TouchSwipe });
  function getCssVar(e, t = document.body) {
    if (typeof e !== "string")
      throw new TypeError("Expected a string as propName");
    if (!(t instanceof Element))
      throw new TypeError("Expected a DOM element");
    return getComputedStyle(t).getPropertyValue(`--q-${e}`).trim() || null;
  }
  var metaValue;
  function getProp() {
    return client2.is.winphone ? "msapplication-navbutton-color" : client2.is.safari ? "apple-mobile-web-app-status-bar-style" : "theme-color";
  }
  function getMetaTag(e) {
    const t = document.getElementsByTagName("META");
    for (const o in t)
      if (t[o].name === e)
        return t[o];
  }
  function setColor(e) {
    metaValue === void 0 && (metaValue = getProp());
    let t = getMetaTag(metaValue);
    const o = t === void 0;
    o && (t = document.createElement("meta"), t.setAttribute("name", metaValue)), t.setAttribute("content", e), o && document.head.appendChild(t);
  }
  var AddressbarColor = { set: client2.is.mobile !== true || client2.is.nativeMobile !== true && client2.is.winphone !== true && client2.is.safari !== true && client2.is.webkit !== true && client2.is.vivaldi !== true ? noop : (e) => {
    const t = e || getCssVar("primary");
    client2.is.nativeMobile === true && window.StatusBar ? window.StatusBar.backgroundColorByHexString(t) : setColor(t);
  }, install({ $q: e }) {
    e.addressbarColor = this, e.config.addressbarColor && this.set(e.config.addressbarColor);
  } };
  var prefixes2 = {};
  function getFullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
  }
  function promisify(e, t) {
    try {
      const o = e[t]();
      return o === void 0 ? Promise.resolve() : o;
    } catch (e2) {
      return Promise.reject(e2);
    }
  }
  var Plugin$5 = defineReactivePlugin({ isActive: false, activeEl: null }, { isCapable: false, request(e) {
    if (Plugin$5.isCapable === true && Plugin$5.isActive === false) {
      const t = e || document.documentElement;
      return promisify(t, prefixes2.request);
    }
    return Plugin$5.__getErr();
  }, exit() {
    return Plugin$5.isCapable === true && Plugin$5.isActive === true ? promisify(document, prefixes2.exit) : Plugin$5.__getErr();
  }, toggle(e) {
    return Plugin$5.isActive === true ? Plugin$5.exit() : Plugin$5.request(e);
  }, install({ $q: e }) {
    e.fullscreen = this;
  } });
  {
    let init = function() {
      prefixes2.request = ["requestFullscreen", "msRequestFullscreen", "mozRequestFullScreen", "webkitRequestFullscreen"].find((e) => document.documentElement[e] !== void 0), Plugin$5.isCapable = prefixes2.request !== void 0, Plugin$5.isCapable !== false ? (Plugin$5.__getErr = () => Promise.resolve(), prefixes2.exit = ["exitFullscreen", "msExitFullscreen", "mozCancelFullScreen", "webkitExitFullscreen"].find((e) => document[e]), Plugin$5.isActive = !!getFullscreenElement(), ["onfullscreenchange", "onmsfullscreenchange", "onwebkitfullscreenchange"].forEach((e) => {
        document[e] = () => {
          Plugin$5.isActive = Plugin$5.isActive === false, Plugin$5.isActive === false ? (Plugin$5.activeEl = null, changeGlobalNodesTarget(document.body)) : (Plugin$5.activeEl = getFullscreenElement(), changeGlobalNodesTarget(Plugin$5.activeEl === document.documentElement ? document.body : Plugin$5.activeEl));
        };
      })) : Plugin$5.__getErr = () => Promise.reject("Not capable");
    };
    init();
  }
  var Plugin$4 = defineReactivePlugin({ appVisible: true }, { install({ $q: e }) {
    Object.defineProperty(e, "appVisible", { get: () => this.appVisible });
  } });
  {
    let e, t;
    if (typeof document.hidden !== "undefined" ? (e = "hidden", t = "visibilitychange") : typeof document.msHidden !== "undefined" ? (e = "msHidden", t = "msvisibilitychange") : typeof document.webkitHidden !== "undefined" && (e = "webkitHidden", t = "webkitvisibilitychange"), t && typeof document[e] !== "undefined") {
      const o = () => {
        Plugin$4.appVisible = !document[e];
      };
      document.addEventListener(t, o, false);
    }
  }
  var BottomSheet$1 = defineComponent2({ name: "BottomSheetPlugin", props: { ...useDarkProps, title: String, message: String, actions: Array, grid: Boolean, cardClass: [String, Array, Object], cardStyle: [String, Array, Object] }, emits: ["ok", "hide"], setup(e, { emit: t }) {
    const { proxy: o } = getCurrentInstance(), n = useDark(e, o.$q), a = ref(null);
    function l() {
      a.value.show();
    }
    function i() {
      a.value.hide();
    }
    function r(e2) {
      t("ok", e2), i();
    }
    function s2() {
      t("hide");
    }
    function u() {
      return e.actions.map((e2) => {
        const t2 = e2.avatar || e2.img;
        return e2.label === void 0 ? h(QSeparator, { class: "col-all", dark: n.value }) : h("div", { class: ["q-bottom-sheet__item q-hoverable q-focusable cursor-pointer relative-position", e2.class], tabindex: 0, onClick() {
          r(e2);
        }, onKeyup(t3) {
          t3.keyCode === 13 && r(e2);
        } }, [h("div", { class: "q-focus-helper" }), e2.icon ? h(QIcon, { name: e2.icon, color: e2.color }) : t2 ? h("img", { class: e2.avatar ? "q-bottom-sheet__avatar" : "", src: t2 }) : h("div", { class: "q-bottom-sheet__empty-icon" }), h("div", e2.label)]);
      });
    }
    function c() {
      return e.actions.map((e2) => {
        const t2 = e2.avatar || e2.img;
        return e2.label === void 0 ? h(QSeparator, { spaced: true, dark: n.value }) : h(QItem, { class: ["q-bottom-sheet__item", e2.classes], tabindex: 0, clickable: true, dark: n.value, onClick() {
          r(e2);
        }, onKeyup(t3) {
          t3.keyCode === 13 && r(e2);
        } }, () => [h(QItemSection, { avatar: true }, () => e2.icon ? h(QIcon, { name: e2.icon, color: e2.color }) : t2 ? h("img", { class: e2.avatar ? "q-bottom-sheet__avatar" : "", src: t2 }) : null), h(QItemSection, () => e2.label)]);
      });
    }
    function d() {
      const t2 = [];
      return e.title && t2.push(h(QCardSection, { class: "q-dialog__title" }, () => e.title)), e.message && t2.push(h(QCardSection, { class: "q-dialog__message" }, () => e.message)), t2.push(e.grid === true ? h("div", { class: "row items-stretch justify-start" }, u()) : h("div", c())), t2;
    }
    function p2() {
      return [h(QCard, { class: [`q-bottom-sheet q-bottom-sheet--${e.grid === true ? "grid" : "list"}` + (n.value === true ? " q-bottom-sheet--dark q-dark" : ""), e.cardClass], style: e.cardStyle }, d)];
    }
    return Object.assign(o, { show: l, hide: i }), () => h(QDialog, { ref: a, position: "bottom", onHide: s2 }, p2);
  } });
  function merge(e, t) {
    for (const o in t)
      o !== "spinner" && Object(t[o]) === t[o] ? (e[o] = Object(e[o]) !== e[o] ? {} : { ...e[o] }, merge(e[o], t[o])) : e[o] = t[o];
  }
  function globalDialog(e, t, o) {
    return (n) => {
      let a, l;
      const i = t === true && n.component !== void 0;
      if (i === true) {
        const { component: e2, componentProps: t2 } = n;
        a = typeof e2 === "string" ? o.component(e2) : e2, l = t2;
      } else {
        const { class: t2, style: o2, ...i2 } = n;
        a = e, l = i2, t2 !== void 0 && (i2.cardClass = t2), o2 !== void 0 && (i2.cardStyle = o2);
      }
      const r = [], s2 = [], u = { onOk(e2) {
        return r.push(e2), u;
      }, onCancel(e2) {
        return s2.push(e2), u;
      }, onDismiss(e2) {
        return r.push(e2), s2.push(e2), u;
      }, hide() {
        return m.value !== null && m.value.hide(), u;
      }, update(e2) {
        if (g !== null) {
          if (i === true)
            Object.assign(l, e2);
          else {
            const { class: t2, style: o2, ...n2 } = e2;
            t2 !== void 0 && (n2.cardClass = t2), o2 !== void 0 && (n2.cardStyle = o2), merge(l, n2);
          }
          g.$forceUpdate();
        }
        return u;
      } }, c = createGlobalNode();
      let d = false;
      const p2 = (e2) => {
        d = true, r.forEach((t2) => {
          t2(e2);
        });
      }, v = () => {
        f.unmount(c), removeGlobalNode(c), f = null, g = null, d !== true && s2.forEach((e2) => {
          e2();
        });
      }, m = ref(null);
      let f = createChildApp({ name: "QGlobalDialog", setup() {
        return () => h(a, { ref: m, ...l, onOk: p2, onHide: v });
      } }, o), g = f.mount(c);
      function b() {
        m.value.show !== void 0 ? m.value.show() : g.$.subTree && g.$.subTree.component && g.$.subTree.component.proxy && g.$.subTree.component.proxy.show ? g.$.subTree.component.proxy.show() : console.error("[Quasar] Incorrectly defined Dialog component");
      }
      return m.value !== null ? b() : typeof a.__asyncLoader === "function" && a.__asyncLoader().then(() => {
        nextTick2(b);
      }), u;
    };
  }
  var BottomSheet = { install({ $q: e, parentApp: t }) {
    this.__installed === true ? e.bottomSheet = globalDialog(BottomSheet$1, false, t) : this.create = e.bottomSheet = globalDialog(BottomSheet$1, false, t);
  } };
  function encode$1(e) {
    return encodeURIComponent(e);
  }
  function decode$1(e) {
    return decodeURIComponent(e);
  }
  function stringifyCookieValue(e) {
    return encode$1(e === Object(e) ? JSON.stringify(e) : "" + e);
  }
  function read(e) {
    if (e === "")
      return e;
    e.indexOf('"') === 0 && (e = e.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\")), e = decode$1(e.replace(/\+/g, " "));
    try {
      e = JSON.parse(e);
    } catch (e2) {
    }
    return e;
  }
  function getString(e) {
    const t = new Date();
    return t.setMilliseconds(t.getMilliseconds() + e), t.toUTCString();
  }
  function parseExpireString(e) {
    let t = 0;
    const o = e.match(/(\d+)d/), n = e.match(/(\d+)h/), a = e.match(/(\d+)m/), l = e.match(/(\d+)s/);
    return o && (t += 864e5 * o[1]), n && (t += 36e5 * n[1]), a && (t += 6e4 * a[1]), l && (t += 1e3 * l[1]), t === 0 ? e : getString(t);
  }
  function set2(e, t, o = {}, n) {
    let a, l;
    o.expires !== void 0 && (Object.prototype.toString.call(o.expires) === "[object Date]" ? a = o.expires.toUTCString() : typeof o.expires === "string" ? a = parseExpireString(o.expires) : (l = parseFloat(o.expires), a = isNaN(l) === false ? getString(864e5 * l) : o.expires));
    const i = `${encode$1(e)}=${stringifyCookieValue(t)}`, r = [i, a !== void 0 ? "; Expires=" + a : "", o.path ? "; Path=" + o.path : "", o.domain ? "; Domain=" + o.domain : "", o.sameSite ? "; SameSite=" + o.sameSite : "", o.httpOnly ? "; HttpOnly" : "", o.secure ? "; Secure" : "", o.other ? "; " + o.other : ""].join("");
    if (n) {
      n.req.qCookies ? n.req.qCookies.push(r) : n.req.qCookies = [r], n.res.setHeader("Set-Cookie", n.req.qCookies);
      let t2 = n.req.headers.cookie || "";
      if (a !== void 0 && l < 0) {
        const o2 = get2(e, n);
        o2 !== void 0 && (t2 = t2.replace(`${e}=${o2}; `, "").replace(`; ${e}=${o2}`, "").replace(`${e}=${o2}`, ""));
      } else
        t2 = t2 ? `${i}; ${t2}` : r;
      n.req.headers.cookie = t2;
    } else
      document.cookie = r;
  }
  function get2(e, t) {
    const o = t ? t.req.headers : document, n = o.cookie ? o.cookie.split("; ") : [], a = n.length;
    let l, i, r, s2 = e ? null : {}, u = 0;
    for (; u < a; u++)
      if (l = n[u].split("="), i = decode$1(l.shift()), r = l.join("="), e) {
        if (e === i) {
          s2 = read(r);
          break;
        }
      } else
        s2[i] = r;
    return s2;
  }
  function remove2(e, t, o) {
    set2(e, "", { expires: -1, ...t }, o);
  }
  function has2(e, t) {
    return get2(e, t) !== null;
  }
  function getObject(e) {
    return { get: (t) => get2(t, e), set: (t, o, n) => set2(t, o, n, e), has: (t) => has2(t, e), remove: (t, o) => remove2(t, o, e), getAll: () => get2(null, e) };
  }
  var Plugin$3 = { install({ $q: e, ssrContext: t }) {
    e.cookies = this;
  } };
  Object.assign(Plugin$3, getObject());
  var DialogPlugin = defineComponent2({ name: "DialogPlugin", props: { ...useDarkProps, title: String, message: String, prompt: Object, options: Object, progress: [Boolean, Object], html: Boolean, ok: { type: [String, Object, Boolean], default: true }, cancel: [String, Object, Boolean], focus: { type: String, default: "ok", validator: (e) => ["ok", "cancel", "none"].includes(e) }, stackButtons: Boolean, color: String, cardClass: [String, Array, Object], cardStyle: [String, Array, Object] }, emits: ["ok", "hide"], setup(e, { emit: t }) {
    const { proxy: o } = getCurrentInstance(), { $q: n } = o, a = useDark(e, n), l = ref(null), i = ref(e.prompt !== void 0 ? e.prompt.model : e.options !== void 0 ? e.options.model : void 0), r = computed2(() => "q-dialog-plugin" + (a.value === true ? " q-dialog-plugin--dark q-dark" : "") + (e.progress !== false ? " q-dialog-plugin--progress" : "")), s2 = computed2(() => e.color || (a.value === true ? "amber" : "primary")), u = computed2(() => e.progress === false ? null : Object(e.progress) === e.progress ? { component: e.progress.spinner || QSpinner, props: { color: e.progress.color || s2.value } } : { component: QSpinner, props: { color: s2.value } }), c = computed2(() => e.prompt !== void 0 || e.options !== void 0), d = computed2(() => {
      if (c.value !== true)
        return {};
      const { model: t2, isValid: o2, items: n2, ...a2 } = e.prompt !== void 0 ? e.prompt : e.options;
      return a2;
    }), p2 = computed2(() => Object(e.ok) === e.ok ? n.lang.label.ok : e.ok === true ? n.lang.label.ok : e.ok), v = computed2(() => Object(e.cancel) === e.cancel ? n.lang.label.cancel : e.cancel === true ? n.lang.label.cancel : e.cancel), m = computed2(() => {
      return e.prompt !== void 0 ? e.prompt.isValid !== void 0 && e.prompt.isValid(i.value) !== true : e.options !== void 0 && (e.options.isValid !== void 0 && e.options.isValid(i.value) !== true);
    }), f = computed2(() => ({ color: s2.value, label: p2.value, ripple: false, ...Object(e.ok) === e.ok ? e.ok : { flat: true }, disable: m.value, "data-autofocus": e.focus === "ok" && c.value !== true || void 0, onClick: S })), g = computed2(() => ({ color: s2.value, label: v.value, ripple: false, ...Object(e.cancel) === e.cancel ? e.cancel : { flat: true }, "data-autofocus": e.focus === "cancel" && c.value !== true || void 0, onClick: w }));
    function b() {
      l.value.show();
    }
    function y() {
      l.value.hide();
    }
    function S() {
      t("ok", toRaw(i.value)), y();
    }
    function w() {
      y();
    }
    function x() {
      t("hide");
    }
    function C(e2) {
      i.value = e2;
    }
    function k2(t2) {
      m.value !== true && e.prompt.type !== "textarea" && isKeyCode(t2, 13) === true && S();
    }
    function _(t2, o2) {
      return e.html === true ? h(QCardSection, { class: t2, innerHTML: o2 }) : h(QCardSection, { class: t2 }, () => o2);
    }
    function q() {
      return [h(QInput, { modelValue: i.value, ...d.value, color: s2.value, dense: true, autofocus: true, dark: a.value, "onUpdate:modelValue": C, onKeyup: k2 })];
    }
    function T() {
      return [h(QOptionGroup, { modelValue: i.value, ...d.value, color: s2.value, options: e.options.items, dark: a.value, "onUpdate:modelValue": C })];
    }
    function P() {
      const t2 = [];
      return e.cancel && t2.push(h(QBtn, g.value)), e.ok && t2.push(h(QBtn, f.value)), h(QCardActions, { class: e.stackButtons === true ? "items-end" : "", vertical: e.stackButtons, align: "right" }, () => t2);
    }
    function $() {
      const t2 = [];
      return e.title && t2.push(_("q-dialog__title", e.title)), e.progress !== false && t2.push(h(QCardSection, { class: "q-dialog__progress" }, () => h(u.value.component, u.value.props))), e.message && t2.push(_("q-dialog__message", e.message)), e.prompt !== void 0 ? t2.push(h(QCardSection, { class: "scroll q-dialog-plugin__form" }, q)) : e.options !== void 0 && t2.push(h(QSeparator, { dark: a.value }), h(QCardSection, { class: "scroll q-dialog-plugin__form" }, T), h(QSeparator, { dark: a.value })), (e.ok || e.cancel) && t2.push(P()), t2;
    }
    function M() {
      return [h(QCard, { class: [r.value, e.cardClass], style: e.cardStyle, dark: a.value }, $)];
    }
    return watch(() => e.prompt && e.prompt.model, C), watch(() => e.options && e.options.model, C), Object.assign(o, { show: b, hide: y }), () => h(QDialog, { ref: l, onHide: x }, M);
  } });
  var Dialog = { install({ $q: e, parentApp: t }) {
    this.__installed === true ? e.dialog = globalDialog(DialogPlugin, true, t) : this.create = e.dialog = globalDialog(DialogPlugin, true, t);
  } };
  var reqProps = { ref: "bar" };
  var LoadingBar = defineReactivePlugin({ isActive: false }, { start: noop, stop: noop, increment: noop, setDefaults: noop, install({ $q: e, parentApp: t }) {
    if (e.loadingBar = this, this.__installed === true)
      return void (e.config.loadingBar !== void 0 && this.setDefaults(e.config.loadingBar));
    const o = ref(e.config.loadingBar !== void 0 ? { ...e.config.loadingBar, ...reqProps } : { ...reqProps }), n = createGlobalNode("q-loading-bar"), a = createChildApp({ name: "LoadingBar", setup: () => () => h(QAjaxBar, o.value) }, t).mount(n);
    Object.assign(this, { start: (e2) => {
      const t2 = a.$refs.bar;
      t2.start(e2), this.isActive = t2.calls > 0;
    }, stop: () => {
      const e2 = a.$refs.bar;
      e2.stop(), this.isActive = e2.calls > 0;
    }, increment() {
      const e2 = a.$refs.bar;
      e2.increment.apply(null, arguments);
    }, setDefaults: (e2) => {
      e2 === Object(e2) && (o.value = { ...o.value, ...e2, ...reqProps });
    } });
  } });
  var app;
  var vm;
  var timeout;
  var uid$12 = 0;
  var props = {};
  var originalDefaults = { delay: 0, message: false, html: false, spinnerSize: 80, spinnerColor: "", messageColor: "", backgroundColor: "", boxClass: "", spinner: QSpinner, customClass: "" };
  var defaults$1 = { ...originalDefaults };
  var Plugin$2 = defineReactivePlugin({ isActive: false }, { show(e) {
    if (props = e === Object(e) && e.ignoreDefaults === true ? { ...originalDefaults, ...e } : { ...defaults$1, ...e }, Plugin$2.isActive = true, app !== void 0)
      return props.uid = uid$12, void vm.$forceUpdate();
    props.uid = ++uid$12, clearTimeout(timeout), timeout = setTimeout(() => {
      timeout = void 0;
      const e2 = createGlobalNode("q-loading");
      app = createApp2({ name: "QLoading", setup() {
        function t() {
          Plugin$2.isActive !== true && app !== void 0 && (preventScroll(false), app.unmount(e2), removeGlobalNode(e2), app = void 0, vm = void 0);
        }
        function o() {
          if (Plugin$2.isActive !== true)
            return null;
          const e3 = [h(props.spinner, { class: "q-loading__spinner", color: props.spinnerColor, size: props.spinnerSize })];
          return props.message && e3.push(h("div", { class: "q-loading__message" + (props.messageColor ? ` text-${props.messageColor}` : ""), [props.html === true ? "innerHTML" : "textContent"]: props.message })), h("div", { class: "q-loading fullscreen flex flex-center z-max " + props.customClass.trim(), key: props.uid }, [h("div", { class: "q-loading__backdrop" + (props.backgroundColor ? ` bg-${props.backgroundColor}` : "") }), h("div", { class: "q-loading__box column items-center " + props.boxClass }, e3)]);
        }
        return onMounted2(() => {
          preventScroll(true);
        }), () => h(Transition, { name: "q-transition--fade", appear: true, onAfterLeave: t }, o);
      } }), vm = app.mount(e2);
    }, props.delay);
  }, hide() {
    Plugin$2.isActive === true && (timeout !== void 0 && (clearTimeout(timeout), timeout = void 0), Plugin$2.isActive = false);
  }, setDefaults(e) {
    e === Object(e) && Object.assign(defaults$1, e);
  }, install({ $q: e }) {
    e.loading = this, e.config.loading !== void 0 && this.setDefaults(e.config.loading);
  } });
  var updateId;
  var currentClientMeta;
  var clientList = [];
  function normalize(e) {
    e.title && (e.title = e.titleTemplate ? e.titleTemplate(e.title) : e.title, delete e.titleTemplate), [["meta", "content"], ["link", "href"]].forEach((t) => {
      const o = e[t[0]], n = t[1];
      for (const e2 in o) {
        const t2 = o[e2];
        t2.template && (Object.keys(t2).length === 1 ? delete o[e2] : (t2[n] = t2.template(t2[n] || ""), delete t2.template));
      }
    });
  }
  function changed(e, t) {
    if (Object.keys(e).length !== Object.keys(t).length)
      return true;
    for (const o in e)
      if (e[o] !== t[o])
        return true;
  }
  function bodyFilter(e) {
    return ["class", "style"].includes(e) === false;
  }
  function htmlFilter(e) {
    return ["lang", "dir"].includes(e) === false;
  }
  function diff(e, t) {
    const o = {}, n = {};
    return e === void 0 ? { add: t, remove: n } : (e.title !== t.title && (o.title = t.title), ["meta", "link", "script", "htmlAttr", "bodyAttr"].forEach((a) => {
      const l = e[a], i = t[a];
      if (n[a] = [], l !== void 0 && l !== null) {
        o[a] = {};
        for (const e2 in l)
          i.hasOwnProperty(e2) === false && n[a].push(e2);
        for (const e2 in i)
          l.hasOwnProperty(e2) === false ? o[a][e2] = i[e2] : changed(l[e2], i[e2]) === true && (n[a].push(e2), o[a][e2] = i[e2]);
      } else
        o[a] = i;
    }), { add: o, remove: n });
  }
  function apply({ add: e, remove: t }) {
    e.title && (document.title = e.title), Object.keys(t).length > 0 && (["meta", "link", "script"].forEach((e2) => {
      t[e2].forEach((t2) => {
        document.head.querySelector(`${e2}[data-qmeta="${t2}"]`).remove();
      });
    }), t.htmlAttr.filter(htmlFilter).forEach((e2) => {
      document.documentElement.removeAttribute(e2);
    }), t.bodyAttr.filter(bodyFilter).forEach((e2) => {
      document.body.removeAttribute(e2);
    })), ["meta", "link", "script"].forEach((t2) => {
      const o = e[t2];
      for (const e2 in o) {
        const n = document.createElement(t2);
        for (const t3 in o[e2])
          t3 !== "innerHTML" && n.setAttribute(t3, o[e2][t3]);
        n.setAttribute("data-qmeta", e2), t2 === "script" && (n.innerHTML = o[e2].innerHTML || ""), document.head.appendChild(n);
      }
    }), Object.keys(e.htmlAttr).filter(htmlFilter).forEach((t2) => {
      document.documentElement.setAttribute(t2, e.htmlAttr[t2] || "");
    }), Object.keys(e.bodyAttr).filter(bodyFilter).forEach((t2) => {
      document.body.setAttribute(t2, e.bodyAttr[t2] || "");
    });
  }
  function updateClientMeta() {
    const e = { title: "", titleTemplate: null, meta: {}, link: {}, script: {}, htmlAttr: {}, bodyAttr: {} };
    for (let t = 0; t < clientList.length; t++) {
      const { active: o, val: n } = clientList[t];
      o === true && extend2(true, e, n);
    }
    normalize(e), apply(diff(currentClientMeta, e)), currentClientMeta = e;
  }
  function planClientUpdate() {
    clearTimeout(updateId), updateId = setTimeout(updateClientMeta, 50);
  }
  var Meta = { install(e) {
    this.__installed !== true && isRuntimeSsrPreHydration.value === true && (currentClientMeta = window.__Q_META__, document.getElementById("qmeta-init").remove());
  } };
  var addNotification;
  var uid2 = 0;
  var defaults = {};
  var positionList = ["top-left", "top-right", "bottom-left", "bottom-right", "top", "bottom", "left", "right", "center"];
  var badgePositions = ["top-left", "top-right", "bottom-left", "bottom-right"];
  var notifTypes = { positive: { icon: (e) => e.iconSet.type.positive, color: "positive" }, negative: { icon: (e) => e.iconSet.type.negative, color: "negative" }, warning: { icon: (e) => e.iconSet.type.warning, color: "warning", textColor: "dark" }, info: { icon: (e) => e.iconSet.type.info, color: "info" }, ongoing: { group: false, timeout: 0, spinner: true, color: "grey-8" } };
  var groups = {};
  var positionClass = {};
  function logError2(e, t) {
    return console.error(`Notify: ${e}`, t), false;
  }
  function getComponent(e) {
    return defineComponent2({ name: "QNotifications", setup() {
      const t = {}, o = [];
      function n(e2) {
        clearTimeout(e2.meta.timer);
        const n2 = t[e2.position].value.indexOf(e2);
        if (n2 !== -1) {
          e2.group !== void 0 && delete groups[e2.meta.group];
          const a = o["" + e2.meta.uid];
          if (a) {
            const { width: e3, height: t2 } = getComputedStyle(a);
            a.style.left = `${a.offsetLeft}px`, a.style.width = e3, a.style.height = t2;
          }
          t[e2.position].value.splice(n2, 1), typeof e2.onDismiss === "function" && e2.onDismiss();
        }
      }
      return positionList.forEach((e2) => {
        t[e2] = ref([]);
        const o2 = ["left", "center", "right"].includes(e2) === true ? "center" : e2.indexOf("top") > -1 ? "top" : "bottom", n2 = e2.indexOf("left") > -1 ? "start" : e2.indexOf("right") > -1 ? "end" : "center", a = ["left", "right"].includes(e2) ? `items-${e2 === "left" ? "start" : "end"} justify-center` : e2 === "center" ? "flex-center" : `items-${n2}`;
        positionClass[e2] = `q-notifications__list q-notifications__list--${o2} fixed column no-wrap ${a}`;
      }), addNotification = (o2, a) => {
        if (!o2)
          return logError2("parameter required");
        let l;
        const i = { textColor: "white" };
        if (o2.ignoreDefaults !== true && Object.assign(i, defaults), Object(o2) !== o2 && (i.type && Object.assign(i, notifTypes[i.type]), o2 = { message: o2 }), Object.assign(i, notifTypes[o2.type || i.type], o2), typeof i.icon === "function" && (i.icon = i.icon(e)), i.spinner ? (i.spinner === true && (i.spinner = QSpinner), i.spinner = markRaw(i.spinner)) : i.spinner = false, i.meta = { hasMedia: Boolean(i.spinner !== false || i.icon || i.avatar) }, i.position) {
          if (positionList.includes(i.position) === false)
            return logError2("wrong position", o2);
        } else
          i.position = "bottom";
        if (i.timeout === void 0)
          i.timeout = 5e3;
        else {
          const e2 = parseInt(i.timeout, 10);
          if (isNaN(e2) || e2 < 0)
            return logError2("wrong timeout", o2);
          i.timeout = e2;
        }
        i.timeout === 0 ? i.progress = false : i.progress === true && (i.meta.progressClass = "q-notification__progress" + (i.progressClass ? ` ${i.progressClass}` : ""), i.meta.progressStyle = { animationDuration: `${i.timeout + 1e3}ms` });
        const r = (Array.isArray(o2.actions) === true ? o2.actions : []).concat(o2.ignoreDefaults !== true && Array.isArray(defaults.actions) === true ? defaults.actions : []).concat(notifTypes[o2.type] !== void 0 && Array.isArray(notifTypes[o2.type].actions) === true ? notifTypes[o2.type].actions : []);
        if (i.closeBtn && r.push({ label: typeof i.closeBtn === "string" ? i.closeBtn : e.lang.label.close }), i.actions = r.map(({ handler: e2, noDismiss: t2, ...o3 }) => ({ flat: true, ...o3, onClick: typeof e2 === "function" ? () => {
          e2(), t2 !== true && s2();
        } : () => {
          s2();
        } })), i.multiLine === void 0 && (i.multiLine = i.actions.length > 1), Object.assign(i.meta, { class: `q-notification row items-stretch q-notification--${i.multiLine === true ? "multi-line" : "standard"}` + (i.color !== void 0 ? ` bg-${i.color}` : "") + (i.textColor !== void 0 ? ` text-${i.textColor}` : "") + (i.classes !== void 0 ? ` ${i.classes}` : ""), wrapperClass: "q-notification__wrapper col relative-position border-radius-inherit " + (i.multiLine === true ? "column no-wrap justify-center" : "row items-center"), contentClass: "q-notification__content row items-center" + (i.multiLine === true ? "" : " col"), attrs: { role: "alert", ...i.attrs } }), i.group === false ? (i.group = void 0, i.meta.group = void 0) : (i.group !== void 0 && i.group !== true || (i.group = [i.message, i.caption, i.multiline].concat(i.actions.map((e2) => `${e2.label}*${e2.icon}`)).join("|")), i.meta.group = i.group + "|" + i.position), i.actions.length === 0 ? i.actions = void 0 : i.meta.actionsClass = "q-notification__actions row items-center " + (i.multiLine === true ? "justify-end" : "col-auto") + (i.meta.hasMedia === true ? " q-notification__actions--with-media" : ""), a !== void 0) {
          clearTimeout(a.notif.meta.timer), i.meta.uid = a.notif.meta.uid;
          const e2 = t[i.position].value.indexOf(a.notif);
          t[i.position].value[e2] = i;
        } else {
          const e2 = groups[i.meta.group];
          if (e2 === void 0) {
            if (i.meta.uid = uid2++, i.meta.badge = 1, ["left", "right", "center"].indexOf(i.position) !== -1)
              t[i.position].value.splice(Math.floor(t[i.position].value.length / 2), 0, i);
            else {
              const e3 = i.position.indexOf("top") > -1 ? "unshift" : "push";
              t[i.position].value[e3](i);
            }
            i.group !== void 0 && (groups[i.meta.group] = i);
          } else {
            if (clearTimeout(e2.meta.timer), i.badgePosition !== void 0) {
              if (badgePositions.includes(i.badgePosition) === false)
                return logError2("wrong badgePosition", o2);
            } else
              i.badgePosition = `top-${i.position.indexOf("left") > -1 ? "right" : "left"}`;
            i.meta.uid = e2.meta.uid, i.meta.badge = e2.meta.badge + 1, i.meta.badgeClass = `q-notification__badge q-notification__badge--${i.badgePosition}` + (i.badgeColor !== void 0 ? ` bg-${i.badgeColor}` : "") + (i.badgeTextColor !== void 0 ? ` text-${i.badgeTextColor}` : "") + (i.badgeClass ? ` ${i.badgeClass}` : "");
            const n2 = t[i.position].value.indexOf(e2);
            t[i.position].value[n2] = groups[i.meta.group] = i;
          }
        }
        const s2 = () => {
          n(i), l = void 0;
        };
        return i.timeout > 0 && (i.meta.timer = setTimeout(() => {
          s2();
        }, i.timeout + 1e3)), i.group !== void 0 ? (e2) => {
          e2 !== void 0 ? logError2("trying to update a grouped one which is forbidden", o2) : s2();
        } : (l = { dismiss: s2, config: o2, notif: i }, a === void 0 ? (e2) => {
          if (l !== void 0)
            if (e2 === void 0)
              l.dismiss();
            else {
              const t2 = Object.assign({}, l.config, e2, { group: false, position: i.position });
              addNotification(t2, l);
            }
        } : void Object.assign(a, l));
      }, () => h("div", { class: "q-notifications" }, positionList.map((e2) => {
        return h(TransitionGroup, { key: e2, class: positionClass[e2], tag: "div", name: `q-notification--${e2}` }, () => t[e2].value.map((e3) => {
          let t2;
          const n2 = e3.meta, a = { class: "q-notification__message col" };
          if (e3.html === true)
            a.innerHTML = e3.caption ? `<div>${e3.message}</div><div class="q-notification__caption">${e3.caption}</div>` : e3.message;
          else {
            const o2 = [e3.message];
            t2 = e3.caption ? [h("div", o2), h("div", { class: "q-notification__caption" }, [e3.caption])] : o2;
          }
          const l = [];
          n2.hasMedia === true && (e3.spinner !== false ? l.push(h(e3.spinner, { class: "q-notification__spinner" })) : e3.icon ? l.push(h(QIcon, { class: "q-notification__icon", name: e3.icon, role: "img" })) : e3.avatar && l.push(h(QAvatar, { class: "q-notification__avatar" }, () => h("img", { src: e3.avatar, "aria-hidden": "true" })))), l.push(h("div", a, t2));
          const i = [h("div", { class: n2.contentClass }, l)];
          return e3.progress === true && i.push(h("div", { key: `${n2.uid}|p|${n2.badge}`, class: n2.progressClass, style: n2.progressStyle })), e3.actions !== void 0 && i.push(h("div", { class: n2.actionsClass }, e3.actions.map((e4) => h(QBtn, e4)))), n2.badge > 1 && i.push(h("div", { key: `${n2.uid}|${n2.badge}`, class: e3.meta.badgeClass, style: e3.badgeStyle }, [n2.badge])), h("div", { ref: (e4) => {
            o["" + n2.uid] = e4;
          }, key: n2.uid, class: n2.class, ...n2.attrs }, [h("div", { class: n2.wrapperClass }, i)]);
        }));
      }));
    } });
  }
  var Notify = { create(e) {
    return addNotification(e);
  }, setDefaults(e) {
    e === Object(e) && Object.assign(defaults, e);
  }, registerType(e, t) {
    t === Object(t) && (notifTypes[e] = t);
  }, install({ $q: e, parentApp: t }) {
    if (e.notify = this.create, e.notify.setDefaults = this.setDefaults, e.notify.registerType = this.registerType, e.config.notify !== void 0 && this.setDefaults(e.config.notify), this.__installed !== true) {
      const o = createGlobalNode("q-notify");
      createChildApp(getComponent(e), t).mount(o);
    }
  } };
  function encode(e) {
    return Object.prototype.toString.call(e) === "[object Date]" ? "__q_date|" + e.toUTCString() : Object.prototype.toString.call(e) === "[object RegExp]" ? "__q_expr|" + e.source : typeof e === "number" ? "__q_numb|" + e : typeof e === "boolean" ? "__q_bool|" + (e ? "1" : "0") : typeof e === "string" ? "__q_strn|" + e : typeof e === "function" ? "__q_strn|" + e.toString() : e === Object(e) ? "__q_objt|" + JSON.stringify(e) : e;
  }
  function decode(e) {
    const t = e.length;
    if (t < 9)
      return e;
    const o = e.substr(0, 8), n = e.substring(9);
    switch (o) {
      case "__q_date":
        return new Date(n);
      case "__q_expr":
        return new RegExp(n);
      case "__q_numb":
        return Number(n);
      case "__q_bool":
        return Boolean(n === "1");
      case "__q_strn":
        return "" + n;
      case "__q_objt":
        return JSON.parse(n);
      default:
        return e;
    }
  }
  function getEmptyStorage() {
    const e = () => null;
    return { has: () => false, getLength: () => 0, getItem: e, getIndex: e, getKey: e, getAll: () => {
    }, getAllKeys: () => [], set: noop, remove: noop, clear: noop, isEmpty: () => true };
  }
  function getStorage(e) {
    const t = window[e + "Storage"], o = (e2) => {
      const o2 = t.getItem(e2);
      return o2 ? decode(o2) : null;
    };
    return { has: (e2) => t.getItem(e2) !== null, getLength: () => t.length, getItem: o, getIndex: (e2) => {
      return e2 < t.length ? o(t.key(e2)) : null;
    }, getKey: (e2) => {
      return e2 < t.length ? t.key(e2) : null;
    }, getAll: () => {
      let e2;
      const n = {}, a = t.length;
      for (let l = 0; l < a; l++)
        e2 = t.key(l), n[e2] = o(e2);
      return n;
    }, getAllKeys: () => {
      const e2 = [], o2 = t.length;
      for (let n = 0; n < o2; n++)
        e2.push(t.key(n));
      return e2;
    }, set: (e2, o2) => {
      t.setItem(e2, encode(o2));
    }, remove: (e2) => {
      t.removeItem(e2);
    }, clear: () => {
      t.clear();
    }, isEmpty: () => t.length === 0 };
  }
  var storage$1 = client2.has.webStorage === false ? getEmptyStorage() : getStorage("local");
  var Plugin$1 = { install({ $q: e }) {
    e.localStorage = storage$1;
  } };
  Object.assign(Plugin$1, storage$1);
  var storage = client2.has.webStorage === false ? getEmptyStorage() : getStorage("session");
  var Plugin = { install({ $q: e }) {
    e.sessionStorage = storage;
  } };
  function useDialogPluginComponent() {
    const { emit: e, proxy: t } = getCurrentInstance(), o = ref(null);
    function n() {
      o.value.show();
    }
    function a() {
      o.value.hide();
    }
    function l(t2) {
      e("ok", t2), a();
    }
    function i() {
      e("hide");
    }
    return Object.assign(t, { show: n, hide: a }), { dialogRef: o, onDialogHide: i, onDialogOK: l, onDialogCancel: a };
  }
  function useMeta(e) {
    {
      const t = { active: true };
      if (typeof e === "function") {
        const o = computed2(e);
        t.val = o.value, watch(o, (e2) => {
          t.val = e2, t.active === true && planClientUpdate();
        });
      } else
        t.val = e;
      clientList.push(t), planClientUpdate(), onActivated(() => {
        t.active = true, planClientUpdate();
      }), onDeactivated(() => {
        t.active = false, planClientUpdate();
      }), onUnmounted(() => {
        clientList.splice(clientList.indexOf(t), 1), planClientUpdate();
      });
    }
  }
  function useQuasar() {
    return inject2(quasarKey);
  }
  function fallback(e) {
    const t = document.createElement("textarea");
    t.value = e, t.contentEditable = true, t.style.position = "fixed", document.body.appendChild(t), t.focus(), t.select();
    const o = document.execCommand("copy");
    return t.remove(), o;
  }
  function copyToClipboard(e) {
    return navigator.clipboard !== void 0 ? navigator.clipboard.writeText(e) : new Promise((t, o) => {
      const n = fallback(e);
      n ? t(true) : o(n);
    });
  }
  Object.assign(Plugin, storage), useDialogPluginComponent.emits = ["ok", "hide"];
  var createMetaMixin = (e) => {
    const t = { activated() {
      this.__qMeta.active = true, planClientUpdate();
    }, deactivated() {
      this.__qMeta.active = false, planClientUpdate();
    }, unmounted() {
      clientList.splice(clientList.indexOf(this.__qMeta), 1), planClientUpdate(), this.__qMeta = void 0;
    } };
    return typeof e === "function" ? Object.assign(t, { computed: { __qMetaOptions() {
      return e.call(this) || {};
    } }, watch: { __qMetaOptions(e2) {
      this.__qMeta.val = e2, this.__qMeta.active === true && planClientUpdate();
    } }, created() {
      this.__qMeta = { active: true, val: this.__qMetaOptions }, clientList.push(this.__qMeta), planClientUpdate();
    } }) : t.created = function() {
      this.__qMeta = { active: true, val: e }, clientList.push(this.__qMeta), planClientUpdate();
    }, t;
  };
  function clean(e) {
    setTimeout(() => {
      window.URL.revokeObjectURL(e.href);
    }, 1e4), e.remove();
  }
  function exportFile(e, t, o = {}) {
    const { mimeType: n, byteOrderMark: a, encoding: l } = typeof o === "string" ? { mimeType: o } : o, i = l !== void 0 ? new TextEncoder(l).encode([t]) : t, r = a !== void 0 ? [a, i] : [i], s2 = new Blob(r, { type: n || "application/octet-stream" }), u = document.createElement("a");
    u.href = window.URL.createObjectURL(s2), u.setAttribute("download", e), typeof u.download === "undefined" && u.setAttribute("target", "_blank"), u.classList.add("hidden"), u.style.position = "fixed", document.body.appendChild(u);
    try {
      return u.click(), clean(u), true;
    } catch (e2) {
      return clean(u), e2;
    }
  }
  function parseFeatures(e) {
    const t = Object.assign({ noopener: true }, e), o = [];
    return Object.keys(t).forEach((e2) => {
      t[e2] === true && o.push(e2);
    }), o.join(",");
  }
  function openWindow(e, t, o) {
    let n = window.open;
    if (Platform.is.cordova === true) {
      if (cordova !== void 0 && cordova.InAppBrowser !== void 0 && cordova.InAppBrowser.open !== void 0)
        n = cordova.InAppBrowser.open;
      else if (navigator !== void 0 && navigator.app !== void 0)
        return navigator.app.loadUrl(e, { openExternal: true });
    }
    const a = n(e, "_blank", parseFeatures(o));
    if (a)
      return Platform.is.desktop && a.focus(), a;
    t && t();
  }
  var openUrl = (e, t, o) => {
    if (Platform.is.ios !== true || window.SafariViewController === void 0)
      return openWindow(e, t, o);
    window.SafariViewController.isAvailable((n) => {
      n ? window.SafariViewController.show({ url: e }, noop, t) : openWindow(e, t, o);
    });
  };
  var Quasar2 = { version: "2.0.0-rc.3", install(e, t, o) {
    installQuasar(e, { components, directives, ...t });
  }, lang: Plugin$7, iconSet: Plugin$6 };

  // boot/quasar.js
  window.Quasar = quasar_esm_prod_exports;
  window.notify = (...a) => Notify.create(...a);

  // yehat/core.js
  var import_pako = __toModule(require_pako());

  // libs/slugid.js
  var import_pako = __toModule(require_pako());
  var Base64 = { _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", encode: function(e) {
    var t = "";
    var n, r, i, s2, o, u, a;
    var f = 0;
    e = Base64._utf8_encode(e);
    while (f < e.length) {
      n = e.charCodeAt(f++);
      r = e.charCodeAt(f++);
      i = e.charCodeAt(f++);
      s2 = n >> 2;
      o = (n & 3) << 4 | r >> 4;
      u = (r & 15) << 2 | i >> 6;
      a = i & 63;
      if (isNaN(r)) {
        u = a = 64;
      } else if (isNaN(i)) {
        a = 64;
      }
      t = t + this._keyStr.charAt(s2) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a);
    }
    return t;
  }, decode: function(e) {
    var t = "";
    var n, r, i;
    var s2, o, u, a;
    var f = 0;
    e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (f < e.length) {
      s2 = this._keyStr.indexOf(e.charAt(f++));
      o = this._keyStr.indexOf(e.charAt(f++));
      u = this._keyStr.indexOf(e.charAt(f++));
      a = this._keyStr.indexOf(e.charAt(f++));
      n = s2 << 2 | o >> 4;
      r = (o & 15) << 4 | u >> 2;
      i = (u & 3) << 6 | a;
      t = t + String.fromCharCode(n);
      if (u != 64) {
        t = t + String.fromCharCode(r);
      }
      if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }
    t = Base64._utf8_decode(t);
    return t;
  }, _utf8_encode: function(e) {
    e = e.replace(/\r\n/g, "\n");
    var t = "";
    for (var n = 0; n < e.length; n++) {
      var r = e.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);
        t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);
        t += String.fromCharCode(r >> 6 & 63 | 128);
        t += String.fromCharCode(r & 63 | 128);
      }
    }
    return t;
  }, _utf8_decode: function(e) {
    var t = "";
    var n = 0;
    var r = c1 = c2 = 0;
    while (n < e.length) {
      r = e.charCodeAt(n);
      if (r < 128) {
        t += String.fromCharCode(r);
        n++;
      } else if (r > 191 && r < 224) {
        c2 = e.charCodeAt(n + 1);
        t += String.fromCharCode((r & 31) << 6 | c2 & 63);
        n += 2;
      } else {
        c2 = e.charCodeAt(n + 1);
        c3 = e.charCodeAt(n + 2);
        t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        n += 3;
      }
    }
    return t;
  } };
  var _byteToHex = [];
  var _hexToByte = {};
  for (i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 256).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }
  var i;
  function parse(s2, buf2, offset2) {
    var i = buf2 && offset2 || 0;
    var ii = 0;
    buf2 = buf2 || [];
    s2.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) {
        buf2[i + ii++] = _hexToByte[oct];
      }
    });
    while (ii < 16) {
      buf2[i + ii++] = 0;
    }
    return buf2;
  }
  var nice = function() {
    var bytes = parse(core.uuid());
    bytes[0] = bytes[0] & 127;
    var base64 = Base64.encode(String.fromCharCode.apply(null, bytes));
    var slug = base64.replace(/\+/g, "-").replace(/\//g, "_").substring(0, 22);
    return slug;
  };

  // yehat/core.js
  var ecs3 = window.ecs;
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var core2 = {
    uuid: () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      let r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    }),
    slug: () => nice(),
    today: () => new Date().toISOString().split("T")[0],
    time: () => Math.floor(+new Date() / 1e3),
    ms: (delay) => new Promise((resolve2) => setTimeout(resolve2, delay)),
    log: (...rest) => console.log(...rest.reduce((a, v) => typeof v == "string" ? [...a, ...core2.colorParse(v)] : [...a, v], [])),
    _log: function() {
      var Log = Error;
      Log.prototype.write = function(args) {
        var suffix = {
          "@": this.lineNumber ? this.fileName + ":" + this.lineNumber + ":1" : extractLineNumberFromStack(this.stack),
          "stack": this.stack.split("\n")
        };
        args = args.concat([suffix]);
        if (console && console.log) {
          if (console.log.apply) {
            console.log.apply(console, args);
          } else {
            console.log(args);
          }
        }
      };
      var extractLineNumberFromStack = function(stack2) {
        if (!stack2)
          return "?";
        var line = stack2.split("\n")[2];
        line = line.indexOf(" (") >= 0 ? line.split(" (")[1].substring(0, line.length - 1) : line.split("at ")[1];
        return line;
      };
      return function(params) {
        Log().write(Array.prototype.slice.call(arguments, 0));
      };
    }(),
    colorParse: (s2) => {
      const add2 = [];
      return [s2.replace(/\^c(.+?)\^/g, (match, cap, index, s3) => {
        add2.push(`color: #${cap}`);
        return "%c";
      }), ...add2];
    },
    epochStart: 18761,
    to2Digits: (v) => {
      let a = "" + v;
      if (a.length < 2)
        a = "0" + a;
      return a;
    },
    to3Digits: (v) => {
      let a = "" + v;
      while (a.length < 3)
        a = "0" + a;
      return a;
    },
    dtToVTime: (dt, short = false) => {
      const ms = dt % 1e3;
      const a1 = Math.floor(dt / 1e3);
      const s2 = a1 % 60;
      const a2 = Math.floor(a1 / 60);
      const m = a2 % 60;
      const a3 = Math.floor(a2 / 60);
      const h3 = a3 % 24;
      const a4 = Math.floor(a3 / 24);
      const d = a4 / 10;
      if (short)
        return `${core2.to2Digits(h3)}:${core2.to2Digits(m)}:${core2.to2Digits(s2)}.${core2.to3Digits(ms)}`;
      return `Day ${a4 - core2.epochStart} Time ${core2.to2Digits(h3)}:${core2.to2Digits(m)}:${core2.to2Digits(s2)}.${core2.to3Digits(ms)}`;
    },
    lerp: (v0, v1, t) => v0 * (1 - t) + v1 * t,
    ease: {
      inQuad: function(pos) {
        return Math.pow(pos, 2);
      },
      outQuad: function(pos) {
        return -(Math.pow(pos - 1, 2) - 1);
      },
      inOutQuad: function(pos) {
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(pos, 2);
        return -0.5 * ((pos -= 2) * pos - 2);
      },
      inCubic: function(pos) {
        return Math.pow(pos, 3);
      },
      outCubic: function(pos) {
        return Math.pow(pos - 1, 3) + 1;
      },
      inOutCubic: function(pos) {
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(pos, 3);
        return 0.5 * (Math.pow(pos - 2, 3) + 2);
      },
      inQuart: function(pos) {
        return Math.pow(pos, 4);
      },
      outQuart: function(pos) {
        return -(Math.pow(pos - 1, 4) - 1);
      },
      inOutQuart: function(pos) {
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(pos, 4);
        return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
      },
      inQuint: function(pos) {
        return Math.pow(pos, 5);
      },
      outQuint: function(pos) {
        return Math.pow(pos - 1, 5) + 1;
      },
      inOutQuint: function(pos) {
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(pos, 5);
        return 0.5 * (Math.pow(pos - 2, 5) + 2);
      },
      inSine: function(pos) {
        return -Math.cos(pos * (Math.PI / 2)) + 1;
      },
      outSine: function(pos) {
        return Math.sin(pos * (Math.PI / 2));
      },
      inOutSine: function(pos) {
        return -0.5 * (Math.cos(Math.PI * pos) - 1);
      },
      inExpo: function(pos) {
        return pos === 0 ? 0 : Math.pow(2, 10 * (pos - 1));
      },
      outExpo: function(pos) {
        return pos === 1 ? 1 : -Math.pow(2, -10 * pos) + 1;
      },
      inOutExpo: function(pos) {
        if (pos === 0)
          return 0;
        if (pos === 1)
          return 1;
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(2, 10 * (pos - 1));
        return 0.5 * (-Math.pow(2, -10 * --pos) + 2);
      },
      inCirc: function(pos) {
        return -(Math.sqrt(1 - pos * pos) - 1);
      },
      outCirc: function(pos) {
        return Math.sqrt(1 - Math.pow(pos - 1, 2));
      },
      inOutCirc: function(pos) {
        if ((pos /= 0.5) < 1)
          return -0.5 * (Math.sqrt(1 - pos * pos) - 1);
        return 0.5 * (Math.sqrt(1 - (pos -= 2) * pos) + 1);
      },
      outBounce: function(pos) {
        if (pos < 1 / 2.75) {
          return 7.5625 * pos * pos;
        } else if (pos < 2 / 2.75) {
          return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
        } else if (pos < 2.5 / 2.75) {
          return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
        } else {
          return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
        }
      },
      inBack: function(pos) {
        var s2 = 1.70158;
        return pos * pos * ((s2 + 1) * pos - s2);
      },
      outBack: function(pos) {
        var s2 = 1.70158;
        return (pos = pos - 1) * pos * ((s2 + 1) * pos + s2) + 1;
      },
      inOutBack: function(pos) {
        var s2 = 1.70158;
        if ((pos /= 0.5) < 1)
          return 0.5 * (pos * pos * (((s2 *= 1.525) + 1) * pos - s2));
        return 0.5 * ((pos -= 2) * pos * (((s2 *= 1.525) + 1) * pos + s2) + 2);
      },
      elastic: function(pos) {
        return -1 * Math.pow(4, -8 * pos) * Math.sin((pos * 6 - 1) * (2 * Math.PI) / 2) + 1;
      },
      swingFromTo: function(pos) {
        var s2 = 1.70158;
        return (pos /= 0.5) < 1 ? 0.5 * (pos * pos * (((s2 *= 1.525) + 1) * pos - s2)) : 0.5 * ((pos -= 2) * pos * (((s2 *= 1.525) + 1) * pos + s2) + 2);
      },
      swingFrom: function(pos) {
        var s2 = 1.70158;
        return pos * pos * ((s2 + 1) * pos - s2);
      },
      swingTo: function(pos) {
        var s2 = 1.70158;
        return (pos -= 1) * pos * ((s2 + 1) * pos + s2) + 1;
      },
      bounce: function(pos) {
        if (pos < 1 / 2.75) {
          return 7.5625 * pos * pos;
        } else if (pos < 2 / 2.75) {
          return 7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75;
        } else if (pos < 2.5 / 2.75) {
          return 7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375;
        } else {
          return 7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375;
        }
      },
      bouncePast: function(pos) {
        if (pos < 1 / 2.75) {
          return 7.5625 * pos * pos;
        } else if (pos < 2 / 2.75) {
          return 2 - (7.5625 * (pos -= 1.5 / 2.75) * pos + 0.75);
        } else if (pos < 2.5 / 2.75) {
          return 2 - (7.5625 * (pos -= 2.25 / 2.75) * pos + 0.9375);
        } else {
          return 2 - (7.5625 * (pos -= 2.625 / 2.75) * pos + 0.984375);
        }
      },
      fromTo: function(pos) {
        if ((pos /= 0.5) < 1)
          return 0.5 * Math.pow(pos, 4);
        return -0.5 * ((pos -= 2) * Math.pow(pos, 3) - 2);
      },
      from: function(pos) {
        return Math.pow(pos, 4);
      },
      to: function(pos) {
        return Math.pow(pos, 0.25);
      }
    },
    vectM: (a, b) => {
      return a.map((v, i) => v * b[i]);
    },
    vectA: (...vv) => {
      return vv.slice(1).reduce((a, v) => a.map((x, i) => x + v[i]), vv[0]);
    },
    and: (predicates) => (v) => {
      for (let predicate of predicates) {
        if (!predicate(v))
          return false;
      }
      return true;
    },
    validateEmail: (email) => {
      const re = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
      return re.test(String(email).toLowerCase());
    },
    escapeHTML: (unsafe) => unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;"),
    parseHTML: (v) => new DOMParser().parseFromString(v, "text/html"),
    replace: (v) => v.replace(/^\s+|\s+$/g, ""),
    textNodesToStrings: (parentNode) => {
      var strings = [], nodeList, length, i = 0;
      if (!parentNode instanceof Node) {
        throw new TypeError("The parentNode parameter expects an instance of a Node.");
      }
      if (!parentNode.hasChildNodes()) {
        return [];
      }
      nodeList = parentNode.childNodes;
      length = nodeList.length;
      do {
        if (nodeList[i].nodeType === Node.TEXT_NODE) {
          strings.push(nodeList[i].nodeValue);
        }
        i++;
      } while (i < length);
      if (strings.length > 0) {
        return strings;
      }
      return [];
    },
    ecs: ecs3,
    style: {
      transform: ([x, y]) => ({ transform: `translateX(${x}px) translateY(${y}px)` }),
      size: ([w, h3]) => ({ width: `${w}px`, height: `${h3}px` })
    },
    Base64: {
      encode: function(input) {
        var output2 = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = core2.Base64._utf8_encode(input);
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          enc1 = chr1 >> 2;
          enc2 = (chr1 & 3) << 4 | chr2 >> 4;
          enc3 = (chr2 & 15) << 2 | chr3 >> 6;
          enc4 = chr3 & 63;
          if (isNaN(chr2)) {
            enc3 = enc4 = 64;
          } else if (isNaN(chr3)) {
            enc4 = 64;
          }
          output2 = output2 + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);
        }
        return output2;
      },
      decode: function(input) {
        var output2 = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
          enc1 = _keyStr.indexOf(input.charAt(i++));
          enc2 = _keyStr.indexOf(input.charAt(i++));
          enc3 = _keyStr.indexOf(input.charAt(i++));
          enc4 = _keyStr.indexOf(input.charAt(i++));
          chr1 = enc1 << 2 | enc2 >> 4;
          chr2 = (enc2 & 15) << 4 | enc3 >> 2;
          chr3 = (enc3 & 3) << 6 | enc4;
          output2 = output2 + String.fromCharCode(chr1);
          if (enc3 != 64) {
            output2 = output2 + String.fromCharCode(chr2);
          }
          if (enc4 != 64) {
            output2 = output2 + String.fromCharCode(chr3);
          }
        }
        output2 = core2.Base64._utf8_decode(output2);
        return output2;
      },
      _utf8_encode: function(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
          var c = string.charCodeAt(n);
          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if (c > 127 && c < 2048) {
            utftext += String.fromCharCode(c >> 6 | 192);
            utftext += String.fromCharCode(c & 63 | 128);
          } else {
            utftext += String.fromCharCode(c >> 12 | 224);
            utftext += String.fromCharCode(c >> 6 & 63 | 128);
            utftext += String.fromCharCode(c & 63 | 128);
          }
        }
        return utftext;
      },
      _utf8_decode: function(utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
        while (i < utftext.length) {
          c = utftext.charCodeAt(i);
          if (c < 128) {
            string += String.fromCharCode(c);
            i++;
          } else if (c > 191 && c < 224) {
            c2 = utftext.charCodeAt(i + 1);
            string += String.fromCharCode((c & 31) << 6 | c2 & 63);
            i += 2;
          } else {
            c2 = utftext.charCodeAt(i + 1);
            c3 = utftext.charCodeAt(i + 2);
            string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
            i += 3;
          }
        }
        return string;
      }
    },
    Notify: Quasar.Notify
  };
  window.core = core2;

  // yehat/pure.js
  var import_pako = __toModule(require_pako());
  window.pure = {
    EPGET: (entity, ep) => {
      const traverse2 = ep.split(".");
      let cursor = entity;
      while (traverse2.length) {
        let token2 = traverse2.splice(0, 1)[0];
        if (!cursor[token2])
          return void 0;
        cursor = cursor[token2];
      }
      return cursor;
    },
    itemName: (item2) => {
      const typeToNameEP = {
        Cargo0: "cargo0.name",
        Code0: "code0.name",
        Code1: "code1.name",
        GTDStatus0: "gtdStatus0.name",
        Page0: "page0.name",
        Gal0: "item.name",
        SHHNPage0: "page0.name",
        Project: "project0.name",
        Cat0: "cat0.name",
        Mission0: "mission0.short",
        MemberCard0: "memberCard0.name"
      };
      if (!item2) {
        return "NaE";
      } else if (typeToNameEP[item2.type]) {
        return pure.EPGET(item2, typeToNameEP[item2.type]) || "";
      } else if (item2.item) {
        return item2.item.name;
      } else {
        return item2.id;
      }
    },
    itemExtra: (item2) => {
      const typeToExtra = {
        Code1: (item3) => `-[HSS0 ${pure.humanStorageSize(item3.code1.code.length)}]-[Stack ${item3.code1seq.stack.length}]`
      };
      return typeToExtra[item2.type] ? typeToExtra[item2.type](item2) : "";
    },
    itemToken: (item2) => {
      if (!item2)
        return `[NaE]`;
      const name = pure.itemName(item2);
      if (item2.type === "Grid0") {
        const sizeKludge = `-[grid0.size ${item2.grid0.size[0]} ${item2.grid0.size[1]}]`;
        return name ? `[${item2.type} ${name}]${sizeKludge}` : `[${item2.type}]${sizeKludge}`;
      }
      return name ? `[${item2.type || "Unknown"} ${name}]` : `[${item2.type || "Unknown"}]`;
    },
    itemTokenExt0: (item2) => {
      return pure.itemToken(item2) + pure.itemExtra(item2);
    },
    humanStorageSize: (e) => {
      const be = ["B", "KB", "MB", "GB", "TB", "PB"];
      let t = 0;
      while (parseInt(e, 10) >= 1024 && t < be.length - 1)
        e /= 1024, ++t;
      return `${e.toFixed(1)}${be[t]}`;
    },
    jsTypeToString: (v) => {
      if (Array.isArray(v)) {
        if (!v.length)
          return `[Empty Array]`;
        return `[Array ${v.map((x) => jsTypeToString(x)).join(" ")}]-[Size ${v.length}]`;
      } else if (typeof v === "object") {
        if (!Object.keys(v).length) {
          if (v.constructor && v.constructor.name) {
            let getAllPropertyNames2 = function(obj) {
              const proto = Object.getPrototypeOf(obj);
              const inherited = proto ? getAllPropertyNames2(proto) : [];
              return [...new Set(Object.getOwnPropertyNames(obj).concat(inherited))];
            };
            var getAllPropertyNames = getAllPropertyNames2;
            const methods = getAllPropertyNames2(v).filter((m) => typeof v[m] === "function");
            return `[Empty Object::${v.constructor.name}] Methods: ${methods.join(" ")}`;
          }
          return `[Empty Plain Object]`;
        }
        return `[${v.type || "Object"} ${Object.keys(v).join(" ")}]`;
      } else if (!v) {
        return typeof v === "undefined" ? "undefined" : v === null ? "null" : typeof v === "string" ? '""' : typeof v === "boolean" ? `${v}` : "" + v;
      } else {
        return "" + v;
      }
    },
    indexToCR: (code, index) => {
      const lineBreaks = [...code.matchAll(/\n/g)].map((v) => v.index);
      const cr = [index, 0];
      for (let lineEnds of lineBreaks) {
        if (index > lineEnds) {
          cr[0] = index - lineEnds - 1;
          cr[1]++;
        } else {
          break;
        }
      }
      return cr;
    },
    safeStringify: (obj, indent = 2) => {
      let cache = [];
      const retVal = JSON.stringify(obj, (key2, value2) => typeof value2 === "object" && value2 !== null ? cache.includes(value2) ? void 0 : cache.push(value2) && value2 : value2, indent);
      cache = null;
      return retVal;
    },
    arrayCount: (a) => computed(() => a.length),
    clamp: (min, max) => (v) => Math.min(Math.max(v, min), max),
    bytesArrToBase64: (arr) => {
      const abc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const bin = (n) => n.toString(2).padStart(8, 0);
      const l = arr.length;
      let result = "";
      for (let i = 0; i <= (l - 1) / 3; i++) {
        let c12 = i * 3 + 1 >= l;
        let c22 = i * 3 + 2 >= l;
        let chunk = bin(arr[3 * i]) + bin(c12 ? 0 : arr[3 * i + 1]) + bin(c22 ? 0 : arr[3 * i + 2]);
        let r = chunk.match(/.{1,6}/g).map((x, j) => j == 3 && c22 ? "=" : j == 2 && c12 ? "=" : abc[+("0b" + x)]);
        result += r.join("");
      }
      return result;
    },
    base64ToBytesArr: (str) => {
      const abc = [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"];
      let result = [];
      for (let i = 0; i < str.length / 4; i++) {
        let chunk = [...str.slice(4 * i, 4 * i + 4)];
        let bin = chunk.map((x) => abc.indexOf(x).toString(2).padStart(6, 0)).join("");
        let bytes = bin.match(/.{1,8}/g).map((x) => +("0b" + x));
        result.push(...bytes.slice(0, 3 - (str[4 * i + 2] == "=") - (str[4 * i + 3] == "=")));
      }
      return result;
    }
  };

  // yehat/sources/00-source-0.js
  var import_pako = __toModule(require_pako());
  var source_0_default = {
    compo: {
      actions: {
        hull: {},
        details: "Roster of handlers, free for all. An Action has to return true to automatically prevent default handling for keyboard events."
      },
      attention0: {
        hull: {
          present: false,
          prev: null,
          pass: (item2) => (entity) => {
            ecs.find((v) => v.attention0 && v.id !== entity.id && item2.attention0.present).map((item3) => item3.attention0.present = false);
            if (!entity.attention0) {
              entity.attention0 = ecs.compo.attention0().attention0;
              ecs.bindMethods({ entity, only: ["attention0"] });
            }
            entity.attention0.present = true;
            entity.attention0.prev = item2.id;
            core.log(`${pure.itemToken(entity)} <[GAIN] attention0.present [LOST]> ${pure.itemToken(item2)}`);
          },
          gain: (item2) => () => {
            if (item2.attention0.present)
              return;
            let lost;
            ecs.find((v) => v.attention0 && v.id !== item2.id && v.attention0.present).map((v) => {
              v.attention0.present = false;
              lost = v;
            });
            item2.attention0.present = true;
            item2.attention0.prev = lost ? lost.id : null;
            if (lost) {
              core.log(`${pure.itemToken(item2)} <[GAIN] attention0.present [LOST]> ${pure.itemToken(lost)}`);
            } else {
              core.log(`${pure.itemToken(item2)} <[GAIN] attention0.present`);
            }
          },
          back: (item2) => () => {
            if (item2.attention0.prev && ecs.root[item2.attention0.prev]) {
              item2.attention0.present = false;
              if (!ecs.root[item2.attention0.prev].attention0) {
                core.log(`[!] <[PREV] attention0.present [THIS]> ${pure.itemToken(item2)}`);
                return false;
              } else {
                ecs.root[item2.attention0.prev].attention0.present = true;
                core.log(`${pure.itemToken(ecs.root[item2.attention0.prev])} <[PREV] attention0.present [THIS]> ${pure.itemToken(item2)}`);
                return true;
              }
            }
            return false;
          }
        },
        details: "Experimental Attention State MK 0"
      },
      cargo2: {
        hull: {
          rawSize: null,
          sha256: null,
          dtDeployed: null,
          by: null,
          on: null
        },
        details: "Cargo MK 2 State"
      },
      cargo2payload: {
        hull: {
          json: null
        },
        details: "Cargo MK 2 Payload"
      },
      cargo2stat: {
        hull: {
          packedRoot: 0,
          packedContained: 0,
          packedTotal: 0
        },
        details: "Cargo MK2 Stat"
      },
      cargo3: {
        hull: {
          rawSize: null,
          sha256: null,
          dtDeployed: null,
          by: null,
          on: null
        },
        details: "Cargo MK 3 State"
      },
      cargo3payload: {
        hull: {
          source: `{
  compo: {},
  types: {},
  roster: {},
  images: {},
  meta: {
    name: "Source1", type: "Yehat Source Container",
    version: "1.0", by: "[MemberCard KotoTheBest]", on: "[DryWare KotoSurf] [Yehat Sunlight]",
    dtCreated: 0, dtModified: 0, writes: 0, manual: false
  }
}`,
          addCompo: (item) => (compodefs) => {
            const parsed = esprima.parseScript(`(${item.cargo3payload.source})`, { range: true });
            core.log(`${pure.itemToken(item)} Parsed comments`, parsed);
            const compoProperty = parsed.body[0].expression.properties.find((v) => v.key.name === "compo");
            if (!compoProperty)
              return false;
            let patchIndex = compoProperty.range[1] - 2;
            let patchTail = patchIndex;
            while (/\s+/g.test(item.cargo3payload.source[patchIndex - 1])) {
              patchIndex--;
              if (patchIndex <= 0)
                break;
            }
            const comma = compoProperty.value.properties.length ? "," : "";
            const output = `${item.cargo3payload.source.slice(0, patchIndex)}${comma}
    ${compodefs.join(",\n")}
  ${item.cargo3payload.source.slice(patchTail)}`;
            core.log(`${pure.itemToken(item)} Output:
${output}
${output.length} bytes`);
            const checked = eval(`(${output})`);
            item.cargo3payload.source = output;
            item.cargo3stat.compo = Object.keys(checked.compo).length;
            item.cargo3stat.types = Object.keys(checked.types).length;
            item.cargo3stat.roster = Object.keys(checked.roster).length;
            item.cargo3stat.images = Object.keys(checked.images).length;
            item.cargo3.rawSize = output.length;
          }
        },
        details: "Cargo MK 3 Payload"
      },
      cargo3stat: {
        hull: {
          compo: 0,
          types: 0,
          entities: 0,
          images: 0
        },
        details: "Cargo MK3 Stat"
      },
      cat0: {
        hull: {
          name: ""
        },
        details: "Category settings"
      },
      cargo0: {
        hull: {
          name: ""
        },
        details: "A Directory of Entities"
      },
      code1: {
        hull: {
          name: "",
          extension: "",
          code: "",
          cursor: 0,
          indexToCR: (item2) => (index) => {
            const lineBreaks = [...item2.code1.code.matchAll(/\n/g)].map((v) => v.index);
            const cr = [index, 0];
            for (let lineEnds of lineBreaks) {
              if (index > lineEnds) {
                cr[0] = index - lineEnds - 1;
                cr[1]++;
              } else {
                break;
              }
            }
            return cr;
          },
          currentCR: (item2) => computed(() => {
            return item2.code1.indexToCR(item2.code1.cursor);
          }),
          run: (item2) => (args = {}) => {
            const fn = new Function("core", "item", ...Object.keys(args), item2.code1.code);
            console.log("fn", fn);
            return fn(core, item2, ...Object.values(args));
          },
          evaluateDirty: (item2) => () => {
            const artisan = JSON.parse(localStorage[`${ecs.prefix}-${item2.id}`] || "{}");
            const artisanCode = artisan.code1 ? artisan.code1.code : "";
            if (artisanCode === item2.code1.code) {
              item2.code1tr.isDirty = false;
              return false;
            } else {
              item2.code1tr.isDirty = true;
              return true;
            }
          }
        },
        details: "Stackable Yehat Code Block MK 1 - Main Compo"
      },
      code1seq: {
        hull: {
          prev: null,
          next: null,
          isStart: true,
          isEnd: true,
          stack: []
        },
        details: `Code1 Chains between its instances, forming a two-linked list of them. Each member is aware of: 
  who are his adjacent predcestor "prev" and successor "next", plus is this node a start of the sequence, end, or
  not. stack[] is the stack of contained objects in order. Object are taken by located.rel connection. Contained
  objects might be present or not in the stack[], that's how Code1 is able to effectively comment out and reorder
  its content.`
      },
      code1tr: {
        hull: {
          isDirty: false
        },
        details: "Code1 Transient Data"
      },
      conn: {
        hull: {},
        details: "Non-reactive connections."
      },
      connections: {
        hull: {
          initConnections: (item2) => {
            item2.c = computed(() => {
              core.log("[Connections]Recomputing connections", `${item2.meta && item2.meta.name || "?"}:${item2.type}`, Object.keys(item2.connections).length);
              const a = {};
              for (let key2 in item2.connections) {
                a[key2] = ecs.root[item2.connections[key2]];
              }
              return a;
            });
            return void 0;
          }
        },
        details: `Keys are "handles", or "slot names", values are entity IDs. Mentioned Entities will be reactively
      mapped to "c" property of [this].`
      },
      eraser0: {
        hull: {
          items: [],
          recursive: true,
          workshop: false,
          artisan: true,
          allItems: (item2) => computed(() => {
            let output2 = new Set(item2.eraser0.items);
            if (!item2.eraser0.recursive)
              return [...output2].map((v) => ecs.root[v]);
            let toRecurr = new Set(output2);
            while (toRecurr.size) {
              let id2 = toRecurr.values().next().value;
              toRecurr.delete(id2);
              let moreItems = ecs.find((v) => v.located && v.located.rel === id2 && !output2.has(v.id)).map((v) => v.id);
              output2 = new Set([...output2, ...moreItems]);
              toRecurr = new Set([...toRecurr, ...moreItems]);
            }
            return [...output2].map((v) => ecs.root[v]);
          }),
          conduct: (item2) => () => {
            if (item2.eraser0.artisan) {
              item2.eraser0.allItems.map((v) => {
                ecs.erase({ entityID: v.id });
                delete ecs.root[v.id];
              });
              return true;
            } else if (!item2.eraser0.artisan && !item2.eraser0.workshop) {
              item2.eraser0.allItems.map((v) => delete ecs.root[v.id]);
              return true;
            }
            return false;
          }
        },
        details: "Eraser MK 0 Configuration"
      },
      diaCreateImage4: {
        hull: {
          incoming: null,
          target: null,
          copyBase64: (item2) => () => {
            let ok = true;
            Quasar.copyToClipboard(item2.diaCreateImage4.incoming).then(() => {
              Quasar.Notify.create(`${Quasar.format.humanStorageSize(item2.diaCreateImage4.incoming.length)} coppied.`);
            }).catch((e) => {
              Quasar.Notify.create("Clipboard copy error.");
              ok = false;
            });
            return ok;
          }
        },
        details: "Configuration for to Create Image 4 somewhere."
      },
      dialog0: {
        hull: {
          show: false
        },
        details: "Something that might be shown or hidden"
      },
      diaCreate0: {
        hull: {},
        details: "Simple (No INPUT) items creating Dialog for ZIITable5"
      },
      gal0: {
        hull: {},
        details: "Gallery Configuration"
      },
      grid0user: {
        hull: {
          gridID: null,
          defaultRecord: { size: [10, 15], pos: [0, 0] },
          isMoving: false
        },
        details: "Placement setup on Grid0"
      },
      gtdStatus0: {
        hull: {
          name: "",
          order: 5
        },
        details: "Mission0 Status Enum Member"
      },
      fav0: {
        hull: {
          fav: false
        },
        details: "A Local Fav Mark"
      },
      identityManager0: {
        hull: {
          roster: {},
          useMemberCard: (item2) => (projectID) => (memberCardID) => {
            item2.identityManager0.roster[projectID] = {
              memberCardID
            };
            return true;
          },
          activeID: (item2) => computed(() => {
            const projects = ecs.find((v) => v.type === "Project");
            return projects.reduce((a, v) => {
              return { ...a, [v.id]: item2.identityManager0.roster[v.id] ? item2.identityManager0.roster[v.id].memberCardID : null };
            }, {});
          })
        },
        details: "roster key: project value: { memberCardID }"
      },
      image4: {
        hull: {
          originalFile: "",
          base64: "",
          lastModified: null,
          mimeType: null,
          fileSize: null,
          image: null,
          size: [0, 0]
        },
        details: "A WebApp Image"
      },
      inventory0: {
        hull: {
          cursor: null,
          height: null,
          inSlot: { type: "none", id: null },
          insert: (item2) => (v) => {
            item2.inventory0.inSlot = { type: "item", id: v.id };
            return true;
          }
        },
        details: "Inventory config."
      },
      item: {
        hull: {
          baseComponent: "IAbstract",
          inventoryComponent: null,
          cargoStyle: null,
          style: null,
          show: false,
          opened: false,
          baseIcon: null,
          baseImage: null,
          onClick: null,
          name: ""
        },
        details: `Makes entity renderable on ZII Table3.`
      },
      keyboardUser0: {
        hull: {
          bindings: [],
          conduct: (item2) => (handlerKey) => (e) => {
            const disp = [];
            let c = 0;
            [...item2.keyboardUser0.bindings.filter((record) => record[handlerKey] && record.keyExpression(e))].sort((a, b) => (b.priority || 5) - (a.priority || 5)).map((record) => {
              disp.push(`${pure.itemToken(item2)} ${record[handlerKey]}`);
              if (ecs.dispatchBang1(item2, record[handlerKey], e) === true) {
                e.preventDefault();
                e.stopPropagation();
              }
              c++;
            });
            if (c === 0) {
              core.log(`${pure.itemToken(item2)}.keyboardUser0 No events dispatched> Key: ${e.keyCode}`, e);
            } else {
              core.log(`${pure.itemToken(item2)}.keyboardUser0 ${c} events dispatched: ${disp.join(" ")}`);
            }
          }
        },
        details: `bindings: [ { keyExpression, maybe handleKeyDown, maybe handleKeyUp, priority: 5 } ... ] 
passthrough [ { keyExpression }] -- for those keys default browser behavior won't be prevented`
      },
      lang: {
        hull: {
          en: {},
          ru: {},
          enchantI: (item2) => {
            item2.i = computed(() => item2.lang[core.yehat.lang]);
            return () => {
            };
          }
        },
        details: "Multilingual Content Container"
      },
      ledger0: {
        hull: {},
        details: "Ledger0 Configuration"
      },
      located: {
        hull: {
          rel: null,
          pos: [0, 0, 0],
          size: [0, 0]
        },
        details: `Entity's parent container ID and Vector3 position inside of it.`
      },
      meta: {
        hull: {
          type: "Unknown",
          name: "No name",
          tags: []
        },
        details: 'General meta-information about an Entity, such its "type" (archetype, classification of the Entity Class amongst other Entity Classes), and its "name" (Entity Class name, arbitrary).'
      },
      messageBase0: {
        hull: {
          newMessages: {},
          items: (item2) => ecs.by((v) => v.type === "Msg0" && v.located.rel === item2.id),
          count: (item2) => pure.arrayCount(item2.messageBase0.items)
        },
        details: "Primarity a contained for Messages, however maybe gonna be a facility in future."
      },
      mission0: {
        hull: {
          short: "",
          details: "",
          status: "onhold",
          commander: null,
          assigned: [],
          working: [],
          donePercent: 0,
          deadline: "",
          hardDeadline: false,
          priority: 5
        },
        details: "Mission0 Hull"
      },
      mission0seq: {
        hull: {
          prev: null,
          next: null,
          stack: []
        },
        details: "Mission0 Sequence"
      },
      mission0vtm: {
        hull: {
          dtCreated: null,
          dtAvailable: null,
          dtInProgress: null,
          dtLastSession: null,
          dtDone: null,
          dtFinalized: null
        },
        onCreate: (item2) => {
          item2.dtCreated = core.time();
          item2.commander = core.yehat.auth.memberID;
        }
      },
      missionBoard0: {
        hull: {
          filter: {
            status: "all",
            project: "all",
            group: "all",
            commander: "all",
            assigned: "all"
          },
          sorting: null,
          cursor: null,
          count: 0,
          items: (item2) => ecs.by((v) => v.type === "Mission0" && (item2.missionBoard0.filter.status === "all" || ~item2.missionBoard0.filter.status.indexOf(v.mission0.status)), { sort: (a, b) => {
            if (a.fav0.fav && !b.fav0.fav)
              return -1;
            if (!a.fav0.fav && b.fav0.fav)
              return 1;
            return b.mission0.priority - a.mission0.priority;
          }, process: (a) => {
            console.log("process");
            item2.missionBoard0.count = a.length;
            if (a.length && item2.missionBoard0.cursor !== null) {
              const index = a.findIndex((v) => v.id === item2.connections.mission);
              if (~index) {
                item2.missionBoard0.cursor = index;
              } else {
                item2.missionBoard0.cursor = 0;
                item2.connections.mission = a[0].id;
              }
            }
            if (item2.missionBoard0.cursor >= a.length) {
              if (a.length) {
                item2.missionBoard0.cursor = a.length - 1;
                item2.connections.mission = a[a.length - 1].id;
              } else {
                item2.missionBoard0.cursor = null;
                item2.connections.mission = null;
              }
            }
            item2.actions.keepCursorInView();
            return a;
          } }),
          mousewheel: (item2) => (event3) => {
            if (event3.deltaY < 0) {
              if (item2.actions.up()) {
                item2.missionBoard0.keepCursorInView();
              }
            } else if (event3.deltaY > 0) {
              if (item2.actions.down()) {
                item2.missionBoard0.keepCursorInView();
              }
            }
            event3.preventDefault();
            event3.stopPropagation();
            return;
          },
          keepCursorInView: (item2) => () => {
            if (item2.refs.scroll && item2.refs.items[item2.missionBoard0.cursor]) {
              item2.refs.items[item2.missionBoard0.cursor].$el.scrollIntoView();
            }
            return;
          }
        },
        details: "Mission Boark MK 0 Settings"
      },
      msg0: {
        hull: {
          msg: "",
          type: "plain"
        },
        details: "A Message on channel"
      },
      msg0vtm: {
        hull: {
          dtStart: null,
          dtUpdated: null,
          dtCreated: null,
          dtModified: null,
          updates: 0,
          edits: 0
        },
        details: "Message0 timestamps"
      },
      msg0seenby: {
        hull: {
          roster: {}
        },
        details: "Message0 Seen By. roster: keys - memberCardID, values: { dt, deviceID, synced: Boolean }"
      },
      pause: {
        hull: {
          dtStart: null,
          dtEnd: null,
          duration: 0
        },
        details: "A pause sub-component stored inside a [Timer]."
      },
      saveLocal: {
        hull: {
          json: (item2) => ({ ...options } = {}) => {
            const a = {};
            let saveSelf = false;
            for (let key2 in item2.saveLocal) {
              let v = item2.saveLocal[key2];
              if (key2 == "self" && v) {
                saveSelf = true;
              }
              if (key2 == "forceUpgrade")
                continue;
              if (key2 == "arbitrary")
                continue;
              if (key2 == "json")
                continue;
              if (Array.isArray(v)) {
                a[key2] = {};
                v.forEach((name) => a[key2][name] = item2[key2][name]);
              } else if (v === true) {
                a[key2] = item2[key2];
              } else if (typeof v == "function") {
              }
            }
            return JSON.parse(JSON.stringify(a));
          },
          save: (item2) => ({ prefix = "yehat1" } = {}) => {
            const a = {};
            let saveSelf = false;
            for (let key2 in item2.saveLocal) {
              let v = item2.saveLocal[key2];
              if (key2 == "self" && v) {
                saveSelf = true;
              }
              if (key2 == "forceUpgrade")
                continue;
              if (key2 == "arbitrary")
                continue;
              if (key2 == "json")
                continue;
              if (Array.isArray(v)) {
                a[key2] = {};
                v.forEach((name) => a[key2][name] = item2[key2][name]);
              } else if (v === true) {
                a[key2] = item2[key2];
              } else if (typeof v == "function") {
              }
            }
            if (saveSelf) {
              const roster = JSON.parse(localStorage[`${ecs.prefix}-local-roster`] || "{}");
              roster[item2.id] = item2.type || item2.meta.type;
              localStorage[`${ecs.prefix}-local-roster`] = JSON.stringify(roster);
              console.log(`[ECS]Saved in Roster ${item2.meta ? item2.meta.name : item2.type}.`);
            } else {
              console.log(`[ECS]Saved locally ${item2.meta ? item2.meta.name : item2.type}.`);
            }
            localStorage[`${prefix}-${item2.id}`] = JSON.stringify(a);
          }
        },
        details: `Declares some components of an Entity to be saved in Local Storage. Keys are component names, values are:
      true - store all the component OR Array of Strings - store given keys only.`
      },
      saveRemote: {
        hull: {
          sha256: null,
          save: (item2) => () => {
            console.trace("SaveRemote");
            const a = { id: item2.id, type: item2.type };
            for (let key2 in item2.saveRemote) {
              if (~["save"].indexOf(key2))
                continue;
              let v = item2.saveRemote[key2];
              if (Array.isArray(v)) {
                a[key2] = {};
                v.forEach((name) => a[key2][name] = item2[key2][name]);
              } else if (v === true) {
                a[key2] = {};
                Object.entries(item2[key2]).forEach(([key22, value2]) => {
                  if (!~["function", "undefined"].indexOf(typeof value2))
                    a[key2][key22] = value2;
                });
              } else if (typeof v == "function") {
              } else if (typeof v == "string") {
                a[key2] = v;
              }
            }
            return core.yehat.ex({
              cmd: "ecs.save",
              entity: a
            }).then(({ code, details, ...rest }) => {
              if (code == "ok") {
                core.log("[ECS]Saved Remote Instance", item2.meta.name);
              } else {
                core.log("[ECS]Saving Remote Instance Error", details);
              }
              return { code, details, ...rest };
            });
          }
        },
        details: "Workshop Persistence Entity"
      },
      slapTarget0: {
        hull: {
          roster: {},
          slap: (item2) => ({ code = "draw", source = null, payload = null } = {}) => {
            if (!item2.slapTarget0.roster[code]) {
              console.warn(`[${item2.type} ${item2.id}] Slap received to an unknown slot [${code}]`);
              return;
            }
            if (typeof item2.slapTarget0.roster[code] === "function") {
              console.log(`Slap0 received on slot ${code}. Calling the handler...`);
              return item2.slapTarget0.roster[code]({ source, payload });
            } else if (typeof item2.slapTarget0.roster[code] === "string") {
              const fn = ({ source: source2, payload: payload2 }) => {
                console.log(`Slap0 received on slot ${code} UNP0 string:`, item2.slapTarget0.roster[code], " => NOP SLUG");
                return;
              };
              return fn({ source, payload });
            } else {
              console.warn("Unknown Slap0 handler type: ", typeof item2.slapTarget0.roster[code], item2.slapTarget0.roster[code]);
            }
          }
        },
        details: "The component used for to declare Entity to be a Slap Receiver just by its presence. Roster: keys -- slot names, values -- called methods on the VDs side."
      },
      slot0: {
        hull: {
          accepts: [],
          autoEject: false,
          contains: (item2) => ecs.by((v) => v.located && v.located.rel === item2.id),
          entity: (item2) => computed(() => item2.slot0.contains.length ? item2.slot0.contains[0] : null),
          grab: (item2) => () => {
            for (let entity of item2.slot0.contains) {
              if (!entity.located)
                ecs.addComponent(entity, ecs.compo.located());
              entity.located.rel = "anVpN8Oqw5RLQMK4b8KCV1";
              if (entity.saveLocal)
                entity.saveLocal.save();
            }
          },
          insert: (item2) => (id2) => {
            if (item2.slot0.autoEject)
              item2.slot0.grab();
            const entity = ecs.root[id2];
            if (!entity) {
              core.log(`${pure.itemToken(item2)} insert non-existing ${id2}`);
              return false;
            }
            if (!entity.located)
              ecs.addComponent(entity, ecs.compo.located());
            entity.located.rel = item2.id;
            if (entity.saveLocal)
              entity.saveLocal.save();
            return true;
          }
        },
        details: "Slot0 Base. autoEject - will grab before insert automatically (one-item mechanics)"
      },
      refs: {
        hull: {},
        details: "Vue3 element refs for your needs."
      },
      tags: {
        hull: {
          tags: [],
          add: (item2) => (a) => {
            if (Array.isArray(a)) {
              a.forEach((tag) => {
                if (!~item2.tags.tags.indexOf(tag))
                  item2.tags.tags.push(tag);
              });
            } else if (typeof a == "string") {
              if (!~item2.tags.tags.indexOf(a))
                item2.tags.tags.push(a);
            } else {
              core.log(`[ECS.compo.tags].add() -- invalid type ${typeof a} currently Array and String are supported. Entity ID: ${item2.id}.`);
            }
          },
          remove: (item2) => (a) => {
            let index;
            if (Array.isArray(a)) {
              a.forEach((tag) => {
                index = item2.tags.tags.indexOf(tag);
                if (~index)
                  item2.tags.tags.splice(index, 1);
              });
            } else if (typeof a == "string") {
              index = item2.tags.tags.indexOf(a);
              if (~index) {
                item2.tags.tags.splice(index, 1);
              } else {
                core.log(`[ECS.compo.tags].remove("${a}") -- tag not found, ignoring. EntityID: ${item2.id}`);
              }
            } else {
              core.log(`[ECS.compo.tags].remove() -- invalid type ${typeof a} currently Array and String are supported. Entity ID: ${item2.id}.`);
            }
          },
          has: (item2) => (tag) => {
            return !!~item2.tags.tags.indexOf(tag);
          }
        },
        details: "Tags, implemented w/o using Set"
      },
      ticket0: {
        hull: {
          ticketType: "",
          details: ""
        },
        details: "Common Denominator of all Ticket0(s)"
      },
      ticket0status: {
        hull: {
          used: false,
          dtIssued: null,
          dtUsed: null
        },
        details: "Ticket0 Status"
      },
      ticketMemberCard0: {
        hull: {
          step: 1,
          name: "",
          email: "",
          tosAccepted: false,
          otpEntered: ""
        },
        details: "MemberCard0 Ticket0 State"
      },
      tier: {
        hull: {
          base: "proto"
        },
        details: "Base Tier: enum | proto monkeys poormans standard premium epic legend"
      },
      timer: {
        hull: {
          state: 0,
          dtStart: null,
          dtPause: null,
          dtEnd: null,
          pauses: [],
          interval: 40,
          t: null,
          elapsedCom: null,
          payload: null,
          once: [],
          tick: (item2) => () => {
            if (item2.timer.state == 1) {
              item2.timer.elapsedCom = item2.timer.elapsed();
            }
            if (item2.timer.payload && typeof item2.timer.payload == "function") {
              item2.timer.payload({ now: performance.now() });
            }
            item2.timer.once.map((request, index) => {
              const { at, fn } = request;
              if (item2.timer.elapsedCom >= at) {
                fn({ timer: item2.timer });
                item2.timer.once.splice(index, 1);
              }
            });
            if (item2.timer.state == 1) {
              item2.timer.t = setTimeout(item2.timer.tick, item2.timer.interval);
            }
          },
          start: (item2) => ({ now = +new Date() } = {}) => {
            if (item2.timer.t) {
              console.log("[Timer]Timer already running.");
              return;
            }
            item2.timer.dtStart = now;
            item2.timer.dtEnd = null;
            item2.timer.pauses = [];
            item2.timer.state = 1;
            item2.timer.t = setTimeout(item2.timer.tick, item2.timer.interval);
            console.log(`[${item2.meta.name}][Timer]Started`);
          },
          pause: (item2) => () => {
            if (item2.timer.state != 1) {
              console.log("[Timer]Cannot pause, timer is not ruunning.");
              return;
            }
            item2.timer.state = 2;
            const now = +new Date();
            item2.timer.pauses.push(new Pause({ dtStart: now }).pause);
            item2.timer.elapsedCom = item2.timer.elapsed({ now });
          },
          resume: (item2) => () => {
            if (item2.timer.state != 2 || !item2.timer.pauses.length) {
              console.log("[Timer]Cannot resume, not paused.");
              return;
            }
            const pause = item2.timer.pauses[item2.timer.pauses.length - 1];
            const now = +new Date();
            pause.dtEnd = now;
            pause.duration = pause.dtEnd - pause.dtStart;
            item2.timer.state = 1;
            item2.timer.elapsedCom = item2.timer.elapsed({ now });
          },
          stop: (item2) => ({ now = +new Date() } = {}) => {
            console.log("[Timer]Timer stopped.", item2.timer.t);
            if (item2.timer.t) {
              clearTimeout(item2.timer.t);
              item2.timer.t = null;
            }
            if (item2.timer.state == 2) {
              const pause = item2.timer.pauses[item2.timer.pauses.length - 1];
              pause.dtEnd = now;
              pause.duration = pause.dtEnd - pause.dtStart;
            }
            item2.timer.dtEnd = now;
            item2.timer.elapsedCom = item2.timer.elapsed({ now });
            item2.timer.state = 3;
          },
          elapsed: (item2) => ({ now = +new Date() } = {}) => {
            const pausedTime = item2.timer.pauses.reduce((a, v) => {
              const interval = v.dtEnd === null ? (item2.timer.dtEnd || now) - v.dtStart : v.dtEnd - v.dtStart;
              return a + interval;
            }, 0);
            return (item2.timer.dtEnd || now) - item2.timer.dtStart - pausedTime;
          },
          elapsedHR: (item2) => computed(() => {
            const to2Digits = (n) => {
              let s2 = "" + n;
              while (s2.length < 2)
                s2 = "0" + s2;
              return s2;
            };
            const to3Digits = (n) => {
              let s2 = "" + n;
              while (s2.length < 3)
                s2 = "0" + s2;
              return s2;
            };
            const toTimerData = (a) => {
              const b = Math.floor(a / 1e3);
              const sec = b % 60;
              const c = (b - sec) / 60;
              const min = c % 60;
              const d = (c - min) / 60;
              return [to3Digits(a % 1e3), ...[sec, min, d].map(to2Digits)];
            };
            const v = toTimerData(item2.timer.elapsedCom);
            const sep = v[0] >= 500 ? '<span class="mw4">:</span>' : '<span class="mw4">&nbsp;</span>';
            const template = `${v[3]}${sep}${v[2]}${sep}${v[1]}`;
            return template;
          })
        },
        details: `Robust [Timer] core featuring full cycle timer operations: "start", "stop", "pause", "resume", as well as
"elapsed" time computation enchantment.
state -- Enum [ 0: Idle, 1: Running, 2: Paused, 3: Stopped ]
dtStart, dtPause: null, dtEnd: null -- recent timestamps
pauses -- Array of Pause
interval -- Interval in milliseconds
t -- JS Timer instance
elapsedCom -- reactively updated elapsed time
payload -- a function to call on every tick`
      },
      websocketConfig: {
        hull: {
          host: "",
          port: "",
          onConnect: (item2) => () => {
            core.log("WebSocket0] CONNECTED, No payload.");
          }
        },
        details: "Web Socket Conn. Configuration"
      },
      tp0: {
        hull: {
          name: "nothingness",
          amount: 0
        },
        details: "Yehat TP Component."
      },
      tp0roster: {
        hull: {
          roster: {
            sunlight: 0,
            moonlight: 0,
            hangars: 0,
            dryware: 0,
            blame: 0,
            devotion: 0,
            chickenkiller: 0,
            fame: 0,
            theta: 0,
            yonda: 0,
            identity: 0,
            intel: 0,
            gold: 0,
            gemstone: 0,
            waifu: 0,
            daddy: 0,
            postulate: 0,
            derelic: 0,
            cargo: 0
          }
        },
        details: "TP Roster."
      },
      nft0: {
        hull: {
          name: "nothingness",
          blockID: 0
        },
        details: "Yehat NFT Component."
      },
      nft0payload: {
        hull: {
          stacked: []
        },
        details: "Yehat NFT Payload: arbitrary. Add things to `stacked` to make them blockchain-friendly."
      },
      tx0: {
        hull: {
          name: "",
          amount: 0,
          blockID: 0,
          dtIssued: 0,
          dtMined: 0
        },
        details: "Mineable Transaction for TPs"
      },
      tx1: {
        hull: {
          json: "",
          blockID: 0,
          dtIssued: 0,
          dtMined: 0
        },
        details: "Mineable Transaction for NFTs"
      },
      memberCard0: {
        hull: {
          name: "",
          email: ""
        },
        details: "Yehat MemberCard0 data."
      }
    },
    types: {
      Cargo0: {
        hull: () => [
          ecs.compo.cargo0(),
          ecs.compo.meta({ type: "Cargo0", name: "Cargo0" }),
          ecs.compo.located(),
          ecs.compo.saveLocal({ self: true, type: "Cargo0", located: true, cargo0: true })
        ],
        details: "A Directory of Entities"
      },
      Cargo2: {
        hull: () => [
          ecs.compo.cargo2({
            rawSize: 0
          }),
          ecs.compo.cargo2stat(),
          ecs.compo.item({
            baseComponent: "Cargo2",
            inventoryComponent: "Cargo2Item",
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAs9JREFUaIHtmsFq2zAYx/9dyg697OIZJ+QaOigLo4Od9gA97gFyGPS458kx0EMfIs8wqCkZg4xeg2dcX3rJIbTzDonsT7JsS4lsJ6l+EFxZsqKfP1my1AAWi8VisVgsFosRTtpugIjX6yc0HQYLo208NVlZFaKMjO+9BZe+QT8xKW2kIhURgJf5cfWhsvx4OgcA3AR9Y5GujLBuVMpFqiXrJicsCjKZtkVUe5EM2js4Ya/XT/KC7UeF4rnONpel40AqLJfdL5jsu/c95WueHgMu/cZoi2rEcx2EUYyvV9/w8fMX7gOg8CjS6LSkAxuhGWEU4/xiCAD4dfczPV8kVsReCTNJP+4A6ODSeUnzPNfBn98zLqpUXJXGhHmZIvg8P86kwyiG5zqpZFFkq27CzsJqIoAoowqrlz7DRdIq3Tudn+goDaxHanUZfWarbmWZ4du/XFn2DOvw9BggjGLkpiWKH3dwffuAbaKiIgIAYbCoLtTrp3+yZ/j8Ylh6FBHn7VyEy6KpIqMkoom3Ed/mpSOM4vVxE2FOmHUhEdWoNcG20qVdmsFEveegrFjthKfZmxWLWBllNyUnPBkNMJ7Os9FxI+uetbNXEC0TrRtOb46MnLD4hgO0J6v73dGyekGVE2aRna268J6DVmV1cc9OgGWAMCru1pwwHZwOTZZBpWVQo+STmy2eDlGWQrv3ffQP2LgqTUuHzmzVTaelg1kPm8IKHzuvTlh7PTwZDXLn1isreRmaNxkNcH37oJVPy8nOF7WhCO1Rmm67MMQVFi1D8y6dF24XA1ivu1ljZfm0Htn5ojZQdhql/bhjdENgPJ3nIifWz9Ky79ZtT+vPsB93pNJ10bowkEk3wV4IA/Xsm8nYG+GmsMLHjhU2zWQ0SD8615Sld6GW/y3RtyI63aiOxOIUtU6bGcXtBsCx8+qEuZ26XX4ps8+Y/jWfxWKxWOriPz/iUE0UkTLPAAAAAElFTkSuQmCC"
          }),
          ecs.compo.located(),
          ecs.compo.meta({ name: "Cargo MK2 Box", type: "Cargo2" }),
          ecs.compo.dialog0(),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.lang({
            en: {
              title: "Cargo MK2",
              subtitle: "Entities in the box"
            },
            ru: {
              title: "Cargo MK2",
              subtitle: "\u041E\u0431\u044A\u0435\u043A\u0442\u044B, \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0432\u043C\u0435\u0441\u0442\u0435"
            }
          }),
          ecs.compo.grid0user({
            defaultRecord: { pos: [0, 0], size: [24, 13] }
          })
        ],
        details: "Cargo MK 2 - (UN)Stackable Yehat Boxes"
      },
      Cargo3: {
        hull: () => [
          ecs.compo.cargo3({
            rawSize: 0
          }),
          ecs.compo.cargo3payload(),
          ecs.compo.cargo3stat(),
          ecs.compo.item({
            baseComponent: "Cargo3",
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAs9JREFUaIHtmsFq2zAYx/9dyg697OIZJ+QaOigLo4Od9gA97gFyGPS458kx0EMfIs8wqCkZg4xeg2dcX3rJIbTzDonsT7JsS4lsJ6l+EFxZsqKfP1my1AAWi8VisVgsFosRTtpugIjX6yc0HQYLo208NVlZFaKMjO+9BZe+QT8xKW2kIhURgJf5cfWhsvx4OgcA3AR9Y5GujLBuVMpFqiXrJicsCjKZtkVUe5EM2js4Ya/XT/KC7UeF4rnONpel40AqLJfdL5jsu/c95WueHgMu/cZoi2rEcx2EUYyvV9/w8fMX7gOg8CjS6LSkAxuhGWEU4/xiCAD4dfczPV8kVsReCTNJP+4A6ODSeUnzPNfBn98zLqpUXJXGhHmZIvg8P86kwyiG5zqpZFFkq27CzsJqIoAoowqrlz7DRdIq3Tudn+goDaxHanUZfWarbmWZ4du/XFn2DOvw9BggjGLkpiWKH3dwffuAbaKiIgIAYbCoLtTrp3+yZ/j8Ylh6FBHn7VyEy6KpIqMkoom3Ed/mpSOM4vVxE2FOmHUhEdWoNcG20qVdmsFEveegrFjthKfZmxWLWBllNyUnPBkNMJ7Os9FxI+uetbNXEC0TrRtOb46MnLD4hgO0J6v73dGyekGVE2aRna268J6DVmV1cc9OgGWAMCru1pwwHZwOTZZBpWVQo+STmy2eDlGWQrv3ffQP2LgqTUuHzmzVTaelg1kPm8IKHzuvTlh7PTwZDXLn1isreRmaNxkNcH37oJVPy8nOF7WhCO1Rmm67MMQVFi1D8y6dF24XA1ivu1ljZfm0Htn5ojZQdhql/bhjdENgPJ3nIifWz9Ky79ZtT+vPsB93pNJ10bowkEk3wV4IA/Xsm8nYG+GmsMLHjhU2zWQ0SD8615Sld6GW/y3RtyI63aiOxOIUtU6bGcXtBsCx8+qEuZ26XX4ps8+Y/jWfxWKxWOriPz/iUE0UkTLPAAAAAElFTkSuQmCC"
          }),
          ecs.compo.located(),
          ecs.compo.meta({ name: "Cargo MK3 Box", type: "Cargo3" }),
          ecs.compo.dialog0(),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.lang({
            en: {
              title: "Cargo MK3",
              subtitle: "Packed Yehat Source Block"
            },
            ru: {
              title: "Cargo MK3",
              subtitle: "\u041E\u0431\u044A\u0435\u043A\u0442\u044B, \u0441\u0433\u0440\u0443\u043F\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0435 \u0432\u043C\u0435\u0441\u0442\u0435"
            }
          }),
          ecs.compo.grid0user({
            defaultRecord: { pos: [0, 0], size: [24, 13] }
          }),
          ecs.compo.saveLocal({
            self: true,
            type: "Cargo3",
            cargo3: true,
            cargo3payload: true,
            cargo3stat: true,
            located: true
          })
        ],
        details: "Cargo MK 3 - (UN)Stackable Yehat Boxes"
      },
      Code1: {
        hull: () => [
          ecs.compo.code1(),
          ecs.compo.code1seq(),
          ecs.compo.code1tr(),
          ecs.compo.dialog0(),
          ecs.compo.fav0(),
          ecs.compo.grid0user({
            defaultRecord: { size: [17, 9] }
          }),
          ecs.compo.item({
            baseComponent: "Code1"
          }),
          ecs.compo.located(),
          ecs.compo.meta({
            type: "Code1",
            details: "Stackable Yehat Module MK 1"
          }),
          ecs.compo.saveLocal({
            self: true,
            code1: true,
            code1seq: true,
            fav0: true,
            located: true,
            tags: true,
            tier: true
          }),
          ecs.compo.tags(),
          ecs.compo.tier(),
          ecs.compo.timer(),
          ecs.compo.attention0(),
          ecs.compo.actions({
            save: (item2) => () => {
              item2.saveLocal.save();
              if (!item2.code1.evaluateDirty()) {
                Quasar.Notify.create("Saved.");
              } else {
                Quasar.Notify.create({ message: "Saved, still DIRTY.", color: "warning" });
              }
              return true;
            }
          }),
          ecs.compo.keyboardUser0({
            bindings: [
              { keyExpression: (v) => v.code === "KeyS" && v.ctrlKey, keyDown: "<[save]" }
            ]
          })
        ],
        details: "Stackable Yehat Module MK 1"
      },
      DiaCreate0: {
        hull: () => [
          ecs.compo.diaCreate0(),
          ecs.compo.dialog0(),
          ecs.compo.meta({ type: "DiaCreate0", name: "Dialog to Create an Item" }),
          ecs.compo.tier({ base: "proto" }),
          ecs.compo.item({
            baseComponent: "DiaCreate0",
            name: "Create Item",
            onClick: (item2) => () => item2.dialog0.show = true
          }),
          ecs.compo.located()
        ],
        details: "Simple (No INPUT) items creating Dialog for ZIITable5"
      },
      DiaCreateImage4: {
        hull: () => [
          ecs.compo.diaCreateImage4(),
          ecs.compo.lang({
            en: {
              incomingImage: "Incoming Image",
              importTarget: "Create Image in",
              chooseTarget: "- Choose Target -",
              yourInventory: "Your Inventory",
              inPage0: "WebApp Page",
              inGal0: "WebApp Gallery",
              create: "Create",
              close: "Dismiss",
              ziiTable5: "ZII Table 5 -- The Container observed",
              copyBase64: "Copy Base64"
            },
            ru: {
              incomingImage: "\u041F\u043E\u0441\u0442\u0443\u043F\u0430\u0435\u0442 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435",
              importTarget: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435 \u0432",
              chooseTarget: "- \u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043C\u0435\u0441\u0442\u043E/\u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 -",
              yourInventory: "\u0412\u0430\u0448\u0435\u043C \u0418\u043D\u0432\u0435\u043D\u0442\u0430\u0440\u0435",
              inPage0: "\u0421\u0442\u0440\u0430\u043D\u0438\u0446\u0430 \u0412\u0435\u0431-\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F",
              inGal0: "\u0413\u0430\u043B\u0435\u0440\u0435\u044F \u0412\u0435\u0431-\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F",
              create: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C",
              close: "\u041E\u0442\u0441\u0442\u0430\u0432\u0438\u0442\u044C",
              ziiTable5: "ZII Table 5 -- \u041F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u0435\u043C\u044B\u0439 \u041A\u043E\u043D\u0442\u0435\u0439\u043D\u0435\u0440",
              copyBase64: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C Base64"
            }
          }),
          ecs.compo.dialog0(),
          ecs.compo.meta({ type: "Dialog", name: "Create Image 4" }),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.slapTarget0({ roster: { draw: () => {
          } } }),
          ecs.compo.grid0user({ defaultRecord: { size: [24, 12] } })
        ],
        details: "Create Image 4 somewhere."
      },
      Eraser0: {
        hull: () => [
          ecs.compo.eraser0(),
          ecs.compo.meta({ name: "Eraser MK 0", type: "Eraser0" }),
          ecs.compo.actions(),
          ecs.compo.dialog0(),
          ecs.compo.attention0(),
          ecs.compo.keyboardUser0(),
          ecs.compo.item({
            baseComponent: "Eraser0"
          }),
          ecs.compo.tier({ base: "monkeys" })
        ],
        details: "Eraser MK 0"
      },
      Gal0: {
        hull: () => [
          ecs.compo.gal0(),
          ecs.compo.meta({ type: "Gal0", name: "An image gallery" }),
          ecs.compo.item({
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAADSElEQVRoBd2ZzY3WQBBEnQBXUuC2CWwIRMKKA0dOiAPSxsGJABABcCQqo0I8VLR6Pnu882N/K1nVPeMZ13O3Z7WwfPv6fR1xfXh8WOP19uH16tf69+fLp+e117X0ho2Qyh1SMT+9IH3f7sCPb16tuiLkaFCguwOrg4B2cFUVEyN1GvC7p6frAMfvcusc8ApT5UsAR1A/gGqg+Z5nQO9q6VugmL8L4D2gR4BntnVa4T2g/rvzCDRrRrf1f8C1oP7rRABXaOs/wC8BBboWeFZbLxGWVkO9dYHLlPvPXuV/wBhG94I6vNaeHhhA9Ago0LXAM9p6aQHqwLXQPH/Uab28pKKAup4e2M22iGuBR7f10gLS96BFz3p4NQcWfG2VeUkjvuNTAI9s627AZ61yF+Azt/U0YLVxvEZ8y12BS20dQckvDVxqa+CkAoy5xnqe1t0qHIHff/ycwjkwL6EndHdgmS/Bak6XQzPWq8pdgalyBgTYXQM7ZIyzl9KjykMqHOE8//Hz16rrboBpa4dUrO9a190DA4gC7hVWzAtq3dbdW9orDGSmpZP8ksBAZ6A+5lW+dIWPALdua/45ekhLA6yqeUWzuHWVAUWHAQOdQfpYK2AAXfXCTw18pK0dkJjzYApwr7YGztVBiYdWuEdbOyAxcJmeHrjU1sC5ZoA+pr2mAMuEH1RZXDq8HJDYobKYvTQ3HPhIWwMWNYPzMQdl/BLAmN2rGShrpwHLQNbK/DGhOYyXFAiU+8gznQJMW2eG/CUAUFLWM0+eKftOA47fI7nMYg6QLc0AGWMvdAowcK4YdGCZdFjuYYw8UwCjDgV2QOIts8BJs3tvjUVY5UOAgXPda9SBa6GHAzsg8S1QzWUmHXprvc9ne3WpMHCubiSLgcpMMldbYT0n7tcU2AGJMzgfAyYa85x7UF+/Ffs+ipsAA+e6ZSSaj8Zizv3Srb19Pu7zImAHJPaHZTHG41w0FnPW1QDHPZQfAgbONQLEHMNxnDwz52OsR1mXqa+LcRWwAxJnD/SxPQa53/8nIhpVzl5S1rhma+LYLmDgXP1BWYy5bK40JnP+x0M0y54RON6X5ex7E9gBiUtmGccUeY26UQz6GHsD7HOlOO7zG9mzcC59YNYoAAAAAElFTkSuQmCC",
            baseComponent: "IGal0",
            onClick: (item2) => () => {
              item2.dialog0.show = true;
            }
          }),
          ecs.compo.tier({ base: "standard" }),
          ecs.compo.connections({
            project: null,
            webapp: null
          }),
          ecs.compo.located(),
          ecs.compo.saveLocal({
            self: true,
            type: "Gal0",
            gal0: true,
            tier: true,
            connections: true,
            located: true,
            tags: true
          }),
          ecs.compo.dialog0(),
          ecs.compo.tags()
        ],
        details: "Image Gallery MK 0"
      },
      GTDStatus0: {
        hull: () => [
          ecs.compo.gtdStatus0(),
          ecs.compo.meta({ type: "GTDStatus0", name: "Mission Status Group" }),
          ecs.compo.located(),
          ecs.compo.lang({
            en: {
              caption: ""
            },
            ru: {
              caption: ""
            }
          }),
          ecs.compo.tier(),
          ecs.compo.saveLocal({ self: true, type: "GTDStatus0", located: true, gtdStatus0: true, tier: true, lang: true })
        ],
        details: "Mission Status Group"
      },
      Image4: {
        hull: () => [
          ecs.compo.image4(),
          ecs.compo.meta({ type: "Image4", name: "Image" }),
          ecs.compo.located(),
          ecs.compo.item({
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAy1JREFUaIHdmyFv20AcR5+nSVFApIAp3ReYwlI8BQ6mYHTfYmOTBqaBSYP9DgMlhQsMa9DQzKqCSY0idVFApYCqyAPZuZfL2b6z73znPRSrtu9e/z+f7xwnwQ+Z9Dnx1EYtfHQmm01GvBq8BOB8mfpsyxpvwkAuDfGIu248m01G/Pj1B4Cz0xMgLvHnPk769fM3AK34++kEgPNlKq7zVsW9CAtiFHfZSDabjHj99kPhDp++fATCRt1rhVViqHirwoKQ4q5OVhnnMtqMepAKq7RZ8SiEBW2Iu4hJoziX4SPqUVVYxUfFoxYWuBRvGmlvcS6jSdQ7UWEVi4ofSXdSWCCLn52e8HP7u/KYJpEOEmcd6+2KdPE9315e76DA7VlLffLGervi9urSeP/OC6uUVRfqC0cR5/V2BcD944PxMZ2vsE2c4T8QlqmKM9QTjirOtnS6wrdXl1bXL3RcWMYkzmAvHFWcbasLHa6w7egs6KywjGmcoXrxIH8LSExxrkuZcP6lWGzUjTMYLg/lBXYsyAPWdDxgeb3Trn9VjK7hm91d/nm7uGC7uKjRxebo4jzs9YG9NMolqMN40LrZ3UUhXjbZMJEuFb5/fDg6eSzi8FTdYa9vXOmqzGfSSfKTyqjX94s370z7a4WIs/xkQ9cfUaCiW1VVpPMDhr1+8Iqro/M83RTuW1Rpq4mHiE5ocZl5umGebvL+VMW7MtLT8UAbHeCgERWXUZefW8n/aCW2GewnR3L/1Gg3ekwrRHXiotpCXFTb1TWuuUYTgHm6ORh3VJw8l25L3HB1lABiIpJvo9tQKI2z3AF1H5dRN4yzMbVXS/Lwrw5iPgY3F7LgKNL/OsB0vN+WJwRQP+q2D9lNMBql4bCzVSNl0UTFNupCWE1JkwqbHHQkUTWb0R0jYyouUuAqzrYHHg33Bo3XFpf/LtOmsKDOu9BW4mW3nxDCTTASL6KpbOODG5CLl614VFwIh3oDIKFkzVp0R3BBqMe0lbM4FRfVhcifS7uuLkQu7IOQP7jQzuJkDCY41oR8bSkRSzh1Dg5+4gzh39M6WLvqxL00GBF1pq9WxCYs8PZTvr/JLyW4hLQMsQAAAABJRU5ErkJggg==",
            baseComponent: "Image4"
          }),
          ecs.compo.connections({
            project: null,
            webapp: null,
            page: null,
            gal: null
          }),
          ecs.compo.tier({ base: "standard" }),
          ecs.compo.saveLocal({
            self: true,
            arbitrary: true,
            image4: true,
            connections: true,
            located: true,
            tags: true,
            shhnSliderItem0: true
          }),
          ecs.compo.dialog0(),
          ecs.compo.tags()
        ],
        details: "An image within Page or Gallery."
      },
      Inventory0: {
        hull: () => [
          ecs.compo.inventory0(),
          ecs.compo.tp0roster(),
          ecs.compo.located(),
          ecs.compo.item({
            baseClass: "Inventory0",
            name: "Inventory"
          }),
          ecs.compo.dialog0(),
          ecs.compo.connections({
            member: null
          }),
          ecs.compo.saveLocal({ self: true, type: "Inventory0", inventory0: true, located: true, connections: true }),
          ecs.compo.tier({ base: "proto" }),
          ecs.compo.meta({ type: "Inventory0", name: "Member's Inventory" }),
          ecs.compo.grid0user({ gridID: "LMOFwoZldRZJwoHChmHDuc", defaultRecord: { size: [24, 6], pos: [0, 15] } })
        ],
        details: "Inventory"
      },
      Ledger0: {
        hull: () => [
          ecs.compo.ledger0(),
          ecs.compo.connections({
            admin: null
          })
        ],
        details: "Ledger0 Singleton Centralized Ledger pure naive, targeting poormans."
      },
      MemberCard0: {
        hull: () => [
          ecs.compo.memberCard0(),
          ecs.compo.connections({
            owner: null,
            ticket: null,
            nft: null,
            tx: null
          }),
          ecs.compo.lang({
            en: {
              title: "Member Card",
              subtitle: "Yehat Membership Card",
              nftSubtitle: "Yehat Membership NFT"
            },
            ru: {
              title: "Member Card",
              subtitle: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0430 \u0423\u0447\u0430\u0441\u0442\u043D\u0438\u043A\u0430 Yehat",
              nftSubtitle: "\u041A\u0430\u0440\u0442\u043E\u0447\u043A\u0430 \u0423\u0447\u0430\u0441\u0442\u043D\u0438\u043A\u0430 Yehat NFT"
            }
          }),
          ecs.compo.located(),
          ecs.compo.saveLocal({
            self: true,
            type: "MemberCard0",
            memberCard0: true,
            connections: true,
            located: true
          }),
          ecs.compo.item({
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAAAXNSR0IArs4c6QAAAqJJREFUaIHtmrFOwzAQhi8RT4GYUZmY2WDIAyBVnZD6CoywMLDAyCtEYkJIPEAH2DozgZgRj0EZwOHy58520saJVX9S1eRydvzn7ItrlyiRSCQSiUQikUgkPMj+vo8HbUU4XjIiOj6/Xz0P3ZIQ3J1lJ9n5/Wr1sHgfui1BmBUTynbnb6uhGxKSfOgGGGbFRDyfFZPaB33xWDrntp1eWr9hfIbcrJhUfub4YfFesxONSLBpHD83GLtk40g2ZDRdmuhfEEbURKuLDRlNhG1oke/C1mVpMcKvpwUdPi0a56+nRc3P2Fy+5rpWHv2wLXgNba578bJql7aJbOvLH4pUXvLDc34PW70umyqYV86FSE+8ja+vTXso3J/jUweRI0tr0bBFSfLF7oW+rkYSNbtolzqIOmRp15iTfLXoaL0EbT73kuqQym5dlh7VxCMEvU08fKZ50iTCp5xW1gfvCOfLkvJl2ekmY8JrDKPQ76N5bw3qG2eXlqKaL0unaN+uSeT+FWTzb4u1S3Ox06sbml7diNdiQu3SKJbzeH1ZHcfWvcUI28SiLbZINyLsEsuxRfqrPFirYbvzt7XKa9QibBMrrSbEGOlKsEusdIy+MYhujGGbWM3m6vpjohrD0vvP9b6zldn0GG67rqX5q+9hn0pDbdHwdeY28LVpgyi4TcUhRNtySNsyDcFdBPQtmidD38Solanm0us2OpYdyOgWAKSprJQ8tSlvFIKx8bhDiIkJHwAvXxOMW4ttbX3Cx6ERyHcGJRuWI4L3MG434tPD7UfpumH0c2kUYcBzyS9kwrJlbJ9s3ujS0hYkIvmFwoxHVdCfXUta1WsJ/06AsxQeWfQbAkm4z2LE9i3Ex/CTblPky/L3n3h7+xdbEeXPj9vM7ZVIJMbMD96/7IclugOjAAAAAElFTkSuQmCC",
            inventoryComponent: "MemberCard0",
            baseComponent: "MemberCard0"
          }),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.dialog0(),
          ecs.compo.grid0user({ defaultRecord: { size: [52, 31] } })
        ],
        details: "Yehat MemberCard0"
      },
      Mission0: {
        hull: () => [
          ecs.compo.mission0(),
          ecs.compo.mission0vtm(),
          ecs.compo.mission0seq(),
          ecs.compo.saveLocal({
            self: true,
            type: "Mission0",
            mission0: true,
            mission0seq: true,
            tags: true,
            tier: true,
            located: true,
            grid0user: true,
            connections: true,
            fav0: true
          }),
          ecs.compo.tags(),
          ecs.compo.tier(),
          ecs.compo.tx1(),
          ecs.compo.meta({
            type: "Mission0",
            name: "Mission MK 0"
          }),
          ecs.compo.located(),
          ecs.compo.item({
            baseComponent: "Mission0"
          }),
          ecs.compo.grid0user(),
          ecs.compo.dialog0(),
          ecs.compo.connections({
            project: null
          }),
          ecs.compo.cargo3(),
          ecs.compo.cargo3payload(),
          ecs.compo.cargo3stat(),
          ecs.compo.cat0(),
          ecs.compo.fav0()
        ],
        details: "Next Level Data Mission MK 0"
      },
      MissionBoard0: {
        hull: () => [
          ecs.compo.missionBoard0(),
          ecs.compo.attention0(),
          ecs.compo.grid0user({ defaultRecord: { size: [24, 12] } }),
          ecs.compo.keyboardUser0({
            bindings: [
              { keyExpression: (v) => v.code === "ArrowDown", keyDown: "<[down]" },
              { keyExpression: (v) => v.code === "ArrowUp", keyDown: "<[up]" }
            ]
          }),
          ecs.compo.lang({
            en: {},
            ru: {}
          }),
          ecs.compo.located({ size: [24, 12] }),
          ecs.compo.meta({
            type: "MissionBoard0",
            name: "Mission Board"
          }),
          ecs.compo.saveLocal({
            self: true,
            type: "MissionBoard0",
            forceUpgrade: ["missionBoard0"],
            missionBoard0: true,
            grid0user: true,
            located: true,
            connections: true
          }),
          ecs.compo.item({
            baseComponent: "MissionBoard0"
          }),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.dialog0(),
          ecs.compo.actions({
            up: (item2) => () => {
              if (item2.missionBoard0.cursor > 0) {
                item2.connections.mission = item2.missionBoard0.items[item2.missionBoard0.cursor - 1].id;
                item2.missionBoard0.cursor--;
                return true;
              }
              return false;
            },
            down: (item2) => () => {
              if (item2.missionBoard0.count !== 0 && item2.missionBoard0.cursor < item2.missionBoard0.count - 1) {
                item2.connections.mission = item2.missionBoard0.items[item2.missionBoard0.cursor + 1].id;
                item2.missionBoard0.cursor++;
                return true;
              }
              return false;
            },
            newMission: (item2) => () => {
              if (item2.located.rel && ecs.root[item2.located.rel].type === "Project" && !item2.connections.project) {
                item2.connections.project = item2.located.rel;
              }
              const commander = ecs.root.useID.slot0.entity ? ecs.root.useID.slot0.entity.id : null;
              const newMission = ecs.create("Mission0", {
                mission0: {
                  commander
                },
                connections: {
                  project: item2.connections.project
                },
                mission0vtm: {
                  dtCreated: core.time()
                },
                dialog0: {
                  show: true
                },
                located: {
                  rel: item2.id
                }
              });
              const grid = ecs.root[item2.grid0user.gridID];
              grid.grid0.deploy(newMission);
              grid.grid0.manage({ id: newMission.id, attach: item2.id, dir: "a", follow: true });
              core.log(`${pure.itemToken(item2)} Mission0 Created!`, newMission);
            },
            keepCursorInView: (item2) => () => {
              if (item2.refs.items[item2.missionBoard0.cursor])
                item2.refs.items[item2.missionBoard0.cursor].$el.scrollIntoView({ block: "center" });
            }
          }),
          ecs.compo.connections({
            mission: null,
            project: null
          }),
          ecs.compo.refs({
            scroll: null,
            items: {}
          })
        ],
        details: "Mission Boark MK 0"
      },
      Msg0: {
        hull: () => [
          ecs.compo.msg0(),
          ecs.compo.msg0vtm(),
          ecs.compo.msg0seenby(),
          ecs.compo.meta({ type: "Msg0", name: "Message" }),
          ecs.compo.actions(),
          ecs.compo.conn({
            from: null,
            to: "all",
            rel: null
          }),
          ecs.compo.located(),
          ecs.compo.saveLocal({
            self: true,
            type: "Msg0",
            msg0: true,
            msg0vtm: true,
            msg0seenby: true,
            conn: true,
            located: true,
            tier: true
          }),
          ecs.compo.saveRemote({
            msg0: true,
            msg0vtm: true,
            msg0seenby: true,
            conn: true,
            located: true,
            tier: true
          }),
          ecs.compo.tier()
        ],
        details: "A Message on channel"
      },
      MessageBase0: {
        hull: () => [
          ecs.compo.messageBase0(),
          ecs.compo.meta({ type: "MessageBase0", name: "Message Base" }),
          ecs.compo.actions(),
          ecs.compo.located(),
          ecs.compo.saveLocal({
            self: true,
            type: "MessageBase0",
            located: true
          })
        ],
        details: "Message Base"
      },
      Slot0: {
        hull: () => [
          ecs.compo.meta({ type: "Slot0", name: "Slot 0" }),
          ecs.compo.slot0(),
          ecs.compo.saveLocal({ self: true, type: "Slot0", slot0: true, located: true })
        ],
        details: "Slot 0"
      },
      TicketMemberCard0: {
        hull: () => [
          ecs.compo.ticket0({ ticketType: "Member Card 0", details: "Submit name, email; confirm email => Get Member Card Level 1" }),
          ecs.compo.ticket0status(),
          ecs.compo.ticketMemberCard0(),
          ecs.compo.located(),
          ecs.compo.item({
            baseComponent: "TicketMemberCard0",
            inventoryComponent: "TicketMemberCard0",
            baseIcon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAAAyCAYAAADCxvyGAAAEjElEQVR4Ae2bPW4UQRCF5wyEyLETEgdESEiWcEzABcgIEIFDh+RwAUTKAQg4AncgJCRAnGHQW/a1Xxeve3p79se7s5aaqq6u6ar6tnaXQngY7n+uh2GorXvPf1rNF2fxZ1H+1x8+fxtraw2bkM7+gZfymYRD0Oxg7qfkIv2noJzP6+/cyGdQw+WTmxELtqXqrF+5UH/0/FX1YxF+FihhLlUSYJQA6pb6ZUBxsFSIWrcCUt3BjF2bAdVLp/RnN2/GY1pT9fBcAUZ9p0CZwCnKCJL72I20q8w6FActgI6pMzXXltrgo4A21TOgrQFP2a8G0HVotA1XV1fpFWkBpa/4MeotNRIq2CgfwqOEn+rwXY2S+lBLwFP3AagEZxhS0wGeW9EfUFfjZw3U7ZdxPKVVqpXdqbM5+TiY7FD1T7N8KQhAPn7946QWairVG6AmPjWgeGYFlQ9TuiCnBpP1uFphI4se2fQtzwTmyt9fL8ZDrpi/A1qDyLc3fdix3EPuHSiKAtR9S8ZUqA7oVIcSKmFyT6gZUBhdEE1ijs7u3DdMjaf5u1qngIIRYRKiygxoKYAmMUcn0EPJmLurV+GU9NiV6rdXoLGgQ+8d0FqHsjOjLALFgQty6MJ3Fd/VulWgpQC7KujQ97p6tduiHjuTe/VLY1WpOxG0pfCLy7smP3fXz19/xm0uF8PZHFDYCAjjp47ltJdkGlf1IRfEJaM2wMTk0QsVMHHfNiTv0PxKuquVQBOcMMtHmOhS2NR/cpYvJQQ7YXLO74HK7sR9BDJX1nLmmQNKYDqb6yzPc0oCVf80q7oAsDGBKCPMXqgEui0Z8yztS/US1hpS4sPPzCgzf24oXRCXUIQJHwKd8/Z3sXZlc7XCRhZRRpDcq1/X30MdTBZ9TFAdUIUTdQKMUv26gCo0glQ5da6+h9Qd0FqHKriSngGFkwsSiyawaNe989n0M5L3bfoc/fl8Sbpaa0BjZ3KvcDOgpQAxIcCKNrdv9XPP7sPm6lU4USfAKNWvC2hvsewcJ2t3On/Yas+0nDmgtQ5VcCU9AwonF6QluWP0cbXWgKIzSyBpz4CWAmwLVm+n8TnkUdJ7cnT1EoyT8a3OvfpubZbvKWhXz7z4+H3E0vudzQHVDsU4qWM5AUZJoGn81IdcEE1sjs7uUon74j7G0HOnqz9BUvKMe0rYXa0EmuCEWT7CxB5A1X/WLM+EH4okMErmxT1lCSi7TWfz2izv/NOsWnrFmJTKd3fvx9KCH87Uf47uulJtevfTt59SXMDjoo+el+oNkBIf2kty9SLEQxeEyRyLVGiac7S7WmGLTDbZd3/La3ciabfXYubo2o1Od3dfvrxNnYrzuF/Z1r9ToGA3ged8u4G6Ih6aDRC5XG4KUnUHCjb3hcQvJT6TAYVRL6be84/GroCHZENNrC9KwolyY6Dx4iXuI0Tdn4Gaz8iWJlGIUY9v8XieveU1GBy5X6IeQem+BjUDqg+d9c1+JZG8slmexpLEeKVjasmP9iX6//d/7AkjSp1VW6Au2T9BZUc5uXKSP5yP2sR1Uff/BebAvwpFXdsCAAAAAElFTkSuQmCC"
          }),
          ecs.compo.dialog0(),
          ecs.compo.tier({ base: "poormans" }),
          ecs.compo.saveLocal({
            ticketMemberCard0: true,
            located: true
          }),
          ecs.compo.grid0user({ defaultRecord: { size: [23, 14] } })
        ],
        details: "Ticket for generating MemberCard0"
      },
      WebSocket0: {
        hull: () => [
          ecs.compo.located({
            pos: [5, 5, 0],
            size: [8, 12]
          }),
          ecs.compo.connections(),
          ecs.compo.item({
            baseComponent: "WebSocket0"
          }),
          ecs.compo.websocketConfig(),
          ecs.compo.meta({
            type: "Dash",
            name: "Yehat Websocket MK 1"
          }),
          ecs.compo.saveLocal({
            websocketConfig: true,
            located: true,
            connections: true
          }),
          ecs.compo.dialog0(),
          ecs.compo.tier({ base: "premium" })
        ],
        details: "Sunlight WebSocket0"
      }
    },
    roster: {
      anVpN8Oqw5RLQMK4b8KCV1: {
        type: "Inventory0",
        meta: { name: "Local Inventory", type: "Inventory0", source: "B-00" },
        dialog0: { show: true }
      },
      useID: { type: "Slot0", slot0: { autoEject: true } }
    },
    meta: {
      name: "Source0",
      type: "Yehat JSON Container",
      version: "1.0",
      by: "[MemberCard KotoTheBest]",
      on: "[DryWare KotoSurf]",
      dtCreated: 1630536120,
      manual: true
    }
  };

  // yehat/sources/05-loader.js
  var import_pako = __toModule(require_pako());
  var loader_default = {
    compo: {
      loader0: {
        hull: {
          defs: [],
          roster: {},
          handlers: {},
          jackIn: (item) => async ({ client$, key, captureArgs }) => {
            const fullKey = `${client$}.${key}`;
            let client = null;
            while (true) {
              try {
                client = eval("(" + client$ + ")");
                if (!client)
                  throw "JackIn client is null.";
                break;
              } catch (e) {
                await core.ms(100);
              }
            }
            item.loader0.handlers[fullKey] = client[key];
            client[key] = (...a) => {
              if (!item.loader0.roster[fullKey])
                item.loader0.roster[fullKey] = [];
              const record = {
                dtStart: +new Date(),
                status: "working",
                iteration: item.loader0.roster[fullKey].length + 1
              };
              item.loader0.roster[fullKey].push(record);
              if (captureArgs) {
                record.args = [];
                captureArgs.map((specs, index) => {
                  if (specs === true) {
                    record.args[index] = a[index];
                  } else if (typeof specs === "string") {
                    record.args[index] = pure.EPGET(a[index], specs);
                  } else if (typeof specs === "object" && !(specs instanceof Array)) {
                    record.args[index] = {};
                    Object.entries(specs).map(([name, spec]) => record.args[index][name] = pure.EPGET(a[index], spec));
                  } else {
                    core.log(`[Loader0] Invalid capture specifier`, s);
                  }
                });
              }
              try {
                const result = item.loader0.handlers[fullKey](...a);
                Promise.resolve(result).then(() => {
                  record.dtEnd = +new Date();
                  record.time = record.dtEnd - record.dtStart;
                  record.status = "ok";
                });
                return result;
              } catch (e) {
                record.dtEnd = +new Date();
                record.time = record.dtEnd - record.dtStart;
                record.status = "fail";
                record.errorMessage = e.message;
                core.log(`[Loader0] Instrumented f() ${fullKey} has thrown the error`, e, "parameters: ");
                console.log(a);
                return null;
              }
            };
          },
          jackOut: (item) => ({ client$, key }) => {
            try {
              const client = eval("(" + client$ + ")");
              const fullKey = `${client$}.${key}`;
              client[key] = item.loader0.handlers[fullKey];
            } catch (e) {
              core.log(`[Loader0] jackOut ${client$} -- failed.`);
            }
          },
          instrumentAll: (item2) => () => {
            for (let def2 of item2.loader0.defs)
              item2.loader0.jackIn(def2);
          },
          retreat: (item2) => () => {
            for (let def2 of item2.loader0.defs)
              item2.loader0.jackOut(def2);
          },
          subjects: (item2) => computed(() => {
            return item2.loader0.defs.map((def2) => {
              const { client$: client$2, key: key2 } = def2;
              const fullKey2 = `${client$2}.${key2}`;
              let iterations = 0;
              if (item2.loader0.roster[fullKey2]) {
                return item2.loader0.roster[fullKey2].map((rec) => {
                  const resourceName = rec.args && rec.args.length ? rec.args[0].name || "?" : "";
                  return { caption: resourceName ? `${def2.name}: ${resourceName}` : def2.name, status: rec.status, time: rec.time, args: rec.args };
                });
              }
              return [{ caption: def2.name, status: "pending" }];
            }).reduce((a, v) => [...a, ...v], []);
          }),
          init: (item2) => {
            item2.loader0.instrumentAll();
            return void 0;
          }
        },
        details: "Loading Monitor MK 0 Car"
      }
    },
    types: {
      Loader0: {
        hull: () => [
          ecs.compo.loader0(),
          ecs.compo.meta({ type: "Loader0", name: "Loader Monitor" }),
          ecs.compo.located(),
          ecs.compo.grid0user({ detaultRecord: { size: [12, 21] } }),
          ecs.compo.item({ baseComponent: "Loader0" }),
          ecs.compo.dialog0()
        ],
        details: "Loading Monitor MK 0"
      }
    },
    roster: {
      AkjDtDXCoS5Dw7jCjsKJw7: {
        type: "Loader0",
        loader0: {
          handlers: {
            ecs: {
              bootSource: ecs.bootSource
            }
          },
          defs: [
            { name: "Static Sources", expectCount: 3, client: ecs, client$: "ecs", key: "bootSource", captureArgs: [{ name: "meta.name" }] },
            { name: "Artisans", expectCount: 1, client: ecs, client$: "ecs", key: "loadLocalInstances" },
            { name: "Dynamic Sources", expectCount: 1, client$: 'ecs.root["AVFZFAofQlnCk8OdYsOewo"].code1', key: "run" }
          ]
        }
      }
    },
    images: {},
    meta: {
      name: "Source1",
      type: "Yehat JSON Container",
      version: "1.0",
      by: "[MemberCard KotoTheBest]",
      on: "[DryWare KotoSurf]",
      dtCreated: 1633809670,
      manual: true
    }
  };

  // yehat/sources/20-source-norton.js
  var import_pako = __toModule(require_pako());
  var fromScreen = ([screenX, screenY]) => {
    const aspectX = window.innerWidth / 576;
    const aspectY = window.innerHeight / 320;
    const aspect = Math.min(aspectX, aspectY);
    return [screenX / aspect, screenY / aspect];
  };
  var overlap = (rectA, rectB) => !(rectB[0] >= rectA[0] + rectA[2] || rectB[0] + rectB[2] <= rectA[0] || rectB[1] >= rectA[1] + rectA[3] || rectB[1] + rectB[3] <= rectA[1]);
  var pxToNormalSize = (x, grid = [10, 4]) => {
    let size3 = 1;
    while ((size3 + 1) * grid[0] + (size3 - 1 + 1) * grid[1] <= x)
      size3++;
    return size3;
  };
  var { copyToClipboard: copyToClipboard2 } = Quasar;
  var source_norton_default = {
    compo: {
      space1: {
        hull: {
          grid: [10, 10, 4, 4],
          baseItemSize: [10, 15],
          pixelPosition: (item2) => (pos) => [
            pos[0] * (item2.space1.grid[0] + item2.space1.grid[2]),
            pos[1] * (item2.space1.grid[1] + item2.space1.grid[3])
          ],
          pixelSize: (item2) => (size3) => [
            size3[0] * item2.space1.grid[0] + (size3[0] - 1) * item2.space1.grid[2],
            size3[1] * item2.space1.grid[1] + (size3[1] - 1) * item2.space1.grid[3]
          ],
          project: (item2) => ([x, y]) => {
            const blockX = Math.floor(x / (item2.space1.grid[0] + item2.space1.grid[2]));
            const blockY = Math.floor(y / (item2.space1.grid[1] + item2.space1.grid[3]));
            return [blockX, blockY];
          }
        },
        details: "Gridspace Configuration"
      },
      space2: {
        hull: {
          grid: [10, 10, 4, 4],
          dims: [41, 20],
          baseItemSize: [10, 15],
          gridPixelSize: (item2) => computed(() => {
            return [
              item2.space2.dims[0] * item2.space2.grid[0] + (item2.space2.dims[0] - 1) * item2.space2.grid[2],
              item2.space2.dims[1] * item2.space2.grid[1] + (item2.space2.dims[1] - 1) * item2.space2.grid[3]
            ];
          }),
          fitAspect: (item2) => computed(() => {
            const p2 = item2.space2.gridPixelSize;
            const aspectX = window.innerWidth / p2[0];
            const aspectY = window.innerHeight / p2[1];
            const aspect = Math.min(aspectX, aspectY);
            return aspect;
          }),
          fitPixelSize: (item2) => computed(() => {
            const p2 = item2.space2.gridPixelSize;
            const aspect = item2.space2.fitAspect;
            return [
              Math.floor(p2[0] * aspect),
              Math.floor(p2[1] * aspect)
            ];
          }),
          fitGrid: (item2) => computed(() => {
            const p2 = item2.space2.fitPixelSize;
            const cellSize = [
              (p2[0] - (item2.space2.dims[0] - 1) * 4) / item2.space2.dims[0],
              (p2[1] - (item2.space2.dims[1] - 1) * 4) / item2.space2.dims[1]
            ];
            return [...cellSize, 4, 4];
          }),
          pixelPosition: (item2) => (pos) => {
            return [
              Math.floor(pos[0] * (item2.space2.fitGrid[0] + item2.space2.fitGrid[2])),
              Math.floor(pos[1] * (item2.space2.fitGrid[1] + item2.space2.fitGrid[3]))
            ];
          },
          pixelSize: (item2) => (size3) => {
            return [
              Math.floor(size3[0] * item2.space2.fitGrid[0] + (size3[0] - 1) * item2.space2.fitGrid[2]),
              Math.floor(size3[1] * item2.space2.fitGrid[1] + (size3[1] - 1) * item2.space2.fitGrid[3])
            ];
          },
          project: (item2) => ([sx, sy]) => {
            const [x, y] = fromScreen([sx, sy]);
            const blockX = Math.floor(x / (item2.space2.grid[0] + item2.space2.grid[2]));
            const blockY = Math.floor(y / (item2.space2.grid[1] + item2.space2.grid[3]));
            return [blockX, blockY];
          }
        },
        details: "Gridspace Desktop Configuration"
      },
      cmdLine0: {
        hull: {
          command: "",
          prompt: "[Yehat]>",
          buffer: [],
          focused: false,
          history: [],
          historyCursor: null,
          historyLimit: 256,
          eval: (item2) => (command) => {
            const commandMatch = /\[([^\[\]]*)\]>$/g.exec(command);
            let result = null;
            if (commandMatch) {
              const cmd = commandMatch[1];
              const hull = command.slice(0, commandMatch.index);
              core.log("[DRNorton0.cmdline0.eval]Matched command token", commandMatch);
              if (cmd === "v") {
                const result2 = new Function(...["app"], `console.log("app inside eval", app); return (${hull});`)(ecs.root.app);
                core.log(`[v]> VERBOSE typeof result = ${typeof result2}`);
                if (result2 instanceof Promise) {
                  result2.then((asyncResult) => {
                    item2.cmdLine0.buffer.push({ type: "result", caption: JSON.safeStringify(asyncResult) });
                  }).catch((e) => {
                    item2.cmdLine0.buffer.push({ type: "exception", caption: e.message || "Unknown Error" });
                  });
                } else {
                  item2.cmdLine0.buffer.push({ type: "result", caption: JSON.safeStringify(result2) });
                }
                return result2;
              } else if (cmd) {
                core.log(`[]> Unsupported output command ${cmd}`);
                return `Unsupported output command ${cmd}`;
              } else {
                console.log("Empty []> command => Standard-0 output, body:", hull);
                result = new Function(...["app"], `console.log("app inside eval", app); return (${hull});`)(ecs.root.app);
              }
            } else {
              result = new Function(...["app"], `console.log("app inside eval", app); return (${command});`)(ecs.root.app);
            }
            item2.cmdLine0.buffer.push({ type: "command", caption: item2.cmdLine0.prompt + command });
            if (result instanceof Promise) {
              item2.cmdLine0.buffer.push({ type: "result", caption: "[Promise]" });
              result.then((asyncResult) => {
                item2.cmdLine0.buffer.push({ type: "result", caption: pure.jsTypeToString(asyncResult) });
              }).catch((e) => {
                item2.cmdLine0.buffer.push({ type: "exception", caption: e.message || "Unknown Error" });
              });
            } else {
              item2.cmdLine0.buffer.push({ type: "result", caption: pure.jsTypeToString(result) });
            }
            return result;
          },
          enter: (item2) => async () => {
            const command = item2.cmdLine0.command.trim();
            if (!command)
              return;
            item2.cmdLine0.pushHistory(command);
            item2.cmdLine0.historyCursor = null;
            item2.cmdLine0.command = "";
            item2.saveLocal.save();
            const go = (id2) => {
              if (item2.drNorton0.activePanel == "mid") {
                item2.drNorton0.activePanel = "left";
                item2.drNorton0.showMenu = false;
              }
              item2.drNorton0.theActivePanel.at = id2;
              const entity = ecs.root[id2] || {};
              Quasar.Notify.create(`[${entity.type || "Unknown"} ${id2}]`);
            };
            try {
              const result = item2.cmdLine0.eval(command);
              item2.drNorton0.panels[item2.drNorton0.activePanel === "left" ? "right" : "left"].mode = "output";
            } catch (e) {
              item2.cmdLine0.command = "";
              item2.cmdLine0.buffer.push({ type: "command", caption: item2.cmdLine0.prompt + command });
              item2.cmdLine0.buffer.push({ type: "error", caption: "[Error]" + e.message });
              item2.drNorton0.panels[item2.drNorton0.activePanel === "left" ? "right" : "left"].mode = "output";
              throw e;
            }
          },
          keydown: (item2) => (e) => {
            const goEOL = () => {
              setTimeout(() => {
                if (item2.refs.input) {
                  item2.refs.input.selectionStart = item2.refs.input.selectionEnd = item2.cmdLine0.command.length;
                } else {
                  core.log("[DRNorton0.cmdLine0]No DRNorton0.refs.input => cursor passive");
                }
              }, 50);
            };
            if (e.code === "ArrowUp" && item2.cmdLine0.history.length) {
              if (item2.cmdLine0.historyCursor === null) {
                item2.cmdLine0.history = [item2.cmdLine0.command.trim(), ...item2.cmdLine0.history];
                item2.cmdLine0.historyCursor = 1;
                item2.cmdLine0.command = item2.cmdLine0.history[1];
                goEOL();
                core.log("[DRNorton0.cmdLine0]History UP historyCursor = ", item2.cmdLine0.historyCursor);
              } else if (item2.cmdLine0.historyCursor < item2.cmdLine0.history.length - 1) {
                item2.cmdLine0.history[item2.cmdLine0.historyCursor] = item2.cmdLine0.command;
                item2.cmdLine0.historyCursor++;
                item2.cmdLine0.command = item2.cmdLine0.history[item2.cmdLine0.historyCursor];
                goEOL();
                core.log("[DRNorton0.cmdLine0]History UP historyCursor = ", item2.cmdLine0.historyCursor);
              } else {
                core.Notify.create("Top of history buffer.");
              }
            }
            if (e.code === "ArrowDown" && item2.cmdLine0.history.length) {
              if (item2.cmdLine0.historyCursor) {
                item2.cmdLine0.history[item2.cmdLine0.historyCursor] = item2.cmdLine0.command;
                item2.cmdLine0.historyCursor--;
                item2.cmdLine0.command = item2.cmdLine0.history[item2.cmdLine0.historyCursor];
                goEOL();
                core.log("[DRNorton0]History DOWN historyCursor = ", item2.cmdLine0.historyCursor);
              } else {
                core.Notify.create("Bottom of history buffer.");
              }
            }
          },
          pushHistory: (item2) => (v) => item2.cmdLine0.history = [v, ...item2.cmdLine0.history].slice(0, item2.cmdLine0.historyLimit),
          insert: (item2) => (s2) => {
            const target2 = item2.refs.input;
            if (s2 == 0) {
              return;
            }
            let startPos = target2.selectionStart;
            let endPos = target2.selectionEnd;
            let cursorPos = startPos;
            let tmpStr = target2.value;
            const txtContent = tmpStr.substring(0, startPos) + s2 + tmpStr.substring(endPos, tmpStr.length);
            item2.cmdLine0.command = txtContent;
            setTimeout(() => {
              cursorPos += s2.length;
              target2.selectionStart = target2.selectionEnd = cursorPos;
              target2.focus();
            }, 10);
          }
        },
        details: "DRNorton0 Command Line 0"
      },
      drNorton0: {
        hull: {
          activePanel: "left",
          panels: {},
          showHistory: false,
          rShowMenu: false,
          menuItems: [],
          showMenu: (item2) => computed({
            get: () => item2.drNorton0.rShowMenu,
            set: (v) => {
              item2.drNorton0.rShowMenu = v;
              if (!v && item2.drNorton0.activePanel === "mid") {
                console.log("Jump back: ", item2.drNorton0.panels.mid.back);
                item2.drNorton0.activePanel = item2.drNorton0.panels.mid.back;
              }
              return true;
            }
          }),
          theActivePanel: (item2) => computed(() => item2.drNorton0.panels[item2.drNorton0.activePanel]),
          panelItems: (item2) => (panel) => {
            return computed(() => {
              if (panel === "mid") {
                const token2 = item2.drNorton0.panels.mid.search || "";
                if (!token2.trim())
                  return item2.drNorton0.menuItems;
                const items = item2.drNorton0.menuItems.filter((v) => !!~v.caption.toLowerCase().indexOf(token2.trim().toLowerCase()));
                if (item2.drNorton0.panels.mid.cursor >= items.length) {
                  item2.drNorton0.panels.mid.cursor = items.length ? items.length - 1 : null;
                }
                return items;
              }
              const enitiesSource = item2.drNorton0.panels[panel].at ? ecs.find((v) => v.located && v.located.rel === item2.drNorton0.panels[panel].at) : ecs.find((v) => v.type === "Project" || v.type === "Inventory0" || v.located && v.located.rel === null);
              const ar = enitiesSource.sort((a, b) => {
                const z1 = (a.type || "Unknown").localeCompare(b.type || "Unknown");
                if (z1)
                  return z1;
                const z2 = pure.itemName(a).localeCompare(pure.itemName(b));
                return z2;
              }).map((x) => {
                return { id: x.id, caption: pure.itemToken(x) };
              });
              const box = item2.drNorton0.panels[panel].at ? ecs.root[item2.drNorton0.panels[panel].at] : null;
              const output2 = [
                ...box && box.located ? [{ id: box.located.rel, caption: ".." }] : [
                  { id: null, caption: "<< [Projects]" }
                ],
                ...ar
              ];
              item2.drNorton0.panels[panel].count = output2.length;
              return output2;
            });
          },
          entity: (item2) => computed(() => {
            const pan = item2.drNorton0.theActivePanel;
            if (!pan)
              return;
            if (pan.cursor === 0)
              return ecs.root[pan.at];
            if (item2.drNorton0.panelItems(item2.drNorton0.activePanel).value[pan.cursor]) {
              return ecs.root[item2.drNorton0.panelItems(item2.drNorton0.activePanel).value[pan.cursor].id];
            } else {
              core.log(`[DRNorton0]Out of bounds? entity computation for cursor ${pan.cursor}, stack size ${item2.drNorton0.panelItems(item2.drNorton0.activePanel).value.length}`);
              return null;
            }
          }),
          getActiveEntity: (item2) => (panel) => {
            const pan = item2.drNorton0.panels[panel];
            if (pan.cursor === 0)
              return ecs.root[pan.at];
            const record = item2.drNorton0.panelItems(panel).value[pan.cursor];
            if (record) {
              return ecs.root[record.id];
            } else {
              return null;
            }
          },
          moveDown: (item2) => (panel = null) => {
            const pan = panel ? item2.drNorton0.panels[panel] : item2.drNorton0.theActivePanel;
            if (pan.cursor < pan.count - 1) {
              pan.cursor++;
              item2.drNorton0.keepCursorInView(pan.name);
              return true;
            } else {
              return false;
            }
          },
          moveUp: (item2) => (panel = null) => {
            const pan = panel ? item2.drNorton0.panels[panel] : item2.drNorton0.theActivePanel;
            if (pan.cursor > 0) {
              pan.cursor--;
              item2.drNorton0.keepCursorInView(pan.name);
              return true;
            } else {
              return false;
            }
          },
          openActiveItem: (item2) => () => {
            const entity = item2.drNorton0.entity;
            if (entity) {
              ecs.root.app.app0.renderItems[entity.id] = true;
              const grid = entity.grid0user && entity.grid0user.gridID ? ecs.root[entity.grid0user.gridID] : ecs.root[item2.grid0user.gridID];
              grid.grid0.deploy(ecs.root[entity.id]);
              if (ecs.root[entity.id].type === "Inventory0") {
                item2.c.grid.grid0.manage({ id: entity.id, edge: "s" });
              } else if (~["Code1"].indexOf(ecs.root[entity.id].type)) {
                item2.c.grid.grid0.manage({ id: entity.id, attach: item2.id, dir: "a", follow: true });
              } else {
                item2.c.grid.grid0.manage({ id: entity.id, attach: item2.id, dir: "w", follow: true });
              }
              item2.attention0.pass(entity);
              return true;
            } else {
              return false;
            }
          },
          box: (item2) => () => {
            const selection = item2.drNorton0.theActivePanel.selection;
            const entity = item2.drNorton0.entity;
            if (!selection.length && !entity) {
              Quasar.Notify.create("Nothing to box.");
              return;
            }
            const items = selection.length ? selection.map((id2) => ecs.root[id2]) : [entity];
            const { roster, stat } = ecs.box(items);
            console.log("Roster:", roster);
            console.table(stat);
            const json = JSON.stringify({
              roster,
              stat,
              meta: {
                name: "Cargo1",
                type: "Yehat JSON Container",
                version: "1.0",
                by: core.yehat.auth.memberID,
                on: localStorage.deviceID,
                dtCreated: +new Date()
              }
            });
            let ok = true;
            copyToClipboard2(json).then(() => {
              Quasar.Notify.create(`${Quasar.format.humanStorageSize(json.length)} coppied.`);
            }).catch((e) => {
              Quasar.Notify.create("Clipboard copy error.");
              ok = false;
            });
            return ok;
          },
          erase: (item2) => () => {
            const selection = item2.drNorton0.theActivePanel.selection;
            const entity = item2.drNorton0.entity;
            if (!selection.length && !entity) {
              Quasar.Notify.create("Nothing to delete.");
              return false;
            }
            const items = selection.length ? [...selection] : [entity.id];
            if (!item2.connections.eraser) {
              const eraser = ecs.create("Eraser0");
              item2.connections.eraser = eraser.id;
              ecs.root.app.app0.renderItems[eraser.id] = true;
            }
            item2.c.eraser.eraser0.items = items;
            item2.c.eraser.dialog0.show = true;
            item2.attention0.pass(item2.c.eraser);
            return true;
          },
          seek: (item2) => ({ panel, id: id2 }) => {
            const index = item2.drNorton0.panelItems(panel).value.findIndex((v) => v.id === id2);
            if (~index)
              item2.drNorton0.panels[panel].cursor = index;
          },
          keepCursorInView: (item2) => (panel) => {
            if (item2.refs[panel]) {
              item2.refs[panel].cursorTo(item2.drNorton0.panels[panel].cursor);
            }
          }
        },
        details: "DRNorton0 State"
      },
      "grid0": {
        hull: {
          roster: {},
          selected: [],
          level: 0,
          scale: "screen0",
          size: [41, 20],
          resizeToScreen: (item2) => () => {
            const winSize = [window.innerWidth, window.innerHeight];
            item2.grid0.size = [pxToNormalSize(winSize[0]), pxToNormalSize(winSize[1])];
            console.log("winSize", winSize, "gridsize", item2.grid0.size);
          },
          isRectOverlap: (item2) => (rect, opts) => {
            const { skip = [] } = opts || {};
            for (let index in item2.grid0.roster) {
              let { pos, size: size3 } = item2.grid0.roster[index];
              if (~skip.indexOf(index))
                continue;
              if (overlap(rect, [pos[0], pos[1], size3[0], size3[1]])) {
                core.log(`[Grid0] isRectOverlap ${rect[0]}, ${rect[1]} ${rect[2]}x${rect[3]} with ${index} @ ${pos[0]}, ${pos[1]} ${size3[0]}x${size3[1]} !skiping [ ${skip.join(" ")} ]`);
                return true;
              }
            }
            return false;
          },
          waila: (item2) => (x, y) => {
            for (let index in item2.grid0.roster) {
              let { pos, size: size3 } = item2.grid0.roster[index];
              if (x >= pos[0] && x < pos[0] + size3[0] && y >= pos[1] && y < pos[1] + size3[1])
                return index;
            }
            return null;
          },
          manage: (item2) => ({ id: id2, attach, dir, follow = false, column = null, nextTo, edge, center }) => {
            if (!id2)
              throw `[Grid0] manage with no ID not supported.`;
            if (attach) {
              const delegate = ecs.root[id2];
              const masterPos = item2.grid0.roster[attach].pos;
              const masterSize = item2.grid0.roster[attach].size;
              const delegateSize = item2.grid0.roster[id2] ? item2.grid0.roster[id2].size : ecs.root[id2].grid0user.defaultRecord.size;
              if (dir === "w") {
                const proposedPos = [masterPos[0], masterPos[1] - delegateSize[1]];
                while (item2.grid0.isRectOverlap([proposedPos[0], proposedPos[1], delegateSize[0], delegateSize[1]], { skip: [id2] })) {
                  proposedPos[0]++;
                  if (proposedPos[0] > 100) {
                    core.log(`[Grid0] Proposed position overflow.`);
                    break;
                  }
                }
                const ppos = item2.space2.pixelPosition(proposedPos);
                const psize = item2.space2.pixelSize(delegateSize);
                core.log(`[Grid0] Proposed pos ${proposedPos[0]}, ${proposedPos[1]} size ${delegateSize[0]}, ${delegateSize[1]}`);
                core.log(`[Grid0] Pixel pos ${ppos[0]}, ${ppos[1]} size ${psize[0]}, ${psize[1]}`);
                core.log(`[Grid0] Master pos ${masterPos[0]}, ${masterPos[1]} size ${masterSize[0]}, ${masterSize[1]}`);
                if (!item2.grid0.roster[id2])
                  item2.grid0.roster[id2] = { size: [...delegateSize] };
                item2.grid0.roster[id2].pos = [...proposedPos];
                item2.grid0.roster[id2].master = attach;
                item2.grid0.roster[id2].dir = dir;
                const hang = proposedPos[0] + delegateSize[0] - (masterPos[0] + masterSize[0]);
                core.log(`[Grid0] Manage "attach" successfull, hang = ${hang}.`);
                if (follow) {
                  const xDelta = proposedPos[0] - masterPos[0];
                  for (let index in item2.grid0.roster) {
                    let record = item2.grid0.roster[index];
                    if (record.master === attach && record.dir === "w") {
                      record.pos[0] -= xDelta;
                    }
                  }
                }
              }
              if (dir === "s") {
                const proposedPos = [masterPos[0], masterPos[1] + masterSize[1]];
                while (item2.grid0.isRectOverlap([proposedPos[0], proposedPos[1], delegateSize[0], delegateSize[1]], { skip: [id2] })) {
                  proposedPos[0]++;
                  if (proposedPos[0] > 100) {
                    core.log(`[Grid0] Proposed position overflow.`);
                    break;
                  }
                }
                const ppos = item2.space2.pixelPosition(proposedPos);
                const psize = item2.space2.pixelSize(delegateSize);
                core.log(`[Grid0] Proposed pos ${proposedPos[0]}, ${proposedPos[1]} size ${delegateSize[0]}, ${delegateSize[1]}`);
                core.log(`[Grid0] Pixel pos ${ppos[0]}, ${ppos[1]} size ${psize[0]}, ${psize[1]}`);
                core.log(`[Grid0] Master pos ${masterPos[0]}, ${masterPos[1]} size ${masterSize[0]}, ${masterSize[1]}`);
                if (!item2.grid0.roster[id2])
                  item2.grid0.roster[id2] = { size: [...delegateSize] };
                item2.grid0.roster[id2].pos = [...proposedPos];
                item2.grid0.roster[id2].master = attach;
                item2.grid0.roster[id2].dir = dir;
                const hang = proposedPos[0] + delegateSize[0] - (masterPos[0] + masterSize[0]);
                core.log(`[Grid0] Manage "attach" successfull, hang = ${hang}.`);
                if (follow) {
                  const xDelta = proposedPos[0] - masterPos[0];
                  for (let index in item2.grid0.roster) {
                    let record = item2.grid0.roster[index];
                    if (record.master === attach && record.dir === "w") {
                      record.pos[0] -= xDelta;
                    }
                  }
                }
              }
              if (dir === "a") {
                const proposedPos = [masterPos[0] - delegateSize[0], masterPos[1]];
                console.log("proposed", proposedPos);
                while (item2.grid0.isRectOverlap([proposedPos[0], proposedPos[1], delegateSize[0], delegateSize[1]], { skip: [id2] })) {
                  console.log("shift", proposedPos[1]);
                  proposedPos[1]++;
                  if (proposedPos[1] > 100) {
                    core.log(`[Grid0] Proposed position overflow.`);
                    break;
                  }
                }
                const ppos = item2.space2.pixelPosition(proposedPos);
                const psize = item2.space2.pixelSize(delegateSize);
                core.log(`[Grid0] Proposed pos ${proposedPos[0]}, ${proposedPos[1]} size ${delegateSize[0]}, ${delegateSize[1]}`);
                core.log(`[Grid0] Pixel pos ${ppos[0]}, ${ppos[1]} size ${psize[0]}, ${psize[1]}`);
                core.log(`[Grid0] Master pos ${masterPos[0]}, ${masterPos[1]} size ${masterSize[0]}, ${masterSize[1]}`);
                if (!item2.grid0.roster[id2])
                  item2.grid0.roster[id2] = { size: [...delegateSize] };
                item2.grid0.roster[id2].pos = [...proposedPos];
                item2.grid0.roster[id2].master = attach;
                item2.grid0.roster[id2].dir = dir;
                const hang = proposedPos[1] + delegateSize[1] - (masterPos[1] + masterSize[1]);
                core.log(`[Grid0] Manage "attach" successfull, hang = ${hang}.`);
                if (follow) {
                  const yDelta = proposedPos[1] - masterPos[1];
                  for (let index in item2.grid0.roster) {
                    let record = item2.grid0.roster[index];
                    if (record.master === attach && record.dir === "a") {
                      record.pos[1] -= yDelta;
                    }
                  }
                }
              }
            } else if (column !== null) {
              const targetY = typeof column === "number" ? column : item2.grid0.roster[column].pos[1];
              const record = item2.grid0.roster[id2];
              const a = [];
              for (let index in item2.grid0.roster) {
                if (item2.grid0.roster[index].pos[0] === record.pos[0])
                  a.push(index);
              }
              const deltaY = targetY - record.pos[1];
              a.map((index) => {
                item2.grid0.roster[index].pos[1] += deltaY;
              });
              core.log(`[Grid0] Manage "column" successfull, scroll by = ${deltaY}.`);
            } else if (nextTo) {
              const delegate = ecs.root[id2];
              const masterPos = item2.grid0.roster[nextTo].pos;
              const masterSize = item2.grid0.roster[nextTo].size;
              const delegateSize = item2.grid0.roster[id2] ? item2.grid0.roster[id2].size : ecs.root[id2].grid0user.defaultRecord.size;
              const delegatePos = [
                dir === "a" ? masterPos[0] - delegateSize[0] : dir === "d" ? masterPos[0] + masterSize[0] : masterPos[0],
                dir === "w" ? masterPos[1] - delegateSize[1] : dir === "s" ? masterPos[1] + masterSize[1] : masterPos[1]
              ];
              item2.grid0.roster[id2].pos = [...delegatePos];
              core.log(`[Grid0] Master pos ${masterPos[0]}, ${masterPos[1]} size ${masterSize[0]}, ${masterSize[1]}`);
              core.log(`[Grid0] Direction: ${dir}`);
              core.log(`[Grid0] Proposed pos ${delegatePos[0]}, ${delegatePos[1]} size ${delegateSize[0]}, ${delegateSize[1]}`);
              let xDemandMin = Infinity, xDemandMax = -Infinity, yDemandMin = Infinity, yDemandMax = -Infinity;
              for (let index in item2.grid0.roster) {
                let record = item2.grid0.roster[index];
                if (index === "id" || index === nextTo)
                  continue;
                let xDemand, yDemand;
                if (dir === "d" && record.pos[0] >= delegatePos[0] + delegateSize[0] && !(record.pos[1] + record.size[1] <= delegatePos[1]) && !(record.pos[1] >= delegatePos[1] + delegateSize[1])) {
                  xDemand = Math.min(delegatePos[0] - record.pos[0] + delegateSize[0], 0);
                  xDemandMin = Math.min(xDemandMin, xDemand);
                  xDemandMax = Math.max(xDemandMax, xDemand);
                }
                if (dir === "a" && record.pos[0] + record.size[0] >= delegatePos[0] && !(record.pos[1] + record.size[1] <= delegatePos[1]) && !(record.pos[1] >= delegatePos[1] + delegateSize[1])) {
                  xDemand = -Math.min(delegatePos[0] - record.pos[0] - record.size[0], 0);
                  xDemandMin = Math.min(xDemandMin, xDemand);
                  xDemandMax = Math.max(xDemandMax, xDemand);
                }
                if (dir === "s" && record.pos[1] >= delegatePos[1] + delegateSize[1] && !(record.pos[0] + record.size[0] < delegatePos[0]) && !(record.pos[0] > delegatePos[0] + delegateSize[0])) {
                  yDemand = Math.min(delegatePos[1] - record.pos[1] + delegateSize[1], 0);
                  yDemandMin = Math.min(yDemandMin, yDemand);
                  yDemandMax = Math.max(yDemandMax, yDemand);
                }
                if (dir === "w" && record.pos[1] + record.size[1] <= delegatePos[1] && !(record.pos[0] + record.size[0] < delegatePos[0]) && !(record.pos[0] > delegatePos[0] + delegateSize[0])) {
                  yDemand = -Math.min(delegatePos[1] - record.pos[1] - record.size[1], 0);
                  yDemandMin = Math.min(yDemandMin, yDemand);
                  yDemandMax = Math.max(yDemandMax, yDemand);
                }
              }
              let c = 0;
              for (let index in item2.grid0.roster) {
                let record = item2.grid0.roster[index];
                if (index === "id" || index === nextTo)
                  continue;
                if (dir === "d" && record.pos[0] >= delegatePos[0] + delegateSize[0] && !(record.pos[1] + record.size[1] < delegatePos[1]) && !(record.pos[1] > delegatePos[1] + delegateSize[1])) {
                  record.pos[0] += xDemandMax;
                  c++;
                }
                if (dir === "a" && record.pos[0] + record.size[0] >= delegatePos[0] && !(record.pos[1] + record.size[1] < delegatePos[1]) && !(record.pos[1] > delegatePos[1] + delegateSize[1])) {
                  record.pos[0] += xDemandMin;
                  c++;
                }
                if (dir === "s" && record.pos[1] >= delegatePos[1] + delegateSize[1] && !(record.pos[0] + record.size[0] < delegatePos[0]) && !(record.pos[0] > delegatePos[0] + delegateSize[0])) {
                  record.pos[1] += yDemandMax;
                  c++;
                }
                if (dir === "w" && record.pos[1] + record.size[1] <= delegatePos[1] && !(record.pos[0] + record.size[0] < delegatePos[0]) && !(record.pos[0] > delegatePos[0] + delegateSize[0])) {
                  record.pos[1] += yDemandMin;
                  c++;
                }
              }
              const useShift = {
                w: yDemandMin,
                a: xDemandMin,
                s: yDemandMax,
                d: xDemandMax
              };
              core.log(`[Grid0] Manage "nextTo" successfull, widgets shifted ${c} scroll by = ${useShift[dir]}.`);
            } else if (edge) {
              const delegate = ecs.root[id2];
              const delegateSize = item2.grid0.roster[id2] ? item2.grid0.roster[id2].size : ecs.root[id2].grid0user.defaultRecord.size;
              const gridSize = item2.grid0.size;
              const delegatePos = [
                ~["a", "q", "z"].indexOf(edge) ? 0 : ~["e", "d", "c"].indexOf(edge) ? gridSize[0] - delegateSize[0] : Math.floor((gridSize[0] - delegateSize[0]) / 2),
                ~["q", "w", "e"].indexOf(edge) ? 0 : ~["z", "s", "c"].indexOf(edge) ? gridSize[1] - delegateSize[1] : Math.floor((gridSize[1] - delegateSize[1]) / 2)
              ];
              item2.grid0.roster[id2].pos = [...delegatePos];
              core.log(`[Grid0] Manage "edge" successfull, direction = ${edge}. Delegate at: ${delegatePos}`, gridSize[1], delegateSize[1]);
            } else if (center) {
              const delegate = ecs.root[id2];
              const delegateSize = item2.grid0.roster[id2] ? item2.grid0.roster[id2].size : ecs.root[id2].grid0user.defaultRecord.size;
              const delegatePos = item2.grid0.roster[id2] ? item2.grid0.roster[id2].pos : ecs.root[id2].grid0user.defaultRecord.pos;
              const gridSize = item2.grid0.size;
              const newPos = [
                Math.floor((gridSize[0] - delegateSize[0]) / 2),
                Math.floor((gridSize[1] - delegateSize[1]) / 2)
              ];
              const delta = [
                newPos[0] - delegatePos[0],
                newPos[1] - delegatePos[1]
              ];
              Object.values(item2.grid0.roster).map((record) => {
                record.pos[0] += delta[0];
                record.pos[1] += delta[1];
              });
              core.log(`[Grid0] Manage "center" successfull. Delegate at: ${newPos}.`);
            } else {
              core.log("[Grid0] Unsupported `manage` call.");
            }
          },
          prune: (item2) => ({ keep = [] } = {}) => {
            let c = 0, k2 = 0;
            for (let key2 in item2.grid0.roster) {
              if (~keep.indexOf(key2)) {
                k2++;
                continue;
              }
              delete item2.grid0.roster[key2];
              c++;
            }
            item2.saveLocal.save();
            core.log(`[Grid0] prune ${c} removed ${k2} kept.`);
          },
          deploy: (item2) => (widget) => {
            if (!widget)
              return;
            if (!widget.grid0user) {
              ecs.addComponent(widget, ecs.compo.grid0user({
                gridID: item2.id,
                defaultRecord: { size: [10, 15], pos: [0, 0] }
              }));
            } else {
              widget.grid0user.gridID = item2.id;
            }
            if (widget.dialog0)
              widget.dialog0.show = true;
            if (!item2.grid0.roster[widget.id])
              item2.grid0.roster[widget.id] = {
                pos: [...widget.grid0user.defaultRecord.pos],
                size: [...widget.grid0user.defaultRecord.size]
              };
            console.log("deployed", item2.grid0.roster[widget.id]);
          },
          dismiss: (item2) => (widget) => {
            const record = item2.grid0.roster[widget.id];
            if (record) {
              if (record.master && record.dir === "a") {
                let maxY = -Infinity;
                for (let index in item2.grid0.roster) {
                  let record2 = item2.grid0.roster[index];
                  if (index !== widget.id && record2.master === record2.master && record2.dir === "a") {
                    maxY = Math.max(maxY, record2.pos[1]);
                  }
                }
                if (maxY != -Infinity) {
                  const deltaY = item2.grid0.roster[record.master].pos[1] - maxY;
                  for (let index in item2.grid0.roster) {
                    let record2 = item2.grid0.roster[index];
                    if (index !== widget.id && record2.master === record2.master && record2.dir === "a") {
                      record2.pos[1] += deltaY;
                    }
                  }
                  core.log(`[Grid0]Dismiss Master rollback by dY=${deltaY}`);
                }
              } else if (record.master && record.dir === "w") {
                let maxX = -Infinity;
                for (let index in item2.grid0.roster) {
                  let record2 = item2.grid0.roster[index];
                  if (index !== widget.id && record2.master === record2.master && record2.dir === "w") {
                    maxX = Math.max(maxX, record2.pos[0]);
                  }
                }
                if (maxX !== -Infinity) {
                  const deltaX = item2.grid0.roster[record.master].pos[0] - maxX;
                  for (let index in item2.grid0.roster) {
                    let record2 = item2.grid0.roster[index];
                    if (index !== widget.id && record2.master === record2.master && record2.dir === "w") {
                      record2.pos[0] += deltaX;
                    }
                  }
                  core.log(`[Grid0]Dismiss Master rollback by dX=${deltaX}`);
                }
              }
              delete item2.grid0.roster[widget.id];
              item2.saveLocal.save();
            }
          },
          affectedNodes: (item2) => (id2) => {
            const afnRecursive0 = (id3) => {
              const a = Object.entries(item2.grid0.roster).filter(([index, record]) => record.master === id3);
              return a.map(([index, record]) => {
                return [index, ...afnRecursive0(index)];
              }).reduce((a2, v) => [...a2, ...v], []);
            };
            return afnRecursive0(id2);
          },
          move: (item2) => (widget, targetPos) => {
            let prevPos = [...item2.grid0.roster[widget.id].pos];
            item2.grid0.roster[widget.id].pos = [targetPos[0], targetPos[1]];
            let delta = [targetPos[0] - prevPos[0], targetPos[1] - prevPos[1]];
            for (let id2 of item2.grid0.affectedNodes(widget.id)) {
              item2.grid0.roster[id2].pos[0] += delta[0];
              item2.grid0.roster[id2].pos[1] += delta[1];
            }
          }
        },
        details: "Grid Component, add to something to make it a ZII Table 5 grid."
      }
    },
    types: {
      DRNorton0: {
        hull: () => [
          ecs.compo.drNorton0({
            panels: {
              left: { name: "left", at: "OsKSbXXCr8KZRcK2woXChc", cursor: 0, mode: "panel", count: 0, selection: [], target: {} },
              right: { name: "right", at: "OsKSbXXCr8KZRcK2woXChc", cursor: 0, mode: "panel", count: 0, selection: [], target: {} },
              mid: { name: "mid", at: null, cursor: 0, mode: "menu", count: 0, selection: [], search: "", target: {}, back: "left" }
            }
          }),
          ecs.compo.cmdLine0(),
          ecs.compo.dialog0(),
          ecs.compo.meta({ type: "Dialog", name: "Dear Norton MK 0" }),
          ecs.compo.connections({ webapp: null, grid: null }),
          ecs.compo.located({ rel: "OsKSbXXCr8KZRcK2woXChc" }),
          ecs.compo.grid0user({
            gridID: null,
            defaultRecord: { size: [25, 12], pos: [10, 8] }
          }),
          ecs.compo.saveLocal({
            cmdLine0: ["command", "history"]
          }),
          ecs.compo.space2({}),
          ecs.compo.item({
            baseComponent: "DRNorton0"
          }),
          ecs.compo.refs({
            input: null
          }),
          ecs.compo.keyboardUser0({
            bindings: [
              { keyExpression: (v) => v.code === "ArrowUp", keyDown: "<[up]" },
              { keyExpression: (v) => v.code === "ArrowDown", keyDown: "<[down]" },
              { keyExpression: (v) => ~["Enter", "NumpadEnter"].indexOf(v.code) && !v.shiftKey && !v.ctrlKey, keyDown: "<[]" },
              { keyExpression: (v) => ~["Enter", "NumpadEnter"].indexOf(v.code) && v.shiftKey && !v.ctrlKey, keyDown: "<[open]" },
              { keyExpression: (v) => ~["Enter", "NumpadEnter"].indexOf(v.code) && !v.shiftKey && v.ctrlKey, keyDown: "<[get]" },
              { keyExpression: (v) => ~["Space"].indexOf(v.code) && !v.shiftKey, keyDown: "<[open]" },
              { keyExpression: (v) => v.code === "Tab" && v.shiftKey, keyDown: "<[prev]" },
              { keyExpression: (v) => v.code === "Tab" && !v.shiftKey, keyDown: "<[next]" },
              { keyExpression: (v) => v.code === "F2" && !v.shiftKey, keyDown: "<[toggleMenu]" },
              { keyExpression: (v) => v.code === "F3" && !v.shiftKey, keyDown: "<[view]" },
              { keyExpression: (v) => v.code === "F4" && !v.shiftKey, keyDown: "<[edit]" },
              { keyExpression: (v) => v.code === "F5" && !v.shiftKey, keyDown: "<[box]" },
              { keyExpression: (v) => v.code === "F7" && !v.shiftKey, keyDown: "<[goCreate]" },
              { keyExpression: (v) => v.code === "F8" && !v.shiftKey, keyDown: "<[delete]" },
              { keyExpression: (v) => v.code === "Insert" && !v.shiftKey, keyDown: "<[toggleSelect]" },
              { keyExpression: (v) => v.code === "Escape" && !v.shiftKey, keyDown: "<[back]" }
            ]
          }),
          ecs.compo.attention0({}),
          ecs.compo.actions({
            bang: (item2) => () => {
              const items = ["left", "right", "mid"].map((panel) => item2.drNorton0.panelItems(panel));
              const record = item2.drNorton0.activePanel === "left" ? items[0].value[item2.drNorton0.panels.left.cursor] : item2.drNorton0.activePanel === "right" ? items[1].value[item2.drNorton0.panels.right.cursor] : items[2].value[item2.drNorton0.panels.mid.cursor];
              console.log("enter on record", record, item2.drNorton0.activePanel);
              if (~["left", "right"].indexOf(item2.drNorton0.activePanel)) {
                const currentBoxID = item2.drNorton0.panels[item2.drNorton0.activePanel].at;
                item2.drNorton0.panels[item2.drNorton0.activePanel].at = record.id;
                const index = items[item2.drNorton0.activePanel == "left" ? 0 : 1].value.findIndex((v) => v.id === currentBoxID);
                item2.drNorton0.panels[item2.drNorton0.activePanel].cursor = ~index ? index : 0;
              } else if (item2.drNorton0.activePanel == "mid") {
                console.log("Create?", record.type);
                if (record.type === "new-type") {
                  item2.actions.createNewType();
                } else {
                  item2.actions.createNew(record.id);
                }
              }
              return true;
            },
            down: (item2) => () => {
              const keepCursorInView = () => {
                if (item2.refs[item2.drNorton0.activePanel]) {
                  item2.refs[item2.drNorton0.activePanel].cursorTo(item2.drNorton0.theActivePanel.cursor);
                }
              };
              if (item2.drNorton0.moveDown()) {
                keepCursorInView();
              }
              return true;
            },
            up: (item2) => () => {
              const keepCursorInView = () => {
                if (item2.refs[item2.drNorton0.activePanel]) {
                  item2.refs[item2.drNorton0.activePanel].cursorTo(item2.drNorton0.theActivePanel.cursor);
                }
              };
              if (item2.drNorton0.moveUp()) {
                keepCursorInView();
              }
              return true;
            },
            next: (item2) => () => {
              if (item2.drNorton0.activePanel === "left") {
                item2.drNorton0.activePanel = "right";
                return true;
              }
              if (item2.drNorton0.activePanel === "right") {
                item2.drNorton0.activePanel = "left";
                return true;
              }
              if (item2.drNorton0.activePanel === "mid") {
                item2.drNorton0.activePanel = item2.drNorton0.panels.mid.back;
                item2.drNorton0.showMenu = false;
                return true;
              }
            },
            prev: (item2) => () => {
              if (item2.drNorton0.activePanel === "left") {
                item2.drNorton0.activePanel = "right";
                return true;
              }
              if (item2.drNorton0.activePanel === "right") {
                item2.drNorton0.activePanel = "left";
                return true;
              }
              if (item2.drNorton0.activePanel === "mid") {
                item2.drNorton0.activePanel = item2.drNorton0.panels.mid.back;
                item2.drNorton0.showMenu = false;
                return true;
              }
            },
            goCreate: (item2) => () => {
              item2.drNorton0.menuItems = [
                { id: "NewType", caption: "- Declare a new Type -", type: "new-type" },
                ...Object.entries(ecs.typeopedia).map((v) => {
                  return { id: v[0], caption: v[0], payload: v[1], type: "type" };
                }).sort((a, b) => a.caption.localeCompare(b.caption))
              ];
              item2.drNorton0.panels.mid.count = item2.drNorton0.menuItems.length;
              item2.drNorton0.showMenu = true;
              if (item2.drNorton0.activePanel != "mid")
                item2.drNorton0.panels.mid.back = item2.drNorton0.activePanel;
              item2.drNorton0.activePanel = "mid";
              nextTick(() => {
                if (item2.refs.menuSearch)
                  item2.refs.menuSearch.focus();
              });
              return true;
            },
            open: (item2) => () => {
              return item2.drNorton0.openActiveItem();
            },
            createNew: (item2) => (type2) => {
              const entity = ecs.create(type2);
              const keys = Object.keys(entity);
              core.log("[DRNorton0] Created Entity", entity);
              if (entity.located) {
                entity.located.rel = item2.drNorton0.panels[item2.drNorton0.panels.mid.back].at;
                console.log("created at", entity.located.rel);
                if (entity.saveLocal) {
                  entity.saveLocal.save();
                  Quasar.Notify.create(`[${entity.type || "Unknown"} ${entity.id}] Saved Locally`);
                } else {
                  Quasar.Notify.create(`[${entity.type || "Unknown"} ${entity.id}] @${item2.drNorton0.theActivePanel.at}`);
                }
              } else {
                Quasar.Notify.create(`Created [${entity.type || "Unknown"} ${entity.id}]: ${keys.join(" ")}`);
              }
              ;
            },
            createNewType: (item2) => () => {
              console.log("Create new type.");
              if (item2.connections.typeEdit0) {
                item2.c.typeEdit0.typeEdit0.name = "";
                item2.c.typeEdit0.typeEdit0.hull = {};
                item2.c.typeEdit0.typeEdit0.details = "";
                item2.c.typeEdit0.dialog0.show = true;
                item2.c.grid.grid0.deploy(item2.c.typeEdit0);
                item2.c.grid.grid0.manage({ id: item2.c.typeEdit0.id, attach: item2.id, dir: "w" });
                console.log("just show");
              } else {
                const typeEdit0 = ecs.create("TypeEdit0", {
                  id: "ElTCrsK3N2ZMC8KSwolgdU",
                  grid0user: { gridID: item2.grid0user.gridID },
                  dialog0: { show: true },
                  connections: { master: item2.id },
                  located: { rel: item2.id }
                });
                item2.c.grid.grid0.deploy(typeEdit0);
                item2.c.grid.grid0.manage({ id: typeEdit0.id, attach: item2.id, dir: "w" });
                item2.connections.typeEdit0 = typeEdit0.id;
                console.log("new widget");
              }
              item2.actions.back();
              item2.attention0.pass(item2.c.typeEdit0);
              return true;
            },
            closeMenu: (item2) => () => {
              if (!item2.drNorton0.showMenu)
                return false;
              item2.drNorton0.activePanel = item2.drNorton0.panels.mid.back;
              item2.drNorton0.showMenu = false;
              return true;
            },
            back: (item2) => () => {
              if (item2.actions.closeMenu()) {
                return true;
              }
              if (item2.drNorton0.activePanel !== "mid") {
                if (item2.drNorton0.activePanel == "left" && item2.drNorton0.panels.right.mode != "panel") {
                  item2.drNorton0.panels.right.mode = "panel";
                } else if (item2.drNorton0.activePanel == "right" && item2.drNorton0.panels.left.mode != "panel") {
                  item2.drNorton0.panels.left.mode = "panel";
                } else {
                  item2.drNorton0.theActivePanel.mode = "panel";
                }
                return true;
              }
            },
            edit: (item2) => () => {
              if (item2.drNorton0.theActivePanel.mode === "edit") {
                item2.drNorton0.theActivePanel.mode = "panel";
                return true;
              }
              if (item2.drNorton0.activePanel === "left") {
                if (item2.drNorton0.panels.right.mode === "edit") {
                  item2.drNorton0.panels.right.mode = "panel";
                } else {
                  item2.drNorton0.panels.right.mode = "edit";
                  item2.drNorton0.panels.right.target = item2.drNorton0.entity;
                }
              } else if (item2.drNorton0.activePanel === "right") {
                if (item2.drNorton0.panels.left.mode === "edit") {
                  item2.drNorton0.panels.left.mode = "panel";
                } else {
                  item2.drNorton0.panels.left.target = item2.drNorton0.entity;
                  item2.drNorton0.panels.left.mode = "edit";
                }
              }
              return true;
            },
            toggleMenu: (item2) => () => {
              item2.drNorton0.showMenu = !item2.drNorton0.showMenu;
              if (item2.drNorton0.showMenu) {
                item2.drNorton0.panels.mid.back = item2.drNorton0.activePanel;
                item2.drNorton0.activePanel = "mid";
              } else {
                item2.drNorton0.activePanel = item2.drNorton0.panels.mid.back || "left";
              }
              return true;
            },
            view: (item2) => () => {
              if (item2.drNorton0.activePanel === "left") {
                if (item2.drNorton0.panels.left.mode === "view") {
                  item2.drNorton0.panels.left.mode = "panel";
                } else {
                  item2.drNorton0.panels.right.mode = item2.drNorton0.panels.right.mode === "view" ? "panel" : "view";
                }
              } else {
                if (item2.drNorton0.panels.right.mode === "view") {
                  item2.drNorton0.panels.right.mode = "panel";
                } else {
                  item2.drNorton0.panels.left.mode = item2.drNorton0.panels.left.mode === "view" ? "panel" : "view";
                }
              }
              return true;
            },
            toggleSelect: (item2) => () => {
              if (item2.drNorton0.panels.left.mode === "edit" || item2.drNorton0.panels.right.mode === "edit") {
                return;
              }
              const entity = item2.drNorton0.entity;
              const index = item2.drNorton0.theActivePanel.selection.indexOf(entity.id);
              if (~index) {
                item2.drNorton0.theActivePanel.selection.splice(index, 1);
              } else {
                item2.drNorton0.theActivePanel.selection.push(entity.id);
              }
              item2.drNorton0.moveDown();
              return true;
            },
            box: (item2) => () => item2.drNorton0.box(),
            delete: (item2) => () => item2.drNorton0.erase(),
            get: (item2) => () => {
              const id2 = item2.drNorton0.entity.id;
              item2.cmdLine0.insert(`ecs.root["${id2}"]`);
              return true;
            }
          })
        ],
        details: "Dear Norton MK 0"
      },
      Grid0: {
        hull: () => [
          ecs.compo.grid0(),
          ecs.compo.located(),
          ecs.compo.item({
            baseComponent: "Grid0"
          }),
          ecs.compo.saveLocal({
            self: true,
            type: "Grid0",
            grid0: true,
            located: true,
            item: true
          }),
          ecs.compo.meta({
            type: "Grid0",
            name: "ZIITable5 Basic Grid"
          }),
          ecs.compo.space1(),
          ecs.compo.space2()
        ],
        details: "Just a minimal Grid0, no extra features."
      }
    },
    roster: {},
    meta: {
      name: "SourceNorton",
      type: "Yehat JSON Container",
      version: "1.0",
      by: "[MemberCard KotoTheBest]",
      on: "[DryWare KotoSurf]",
      dtCreated: 1633409850,
      manual: true
    }
  };

  // yehat/yehat.js
  var import_pako = __toModule(require_pako());

  // node_modules/socket.io-client/wrapper.mjs
  var import_pako = __toModule(require_pako());
  var import_build = __toModule(require_build());
  var Manager = import_build.default.Manager;
  var Socket = import_build.default.Socket;

  // yehat/yehat.js
  init_ecs();

  // yehat/yehat-version.js
  var import_pako = __toModule(require_pako());
  var yehat_version_default = "0.99";

  // yehat/yehat.js
  var ZXHRAbstractException = class extends Error {
  };
  var ZXHRStatusException = class extends ZXHRAbstractException {
  };
  var ZXHRServerException = class extends ZXHRAbstractException {
    constructor(code, details) {
      super(`API error. Code: ${code}. Details: ${details}`);
    }
  };
  var xhr2 = async ({ url, body }) => {
    const res = await fetch(url, {
      method: body ? "POST" : "GET",
      headers: {
        "Accept": "application/json",
        "Content-Type": "application/json",
        ...core.yehat.zxhr.headers
      },
      body: body ? JSON.stringify(body) : void 0
    });
    if (res.status != 200)
      throw new ZXHRStatusException(`${res.status} ${res.statusText}`);
    const { code, details, ...rest } = await res.json();
    if (code != "ok")
      throw new ZXHRServerException(code, details);
    return rest;
  };
  var log = (([color1, color2]) => (s2, ...r) => (core.yehat.yehatConfig0.traceYehatLog ? console.trace : console.log)(`${s2.replace("[", "[%c").replace("]", "%c]")}`, `color: ${color1}`, `color: ${color2}`, ...r))(["#ffc700", "#ffffff"]);
  var logT = (([color1, color2]) => (s2, ...r) => console.trace(`${s2.replace("[", "[%c").replace("]", "%c]")}`, `color: ${color1}`, `color: ${color2}`, ...r))(["#ffc700", "#ffffff"]);
  var setToken = (token2) => {
    if (token2) {
      core.yehat.zxhr.headers["Authorization"] = token2;
      localStorage.ziiToken = token2;
    } else {
      delete core.yehat.zxhr.headers["Authorization"];
      delete localStorage.ziiToken;
    }
  };
  var runYehat = ({ appMode } = { appMode: "development" }) => {
    console.log("Running yehat... AppMode: ", appMode);
    if (typeof __require === "function")
      console.log(`Electron detected.`);
    core.yehat = core.yehat || reactive({
      version: yehat_version_default,
      websocketID: "ccOtwqglMWxOFsKPPDbDp8",
      yehatConfig0: {
        traceYehatLog: false
      },
      log,
      isElectron: typeof __require === "function",
      auth: {
        useIdentity: null,
        memberID: null,
        name: "guest",
        avatar: "/images/default-av.png",
        keys: [],
        getStatus: () => {
          return Promise.reject();
        },
        logout: () => {
          delete localStorage.ziiToken;
          setToken(null);
          yehat.auth.getStatus();
        },
        hasKey: (key2) => !!~yehat.auth.keys.indexOf(key2),
        isSuperAdmin: computed(() => !!~["I8K7wrTDkMKOw45Hw5HCl8", "I28Rw4nCqFJOIcK7w6HCjc"].indexOf(core.yehat.auth.memberID))
      },
      zxhr: {
        headers: {},
        xhr: xhr2
      },
      lang_: localStorage.lang || "en",
      lang: computed({ get: () => yehat.lang_, set: (v) => {
        yehat.lang_ = v;
        localStorage.lang = v;
        return true;
      } }),
      appMode,
      manualAppMode: null,
      useAppMode: computed(() => core.yehat.manualAppMode || core.yehat.appMode),
      ioStatus: "down",
      outbound: [],
      emit: ({ cmd, ...a }) => {
      },
      cmdCounters: {},
      transmitOutbound: async ({ socket }) => {
        if (!socket || !socket.connected)
          return;
        const noLog = ["events0.move"];
        const output2 = [];
        while (core.yehat.outbound.length) {
          let message = core.yehat.outbound[0];
          let { cmd, ack, ...rest } = message;
          let counter = cmd ? (core.yehat.cmdCounters[cmd] || 0) + 1 : 1;
          if (cmd)
            core.yehat.cmdCounters[cmd] = counter;
          core.yehat.outbound.splice(0, 1);
          let response = await new Promise((resolve2, reject) => {
            if (!~noLog.indexOf(cmd)) {
              log(`[Socket] => ${cmd}(${counter})`, rest);
            }
            socket.emit(cmd, rest, (response2) => {
              if (ack && typeof ack == "function")
                ack(response2);
              if (!~noLog.indexOf(cmd)) {
                log(`[Socket] <= [${cmd}(${counter})]`, response2);
              }
              resolve2(response2);
            });
          });
          output2.push(response);
        }
        return output2;
      },
      ex: async ({ cmd, ack, ...a }) => {
        while (!core.socket)
          await core.ms(50);
        while (yehat.outbound.length)
          await yehat.transmitOutbound({ socket: core.socket });
        yehat.outbound.push({ cmd, ack, ...a });
        const r0 = await yehat.transmitOutbound({ socket: core.socket });
        if (Array.isArray(r0)) {
          const [r] = r0;
          return r;
        } else {
          return r0;
        }
      },
      connectIO: () => {
        if (core.socket)
          core.socket.close();
        const plWebSocket = Object.assign({
          websocketConfig: { host: null, port: null }
        }, JSON.parse(localStorage[`yehat1-${core.yehat.websocketID}`] || '{ "websocketConfig": { "host": "", "port": "" } }'));
        const { host, port } = plWebSocket.websocketConfig;
        core.yehat.ioStatus = "connecting";
        log("[Yehat]Connecting to Yehat Beta I WebSocket Server", host, port);
        if (typeof import_build.default == "undefined") {
          log("[Yehat]No IO => OFFLINE MODE.");
          return;
        }
        const socket = port ? (0, import_build.default)(`${host}:${port}`, { transports: ["websocket"] }) : (0, import_build.default)(host, { transports: ["websocket"] });
        socket.on("connect", async () => {
          log("[Yehat]Connected!");
          core.yehat.ioStatus = "connected";
          while (!core.ecs)
            await core.ms(50);
          while (!core.ecs.root[core.yehat.websocketID])
            await core.ms(50);
          const plWebSocket2 = core.ecs.root[core.yehat.websocketID];
          plWebSocket2.websocketConfig.onConnect();
        });
        socket.on("reconnected", async () => {
          log("[Yehat]Reconnected!");
          core.yehat.ioStatus = "connected";
          yehat.reportDeviceID({ socket });
          await yehat.transmitOutbound({ socket });
        });
        socket.on("connect_error", (a, b, c) => {
          log("[Yehat]Socket IO Error", a, a.message);
          core.yehat.ioStatus = "error";
        });
        socket.on("server", async (a, b, c) => {
          log("[Socket] <= server", a, b, c);
          yehat.reportDeviceID({ socket: core.socket });
          await yehat.transmitOutbound({ socket: core.socket });
        });
        core.socket = socket;
        socket.onAny(async (event3) => {
          const { cmd, id: id2, type: type2, ...b } = event3;
          core.log("[Socket] <= ", cmd, "ID", id2, "TYPE", type2, "REST", b);
          try {
            if (cmd == "eu") {
              if (core.ecs.root[id2]) {
                Object.assign(core.ecs.root[id2], b);
              } else {
                if (type2) {
                  await yehat.typeDeclared(type2);
                  core.ecs.root[id2] = core.ecs.create(type2, { id: id2, ...b });
                } else {
                  core.ecs.root[id2] = reactive({ id: id2, type: type2, ...b });
                }
              }
            }
            if (cmd == "auth") {
              console.log("<= auth", id2, type2, b);
              if (core.ecs.root[id2]) {
                Object.assign(core.ecs.root[id2], b);
              } else {
                await yehat.typeDeclared("Member");
                if (b.member0 && b.member0.name) {
                  core.ecs.root[id2] = core.ecs.create("Member", { id: id2, ...b });
                } else {
                  core.log("ALERT Unfamous auth.");
                }
              }
              core.yehat.auth.memberID = id2;
              core.yehat.auth.name = b.member0.name;
              await core.yehat.timed(() => ecs2.root["U8K6LcOgwoHDsETDr8KaPU"]);
              ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member = id2;
            }
            if (cmd == "balanceRoster") {
              await core.yehat.timed(() => ecs2.root["U8K6LcOgwoHDsETDr8KaPU"]);
              await core.yehat.timed(() => ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member);
              if (ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member === id2) {
                for (let key2 in b.roster) {
                  ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].tp0roster.roster[key2] = b.roster[key2];
                }
              } else {
                core.log("ALERT Balance Roster ID mismatch", id2, "inventory for", ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member);
              }
            }
            if (cmd == "balance") {
              await core.yehat.timed(() => ecs2.root["U8K6LcOgwoHDsETDr8KaPU"]);
              await core.yehat.timed(() => ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member);
              if (ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member === id2) {
                ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].tp0roster.roster[b.name] = b.amount;
              } else {
                core.log("ALERT Balance ignored, ID mismatch", id2, "inventory for", ecs2.root["U8K6LcOgwoHDsETDr8KaPU"].connections.member);
              }
            }
          } catch (e) {
            console.log("On ANY", e);
          }
        });
      },
      connectIOConduct: async () => {
        yehat.connectIO();
        await core.yehat.timed(() => core.yehat.ioStatus === "connected");
        return true;
      },
      reportDeviceID: ({ socket }) => {
        socket.emit("deviceID", { deviceID: localStorage.deviceID, userObject: JSON.parse(localStorage.userObj || "{}") }, async ({ code, details, member, passwords }) => {
          if (code != "ok") {
            log("[Yehat]Failed to create a member.", details);
            return;
          }
          while (!ecs2.types.Member)
            await core.ms(50);
          const member0 = core.yehatAuth ? core.yehatAuth.connections.member : null;
          if (passwords && member0) {
            for (let password of passwords) {
              let found = ecs2.find((v) => v.password0 && v.password0.password == password).length;
              if (found)
                continue;
              ecs2.create("Password0", {
                password0: { password },
                connections: { member: member0.id }
              });
            }
          } else {
            console.warn("Passwords dropped, no user exists at this point.");
          }
        });
      },
      updateIcon: ({ url }) => {
        document.querySelector("link[rel=icon]").href = url;
      },
      scene: null,
      ccg: [],
      warp: async () => {
        const dtStart = +new Date();
        while (yehat.ioStatus != "connected") {
          await core.ms(50);
          if (+new Date() - dtStart > 5e3) {
            log(`[Yehat]Websocket connection takes more than 5 seconds => rejecting warps.`);
            return Promise.reject();
          }
        }
        const elapsed = +new Date() - dtStart;
        log(`[Yehat]WARP fulfilled in ${elapsed} ms.`);
      },
      timed: async (fn) => {
        const dtStart = +new Date();
        while (!fn()) {
          await core.ms(50);
          if (+new Date() - dtStart > 5e3) {
            log(`[Yehat]TIMED takes more than 5 seconds => rejecting.`);
            return Promise.reject();
          }
        }
        const elapsed = +new Date() - dtStart;
        log(`[Yehat]TIMED fulfilled in ${elapsed} ms.`);
      },
      typeDeclared: async (t) => {
        const dtStart = +new Date();
        while (!ecs2.types[t]) {
          await core.ms(50);
          if (+new Date() - dtStart > 5e3) {
            log(`[Yehat]typeDeclared("${t}") waking up takes more than 5 seconds => rejecting.`);
            return Promise.reject();
          }
        }
        const elapsed = +new Date() - dtStart;
        log(`[Yehat]typeDeclared("${t}")  fulfilled in ${elapsed} ms.`);
      },
      resolveNFT0: (id2) => {
        return core.yehat.ex({ cmd: "nft0.resolve", id: item.id }).then(({ code, details, payload }) => {
          if (code === "ok") {
            const { cargo: cargoBase64 } = payload;
            core.log(`[Yehat resolveNFT ${id2}] []> OK Cargo`, cargoBase64 ? pure.humanStorageSize(cargoBase64.length) : "None");
            const json = JSON.parse(core.Base64.decode(cargoBase64));
            core.log(`[yehat resolveNFT ${id2}] []>`, json);
            return json;
          } else {
            core.log(`[Yehat resolveNFT ${id2}] []> ${code}: ${details}`);
          }
          return null;
        }).catch((e) => {
          core.log(`[Yehat resolveNFT ${id2}] [!]> Exception`, e.message);
        });
      },
      deploy: ({ item: item2, level }) => {
        const app2 = ecs2.root.app;
        if (level > app2.towerGrids.length) {
          log(`[Yehat]Deploy to unfamous level ${level} not supported. Max level: ${app2.towerGrids.length}.`);
          return false;
        }
        const grid = level ? app2.towerGrids[level - 1] : app2.grid;
        grid.grid0.deploy(item2);
        return true;
      }
    });
    window.yehat = core.yehat;
    let deviceID = localStorage.deviceID;
    if (!deviceID) {
      deviceID = core.uuid();
      localStorage.deviceID = deviceID;
    }
    core.deviceID = deviceID;
    yehat.zxhr.headers.deviceID = deviceID;
    if (localStorage.ziiToken)
      setToken(localStorage.ziiToken);
    yehat.connectIO();
    return core.yehat;
  };
  window.uuidv4 = core.uuid;

  // yehat/vcom.js
  var import_pako = __toModule(require_pako());
  var Compiler = __toModule(require_vue3_sfc_loader());
  init_vue_esm_bundler();
  var vcom = {
    compile: async (code, name) => {
      const options = {
        moduleCache: {
          vue: vue_esm_bundler_exports,
          ...ecs.root.app.theApp._context.components,
          yehatRT: {
            status: "Arbitrary notes over the virtual component base."
          }
        },
        getFile: (filename) => {
          core.log(`[VCom0]getFile ${filename}`);
          if (filename === `${name}.vue`) {
            return code;
          } else {
            const file = filename.split(".")[0];
            const code1 = ecs.findOne((v) => v.code1 && v.code1.name === file);
            if (code1) {
              return code1.code1.code;
            } else {
              core.log(`[VCom0]Unhandled getFile: ${filename}.`);
              return "";
            }
          }
        },
        addStyle(textContent, scopeID) {
          const sameScopeID = document.head.querySelectorAll(`style[data-scope-id=${scopeID}]`);
          sameScopeID.forEach((item2) => item2.remove());
          const style2 = Object.assign(document.createElement("style"), { textContent });
          style2.setAttribute("data-scope-id", scopeID);
          const ref3 = document.head.getElementsByTagName("style")[0] || null;
          document.head.insertBefore(style2, ref3);
        },
        handleModule(type2, source, path, options2) {
          core.log("[VCom0]handleModule type", type2, "\nsource", source, "\npath", path, "\noptions", options2);
          if (type2 === ".json") {
            return JSON.parse(source);
          }
        }
      };
      const mod2 = await Compiler.loadModule(`${name}.vue`, options);
      const component = defineComponent(mod2);
      core.log(`[VCom0]Defined component ${name}`, component);
      ecs.root.app.theApp.component(name, component);
      return true;
    },
    compileID: async (id2) => {
      if (!ecs.root[id2])
        ecs.create("Code1", { id: id2 });
      if (!ecs.root[id2])
        throw "[VCom0]Failed to compile ID:", id2, "Item not found.";
      const code = ecs.root[id2].code1.code;
      const name = ecs.root[id2].code1.name;
      return vcom.compile(code, name);
    }
  };
  (async () => {
    console.log(`[VCom0]Init.`, core, pure, ecs);
  })();

  // fed:index-file.js
  core.vcom = vcom;
  ecs.bootSource(source_0_default);
  runYehat();
  ecs.bootSource(loader_default);
  ecs.bootSource(source_norton_default);
  Promise.resolve().then(() => (init_stage2(), stage2_exports)).then((v) => v.default());
})();
/*!
  * vue-router v4.0.11
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
/*!
 * Quasar Framework v2.0.0-rc.3
 * (c) 2015-present Razvan Stoenescu
 * Released under the MIT License.
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * vue3-sfc-loader v0.8.4 for vue3
 *
 * @description Vue3 Single File Component loader.
 * @author      Franck FREIBURGER <franck.freiburger@gmail.com>
 * @license     MIT
 * @sources     https://github.com/FranckFreiburger/vue3-sfc-loader
 */
/*! https://mths.be/cssesc v3.0.0 by @mathias */
/*! https://mths.be/punycode v1.3.2 by @mathias */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
